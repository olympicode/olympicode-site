Најпре је неопходно уочити да сваки задатак из поставке има свој редни број (индекс) у редоследу задатака, почетак и крај извршавања, те тренутак уписа резултата у меморију који је потребно одредити. Стога је корисно искористити неку од структура која групише ове четири каратеристике сваког задатка. Такође, према поставци, задаци нису сортирани ни према почетном, а ни према крајњем тренутку свог извршавања.

## Квадратно решење

Довољно је у две угнежђене петље редоследом проћи по свим задацима и за сваки задатак испитати да ли постоји неки други задатак који је почео пре њега, а који се завршава након њега. Другим речима, у петљама за свака два задатка $i$ и $j$ проверавати да ли је $A_ј < A_i$ и $B_j > B_i$ и симултано ажурирати тражено време уписа у меморију на максимално $B_j$ од задатака који задовољавају претходни услов. Најзад, по редоследу проћи и исписати времена. Како се у свакој од две петље пролази кроз све задатке, ово решење има квадратну временску сложеност, односно $\mathcal{O}(N^2)$, где $N$ представља број задатака.

## Главно решење у логлинеарној сложености

Да би се проблем решио на ефикасан начин, могу се задаци уместо по индексу сортирати по времену почетка извршавања. Пошто у тако сортираним задацима након $i$-тог задатка нема задатака који су почели после њега, то је довољно у само једном проласку кроз задатке, водећи рачуна о дотадашњем максимуму, ажурирати време уписа у меморију као тренутну вредност максимума. Најзад, потребно је пре исписа задатке поново сортирати по редоследу учитавања, односно по индексима, како би се у једном проласку исписала тражена времена. Како је операцију сортирања ефикасним алгоритмима могуће извршити у логлинеарној временској сложености $\mathcal{O}(N\log N)$, а како је ово временски најзахтевнија операција у предложеном решењу, то је и укупна сложеност овог решења логлинеарна по броју задатака.
