Можемо за сваки пар сегмената проверити у константној сложености да ли су коњуговани - сложеност овог алгоритма је $О(N^2)$, што је довољно за **Подзадатак 1**

Ако су координате крајева сегмената бројеви не већи од $MaxVal$, тада постоји $O(MaxVal^2)$ могућих позиција за сегменате. Можемо у некој помоћној матрици $m$ памтити $m[i][j] =$ број сегмената са крајевима у $i$ и $j$. Затим, слично као и у претходном случају, за сваке две могуће позиције сегмената проверимо да ли су они коњуговани и колико је то укупно парова на основу матрице $m$. Укупна сложеност је $O(N + MaxVal^4)$ што је довољно за **Подзадатак 2**

Једна од идеја је сортирати сегменте неопадајуће на основу координате центра $c_i = \frac{a_i+b_i}{2}$ и за сваки сегмент $i$ одредити колико има сегмената лево од њега који су коњуговани са њим; коначно решење добијамо када саберемо ове количине за сваки сегмент. Број таквих сегемената је једнак броју индекса $j$ за које важи $1 \leq j < i$ и $a_i \leq c_j$ и $c_i \leq b_j$.

У **Подзадатку 3** су сегменти већ сортирани растуће по оба краја посебно (па самим тим и по центру) па је скуп сегмената лево од $i$-тог и који су коњуговани са $i$-тим неки узастопни подниз сортираног низа сегмената. У сваком кораку се са почетка овог подниза могу избацивати сегменти који нису коњуговани са тренутним (неће бити коњуговани ни са "деснијим" сегментима због услова подзадатка) па техника двa показивача и/или бинарне претраге решава овај подзадатак у сложености $O(N)$ или $O(N \log N)$.

Претпоставимо да су све координате центара $c_i$ релативно мали, различити цели бројеви (можемо се обезбедити да буду цели тако што на почетку помножимо све крајеве сегемената са $2$). Дефинишимо низ $A$ где је за свако $i=\overline{1,N}$, $A[c_i] = r_i$ а на осталим позицијама су нуле. Ако је $c_1 < c_2 < \ldots < c_N$, тада је број сегмената који су лево од сегмента $i$ и који су коњуговани са њим једнак броју елемемената узстопног подниза $A[l_i], A[l_i+1],\ldots, A[c_i - 1]$ који су већи или једнаки од $c_i$ (посматра се само подниз од $l_i$-те до $(c_i-1)$-те позиције јер су индекси - центри сегмената и они морају припадати $i$-том сегменту; вредности елемента су десни крајеви тих сегмената па морају бити $\geq c_i$ да би садржали центар $i$-тог сегмента). 

Овим се задатак своди на **релативно познат проблем**: *дат је низ $A$ дужине $M$ и $N$ упита облика $(l, r, k)$ - одредити колико има елемената у поднизу $A[l..r]$ који су већи или једнаки $k$*. Овај проблем се најлакше решава *offline* користећи структуру *сегментно стабло*. На почетку напунимо помоћни низ $B$ нулама и сортирамо све елемементе и упите (заједно) опадајуће по вредности елемента односно вредности $k$ у упитима. Затим идемо редом по сортираном низу и када наиђемо на неки елемент $A[i]$, на позицији $i$ у низу $B$ поставимо јединицу; када наиђемо на упит $(l,r,k)$, само одредимо број (или збир) свих елемената у низу $B$ на позицијама од $l$ до $r$ јер су у том тренутку додати само елементи из $A$ који су већи или једнаки $k$. Ово се једноставно ради сегментним стаблом у укупној сложености $O(M + N \log M)$.

У **Подзадатку 4** су вредности $c_i$ заиста довољно мале да се њима може директно индексирати низ $A$ (тј. овде је $M \leq 10^6$) а случајеви се једнаким $c_i$-овима се решавају малом модификацијом алгоритма. Када су вредности $c_i$ велике (нпр. до $10^9$) треба користити *имплицитно сегментно стабло* или, једноставније, компресовати координате на почетку, што даје алгоритам сложености $O(N \log MaxVal)$ или $O(N \log N)$ који решава **све подзадатке**. 

Алтернативни приступ (за решавање проблема на који смо свели оригинални проблем) је коришћење такозване $Sqrt$-декомпозиције где делимо низ на $\sqrt{N}$ делова величине $\sqrt{N}$ и за сваки од њих памтимо сортирани низ елемената из тог дела. Када дође упит $(l,r,k)$, за највише два дела у којима су крајеви упита одрадимо претрагу ручно а за осталих $O(\sqrt{N})$ делова одрадимо бинарну претрагу над одговарајућим низом. Ово даје алгоритам сложености $O(N\sqrt{N}\log N)$ који би, уз пристојну имплементацију, такође требало да освоји све поене. Напоменимо да овај приступ у истој сложености решава варијанту проблема у коме се захтева да се на упите одговара у задатом редоследу (*online*) и где су дозвољени упити који модификују појединачне елементе (иначе, ова тежа варијанта проблема се може решити и у сложености $O(N \log^2 N)$).
