## Решење када $l_i = r_i$
Пошто ће киша сваког дана падати над тачно једним буретом, можемо свако буре гледати засебно. Избројаћемо колико литара је прогнозирано да упадне у $i$-то буре, назовимо тај број $cnt_i$. Уколико $cnt_i > a_i$, значи да долази до преливања и морамо прекрити буриће $cnt_i - a_i$ дана. Урадимо то за свако $i$ и сумирајмо како бисмо добили крајње решење. Временска сложеност је $O(N+M)$, а меморијска $O(N)$.

## Решење када у свако буре пада највише један литар кише
Једина места на којима може доћи до преливања јесу бурад са капацитетом $0$, а пошто су сви интервали дисјунктни, то значи да је укупна дужина свих интервала до $N$, па је довољно ефикасно да за сваки дан прођемо кроз све буриће у које би упала киша и проверимо да ли неки од њих има капацитет $0$. Временска сложеност $О(N+M)$, а меморијска $O(N)$.

## Решење када $a_i \in \{0, 10^9\}$
Једина места на којима може доћи до преливања јесу бурад са капацитетом $0$, у које не сме упасти ни литар кише. Зато, Марко мора прекрити све буриће на дане када би у макар једно буре капацитета $0$ упала киша, што је еквивалентно са провером да ли у интервалу низу постоји $0$. Ово можемо проверити нпр. бинарном претрагом над индексима где се појављује $0$ или префиксним сумама којим бројимо нуле на префиксу. Временска сложеност $O(N+M)$ или $O(N+MlogN)$, а меморијска $O(N)$.

## Решење када $N, M \leq 2000$
Прво је потребно да одредимо колико литара кише је прогнозирано за свако буре. То можемо једноставно урадити тако што за сваки дан пролазимо кроз све буриће и увећамо број литара за један. Назовимо тај број литара за $i$-то буре $cnt_i$. Сада је потребно да посматрамо искључиво буриће за које важи $cnt_i > a_i$, односно оне који би се прелили када ништа не бисмо учинили. 

Сада, идемо слева надесно и сваки пут када наиђемо на такво буре, знамо да морамо да покријемо буриће на макар $cnt_i - a_i$ нових дана. Чувајмо у неком низу све дане за које нисмо одредили да ли ћемо прекрити буриће тај дан (зваћемо их *необрисани интервали*). Кад год морамо да обришемо нови интервал, обрисаћемо онај интервал који садржи $i$, а просеже се што је могуће даље у десно. Ово је оптимално, јер су тако највеће шансе да ћемо тим брисањем смањити $cnt_j$ других *критичних* бурића. Када одаберемо такав интервал, бришемо га из низа, и смањујемо одговарајуће елементе $cnt$ низа. Настављамо десно док не обрадимо цео низ. 

Временска сложеност је $O(NM)$, а меморијска $O(N+M)$.

## Главно решење
Идеја иза овог решења иста је као за претходно, само је потребно да све урадимо ефикасније. Први део, проналажење низа $cnt_i$, урадићемо конструкцијом новог низа, $b$. На почетку, он ће бити испуњен нулама. За сваки дан $i$, ми ћемо повећати $b_{l_i}$ за један, а смањити $b_{r_i+1}$ исто за један. Низ $cnt$ добијамо као низ префиксних сума над низом $b$.

Други део ћемо радити слично као у претходном решењу, само што ћемо уместо низа необрисаних интервала, чуваћемо скуп (*std::multiset*), сортиран по десном крају интервала. Чуваћемо само оне интервале који садрже тренутни елемент, дакле додаћемо интервал $j$ тек кад важи $l_j = i$, а избацити тек кад је обрисан или када $r_j = i$. Сваки пут када треба да обришемо интервал, обрисаћемо највећи у скупу. Слично се може урадити и са приоритетним редом (*std::priority_queue*), са мало додатне анализе.

Временска сложеност је $O(N+MlogN)$, а меморијска $O(N+M)$.
