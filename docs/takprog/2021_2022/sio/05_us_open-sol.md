
Прва ствар коју је потребно да приметимо јесте   како да доделимо време трајања неком конкретним мечу. Приметимо да нам се увек исплати да то буде време трајања првог меча победника. Такав меч још увек има потенцијал да буде интересантан, а не ограничавамо се за будуће мечеве више него што морамо. Сада је потребно само одредити победника сваког меча док замишљамо да се његово време *пропагира* на следеће коло.

## Решење када $N \leq 4$
Пошто има $16$ преосталих играча, постојаће још укупно $15$ мечева. За сваки меч можемо да одаберемо да ли побеђује леви или десни играч, јер постоји само $2^{15} = 32768$ комбинација.

Временска сложеност је $O(2^ {2^N})$, а меморијска $О(2^N)$.

## Решење када $A[i] \leq 2$
Јасно је по горњој обзервацији да ће сваки меч трајати или $1$ или $2$ минута (мора да игра Ђоковић). Нумеришемо све мечеве од $1$ до $2^{N+1}-1$. Сада, можемо радити динамичко програмирање облика: 

$$
dp[i][1/2] = \text{оптимално решење ако меч }i\text{ траје 1, односно 2 минута}
$$

Базни случајеви су очигледно мечеви првог кола, за које знамо колико су трајали (и онда на један случај тих мечева стављамо $0$, а на други $-\infty$). 

Посматрајмо неки фиксни меч $i$ који није меч првог кола. Нека је $l$ меч из којег је дошао победник леве стране жреба, а $d$ меч из којег је дошао победник леве стране жреба.

Важе следеће рекурентне везе: 

$$
dp[i][1] = \max(dp[l][1]+dp[r][1]+1, dp[l][1]+dp[r][2]+1, dp[l][2]+dp[r][1])
$$
$$
dp[i][2] = \max(dp[l][2]+dp[r][2]+1, dp[l][1]+dp[r][2]+1, dp[l][2]+dp[r][1])
$$ 

Дакле, свака комбинација, сем када је меч $l$ трајао $2$ минута, а меч $r$ трајао $1$ минут, даје један нови интересантан меч. Крајњи резултат, ако је финале нумерисано бројем $f$, је $\max(dp[f][1], dp[f][2])$.

Временска и меморијска сложеност је $O(2^N)$.

## Решење када $N \leq 17$ и $A[i] \leq 100$
Слично претходном подзадатку, радићемо динамичко програмирање над нумерисаним мечевима:

$$
dp[i][j] = \text{оптимално решење ако меч }i\text{ траје } j \text{ минута}
$$

Поново имамо три случаја:
- Први случај је ако не желимо да тренутни меч буде интересантан. Онда један меч (леви или десни) мора трајати $j$ минута, за други можемо узети било коју вредност, па ћемо узети ону која даје највише интересантних мечева. 
- Други случај је да желимо да меч $i$ буде интересантан, а да **леви** меч траје $j$ минута. Зато, десни меч мора трајати макар толико, да бисмо добили нови интересантан меч. Узећемо наравно оптималну дужину десног меча.
- Трећи случај је такође да желимо да меч $i$ буде интересантан, а да **десни** меч траје $j$ минута. Леви меч онда мора трајати највише толико. Поново узимамо оптималну дужину левог меча.

Све ово можемо ефикасно имплементирати чувајући префиксне, односно суфиксне максимуме над динамичким програмирањем за сваки меч.

Временска и меморијска сложеност је $O(2^N\cdot maxA)$.

## Решење када $N \leq 17$
Задатак поново радимо динамичким програмирањем, мада овај пут нумеришемо и мечеве и играче:

$$
dp[i][j] = \text{оптимално решење ако је победника меча }i\text{ играч } j
$$

Овде на први поглед има $O(2^N\cdot 2^N)$ стања, али то није тачно - број играча који могу бити победници неког меча (који су у том делу жреба) доста варира. У збиру, зато, постоји само $О(2^N \cdot N)$ стања, јер сваки играч може бити победник у само $N$ различитих мечева. Динамичко програмирање можемо радити коло по коло, кренувши од другог кола (прво је већ одиграно).

Сада, слично претходном подзадатку, ако нам је победник са леве стране жреба и желимо интересантан меч, десно морамо одабрати играча којем је први меч трајао макар колико први меч победника. Аналогно радимо и ако желимо да победник буде из десне стране жреба.

Како бисмо то ефикасно урадили, морамо у обе половине имати играче сортиране по дужини првог меча. Након дога, попут претходног задатка можемо користећи префиксне/суфиксне максимуме над низом динамичког програмирања, као и технику два показивача или бинарну претрагу, можемо наћи одговарајуће вредности. Све ово можемо једноставно имплементирати рекурзијом.

Временска сложеност је $O(2^N \cdot N^2)$, а меморијска $O(2^N)$ (ако памтимо увек само резултате претходног кола).

## Главно решење
Слично претходном подзадатку, само што уместо да користимо сортирање на сваком нивоу рекурзије, ми одржавамо сортирани низ и спајамо их техником два показивача, попут алгоритма *merge sort*. Тиме смањујемо временску сложеност за $N$ фактор.

Временска сложеност је $O(2^N\cdot N)$, а меморијска $O(2^N)$.

