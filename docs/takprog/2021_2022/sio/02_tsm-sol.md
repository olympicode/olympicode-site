## Решење када $M \leq 9$
Прво нађимо неко минимално разапињуће стабло графа који добијемо када као гране додамо сваки метро план (у даљем тексту МСТ). За то можемо користити неки познати алгоритам, попут Крускаловог или Примовог. Након тога, за сваки могући поредак проверимо да ли нам даје МСТ и од таквих узимамо лексикографски највећи.

Временска сложеност је $O(M! \cdot M \cdot \alpha(M))$, а меморијска $O(M)$.

## Решење када се сваки план линије налази у највише једном циклусу
Овакав граф се зове *кактус граф*. Можемо лако закључити да је у кактус графу, да бисмо добили МСТ, потребно да у сваком циклусу у графу избацимо најскупљу грану. Што значи, да се најскупља грана мора наћи у поретку након свих других грана у том циклусу.

Пошто је у питању кактус граф, лако можемо *DFS* алгоритмом наћи све циклусе (нпр. посматрањем свих повратних грана), и тако свести проблем на спајање $K$ низова на лексикографски највећи начин, што је познат проблем који се може решити применом приоритетног реда (*std::priority_queue*).

Временска сложеност је $O(MlogN)$, а меморијска $O(M)$.

## Решење када је МСТ пут и $N,M \leq 5000$
Пошто су цене свих грана различите, МСТ је јединствен. Дакле, нађимо МСТ и знамо да ће он бити пут. Поставимо његове гране редом у низ тако да је један крај пута индексиран са $1$, а други са $N-1$.

Сада, за сваку грану која није у МСТ, рецимо да повезује станице $x$ и $y$, мора да важи да се налази у пермутацији након свих грана на путу између $x$ и $y$ у МСТ. Ако то не важи, додали бисмо скупљу грану, а касније не бисмо могли да додамо јефтинију, што значи да не бисмо добили МСТ. Тај пут одговара неком интервалу у нашем низу.

Сада можемо конструисати нови, усмерени, граф, где су планиране метро линије чворови, а грана од чвора $u$ до чвора $v$ постоји искључиво ако линија $u$ мора да се нађе пре линије $v$ у крајњем поретку. Ове гране можемо лако наћи проласком кроз низ за сваку грану ван МСТ.

Сада се проблем своди на лексикографски највеће тополошко сортирање, које је могуће јер сви чворови имају различите цене. Можемо га урадити приоритетним редом.

Временска сложеност: $O(M^2\log M$), а меморијски $O(M^2)$.

## Решење када је МСТ пут
Слично претходном подзадатку, налазимо МСТ и за сваку грану ван њега знамо да све гране на том путу се морају налазити пре ње. Оно што је потребно да приметимо јесте да ћемо гране на том путу додавати опадајуће по цени, тј. ако желимо лексикографски највећи поредак, нема разлога да додамо мању грану МСТ-а пре веће.

Зато, уместо да конструишемо све гране усмереног графа, довољно је конструисати грану између најјефтиније гране на одређеном интервалу и гране коју посматрамо. То је довољно ограничава, јер знамо да по транзитивности онда неће се јавити пре ниједне гране на путу.

Сада можемо радити тополошко сортирање као у претходном подзадатку, само што овај пут имамо много мање грана. Такође, можемо приметити да је могуће и радити лексикографско спајање $K$ низова као у другом задатку.

Временска сложеност је $O(MlogN)$, а меморијска $O(M)$.

## Решење када $N, M \leq 5000$
Слично подзадатку у коме је МСТ пут, само како бисмо нашли гране усмереног графа, потребно је да прођемо кроз пут на МСТ, уместо кроз интервал низа. Ово можемо урадити тако што коренујемо стабло у неком чвору, па памтимо родитеља за сваки чвор.

Временска сложеност: $O(M^2\log M$), а меморијски $O(M^2)$.

## Главно решење
Слично подзадатку у коме је МСТ пут, само како бисмо нашли гране усмереног графа, потребно је да ефикасно нађемо најмању грану на путу МСТ, уместо на интервалу низа. Ово можемо урадити преко технике бинарног подизања (*binary lifting*). Коренујемо МСТ у произвољном чвору, нађемо претка сваког чвора (за претка корена ставимо самог себе). Након тога, за сваки чвор и за свако $l$ od $0$ do $\log N$ памтимо најмању грану ако се $2^l$ грана пењемо на горе. То нам може помоћи да у $O(\log N)$ нађемо минимум на било ком путу (слично алгоритму тражења минималног заједничког претка).

Временска сложеност је $O(MlogN)$, а меморијска $O(M)$.
