
## Забрањена реч је 'a'
У овом подзадатку је очито довољно само цензурисати сва појављивања слова 'a', што можемо да урадимо тако што линеарно прођемо кроз $T$ и нађемо свуда где се појављује то слово, заменимо са *, и избројимо колико се пута појавио.
##  Сва слова забрањене речи су 'a'
Исто је решење као у претходном подзадатку, само прескочимо првих $M-1$ појављивања слова 'a'.

## Да ли је једна реч подсеквенца друге?
Да бисмо умели да приступимо овом проблему потребно је анализирати алгоритам како проверавамо да ли је једна реч подсеквенца друге. 
Ово се врши похлепним алгоритмом. Наиме, нека проверавамо да ли је реч $S$ подсеквенца речи $T$. Онда пролазимо линеарно кроз реч $T$ док памтимо најдужи префикс $S$ који нам се појављује до сад као подсеквенца.  Сада, када следећи пут наиђемо на следеће слово које би нам требало да бисмо повећали дужину тог највећег префикса (то јест следеће слово у $S$), знамо да нам је оптимално да  га искористимо у конструкицији $S$ као подсеквенце. То значи да у том случају можемо да повећамо дужину тог најдужег префикса, док он у супротном остаје исти. На крају видимо да ли је најдужи префикс $S$ који је подсеквенца $T$ управо цео $S$ у том случају је одговор "ДА", а у супротном "НЕ".

## Пуно решење
Сада када смо проучили тај алгоритам, можемо да решимо цео задатак.
Решење ћемо вршити динамичким програмирањем, најсличније ДП решењу за најдужу заједничку подсеквенцу две ниске. Наиме нека је $DP[n][k]$ вредност "колико најмање карактера треба цензурисати у првих $n$ слова $T$ да би најдужи префикс $S$ који је подсеквенца тих првих $n$ карактера дужине тачно $k$". Сада ове вредности у динамичком програмирању се лако рачунају: ако не желимо да повећамо вредност $k$, онда кад наиђемо на слово које би нам га повећало, морамо да цензуришемо, а у супротном само повећамо вредност $k$. Како стања има $MN$ и свако има константно прелаза, добијамо укупно временску и меморијску сложеност $O(MN)$. 


