## Први подзадатак:  
Како су ограничења мала, задатак се може решити директном имплементацијом текста задатка, односно грубом силом.
  
## Други подзадатак:  
У овом подзадатку пролазе спорије имплементације главног решења, које иначе не би прошле. На пример, коришћење структура *std::set* или *std::map* је неефикасно, али доноси одређен број поена.
  
## Трећи подзадатак:  
Пошто кутије морају садржати исти број штапова, кандидати за број штапова у свакој од кутија су само делиоци броја $N$. Делиоце броја $N$ можемо наћи у $O(\sqrt{N})$ . Такође, за $N\le200000$ највећи број делилаца биће $160$ . Ова чињеница се може потврдити локално генерисаним кодом.

Сада можемо направити низ вектора $pos$; $pos_{x}$ представља све позиције броја $x$ у низу, поређане од мање ка већој. Након тога за фиксирани делилац $d$ можемо проверити да ли је та величина кутије валидна. То радимо тако што за сваки штап $x$ проверимо да ли се он у свакој кутији појавио не више од $K$ пута. За било коју позицију $i$, најлевљи штап који ће садржати кутија која садржи и $i$-ти штап биће највећи садржалац $d$ који је мањи или једнак од $i$. Због ове чињенице можемо само једном проћи кроз све позиције штапа $x$ и проверити да ли се он у свакој кутији појавио не више од $K$ пута. 

Временска сложеност је $O(Т \cdot (maxA_i+N))$, а меморијска сложеност је $O(maxA_i+N)$.  $Т$ представља број делилаца броја $N$, који износи највише $160$.
  
## Главно решење:  
Пошто нам је за било која два штапа важно само да ли су исти, низ можемо компресовати(у сложености $O(N\log N)$) тако да све вредности буду мање од или једнаке $N$. Након што смо то урадили, решење се своди на решење из претходног подзадатка. 

Временска сложеност је $O(N\log N + T\cdot N)$, а меморијска сложеност је $O(N)$.
