Проблем Крипто спада у категорију лакших задатака на другим Квалификацијама. Због једноставности формулације у тексту задатка, није тешко превести проблем у формално математички облик; једна од могућих форми је:

*За дата два цела броја $N$ и $M$, одредити цели број $X$ тако да важи $0\leqX M$ и $N\equiv X (mod M)$.*

Непажљивом читаоцу се ово може чинити као тривијалан задатак, и без обазирања на ограничења променљивих (или можда без разумевања тих ограничења) добијамо следећи C++ код:

```cpp
int N, M;
scanf("%d%d", &N, &M);
printf("%d\n", N % M);
```

Овакво решење, међутим, доноси само око $20$ бодова; целобројни тип *int* не подржава бројеве веће од oko $2\cdot 10^9$. Пажљивији решаваоци су приметили да је боље користити 64-битни тип *long long*, који је уједно и највећи целобројни тип који нам програмски језик нуди. Решење се тако трансформише у следећи облик:

```cpp
long long N, M;
scanf("%lld%lld", &N, &M);
printf("%lld\n", N % M);
```

Овакво решење доноси $40$ бодова; док је овај тип свакако већег капацитета, у задатку можемо да очекујемо бројеве које имају и до $100000$ цифара, док *long long* може да подржи целе бројеве само до oko $9\cdot 10^{18}$. Једно могуће решење за овај проблем је креирање сопствене класе за велике бројеве, и затим имплементирање фукнција дељења и множења над тим типовима да би се дошло до операције модуловања; али пажљивим опсервацијама можемо доста поједноставити овај приступ. Најпре приметимо да, пошто је модул увек унутар 64-битне променљиве, да ће и решење стати у 64-битни цео број. Затим би требало број $N$ трансформисати у неки облик који ће нам омогућити да решење рачунамо у корацима, а да нам оно никад не искочи из тих граница. Конкретно, уколико је $N = \overline{c_k c_{k-1}\ldots c_1 c_0 }$, где је $k$ број цифара броја $N$, а $c_i$ његова $i$-та значајна цифра, посматрајмо следећи полином, у две различите форме:

$$
P(x) = c_k x^k+c_{k-1} x^{k-1}+\ldots+c_1 x+c_0 
$$

$$
= c_0+x(c_1+x(c_2+x(\ldots+x(c_{k-1}+x(c_k+x\cdot 0))\ldots))).
$$

Уколико је $x=10$, онда је ово очигледно једнако броју $N$. Друга форма нам даје поступан начин за рачунање овог модула; можемо, почевши од нуле, у сваком моменту да множимо број са $10$ и да му додамо следећу цифру броја $N$ (идући слева надесно), одржавајући све време резултат по модулу $M$. Ово можемо урадити уз помоћ идентитета везаних за модул збира и производа два цела броја:

$$
(a\equiv x (mod M)) \land (b\equiv y (mod M)) \Rightarrow a+b \equiv x+y (mod M)
$$

$$
(a\equiv x (mod M)) \land (b\equiv y (mod M)) \Rightarrow a\cdot b \equiv x\cdot y (mod M)
$$

Коначно решење се онда може изразити у виду рекурентне везе:

$$
X_0 = 0
$$

$$ 
X_{i+1} = (((10 mod M)\cdot X_i) mod M+c_{k-i} mod M) mod M
$$

где је X_{k+1} тражено решење. Временска сложеност овог решења је $O(k)$, dakle $O(log⁡ N)$, и оно је довољно за освајање $100$ бодова. 

**Напомена:** приметите да је у решењу коришћена променљива типа *unsigned long long*; ово је урађено зато што је могуће искочити из опсега *long long* променљиве приликом множења са 10, међутим тест примери нису санкционисали ову грешку; могуће је освојити *100* поена и без коришћења овог типа: