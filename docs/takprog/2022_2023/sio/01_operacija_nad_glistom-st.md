Један пре свега велики љубитељ животиња по имену Окрам пробудио се једног дана и имао је шта да види: његов љубимац Едгар де Глист, једна кишна глиста, био је раскомадан на $N$ делова. Окрам је био потрешен овим призором, али је, сa обзиром да се разуме у ову врсту животиње, знао за они могу да преживе и након што им се деси оваква повреда, и што је најбитније, знао је да најновијим технологијама он може да врати свог љубимца у стање у ком је био пре немилог догађаја. 

Oкрам је припремио своју глисту за операцију тако што је делове њеног тела поређао у низ у правилном редоследу и њихове дужине записао у један низ истим редоследом (при томе је пазио да је последњи део, то јест део скроз десно, онај са усном дупљом, видећемо после да је оријентација битна). У овој незгодној операцији над својом глистом он мора да обрати пажњу на неколико ствари:

 -  Два дела глисте се могу спојити само ако су они суседни и ако за њихове дужине $a$ и $b$ важи $a \le b \le a+1$. При овоме је битно обратити пажњу и на редослед, то јест $a$ представља леви а $b$ десни број (као што смо рекли оријентација је битна).
 - Да би прошли услов за спајање могао да буде испуњен неки делови ће морати да се "преполове" пре поновног спајања са другим деловима, и то искључиво на следећи начин: ако је $c$ дужина дела који се полови, леви део ће након поделе бити дужине $floor(c/2)$ а десни дужине $ceil(c/2)$.

Помозите Окраму тако што ћете му рећи колико минимално корака (спајања + половљења) је потребно да би се операција одрадила, то јест да би поново спојио Едгара у један део, како би знао да процени време овог хируршког подухвата.


## Описи функција
Потребно је да имплементирате функцију

-   $Resi(N,  A[\ldots])$

Функција $Resi$ се позива само једном на почетку ивршавања програма, а њени параметри су $N$, број делова глисте, и $A[\ldots]$, низ дужине $N$ који садржи дужине делова глисте, и индексиран је од $0$. Повратна вредност функције је минималан број корака који је потребан да се операција изврши.

## Пример 1
### Улаз
```
3
1 2 1
```

### Излаз
```
4
```

#### Објашњење
На пошетку морамо поделити средњи део, након чега имамо 4 дела дужине 1. Сада можемо спојити прва два, као и последња два дела, након чега нам остају 2 дела дужине 2 које можемо потом спојити и тиме завршити поступак

## Пример 2

### Улаз
```
9
1 1 1 1 1 1 1 1 1
```

### Излаз
```
8
```

### Објашњење

Нумеришимо делове од $1$ до $9$. Спојимо сада редом делове 1 и 2, 3 и 4, 5 и 6, као и 8 и 9. Низ сада изгледа овако: 2 2 2 1 2. Спојимо последња прва два дела и последња два дела и добијамо низ: 4 2 3, код ког можемо спојити последња два дела одакле добијамо низ: 4 5, који сада можемо спојити и завршити поступак.

## Ограничења

* $N \le 10^5$
* $S \le 10^6$, где је $S$ укупна дужина глисте, то јест сума бројева у низу

## Подзадаци

Тест примери су подељени у $5$ подзадатака:

- **[10 поена]** $S \le 20$
- **[10 поена]** Дужине свих делова, то јест сви елементи низа, су $1$ или $2$.
- **[20 поена]** $S \le 1000$
- **[30 поена]** $S \le 10^5$
- **[30 поена]** Без додатних ограничења.

## Детаљи имплементације

Потребно је да пошаљете тачно један фајл  `operacija_nad_glistom.cpp`  који имплементира поменуту функцију. Осим тражене функције, ваш фајл може садржати и додатне глобалне променљиве, помоћне функције и додатне библиотеке.

Ваша функција мора бити следећег облика:

`int Resi(int N, int* A);`

**Вашим програмима је дозвољено да мењају садржај низова али не смеју да приступају ван граница датих низова.**

Уз задатак, обезбеђен вам је "template" фајл  `code.cpp`  које можете користити и мењати по потреби. Такође вам је обезбеђен програм  `grader.cpp`  који служи да лакше тестирате кодове. Овај програм учитава са стандардног улаза следеће податке:

-   У првом реду бројеви $N$.
-   У наредном реду $N$ бројева: $A_i$.

Затим овај програм зове вашу функцију и исписује резултате које она врати.