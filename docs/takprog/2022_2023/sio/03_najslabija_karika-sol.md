## Rešenje kada $N \leq 10$, $Q\leq100$
Primetimo da svaki niz koji dobijemo na kraju je podsekvenca početnog, pa za dati niz postoji najviše $2^N$ mogućih podsekvenci i za svaku možemo gramzivim algoritmom da proverimo da li se zaista može dobiti opisanim operacijama. $O(Q2^NN)$ 

## Rešenje kada $N,Q \leq 500$
Za svaki podzadatak nadalje ćemo morati da se udubimo u koncept *Dekartovog stabla* niza. Naime, to je binarno stablo koje se konstruiše rekurzivno (u kvadratnom vremenu) na sledeći način: neka je $i$ indeks maksimuma u našem nizu, onda je čvor $i$ koren našeg stabla. Zatim, podelimo niz na dva niza $1$,$2$,$\cdots$,$i-1$ i $i+1,i+2,\cdots,N$ i nađemo Dekartovo stablo od ova dva podniza, čijim kačanjem na koren $i$ kao levo i desno dete, redom, ćemo dobiti Dekartovo stablo celog niza. Sada može se primetiti da je moguće ukloniti neki član niza akko smo već uklonili celo njegovo podstablo u Dekartovom stablu. Stoga je zadatak zapravo ekvivalentan sa traženjem broja načina kako možemo da izaberemo nekoliko disjunktnih podstabala Dekartovog stabla datog niza. Ovo se rešava prostim dinamičkim programiranjem na stablu. Ako su $l$ i $r$ deca čvora $u$, onda možemo da sračunamo $dp[u]=dp[l]\cdot dp[r]+1$. $O(QN^2)$

## Rešenje kada $N,Q \leq 500$
Ovaj podzadatak se radi slično kao i prethodni, samo je potrebno da se brže izgradi Dekartovo stablo. Ovo može da se uradi, na primer, tako što se za svaki element niza nađe prvi element levo i desno veći od njega (preko takozvane "stek fore"), i onda je njegov roditelj u Dekartovom stablu upravo manji od ta dva broja. $O(NQ)$

## Rešenje kada svaki upit sadrži maksimum
Nadalje je jasno da je ključni problem kako brzo nalaziti Dekartovo stablo za podniz ili bar dovoljno informacija o tom Dekartovom podstablu. Ako interval sadrži $M$ čiji je indeks $i$ onda je jasno da je dovoljno rešiti zadatak samo za $[L,i]$ i $[i,R]$ odvojeno, nakon čega lako nalazimo rešenje ukupno. Sada ćemo računati odgovor za svaki interval oblika $[i,R]$ nekom vrstom dinamičkog programiranja, gde ćemo se pozivati na vrednosti koje smo sračunali dinamičkog programiranja za ceo niz (ako bismo prvo rešili zadatak za ceo niz kao u prethodnom podzadatku). Naime neka je $last[R]$ najveći indeks broja većeg od onog na poziciji $R$. Ako je $last[R]=i$, potrebno nam je samo rešenje za interval $[i+1,R-1]$. Ukoliko nije, onda je rešenje jednako rešenju za $last[R]$, ali treba da mu dodamo još proizvod rešenja za $[last[R]+1,R-1]$,$\cdots$, $[last^k[R]+1, last^{k-1}[R]-1]$ (u kasnijim podzadacima ćemo videti tačan razlog ovome). Međutim, sva ova rešenja potproblema koja nam trebaju su zapravo već izračunati u Dekartovom stablu, tako da već za te intervale znamo da rešimo problem i kombinovanjem svega toga možemo rešiti ovaj podzadatak. 

## Rešenje kada je permutacija nasumična
Inspirisani prethodnim podzadatkom, jasno je da se nekako sve vrti oko maksimuma na intervalu $L,R$, tako da bi bilo lepo kada bismo našli vezu maksimuma na intervalu i Dekartovog stabla. Nije teško uveriti se da je najmanji zajednički predak od $L$ i $R$ zaista maksimum na intervalu $[L,R]$. Međutim, sada dolazi pitanje, kako tačno izgleda to Dekartovo stablo podniza, i da li možemo da ga izrazimo preko Dekartovog stabla početnog niza. Ispostavlja se da možemo, i to na sledeći način: krenimo od čvora $L$ i njegovog desnog podstabla. Sada idemo putem od $L$ do $LCA(L,R)$: ako dođemo u neki čvor iz levog deteta, onda taj čvor izbacujemo, a čvor iz kog smo došli prespojimo sa njegovim dedom. Ovo isto radimo sa $R$, samo zamenimo reči "levo" i "desno". Uverite se sami da ovakva konstrukcija radi!! Kako je permutacija random generisana, zapravo možemo da tvrdimo da je Dekartovo stablo dubine reda veličine $O(\log N)$, pa ovakvu simulaciju možemo da vršimo u $O(Q\log N)$, kao i onda preračunavanje vrednosti dinamičkog programiranja za tih $O(\log N)$ novih vrednosti po upitu.

## Glavno rešenje
Sada treba nekako izbeći ručnu simulaciju pravljenja novog Dekartovog stabla, kada ne znamo da je ono plitko. Ovo ćemo raditi, naravno, putem **sparse tabela*. Naime za svaki čvor ćemo primetiti da nam je operacija koja se primeni na trenutnu vrednost $dp$ biti oblika linearna oblika $dp$ $->dp\cdot x+c$. Šta mislimo pod ovime? Pa ako imamo vrednost $dp[l]$, onda nalazimo vrednost za $dp[u]=dp[l]\cdot dp[r]+1$, znači transformaciju od $dp[l]$ u $dp[u]$ imamo po gornjoj formuli za $k=dp[r]$, $c=1$. Međutim, ono što je važno primetiti je da je kompozicija dve operacije ovog tipa opet operacija tog tipa (kompozivcija dve linearne funkcije je opet linearna). Tako da mi u sparse tabeli možemo naći kako izgleda formula za $dp[2^k\text{-ti predak od }u]$ preko $dp[u]$. Ono što još važi je da je $x\cdot1+0$, neutral za operaciju kompozicije funkcije. Onda nalazimo rešenje na sledeći način: imamo dve tabele, jedna koja kad idemo na gore od nekog čvora kad uđemo sleva množi rezultat sa vrednosti $dp$ od desnog deteta i dodaje $1$, a ako ulazi sdesna onda ne radi ništa i druga koja radi obrnuto. Nije teško videti da se na ovaj način ako krenemo od $L$ do $LCA(L,R)$ upravo računa rešenje problema za taj podinterval, a takve operacije su sve linearne, pa svaku od njih možemo pretvoriti u spars tabelu, koja nam dozvoljava brzo računanje rešenja za taj podinterval. Zatim radimo to za desnu stranu i spajamo rešenja kao u podzadatku $4$. Složenost $O(Q\log N)$. 
