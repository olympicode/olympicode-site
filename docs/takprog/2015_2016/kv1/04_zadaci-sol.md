## Решење и анализа

Овом проблему jе могуће приступити на доста начина, коjи се поприлично разликуjу по ефикасности (самим тим и броjу поена предвиђеном за таj приступ). Оно што jе увек користан први корак jесте састављање апстрактне поставке проблема. У овом случаjу, ова поставка би била:
за дати низ $A$ од $N$ ненегативних целих броjева, одговорити на $Q$ упита представљених jедним ненегативним природним броjем $x$ са значењем "колико постоjи поднизова (не нужно узастопних
елемената) низа $A$ чиjи jе максимум $k$?"

## Претрага свих могућности
Наjjедноставниjе решење (овде "наjjедноставниjе" значи "наjлакше jе смислити га") jе примена грубе силе. Ово значи да се разматраjу сви поднизови $A$ и за сваки подниз се одреди да ли jе максимум заиста jеднак $k$. Броj решења представља вредност jедног броjача коjи jе на почетку постављен на 0 и коjи се инкрементира сваки пут када се нађе подниз са датим своjством.
Начина за генерисање свих могућих поднизова $A$ има неколико, али су такмичари наjвероватниjе наjбоље упознати са рекурзивним бектрекингом. У овом конкретном случаjу, пише се рекурзивна процедура чиjе jе основно значење "разматрање" неког члана низа, након чега се рекурзивно позива
"разматрање" за следећи члан низа два пута: први пут, када актуелни елемент ниjе у поднизу; други пут, када актуелни елемент jесте у поднизу. Када више не постоjе чланови низа за разматрање, долази тренутак "испитивања максимума".
Овакво решење ниjе компликовано: штавише, очекуjе се да су сви такмичари коjи су раниjе видели бектрекинг решења задатака у могућности да ово успешно имплементираjу. Међутим, оно jе веома неефикасно: временска сложеност овог решења jе чак $O(2^N)$
за jедан упит (односно, укупно $O(Q2^N)$, што се може закључити из чињенице да постоjи  $2^N$ поднизова неког низа дужине $N$ (стандардан резултат комбинаторике). Постоjе неке вариjанте овог решења коjе у општем случаjу
незнатно побољшаваjу сложеност, али се не очекуjе да ће такмичарима донети много више од 20 поена, колико jе предвиђено за овакав приступ.

## Примена комбинаторике
У претходном решењу jе у поменуто да jедан низ од $N$ елемената има $2^N$ поднизова. Испоставља се да ова чињеница итекако помаже при даљем развоjу решења. Придржавамо се истих ознака као и пре, тако да разматрамо ситуациjу када упит има аргумент $k$. Поднизови коjи ће се рачунати у решењу сигурно неће садржати елементе низа $A$ коjи су већи од $k$, али сви остали елементи ће сигурно бити у неком поднизу. Ако $A$ садржи $p$ елемената коjи су jеднаки $k$ и $q$ елемената коjи су мањи од $k$ (где $p, q > 0$), тада се у неком од одабраних поднизова jавља бар jедан од елемената jеднаких k и можда неки од елемената мањих од $k$. Броj поднизова формираних од поменутих q елемената jе зато $2^q$ , док jе броj непразних поднизова формираних од p елемената jеднак $(2^p − 1)$ (неопходно jе "одбити" празан подниз). Стога jе одговор на jедан упит jеднак $(2^{p} − 1) · 2^q$.

Уколико такмичари исправно имплементираjу ово решење (уз посебну пажњу на исписивање
резултата "по модулу"), чиjа jе временска сложеност $O (QN)$, предвиђен броj поена jе 50. Међутим,
оно се у основи не разликуjе много од решења коjе доноси 100 поена, као што ћемо касниjе видети.

## Вредности, препроцесирање степена двоjке
У jедном од "подзадатака" постоjи ограничење за вредности елемената у $A$: ниjедан елемент ниjе већи од $10^6$. Ово омогућава примену идеjе сличне овоj у претходно наведеном "подзадатку", али захтева и jедан "трик" уколико желимо да постигнемо добру сложеност. Приметимо да одређивање колико постоjи елемената низа A коjи су jеднаки x захтева $O (N)$ операциjа у сваком упиту. Основна идеjа jе да се на сваки упит одговори у константном времену тако што ће се наjпре вршити препроцесирање, односно биће припремљени делови коначног одговора одмах по учитавању низа. Ово захтева да формирамо два помоћна низа, C и D, чиjе су дужине 106 (уз пажњу око граница), при чему им jе значење следеће:
* $C [i]$: броj поjављивања вредности $i$ у низу $A$;
* $D [i]$: броj елемената у низу $A$ коjи су мањи од $i$.
Ови низови могу jедноставно да се израчунаjу на почетку програма. Зато jе одговор на упит $k$ jеднак $(2^{C[k]} − 1)2^{D[k]}$.

Међутим, неопходан нам jе jош jедан "трик" да бисмо добили ефикасно решење: препроцесирање свих степена двоjке. Тачниjе, на почетку можемо да направимо низ $S$ такав да jе $S [i] = 2i$ (уз пажњу око модула). Тиме смо успели да смањимо броj операциjа на $O (N + Q)$ укупно. За ово решење jе предвиђено 45 поена. Уз мало пажње око рада са случаjевима, уколико се ово решење
укомбинуjе са претходним, могуће jе остварили 70 поена на задатку.

## Коначно решење
Сада представљамо решење у сложености $O ((N + Q) log N)$, за коjе су предвиђени сви поени. Могуће jе добити 100 поена на овом задатку применом неког решења коjе овде ниjе описано, али исте/сличне сложености. Користан додатни задатак за такмичаре jе да откриjу што jе могуће више оваквих алгоритама, будући да неке од тих идеjа могу да послуже у далеко тежим и компликованиjим задацима!

За потребе овог решења ћемо користити неке идеjе из решења претходних "подзадатака": постоjање низа $S$ коjи садржи степене двоjке, формулу за броj поднизова. Међутим, за долазак до решења jе неопходно уочити jедно кључно своjство: редослед елемената коjи нам jе задат у $A$ ниjе битан. Ово неће бити формално доказано, али би неки "интуитивни" аргумент био таj да се задаци различите тежине и даље разликуjу по томе на ком су месту у $A$, тако да су сви редоследи еквивалентни. Пошто jе редослед небитан, можемо да сортирамо низ $A$ у растућем (у другоj терминологиjи: неопадаjућем) поретку. Ово jе корисно jер су тада сви задаци коjи су исте тежине узастопни, а ово нам омогућава да искористимо алгоритам бинарне претраге. Алгоритам бинарне претраге може да се напише у неколико вариjанти. У уобичаjеном облику, резултат бинарне претраге jе само $true$ или $false$ и оваj повратни резултат има значење "ова вредност се налази у овом сортираном низу". Међутим, можемо да инсистирамо на томе да нас бинарна претрага на неки начин информише о положаjу елемента уколико он постоjи у низу. Поставља се
питање: шта се ради уколико се елементи низа понављаjу? У том случаjу, можемо да посматрамо
две корисне функциjе:
* $binpretl (v)$: одређуjе индекс првог елемента у низу $A$ коjи ниjе већи од $v$;
* $binpretd (v)$: одређуjе индекс последњег елемента у низу $A$ коjи ниjе мањи од $v$.

Ове две вариjанте бинарне претраге имаjу сличне имплементациjе, неопходно jе адекватно изменити корак у ком се "помераjу границе".

На основу овога можемо да закључимо да jе броj поjављивања $k$ у сортираном низу $A$ jеднак $binpretd (k) − binpretl(k) + 1$, а да jе $binpretl(k)$ броj елемената коjи су стого мањи од $k$ (под претпоставком да jе низ индексиран од 0, $binpretl(k)−1$ уколико jе индексиран од 1). Након овога можемо да применимо формулу коjа jе раниjе била наведена да бисмо дошли до резултата.

Сложеност овог приступа зависи од сложености алгоритма сортирања. Постоjе алгоритми сортирања коjи захтеваjу $O (N log N)$ операциjа, попут Quick sort, Merge sort (уз пажњу да jе избор пивота у Quick sort критичан и да може да доведе до квадратне сложености у лошим случаjевима). Сложеност бинарне претраге jе $O (log N)$, те jе укупна временска сложеност $O ((N + Q) log N)$, уз
свега $O (N)$ помоћног простора.
