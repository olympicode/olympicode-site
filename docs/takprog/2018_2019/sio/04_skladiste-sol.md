Посматрајмо тренутак доставе једне од кутија. Нека се у складишту тренутно налази $n$ кутија које ће бити извађене у тренуцима $T_0, T_1, \dots, T_n$, и нека је време вађења оне коју тренутно убацујемо $t$.

Ако је укупно време потребно да се изваде кутије које су тренутно у складишту $R$ (ако нема даљих достава), након што додамо нову, постоје две могућности:

* нову кутију ставимо на крај: времена вађења појединачних кутија које су већ у складишту се неће променити. Када нова кутија дође на ред, испред ње ће бити оне за које важи $T_i > t$, тако да је укупно време $R + |i : T_i > t|$.
* нову кутију ставимо на почетак: за кутије које се ваде пре ње ($T_i < t$), време ће се повећати за $1$, а за нову кутију ће време вађења бити $0$. Ново укупно време је дакле $R + |i : T_i < t|$.

Приметимо да ове две вредности уопште не зависе од тренутног редоследа кутија у складишту. Самим тим, избор који даје мање укупно време је оптималан и у случају у ком тренутна кутија није последња, тако да је довољно да израчунамо ове две вредности за сваку кутију и одаберемо мању.

Да би добили решење чија је временска сложеност $\mathcal{O}(N \log{N})$, неопходна нам је структура која подржава следеће операције у логаритамском времену:

* додај $x$ у скуп,
* избаци $x$ из скупа, и
* одговори на "колико елемената скупа су мањи од $x$?"

Једна опција је структура слична `set`-у, али C++ стандардна библиотека не подржава директно упит који нам је потребан. Пошто су сви елементи мали (максимално $2N$), једна алтернатива је сегментно стабло (или Fenwick стабло). Овде, у $i$-том елементу чувамо $1$ ако је $i$ у скупу, и $0$ у супротном. Упит се у том случају своди на проналажење збира на интервалу $[0, x)$.
