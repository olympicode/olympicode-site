## Идеја за  динамичко програмирање
За решавање проблема користићемо динамичко програмирање.
Нека $dp[i][v][k]$ прставља $dp$ стање где $i$ означава број заграда које још морамо да поставимо, $v$ означава тренутну префиксну суму постављених заграда (ако узмемо да је `(` једнако 1 а `)` једнако -1) и $k$ представља број заграда које можемо још да обришемо.
За прелазе имамо 2 опције: Постави `(` као следећу заграду или постави `)` као следећу заграду.
Ако постављамо `(`, из стања $dp[i][v][k]$ ћемо прећи у стање $dp[i-1][v+1][k]$.
Ако постављамо `)` имамо 2 опције: 
- $v=0$, из стања $dp[i][0][k]$ ћемо прећи у стање $dp[i-1][0][k-1]$.
- $v>0$, из стања $dp[i][v][k]$ ћемо прећи у стање $dp[i-1][v-1][k]$.

На почетку треба да иницијализујемо $dp[0][v][k]$ на $1$ ако је $v<=k$, а на $0$ у осталим случајевима.
Такође треба пазити на $overflow$, вредности у $dp$-у веома брзо могу да премаше $long~long$, тако да је потребно ограничити их да не могу да буду веће од $2^{61}$ или неке сличне вредности. $2^{61}$ је добра вредност јер $2\cdot 2^{61}$ идаље стаје у $long~long$, док је $2^{61}$ веће од највеће могуће вредности за $t$.
Уз помоћ овог $dp$-а, можемо да одговоримо на упите. За упит $n,k,t$ ћемо кренути од стања $dp[n][0][k]$ и након тога ћемо радити следеће док $n$ не постане $0$ :
- Ако је $dp[n-1][v+1][k]\geq t$, прећи ћемо у то стање и на одговор додати `(`.
- У супротном ћемо од $t$ одузети $dp[n-1][v+1][k]$, на одговор додати `)` и прећи у стање $dp[i-1][0][k-1]$ ако је $v=0$ или $dp[i-1][v-1][k]$ ако је $v>0$.

Са овим решењем се могло добити $40$ бодова, док се са мало модификованим решењем (за случај када је $k=0$), могло добити још  $10$ бодова.
Главни проблем овог решења је меморија, тако да ћемо се у следећем делу фокусирати на смањење меморије.
Биће описана 3 решења, у редоследу од најлакшег до најтежег за имплементацију. Прво решење је алтернативно решење за проблем, друго користи идеју коју је Тадија Шебез користио да реши проблем, и треће је замишљено решење.

У сва 3 решења се користи класична меморијска оптимизација где се чувају само последња 2 реда. Ово је поприлично лако урадити када се рачуна у редоследу растућих дужина, међутим, за одговарање на упите нама требају вредности у редоследу опадајућих дужина.
## Решење 1
Ово решење користи чињеницу да у нашем $dp$-у има мало вредности које нису $0$, а мање су од $2^{61}$. Штавише, има тачно $2,358,736$ таквих вредности. 
Постоје 2 случаја када је $dp[i][v][k]=0$:
- $i+k-v<0$
- $k=0$ и $i\not\equiv v\ (\textrm{mod}\ 2)$

Треба нам још добар начин да сачувамо ове вредности. Можемо да направимо матрицу где за све вредности $i$ и $v$ чувамо све вредности $k$ (листу вредности) и вредности одговарајућег $dp$ стања.
Међутим, како вредности $i$ и $v$ могу бити до $1000$, ова матрица ће користити превише меморије. Да би смањили меморију, можемо да приметимо да за неку вредности параметра $i$, вредност параметра $v$ ће бити у интервалу $[i-k,i+k]$ за сва поља чија је вредност у траженом интервалу. Тиме можемо да смањимо матрицу на димензије $1000\times 200$.
Што се тиче, проналажења одговарајуће вредности за $k$ из листе, довољно је само да прођемо кроз целу листу ако нам треба нека вредност из ње. Ово је могуће урадити и у $О(\log{k})$ али нема потребе како сложеност програма остаје иста.
Сложеност: Време: $O(n^2\cdot k)$, Меморија: $O($Број поља чија је вредност у интервалу $(0,2^{61})$ $)$.

## Решење 2
У овом и следећем решењу решаваћемо упите офлајн, тј. решићемо их све једним пролазом кроз $dp$ табелу у редоследу опадајућих дужина. За ово решење дефинисаћемо константу $S$ и у одвојену табелу ћемо запамтити сваки $S$-ти ред, тј. $dp[0][v][k]$, $dp[S][v][k]$, $dp[2\cdot S][v][k]$,...
Након тога, пролазимо кроз све дужине у опадајућем редоследу, и за сваку дужину $i$ ћемо да добијемо ред који који нам треба, тј. $dp[i][v][k]$ тако што ћемо кренути од најближег запамћеног реда, у овом случају то је $dp[\lfloor\frac{i}{S}\rfloor\cdot S][v][k]$, и померити се $i-\lfloor\frac{i}{S}\rfloor\cdot S$ корака до $i$-тог реда.
Одабир константе $S=20$ је довољно велик да решење прође меморијско ограничење, а довољно мали да прође временско ограничење.
Сложеност: Време: $O(n^2\cdot k\cdot S)$, Меморија: $O(\frac{n^2}{S}\cdot k)$.

## Решење 3
Ово решење се своди на меморијску оптимизацију прве димензије $dp$ табеле. Ако знамо све вредности за дужину $i+1$ и прва 2 реда за тренутну дужину тј. $dp[i][0][k]$ и $dp[i][1][k]$, можемо да израчунамо све вредности за дужину $i$. Ово је могуће урадити тако што конструишемо граф свих прелаза и ако знамо неку вредност у реду $i$, одузећемо ту вредност од свих стања (из реда $i+1$) са којима је то стање повезано, а ако имамо неко стање у реду $i+1$ које је повезано са тачно једним стањем (из реда $i$) за које не знамо вредност, можемо да закључимо која је вредност тог стања.
Како би ово радило, морамо да рачунамо вредности по модулу, модуо $2^{61}$ ради из истих разлога као у решењу 1. Сад нам још треба начин да кажемо да ли је вредност у неком пољу заправо већа од модула или не. За ово ћемо дефинисати вредност $p=i+k-v$, поље $kada[p][k]$ ће нам чувати најмање $i$ за које је неко стање $dp[i][v][k]$ чија је вредност параметра $p$ одговарајућа, постало веће од модула. Приметимо да кад једном постане веће од модула за неко $i$, вредност за свако веће $i$ и истом вредношћу параметра $p$ ће такође бити већа од модула.
Ово је све што нам треба да решимо проблем, решаваћемо уптите офлајн, прво израчунамо вредности у предоследу растућих дужина, попунимо табелу $kada$ и сачувамо $dp$ вредности за $v=0$ и $v=1$, и одговоримо на упите за које је решење "Ne postoji". Након тога ћемо да израчунамо вредности у редоследу опадајућих дужина и одговоримо на остале упите.
Сложеност: Време: $O(n^2\cdot k)$, Меморија: $O(n\cdot k)$.
