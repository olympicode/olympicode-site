## Изглед метроа

Станице и тунеле можемо сматрати чворовима и гранама усмереног графа. Прво треба да закључимо неколико ствари о томе како овај граф изгледа. 

Посматрајмо прво само јужне станице и тунеле између њих. Ове станице имају тачно један улазни тунел, осим главне полазне станице у коју не улази ниједан тунел. Према томе, јужне станице формирају усмерено стабло са кореном у главној полазној станици тако да су све гране усмерене од корена ка листовима. Слично, и северне станице формирају усмерено стабло са кореном у главној долазној станици, али гране су супротно усмерене, тј. од листова ка корену. 

Ова два стабла су повезана преко средишњих станица и за сваку средишњу станицу постоји тачно један пут који води од главне полазне станице до гравне долазне станице преко ње. Према томе, број различитих путева једнак је броју средишњих станица. Треба некако да одржавамо дужине путева од главне полазне станице до сваке средишње, и од сваке средишње до главне долазне станице. Ако средње станице сматрамо заједничким листовима за два стабла, ове удаљености су уствари дубине листова у стаблима.


## Препроцесирање графа

У улазу нам није дато које станице су јужне, које северне, а које средишње, међутим, ово можемо сами да закључимо. 

Свака станица која има више од једне излазне гране је јужна станица, а свака станица која има више од једне улазне гране је северна станица. Ако кренемо **DFS** обилазак (претрагу у дубину) од главне полазне станице, и не прелазимо ниједну станицу за коју већ знамо да је северна, све станице до којих нисмо успели да дођемо су северне. Средње станице су оне од преосталих станица које имају тунел ка некој од северних станица. И на крају када смо нашли северне и средње станице знамо и које су јужне.


## Подзадаци када је $Q = 1$ и $N, Q \leq 1000$

За сваки упит, пронађимо најкраћи пут од главне полазне станице до сваке средишње станице, и најкраћи пут од сваке средишње станице до главне долазне станице. Ово се може реализовати применом Дијкстриног алгоритма два пута, једном почевши од главне полазне станице и други пут из главне долазне станице, али када обрнемо смер сваког тунела. Када за сваку средишњу станицу саберемо две дистанце које смо нашли, лако можемо да одговоримо на упит сортирањем добијених вредности.


## Подзадатак када се све промене времена односе на тунеле који крећу из средишње станице или стижу у средишњу станицу

На почетку можемо да нађемо дужине путева од главне полазне до главне долазне станице преко сваке средишње станице. Свака промена времена мења тачно један од путева. Треба нам начин да брзо тражимо која је $К$-та најмања дужина пута, подржавајући ове промене. Направимо низ $C$ где је $C_i$ број путева дужине $i$. Направимо **Фенвиково стабло** над овим низом. Тако можемо у $O(logD)$ да променимо вредност низа $C$, и да нађемо колико има путева не дужих од $x$, где је $D$ највећа дужина пута. Користећи ову структуру можемо бинарном претрагом да нађемо дужину $К$-тог пута. Како дужине путева могу бити доста велике, а биће мање од $N+Q$ различитих вредности дужина путева, можемо да мапирамо ове вредности на интервал $[1, d]$, где је $d$ број различитих дужина путева, користећи $std::map$ структуру података.


## Подзадатак када постоји највише $1000$ средишњих станица

Посматрајмо на које средишње станице утиче промена времена потребног да се прође кроз неки тунел. Поређајмо средишње станице у низ по њиховом распореду од истока ка западу. Ако се промена односи на две средишње станице онда се она односи и на све средишње станице између њих. Дакле, свака промена се односи на неки подниз средишњих станица. За сваки тунел можемо наћи на који подниз утиче његова промена ако пустимо **ДФС** алгоритам на северном и јужном стаблу. Сада у $O(S)$, где је $S$ број средишњих станица, можемо да променимо дужине путева, а $K$-ти најкраћи пут можемо да нађемо у $O(SlogS)$ сортирањем низа, или у $O(S)$ применом **quick select** алгоритма.


## Подзадатак када се увек тражи само први најкраћи пут

Као код прошлог задатка одржаваћемо низ путева поређаних од истока ка западу по њиховим средишњим станицама. Направимо **сегментно стабло** над овим низом. Користећи **lazy propagation** технику на сегментном стаблу, можемо да подржимо упите додавања неке вредности на цео подниз, и упите тражења минимума на целом низу. Временска сложеност овог решења је $O(N+QlogN)$.


## Решење за 100 поена

Уместо коришћења сегментног стабла, изделимо низ у узастопне блокове од $SQ$ путева. Одржаваћемо сортиране путеве у сваком блоку. Свака промена додаје неку вредност на неколико целих блокова и на неки део највише још два блока. Применимо **lazy propagation** на блокове тако да не мењамо вредности свих путева у блоку, већ запамтимо за коју вредност треба променити цео блок. Два блока који се делом мењају можемо поново да изградимо, тако што ћемо променити дужине путева који се мењају и спојити део блока који је промењен са делом блока који није промењен као код **merge sort**-а. Тражење $K$-тог најкраћег пута можемо урадити бинарном претрагом по дужини. За неку дужину можемо наћи колико постоји путева не дужих од те дужине ако прођемо кроз све блокове и још једном бинарном претрагом нађемо колико таквих путева постоји у сваком блоку. Временска сложеност операције промене је $O(\frac{N}{SQ} + SQ)$, а тражења решења $O(\frac{N}{SQ}logDlogSQ)$. Ако узмемо да је $SQ = \sqrt{NlogNlogD}$, укупна сложеност овог алгоритма је $O(Q\sqrt{NlogNlogD})$.
