
## Анализа
Почећемо од DP решења за овај проблем. Дефинисаћемо $DP[row][pos]$ на следећи начин:

$DP[row][pos] =$ најмањи број потеза који треба направити тако да полица у реду $row$ почиње на позицији $pos$.

Нека $W_i$ представља дужину $i$-тог реда, тј., $W_i = R_i - L_i + 1$. Тада за $row > 1$ и $1 \le pos \le M - W_{row} + 1$, $DP[row][pos]$ може да се израчуна на следећи начин:

$$
DP[row][pos] = |pos - L_i| + \min_{offset = 0 \ldots W_{row} - W_{row - 1}} DP[row - 1][pos + offset]
$$

За $row = 1$ имамо $DP[1][pos] = |pos - L_1|$.

Решење проблема је $\min_{pos = 1 \ldots N - W_N + 1} DP[N][pos]$.

## Анализа сложености
Лако је видети да горе описани начин за рачунање $DP[row][pos]$ захтева највише $O(N \cdot M \cdot M)$ корака -- за свако од $N \cdot M$ вредности $(row, pos)$ треба $W_{row} - W_{row - 1} + 1 \le M$ корака. $N \cdot M \cdot M$ корака је преспоро за ограничења у овом задатку.

Једна опција је да израчунамо $\min$ у дефиницији $DP[row][pos]$ ефикасније него да посетимо свако од $W_{row} - W_{row - 1} + 1$ вредност у $DP[row - 1]$. За то постоје бар два начина.

-- На пример, ако $DP[row - 1]$ чувамо у сегментном стаблу онда можемо да нађемо $\min$ датог интервала у $O(\log M)$ времену.

-- Или, рачунање $DP[row][pos + 1]$ у односу на $DP[row][pos]$ се разликује у томе што се ``прозор'' од $W_{row} - W_{row - 1} + 1$ елемената који нам требају из $DP[row - 1]$ помери за $1$. То значи да ако бисмо применили Метод 3 са https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/, онда бисмо могли да израчунамо $DP[row][pos + 1]$ у $O(1)$ времену, под претпоставком да рачунамо у редоследу $DP[row][1], DP[row][2], \ldots, DP[row][M - W_{row} + 1]$. Ово би било довољно за решење које ради ефикасно на свим примерима.

Друга опција, она коју ћемо ми применити, јесте да прво прецизније одредимо сложеност горе наведеног приступа, па тек онда ако је потребно да оптимизујемо.

## Прецизнија анализа сложености
Да бисмо израчунали $DP[row][pos]$ за \textbf{све валидне} вредности $pos$ директно користећи формулу изнад треба нам $(M - W_{row} + 1) \cdot (W_{row} - W_{row - 1} + 2)$ операција -- $(W_{row} - W_{row - 1} + 1)$ долази од $\min$, а додатна операција од $|pos - L_i|$. Када сумирамо за све $row \ge 2$, добијемо

$$
\sum_{row = 2}^N (M - W_{row} + 1) \cdot (W_{row} - W_{row - 1} + 2) \le \sum_{row = 2}^N (M + 1) \cdot (W_{row} - W_{row - 1} + 2) = 2 (N - 1) (M + 1) + (M + 1) \sum_{row = 2}^M (W_{row} - W_{row - 1}).
$$

Сви елементи сем $W_N$ и $W_1$ се згодно скрате у последњој суми, те добијемо

$$
\sum_{row = 2}^N (M - W_{row} + 1) \cdot (W_{row} - W_{row - 1} + 2) \le 2 (N - 1) (M + 1) + (M + 1) (W_N - W_1) \le 3 (N - 1) (M + 1).
$$

Другим речима, директна имплементција горе дате $DP$ дефиниције, и вероватно најједноставније решење овог проблема, је довољно ефикасна за све тест примере.

## Оптимизација потрошње меморије
$DP$ не можемо декларисати са $10000 \times 10000$ поља јер то заузима више меморије него што је дозвољено. Уместо тога, довољно је да у меморији чувамо само $DP[row]$ и $DP[row - 1]$, где је $row$ ред који се тренутно обрађује. То нам омогућава да знатно уштедимо на меморији.
