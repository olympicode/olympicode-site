# Марско

Аутор: Тадија Шебез
Текст и тест примери: Тадија Шебез
Анализа решења: Тадија Шебез
Тестирање: Алекса Плавшић

### Решење када су све вредности у низу $A$ једнаке

Како сва возила имају исту заштиту, можемо да избацимо путеве којима Марско не може безбедно да се вози. Након тога можемо DFS алгоритмом да нађемо повезане компоненте и њихове величине. Решење за сваки град је величина његове повезане компоненте.

### Решење када су све вредности у низу $W$ једнаке

За свако возило важи да Марско може безбедно да се вози по било ком путу или уопште не може безбедно да се вози. У првом случају је решење величина повезане компоненте у којој се град налази, а у другом случају решење је 1. И овај подзадатак решавамо DFS алгоритмом.

### Решење за $N, M \leq 250$

За сваки град $i$ нађимо скуп градова које Марско може да посети кренувши из $i$-тог града ако користи само возило које је затекао у почетном граду. Направимо усмерени граф тако што ћемо додати грану од $i$-тог града до сваког града из претходно поменутог скупа. Решење за град $i$ је број чворова које можемо да посетимо кренувши од чвора $i$ у усмереном графу. Овај подзадатак такође можемо да решимо применом DFS алгоритма. Временска сложеност овог решења је $O(N^3)$.

### Решење за $N, M \leq 2500$

Кренимо из града $i$ и памтимо највећу вредност $A$ за градове које смо посетили. Убацимо све путеве од посећених градова у **heap** структуру података. Узмимо пут са најмањим $W$ и ако је ова вредност мања од највећег $A$ за посећене градове, можемо да пређемо преко тог пута и посетимо нови град ако већ није посећен. Ако смо посетили нови град ажурирамо максимално $A$ и додајемо нове путеве на **heap**. Када више немамо путева или сви путеви на **heap**-у имају превелику вредност $W$, прекидамо и памтимо број посећених чворова као решење за град $i$. Ово решење покрећемо за сваки град па је временска сложеност $O(NMlogM)$

### Решење за 100 поена

Решење за неки град једнако је решењу града са највећим $A_i$ међу градовима које може да посети. Посматрајмо град $i$ и скуп $S$ свих градова који не могу да посете град са већим $A$ од свог. Нека је $j$ град са најмањим $A$ међу градовима из скупа $S$ који могу да посете град $i$. Решење за $i$ је исто као решење за $j$. Доказаћемо претходно тврђење тако што ћемо показати да $i$ може да посети $j$. Ако $i$ може да посети неки град $k$ са $A_k \geq A_j$, може и да посети $j$ тако што оде до $k$, пређе у возило из тог града, врати се у $i$ и оде у $j$ обрнутим путем којим би се од $j$ дошло до $i$ (знамо да су на том путу сви $W_e \leq A_j \leq A_k$ јер $j$ не може да посети град са већим $A$). Ako je $A_k < A_j$ за све градове које $i$ може да посети, онда постоји град у скупу $S$ који може да посети $i$ и има мање $A$ него град $j$, што је контрадикција. Сада знамо да је решење за сваки град једнако решењу за најмањи град по вредности $A$ у скупу $S$ који може да посети тај град и можемо да решимо задатак на следећи начин. Процесирајмо градове растуће по њиховим вредностима $A$. Када процесирамо неки град $i$ додајемо све гране $e$ које имају $W_e$ мање или једнако $A_i$. За сваку повезану компоненту чувајмо највеће $A$ за чворове у њој. Ако је највеће $A$ за чворове у компоненти чвора $i$ једнако $A_i$, чвор $i$ је у скупу $S$ и његово решење је величина повезане компоненте. Такође је то и решење за сваки чвор у овој компоненти који се већ није нашао у компоненти неког чвора из скупа $S$. Moжемо да одржавамо ове градове за сваку компоненту у низу и да их пребацујемо из мање у већу компоненту када се догоди спајање две компоненте. На овај начин добијамо решење које ради у временској сложености $O(NlogN + MlogM)$.