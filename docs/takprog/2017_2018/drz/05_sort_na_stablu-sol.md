Ако размислимо о начинима на које се стабло може користити при сортирању природно се намећу замене, па уместо оригиналног проблема сортирања посматрајмо прво проблем замене два суседна елемента из низа, конкретно златника на индексима $k-1$ и $k$. Назовимо чвор стабла најближи корену који има више од једног сина *рачва*. Замену златника вршимо тако што преместимо део низа закључно са индексом $k-2$ негде у дубину стабла, затим поставимо златнике са индексима $k-1$ и $k$ у различита подстабла рачве, вратимо их у низ у обрнутом редоследу, и затим вратимо део низа закључно са индексом $k-2$ (истим редом). Потребан и довољан услов за ово је да подстабло рачве (не укључујући саму рачву) има барем $k$ елемената. Лако се види да у супротном златници на индексима $k-1$ и $k$ никада не могу заменити места.

Сада када знамо процедуру за замену два суседна златника алгоритмом налик на _bubble sort_ изводимо сортирање целог низа. Сортирање је могуће уколико је могућа замена пара суседних златника са највећим индексима (приметимо да ово нису увек златници $n-1$ и $n$, јер неки суфикс низа може бити већ сортиран). Простим поређењем величине подстабла рачве и индекса последњег златника који није на свом месту добијамо одговор на упит.

## Смернице за алгоритам

Оба броја потребна за решавање упита можемо једноставно наћи. Једним пролазом кроз низ златника налазимо последњи индекс $k$ такав да је $p_k \neq k$. Проласком кроз стабло налазимо рачву и величину одговарајућег подстабла, $R$. За $R >= k$ исписујемо $DA$, а у супротном $NE$. У задацима са више упита тј. више тест примера по једном покретању програма важно је посебну пажњу обратити на глобално стање програма које је неопходно reset-овати између тест примера. У овом задатку би пример био број деце за сваки чвор у стаблу - уколико заборавимо да анулирамо ово поље можемо добити неочекиване резултате.
