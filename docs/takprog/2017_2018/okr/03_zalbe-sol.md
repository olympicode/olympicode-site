Први подзадатак се може решити једноставном анализом случајева: за $n \leq 4$ после фиксирања $p_1 = k$ остаје нам највише $3 \cdot 2$ могућих распореда које треба проверити. Други (истовремено и први) подзадатак се може решити у сложености $O(n! \cdot n)$ проверавањем свих пермутација дужине $n$ за укупно $25$ поена.

Анализирајмо сада како генерисати *било коју* добру пермутацију, не обраћајући пажњу на број $k$ и на лексикографски поредак (решење за $60$ поена). Један од начина је 
следећи: редом ћемо постављати вредности $p_1, p_2, \ldots, p_n$ тако да се након $i$ постављања на позицијама $p_1, p_2, \ldots, p_i$ налазе узастопне вредности из сегмента $[l, r]$ за неке $l,r$ (где је $l - r + 1 = i$). У $(i+1)$-вом потезу, уколико је одговарајући карактер `P`, довољно је поставити $p_{i+1} = l - 1$, односно $p_{i+1} = r+1$ у супротном (наредни постављени број је увек или тренутни најмањи број - 1 или тренутни највећи број + 1); на почетку постављамо $p_1 = x$ (за неки природан број $x$). На пример, за улаз 
`PPGPGGGPP` и нпр. $x = 1$, добијамо 

$$
(1) \rightarrow (1, 0) \rightarrow (1, 0, -1) \rightarrow (1, 0, -1, 2) \rightarrow (1, 0, -1, 2, -2) \rightarrow (1, 0, -1, 2, -2, 3) \rightarrow 
$$

$$
(1, 0, -1, 2, -2, 3, 4) \rightarrow (1, 0, -1, 2, -2, 3, 4, 5) \rightarrow (1, 0, -1, 2, -2, 3, 4, 5, -3) \rightarrow
$$

$$
(1, 0, -1, 2, -2, 3, 4, 5, -3, -4).
$$

Поменути поступак се може имплементирати у сложености $O(n)$. Јасно, добијена "пермутација" је у складу са бацањем новчића али добијени бројеви нису нужно из сегмента $[1, n]$. Ово можемо решити на $2$ начина: $1$) додати свим елементима пермутације $p$ апсолутну вредност најмањег елемента + $1$ или $2$) изабрати $x$ као 1 + број појављивања карактера `P`. Нпр. први начин примењен на поменути пример даје 

$$
(1, 0, -1, 2, -2, 3, 4, 5, -3, -4) + 5 = (6, 5, 4, 7, 3, 8, 9, 10, 2, 1)
$$

Дакле, (бар једна) добра пермутација увек постоји. У четвртом подзадатку се тражи лексикографски најмања добра пермутација (без услова за почетни број $k$) -- сада је неопходно тежити да $p_1$ буде најмање могуће, затим да $p_2$ буде најмање могуће за изабрано $p_1$ итд. Уколико на почетку имамо $m \geq 0$ узастопних карактера `P`, тада мора бити $p_1 = m + 1$. Заиста, уколико би било $p_1 < m + 1$ не бисмо имали довољно места за померање улево; са друге стране, постоји добра пермутација која почиње са $(m + 1, m, m - 1, \ldots, 2, 1)$ а затим неки скок удесно преко $m+1$ (могуће је наставити, нпр. на основу конструкције за 60%). Настављањем овог поступка за низ $(m+2, m+3, \ldots, n)$ и преостале карактера долазимо до оптималног решења. 

Није тешко доћи до следећег алгоритма сложености $O(n)$ који реализује поменути поступак: додати 'вештачки' карактер `G` на почетак стринга; поделити стринг на узастопне подстрингове чији је први карактер `G`; у пермутацији $(1, 2, \ldots, n)$ обрнути редослед узатопним елементима који одговарају одговарајућим подстринговима и вратити добијену пермутацију. На пример, PPGPGGGPP $\rightarrow$ **G**PPGPGGGPP $\rightarrow$ GPP|GP|G|G|GPP $\rightarrow$ 1 2 3 | 4 5 | 6 | 7 | 8 9 10 $\rightarrow$ 3 2 1 | 5 4 | 6 | 7 | 10 9 8 $\rightarrow$ (3, 2, 1, 5, 4, 6, 7, 10, 9, 8). Овај алгоритам осваја 72 поена.

Коначно, за максималан број поена треба модификовати претходни алгоритам тако да пермутација увек почиње бројем $k$. Нека на почетку стринга иде прво $a \geq 0$ 'G'-ова а затим $b \geq 0$ 'P'-ова. Узимајући у обзир лексикографску минималност, разликујемо два случаја: 1) Уколико је $b < k$ (има места улево) тражена пермутација почиње са $(k, k+1, \ldots, k + a)$ а остатак добијамо тражењем минималне добре пермутације преосталог скупа вредности $(\{1, 2, \ldots, n\} \setminus \{k, k+1, \ldots, k + a\})$ за преостали низ карактера; 2) Уколико је $b \geq k$ (нема места улево) тражена пермутација почиње са $(k, k+1, \ldots, k + a - 1, k + a + (b - k + 1))$ а остатак добијамо тражењем минималне добре пермутације преосталог скупа вредности за преостали низ карактера. Наравно, у оба случаја за остатак пермутације користимо алгоритам из четвртог подзадатка.

Неефикасна имплементација претходних алгоритама (нпр. у $O(n^2)$) довољна је за прва три подзадатка тј. за око 40 поена. 


