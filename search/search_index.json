{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Po\u010detna","text":"<p>Dobrodo\u0161li na sajt inicijative OlympiCode. </p> <p>Za sad na njemu mo\u017eete na\u0107i nezvani\u010dnu arhivu srpskih takmi\u010denja iz programiranja, a uskoro i materijale sa olimpijskih priprema Zlatna Groznica. Vremenom \u0107e biti dodato jo\u0161 korisnih resursa za va\u0161 napredak u takmi\u010darskom programiranju.</p>"},{"location":"materijali/","title":"Materijali za takmi\u010darsko programiranje na srpskom jeziku","text":"<p>Tokom godina nastalo je dosta materijala iz takmi\u010darskog programiranja na srpskom jeziku. Uglavnom su u pitanju materijali sa olimpijskih priprema ili maturski radovi takmi\u010dara koji su odlu\u010dili da pi\u0161u o temi iz takmi\u010darskog programiranja. Samim tim, dosta ovih materijala sadr\u017ei napredno gradivo - zvezdicom su ozna\u010deni materijali koji sadr\u017ee gradivo koje bi pomoglo i naprednijim po\u010detnicima. </p> <ul> <li>Dinami\u010dko programiranje | Andreja Ili\u0107 i Aleksandar Ili\u0107*</li> <li>Uparivanje u bipartitnim grafovima | Pavle Martinovi\u0107</li> <li>Fenvikovo stablo | Petar Veli\u010dkovi\u0107</li> </ul>"},{"location":"materijali/#olimpijske-pripreme","title":"Olimpijske pripreme","text":"<ul> <li>NEERC problemi (IOI 2019) | Nikola Milosavljevi\u0107</li> <li>Dinami\u010dko programiranje (BOI 2018) | Nikola Milosavljevi\u0107</li> <li>Grafovi i jo\u0161 pone\u0161to (IOI 2017) | Nikola Milosavljevi\u0107</li> <li>Starije pripreme </li> </ul>"},{"location":"materijali/#maturski-radovi","title":"Maturski radovi","text":"<ul> <li>Algoritmi za re\u0161avanje problema iz teorije grafova | Magdalina Jeli\u0107*</li> <li>Segmentno i fenvikovo stablo u takmi\u010darskom programiranju | David Mili\u0107evi\u0107</li> <li>Segmentno stablo | Marko Ili\u0107</li> <li>Segmentno i Fenvikovo stablo | Mihajlo Markovi\u0107</li> <li>Probabilisti\u010dki algoritmi u takmi\u010darskom programiranju | Bogdan Petrovi\u0107</li> <li>Randomizirani algoritmi i strukture podataka | Marko Gruj\u010di\u0107</li> <li>Komparativna analiza prioritetnih redova | Kosta Gruj\u010di\u0107</li> </ul>"},{"location":"materijali/#ostali-materijali","title":"Ostali materijali","text":"<ul> <li>Arhiva zadataka i re\u0161enja srednjo\u0161kolskih takmi\u010denja od 2014. godine*</li> <li>Arhiva zadataka srednjo\u0161kolskih takmi\u010denja do 2013. godine*</li> <li>Agoge i-training - stari materijali sa dodatnih nastava i SIO priprema u Ni\u0161u | Andreja Ili\u0107 i Nikola Milosavljevi\u0107*</li> </ul> <p>Ukoliko imate jo\u0161 materijala koji bi mogli biti korisni takmi\u010darima, kontaktirajte nas na mladen@olympicode.rs. Svi materijali su u trenutku objavljivanja ili javno dostupni, ili su autori odobrili objavljivanje.</p>"},{"location":"materials/dp_nikolamilosavljevic/","title":"Dinami\u010dko programiranje - BOI 2018 pripreme","text":"Autor Nikola Milosavljevi\u0107"},{"location":"materials/dp_skripta/","title":"Dinami\u010dko programiranje","text":"Autor Andreja Ili\u0107 i Aleksandar Ili\u0107"},{"location":"materials/fenvik_petarvelickovic/","title":"Fenvikovo stablo","text":"Autor Petar Veli\u010dkovi\u0107"},{"location":"materials/grafovi_magdalinajelic/","title":"Algoritmi za re\u0161avanje problema iz teorije grafova","text":"Autor Magdalina Jeli\u0107"},{"location":"materials/grafovi_nikolamilosavljevic/","title":"Grafovi i jo\u0161 pone\u0161to - IOI 2017 pripreme","text":"Autor Nikola Milosavljevi\u0107"},{"location":"materials/matching_pavlemartinovic/","title":"Uparivanje u bipartitnim grafovima","text":"Autor Pavle Martinovi\u0107"},{"location":"materials/neerc_nikolamilosavljevic/","title":"NEERC problemi - IOI 2019 pripreme","text":"Autor Nikola Milosavljevi\u0107"},{"location":"materials/priorityqueue_kostagrujcic/","title":"Komparativna analiza prioritetnih redova","text":"Autor Kosta Gruj\u010di\u0107"},{"location":"materials/probability_bogdanpetrovic/","title":"Probabilisti\u010dki algoritmi u takmi\u010darskom programiranju","text":"Autor Bogdan Petrovi\u0107"},{"location":"materials/randomizacija_markogrujcic/","title":"Randomizirani algoritmi i strukture podataka","text":"Autor Marko Gruj\u010di\u0107"},{"location":"materials/segmentno_davidmilicevic/","title":"Segmentno i fenvikovo stablo u takmi\u010darskom programiranju","text":"Autor David Mili\u0107evi\u0107"},{"location":"materials/segmentno_markoilic/","title":"Segmentno stablo","text":"Autor Marko Ili\u0107"},{"location":"materials/segmentno_mihajlomarkovic/","title":"Segmentno i Fenvikovo stablo","text":"Autor Mihajlo Markovi\u0107"},{"location":"takprog/","title":"Takprog Arhiva","text":""},{"location":"takprog/#nezvanicna-arhiva-srpskih-srednjoskolskih-takmicenja-iz-informatike","title":"Nezvani\u010dna arhiva srpskih srednjo\u0161kolskih takmi\u010denja iz informatike","text":"<p>Ovde mo\u017eete na\u0107i tekstove, tekstualna i kodna re\u0161enja zadataka sa srednjo\u0161kolskih takmi\u010denja iz informatike od sezone 2013/2014. nadalje. Plan je da arhiva bude dopunjena novim takmi\u010denjima, tako da se ova arhiva mo\u017ee smatrati arhivom moderne ere takmi\u010denja. Starije sezone mo\u017eete na\u0107i na starom Takprogu.</p> <p>Arhivu treba posmatrati kao work in progress - neka re\u0161enja nedostaju (uglavnom iz starijih sezona), nekima nedostaju podzadaci, neki prosto mogu biti bolji uz bolju formulaciju ili slike. Iako \u0107emo nastaviti i mi da radimo na arhivi, potrebna nam je i pomo\u0107 \u0161ireg dru\u0161tva takmi\u010darskog programiranja (u arhivi je ve\u0107 preko 300 zadataka!). Zato, ose\u0107ajte se slobodno da doprinesete arhivi, koliko god sitne ili ogromne promene bile - vi\u0161e informacija mo\u017eete prona\u0107i na zvani\u010dnom GitHubu.</p> <p>Arhivu su sakupili, organizovali i sredili Aleksandar Vi\u0161nji\u0107, Bogdan Petrovi\u0107 i Mladen Puzi\u0107. Zahvalni smo svim autorima zadataka i re\u0161enja, bilo \u010dlanovima komisije (trenutnim i biv\u0161im), bilo takmi\u010darima koji su dopunili neka od nedostaju\u0107ih re\u0161enja (a sve zasluge mo\u017eete na\u0107i na pojedina\u010dnim zadacima). </p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/","title":"B1 - Ljute ptice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Kako je prole\u0107e donelo lepo vreme, tajna komisija je organizovala zanimljiv doga\u0111aj u centru jednog lepog grada. Naime oni su tajno, dok su svi spavali, napravili kule od stiropora koje stoje jedna pored druge. Svaka kula je sa\u010dinjena od stiropornih blokova koji su stavljeni jedan na drugi. Pored kula se nalazi pra\u0107ka iz koje \u0107e se ispaljivati poznate ljute ptice od stiropora. Pra\u0107ka na po\u010detku mo\u017ee da se podesi na visinu \\(h\\) i do kraja \u0107e ispaljivati ptice samo na toj visini horizontalno u odnosu na zemlju. Kada se ptica ispali ona leti u smeru ka kulama ne gube\u0107i visinu i kada naleti na kulu visine \\(h\\) ili vi\u0161e, udara u nju, te pomera pogo\u0111eni blok kao i sve blokove koji se nalaze iznad bloka u koji je udarila za jedno mesto u smeru u kom je putovala. Kako i ovde va\u017ee zakoni fizike, ukoliko blok treba da se pomeri za jedno mesto, a na tom mestu se nalazi drugi blok, i taj drugi blok \u0107e se pomeriti za jednu mesto u smeru pomeranja prvog bloka. Isto tako deluje i gravitacija, te ukoliko se neki blok pomeri za jedno mesto i ne postoji blok ispod njega, on pada sve dok ne padne na zemlju ili neki drugi blok. Ptice se ispaljuju sve dokle poga\u0111aju neki blok, a ukoliko ptica ne pogodi nijedan blok, prekida se ispaljivanje.</p> <p>Tajna komisija je sakrila veoma vrednu nagradu (neki je zovu \u201e10 poena\u201c) u jednom od stiropornih blokova te \u0107e posle ispaljivanja ptica tra\u017eiti od u\u010desnika da na\u0111e taj blok. Miroslav je od tajnog izvora saznao gde \u0107e tajna komisija sakriti tu nagradu i odlu\u0161io je da postavi pra\u0107ku na visinu \\(k\\). Me\u0111utim kako je on tek \u010detvrti razred osnovne \u0161kole, od vas tra\u017ei da mu pomognete i ka\u017eete gde \u0107e se posle ispaljivanja svih ptica nalaziti blok u kom se nalazi nagrada.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Demjan Grubi\u0107 Marko Ili\u0107 Boris Grubi\u0107"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalaze prirodni brojevi \\(n\\) i \\(k\\), koji redom ozna\u010davaju broj kula i visina na kojoj Miroslav ho\u0107e da ispaljuje ptice od stiropora. U slede\u0107em redu se nalazi \\(n\\) prirodnih brojeva \\((h_1,h_2,\\ldots,h_n)\\) koji ozna\u010davaju visine kula. U tre\u0107em redu standardnog ulaza se nalaze brojevi \\(rk\\) i \\(hb\\) koji redom ozna\u010davaju redni broj kule i visinu bloka u kojem se nalazi nagrada.</p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#izlaz","title":"Izlaz","text":"<p>U prvi i jedini red standardnog izlaza potrebno je ispisati gde \u0107e se nalaziti blok sa nagradom. Prvo se ispisuje redni broj mesta na kom \u0107e se nalaziti, a zatim i na kojoj visini \u0107e se nalaziti.</p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#ulaz_1","title":"Ulaz","text":"<pre><code>3 4\n6 7 1\n1 6\n</code></pre>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#izlaz_1","title":"Izlaz","text":"<pre><code>5 2\n</code></pre>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Blokovi ozna\u010deni istom bojom su blokovi koji sa\u010dinjavaju jednu kulu na po\u010detku pre ispaljivanja ljutih ptica. Crveni blok je blok u kome se nalazi nagrada \u2013 on \u0107e se na kraju nalaziti na mestu broj \\(5\\) (dobili smo dve nove \u201ckule\u201d) na visini \\(2\\).</p> <p></p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 10^6\\).</li> <li>Svi ostali brojevi iz ulaza su prirodni brojevi ne ve\u0107i od \\(10^9\\).</li> <li>\\(1\\leq rk \\leq n\\) i \\(1\\leq hb \\leq h_rk\\), tj. garantuje se da zadati blok u kom se nalazi nagrada postoji.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena va\u017ei \\(n = 1\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(h_i = h_j\\), za svako \\(1 \\leq i,j \\leq n\\).</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(h_i, n\\leq 100\\), za svako \\(1\\leq i\\leq n\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#resenje-za-n-1","title":"Re\u0161enje za \\(n = 1\\)","text":"<p>Prvo treba primetiti da ukoliko se blok sa nagradom nalazi ispod nivoa pra\u0107ke, da se ne\u0107e uop\u0161te pomeriti. Posmatrajmo sada slu\u010daj kada je iznad ili na njenoj visini. U kona\u010dnom rasporedu blokova ima\u0107emo seriju kula visine \\(k-1\\) i eventualno jo\u0161 jednu kulu manje visine. Sada jednostavnom aritmetikom treba odrediti ta\u010dno u kojoj kuli \u0107e se blok sa nagradom na\u0107i i na kojoj visini. Vremenska slo\u017eenost: \\(O(1)\\). Memorijska slo\u017eenost: \\(O(n)\\).</p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#resenje-kada-su-sve-kule-iste-visine","title":"Re\u0161enje kada su sve kule iste visine","text":"<p>Ponovo, ako je blok sa nagradom ispod visine pra\u0107ke, osta\u0107e tu. Ukoliko nije, mo\u017eemo posmatrati kule sa desna na levo i sa svake skinuti blokove koji su na visini barem \\(k\\), a potom ih redom pakovati u nove kule koje \u0107emo postaviti skroz desno. Vremenska slo\u017eenost: \\(O(n)\\). Memorijska slo\u017eenost: \\(O(n)\\).</p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#resenje-za-1-le-n-h_i-le-100","title":"Re\u0161enje za \\(1 \\le n, h_i \\le 100\\)","text":"<p>Kada je blok sa nagradom ispod nivoa pra\u0107ke, ne\u0107e se pomerati. Posmatrajmo drugi slu\u010daj. U ovom podzadatku mo\u017eemo ponovo i\u0107i sa desna na levo i sada za svaku kulu posmatrati blokove odozdo na gore, a potom za svaki blok mo\u017eemo na\u0107i prvu kulu na desno na koju mo\u017ee da stane. Vremenska slo\u017eenost: \\(O(maxh_i \\cdot n^3)\\). Memorijska slo\u017eenost: \\(O(n^2)\\).</p>"},{"location":"takprog/2013_2014/drz/01_ljute_ptice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sli\u010dno, kao u prethodnim podzadacima, obilazi\u0107emo kule sa desna na levo. Mo\u017eemo primetiti da kada se neki blokovi pomeraju na desno, oni popunjavaju najbli\u017ea upra\u017enjena mesta na desnoj strani. Dakle, pri obilasku kula, ukoliko je neka kula niza od pra\u0107ke(ima praznih mesta), mo\u017eemo je postaviti kao prvu poziciju koju \u0107e kule levo popunjavati ako imaju vi\u0161ak blokova. Dok, ukoliko posmatrana kula ima vi\u0161ak blokova, mo\u017eemo popunjavati prazna mesta, sve dok ne iskoristimo sve kule koje su vi\u0161ak. Struktura koju mo\u017eemo koristiti za ovo je std::stack u C++. Vremenska slo\u017eenost: \\(O(n)\\). Memorijska slo\u017eenost: \\(O(n)\\).</p> 01_ljute_ptice.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\n#define MaxN 1000010\n\nint n,k;\nint h[MaxN];\nint rk, hb;\n\nint main()\n{\n    scanf(\"%d%d\",&amp;n,&amp;k);\n    for (int i = 0; i &lt; n; ++i)\n        scanf(\"%d\",&amp;h[i]);\n    scanf(\"%d%d\",&amp;rk,&amp;hb);\n\n    long long retr = -1LL;\n    long long reth = hb;\n\n    if ( hb &gt;= k )\n    {\n        rk--;\n\n        long long count = hb - k + 1;\n\n        for (int i = rk + 1; i &lt; n; ++i)\n        {\n            if (k &gt; h[i])\n            {\n                if (h[i] + count &gt;= k)\n                {\n                    count -= k - h[i] - 1;\n                }\n                else\n                {\n                    retr = i + 1;\n                    reth = h[i] + count;\n                    break;\n                }\n            }\n            else\n            {\n                count += h[i] - k + 1;\n            }\n        }\n\n        if (retr == -1LL)\n        {\n            retr = n + (count + k - 2) / (k - 1);\n            reth = (count-1) % (k-1) + 1;\n        }\n\n    }\n\n    if (retr == -1LL) retr = rk;\n\n    printf(\"%lld %lld\\n\",retr,reth);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/drz/02_sadnice/","title":"B2 - Sadnice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Kao \u0161to svi znamo, prvog dana prole\u0107a, na\u0161 poznati kom\u0161ija \u017dika posadi cve\u0107e, ne znam da li znate, ali... \u017dika je cve\u0107oholi\u010dar. Ove godine je posadio \\(N\\) sadnica zgodno numerisanih brojevima od \\(1\\) do \\(N\\). Kako \u017dika nikada nije bio dobar u ovome, \u010desto se de\u0161ava da mu odre\u0111eni broj sadnica ne uspe.</p> <p>Po\u0161to vidi koje su mu sadnice uspele, a koje ne, on u svoju svesku napi\u0161e niz rednih brojeva sadnica \\([a_1, a_2, \\ldots, a_k]\\), \\((1\\leq a_1 &lt; a_2&lt; \\ldots &lt; a_k \\leq N)\\) koje su mu uspele (uvek ispisuje niz u rastu\u0107em redosledu). Me\u0111utim, ove godine \u017dika je, umesto rednih brojeva sadnica koje su mu uspele \\(A = [a_1, a_2, \\ldots, a_k]\\), napisao samo jedan broj \\(M\\) \u2013 redni broj niza \\(A\\) u leksikografski sortiranom nizu svih mogu\u0107ih rastu\u0107ih nizova uspelih sadnica (takvih nizova ima \\(2N\\)). Na\u017ealost, posle je zaboravio svoj niz \\(A\\).</p> <p>Va\u0161 zadatak je da pomognete \u017diki i za dati broj \\(M\\) koji predstavlja redni broj niza \\(A\\) ispi\u0161ete redne brojeve sadnica koje su mu uspele.</p> <p>Podsetimo se da je niz \\(A = [a_1, a_2,\\ldots ,a_k]\\) leksikografski manji od niza \\(B=[b_1, b_2, \\ldots, b_l]\\) ako i samo ako va\u017ei jedan od slede\u0107a dva uslova (analogno pore\u0111enju \\(2\\) stringa):</p> <ul> <li>Postoji \\(1\\leq j\\leq min(k, l)\\) tako da va\u017ei i \\(a_i = b_i\\) za svako \\(1\\leq i &lt; j\\) i pri tom \\(a_j &lt; b_j\\);</li> <li>\\(k&lt;l\\) i \\(a_i = b_i\\) za svako \\(1\\leq i\\leq k\\).</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Boris Grubi\u0107 Bogdan Petrovi\u0107 Demjan Grubi\u0107"},{"location":"takprog/2013_2014/drz/02_sadnice/#ulaz","title":"Ulaz","text":"<p>U prvom i jedinom redu standardnog ulaza se nalaze dva prirodna broja \\(N\\) i \\(M\\), gde \\(N\\) predstavlja broj sadnica, a \\(M\\) predstavlja redni broj niza \u017dikinih uspelih sadnica (indeksiranje kre\u0107e od \\(1\\)).</p>"},{"location":"takprog/2013_2014/drz/02_sadnice/#izlaz","title":"Izlaz","text":"<p>U prvi red standardnog izlaza treba ispisati niz brojeva, razdvojenix znakom razmaka, koji predstavljaju redne brojeve sadnica koje su uspele, u rastu\u0107em redosledu.</p>"},{"location":"takprog/2013_2014/drz/02_sadnice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/02_sadnice/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n12\n</code></pre>"},{"location":"takprog/2013_2014/drz/02_sadnice/#izlaz_1","title":"Izlaz","text":"<pre><code>2 3 4\n</code></pre>"},{"location":"takprog/2013_2014/drz/02_sadnice/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Posa\u0111ene su sadnice sa rednim brojevima \\(\\{1, 2, 3, 4\\}\\). Leksikografski sortirani niz svih mogu\u0107ih uspelih sadnica u ovom slu\u010daju je:</p> <ol> <li>[]</li> <li>[1]</li> <li>[1, 2]</li> <li>[1, 2, 3]</li> <li>[1, 2, 3, 4]</li> <li>[1, 2, 4]</li> <li>[1, 3]</li> <li>[1, 3, 4]</li> <li>[1, 4]</li> <li>[2]</li> <li>[2, 3]</li> <li>[2, 3, 4]</li> <li>[2, 4]</li> <li>[3]</li> <li>[3, 4]</li> <li>[4]</li> </ol> <p>Niz sa rednim brojem \\(12\\) u ovom nizu je niz \\([2, 3, 4]\\).</p>"},{"location":"takprog/2013_2014/drz/02_sadnice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 60\\).</li> <li>\\(1 \\leq M \\leq 2^N\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(15\\) poena va\u017ei \\(N\\leq 5\\).</li> <li>U test primerima vrednim \\(35\\) poena va\u017ei \\(N\\leq 15\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/02_sadnice/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Zbog malih ograni\u010denja prvi podzadatak mo\u017eemo re\u0161iti hardcodovanjem re\u0161enja za svaki slu\u010daj. Vremenska i memorijska slo\u017eenost je \\(O(1)\\).</p>"},{"location":"takprog/2013_2014/drz/02_sadnice/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Podzadatak re\u0161avamo tako \u0161to generi\u0161emo sve podskupove i ispisujemo tra\u017eeni. Ukoliko podskupove generi\u0161emo leksikografski vremenska slo\u017eenost je \\(O(2^N \\cdot N)\\), u suprotnom moramo sortirati podskupove pa \u0107e vremenska slo\u017eenost biti \\(O(2^N \\cdot N^2)\\). Oba pristupa zadovoljavaju vremensko ograni\u010denje. Memorijska slo\u017eenost je \\(O(2^N \\cdot N)\\).</p>"},{"location":"takprog/2013_2014/drz/02_sadnice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo da je svaki podskup koji sadr\u017ei jedinicu leksikografski manji od svakog podskupa koji je ne sadr\u017ei (osim praznog skupa koji je leksikografski najmanji).</p> <p>Dakle,  ako je \\(M=1\\), re\u0161enje je prazan skup, ako je \\(M&lt;=2^{N-1}+1\\), re\u0161enje \u0107e sadr\u017eati jedinicu, u suprotnom re\u0161enje ne\u0107e sadr\u017eati jedinicu. Sli\u010dnu ideju dalje primenjujemo za \\(k=2, 3, 4, ... N\\). Generalizova\u0107emo ovaj pristup na slede\u0107i na\u010din:</p> <p>Na po\u010detku, za \\(k=1\\)  posmatramo sve podskupove, pa su nam granice intervala \\(l=1\\) i \\(r=2^N\\).</p> <ul> <li>Ukoliko je \\(M=l\\), tu zaustavljamo rad programa.</li> <li>Ukoliko je \\(M&lt;=l+2^{N-k}\\), ispisujemo \\(k\\) i postavljamo gornju granicu \\(r\\) na \\(l+2^{N-k}\\).</li> <li>Ukoliko je \\(M&gt;l+2^{N-k}\\), postavljamo donju granicu \\(l\\) na \\(l+2^{N-k}\\).</li> </ul> <p>Ovu proceduru ponavljamo za svako \\(k\\in[1,N]\\).</p> <p>Vremenska slo\u017eenost je \\(O(N)\\), a memorijska \\(O(1)\\).</p> 02_sadnice.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nbool res[50];\n\nvoid solve(long long x, int cur, int n) {\n    if (x == 0) return;\n    x = x - 1;\n    int t = n - 1;\n    while ((1LL &lt;&lt; t) &lt;= x) {\n        x -= (1LL &lt;&lt; t);\n        t = t - 1;\n        cur++;\n    }\n    res[cur] = true;\n    solve(x, cur + 1, t);\n}\n\nint main() {\n    int n;\n    long long m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    memset(res, false, sizeof(res));\n    solve(m - 1, 1, n);\n\n    for (int i = 1; i &lt;= n; ++i)\n        if (res[i])\n            printf(\"%d \", i);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/drz/03_branje/","title":"B3 - Branje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 64MB <p>Stiglo je prole\u0107e, visibabe su uveliko po\u010dele da rastu, a gazda Srba \u017eeli da to iskoristi i da profitira prodavaju\u0107i visibabe ljudima u gradu koji nemaju dvori\u0161te, a \u017eele da se raduju ovom prvom prole\u0107nom cve\u0107u.</p> <p>U svom dvori\u0161tu Srba ima \\(N\\) visibaba pore\u0111anih u red, i za svaku je odredio, gledaju\u0107i njenu lepotu, koliko dinara mo\u017ee da zaradi ako je proda.</p> <p>Po\u0161to ima mnogo visibaba, a Srba je malo lenj, on je kupio dve ma\u0161ine (visibabobera\u010de) koje \u0107e ih brati umesto njega. Ipak, ma\u0161ine zahtevaju struju, i \u0161to je ve\u0107a visibaba ma\u0161ina zahteva vi\u0161e potro\u0161nje. Srba je za svaku visibabu izra\u010dunao koliko \u0107e u dinarima platiti struju ako bi je ma\u0161ina obrala. Da bi dodatno u\u0161tedeo, Srba ne\u0107e da stalno gasi i pali ma\u0161ine, ve\u0107 \u0107e ih samo jednom upaliti, pustiti svaku od njih da obere neki broj uzastopnih visibaba, i zatim ugasiti. Pri tome, obe ma\u0161ine moraju da budu uklju\u010dene za neku uzastopnu grupu visibaba (za barem jednu visibabu), a te grupe ne smeju da sadr\u017ee nijednu istu visibabu.</p> <p>Pomozite Srbi da ostvari najve\u0107i profit, ra\u010dunaju\u0107i dobit od prodavanja visibaba i tro\u0161ak na struju za branje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Nemanja Majski Boris Grubi\u0107"},{"location":"takprog/2013_2014/drz/03_branje/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalazi broj \\(N\\) koji predstavlja broj visibaba u Srbinom dvori\u0161tu. U drugom redu se nalazi niz od \\(N\\) brojeva \\(Z_i\\) gde \\(i\\)-ti broj predstavlja koliko \u0107e Srba zaraditi ako proda \\(i\\)-tu visibabu. U tre\u0107em redu se nalazi niz od \\(N\\) brojeva \\(S_i\\)  u kome \\(i\\)-ti broj ozna\u010dava koliko \u0107e dinara potro\u0161iti na struju ukoliko bere \\(i\\)-tu visibabu.</p>"},{"location":"takprog/2013_2014/drz/03_branje/#izlaz","title":"Izlaz","text":"<p>U prvi i jedini red standardnog izlaza ispisati jedan broj \u2013 koliko Srba najvi\u0161e mo\u017ee da zaradi. Obratite pa\u017enju da ovo mo\u017ee biti i negativan broj, ukoliko \u0107e Srba u svakom slu\u010daju vi\u0161e izgubiti na struju nego na prodaju.</p>"},{"location":"takprog/2013_2014/drz/03_branje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/03_branje/#ulaz_1","title":"Ulaz","text":"<pre><code>11\n5 6 3 14 9 7 11 3 8 1 4\n1 5 11 4 6 4 4 5 4 8 2\n</code></pre>"},{"location":"takprog/2013_2014/drz/03_branje/#izlaz_1","title":"Izlaz","text":"<pre><code>19\n</code></pre>"},{"location":"takprog/2013_2014/drz/03_branje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2013_2014/drz/03_branje/#ulaz_2","title":"Ulaz","text":"<pre><code>2\n3 3\n5 2\n</code></pre>"},{"location":"takprog/2013_2014/drz/03_branje/#izlaz_2","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2013_2014/drz/03_branje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, jedno od re\u0161enja gde dobijamo najve\u0107i profit je ako prvu ma\u0161inu pustimo da obere samo \\(4\\). visibabu (profit je \\(10 = 14 \u2013 4\\)), a drugu ma\u0161inu pustimo da obere od sedme do devete visibabe (profit je \\(9 = (11 + 3 + 8) \u2013 (4 + 5 + 4))\\), pa je ukupan profit \\(9 + 10 = 19\\).</p> <p>U drugom primeru nemamo izbora osim da prvu ma\u0161inu pustimo da obere prvu visibabu, a drugu ma\u0161inu da obere drugu, gde \u0107emo kod prve visibabe izgubiti \\(2\\) dinara, a kod druge zaraditi \\(1\\) dinar, pa je ukupna zarada \\(-1\\).</p>"},{"location":"takprog/2013_2014/drz/03_branje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2\\leq N\\leq 10^6\\).</li> <li>\\(0\\leq Z_i\\leq 10^9\\).</li> <li>\\(0\\leq S_i\\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N\\leq 50\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N\\leq 500\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N\\leq 5000\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/03_branje/#uproscavanje-problema","title":"Upro\u0161\u0107avanje problema","text":"<p>Recimo da smo sekli neku visibabu \\(i\\). Primetimo da profit od njenog se\u010denja ne zavisi od toga koje visibabe sem nje smo odsekli, nego je uvek \\(Z_i-S_i\\). Taj profit \u0107emo pamtiti u novom nizu \\(P_i=Z_i-S_i\\).</p> <p>Sada je na\u0161 zadatak da podelimo niz \\(P\\) u \\(K=2\\) disjunktna uzastopna podniza tako da je zbir elemenata u njima maksimalan.</p>"},{"location":"takprog/2013_2014/drz/03_branje/#resenje-za-n-le-50","title":"Re\u0161enje za \\(N \\le 50\\)","text":"<p>U ovom podzadatku je dovoljno ru\u010dno proveriti sve mogu\u0107e podele niza na podnize. Vremenska slo\u017eenost je \\(O(N^4)\\).</p>"},{"location":"takprog/2013_2014/drz/03_branje/#resenje-za-n-le-500","title":"Re\u0161enje za \\(N \\le 500\\)","text":"<p>U ovom podzadatku \u0107emo i\u0107i po desnoj granici levog podniza. Sada treba shvatiti da \u0107e leva granica levog podniza biti takva da je zbir brojeva u levom podnizu maksimalan. Nju mo\u017eemo na\u0107i preko jedne petlje. Nakon toga radimo dvostruku petlju po svim mogu\u0107im desnim podnizovima. Vremenska slo\u017eenost je  \\(O(N^3)\\).</p>"},{"location":"takprog/2013_2014/drz/03_branje/#resenje-za-n-le-5000","title":"Re\u0161enje za \\(N \\le 5000\\)","text":"<p>Za svaku poziciju u nizu \u0107emo prekalkulisati najve\u0107i mogu\u0107i zbir podniza koji po\u010dinje \\(R_i\\) i najve\u0107i mogu\u0107i zbir podniza koji zavr\u0161ava u toj poziciji \\(L_i\\). To mo\u017eemo da uradimo preko dvostruke petlje.</p> <p>Sada radimo dvostruku petlju po desnoj granici levog podniza i levoj granici desnog podniza. Ako smo izabrali granice \\(i\\) i \\(j\\) \\((i &lt;j)\\), onda je najbolja mogu\u0107a vrednost takvog izbora \\(L_i + R_j\\).</p> <p>Vremenska slo\u017eenost je  \\(O(N^2)\\).</p>"},{"location":"takprog/2013_2014/drz/03_branje/#resenje-za-k1","title":"Re\u0161enje za \\(K=1\\)","text":"<p>Ovo nije podzadatak u originalom zadatku, ali je va\u017eno da ga razumemo kako bismo razumeli glavno re\u0161enje. U ovom podzadatku nam je dat niz i treba da na\u0111emo najve\u0107i mogu\u0107i zbir nekog podniza.</p> <p>Mo\u017eemo da odr\u017eavamo \\(dp[i]\\) niz, gde je \\(dp[i]\\) najve\u0107a vrednost podniza koji se zavr\u0161ava na \\(i\\). Osnovni slu\u010daj je \\(dp[0]=0\\). Ako smo izra\u010dunali \\(dp[k-1]\\), onda je \\(dp[k]=max(dp[k-1],0)+p[k]\\), zato \u0161to mo\u017eemo ili da nastavimo prethodni podniz, ili da zapo\u010dnemo novi.</p> <p>Re\u0161enje zadatka je najve\u0107a vrednost nekog elementa u \\(dp\\) nizu. Vremenska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2013_2014/drz/03_branje/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Kori\u0161\u0107enjem re\u0161enja za \\(K=1\\) mo\u017eemo da kreiramo \\(dp\\) niz. Sada \u0107emo da imamo niz \\(L_i\\) takav da je \\(L_i=max(dp_1, dp_2, dp_3, ... ,dp_{i-1}, dp_i)\\). To zna\u010di da ako se desni kraj levog podniza nalazi negde pre ili na poziciji \\(i\\), maksimalan zbir levog podniza je \\(L_i\\).</p> <p>Sli\u010dno mo\u017eemo da odredimo \\(R_i\\) za desni podniz. I sada samo treba da pro\u0111emo kroz svako \\(1\\le i &lt;N\\) i na\u0111emo najve\u0107e \\(L_i + R_{i+1}\\). Vremenska slo\u017eenost je \\(O(N)\\).</p> <p>Bonus: Re\u0161ite ovaj zadatak kada je \\(K \\le N\\). Takav zadatak nije po programu dr\u017eavnog takmi\u010denja, ali mo\u017ee da se pojavi na SIO.</p> 03_branje.cpp<pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;deque&gt;\n#include &lt;stack&gt;\n#include &lt;bitset&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;numeric&gt;\n#include &lt;utility&gt;\n#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\n#define sz size()\n#define pb push_back\n#define len length()\n#define clr clear()\n#define FOR(i,a,b) for(i=a;i&lt;b;i++)\n#define FORR(i,n) for(i=0;i&lt;n;i++)\n#define is_digit(c) ('0'&lt;=(c) &amp;&amp; (c)&lt;='9')\n\n#define eps 0.0000001\n#define PI  3.14159265359\n#define infll 199988877733322255LL\n\nlong long a[1000333],s[1000333],llevo[1000333],rlevo[1000333],res_levo[1000333];\n\nint main() {\n\n    freopen(\"input2.txt\", \"r\", stdin);\n    //freopen(\"output9.txt\", \"w\", stdout);\n\n    int n,k,i,j;\n    long long x,l1,r1,l2,r2,res,min_l,max_d,min_l_ind,max_d_ind;\n    bool bres;\n\n    scanf(\"%d\", &amp;n);\n\n    for(i=1; i&lt;=n; i++) {\n        scanf(\"%lld\", &amp;a[i]);\n    }\n\n    for(i=1; i&lt;=n; i++) {\n        scanf(\"%lld\", &amp;x);\n        a[i] -= x;\n    }\n\n    s[0] = 0;\n    for(i=1; i&lt;=n; i++) {\n        s[i] = s[i-1] + a[i];\n    }\n\n    res_levo[1] = s[1] - s[0];\n    if (s[1] &lt; s[0]) {\n        min_l = s[1];\n        min_l_ind = 1;\n    } else {\n        min_l = s[0];\n        min_l_ind = 0;\n    }\n\n    rlevo[1] = 1;\n    llevo[1] = 1;\n\n    for(i=2; i&lt;=n; i++) {\n        res_levo[i] = res_levo[i-1];\n        rlevo[i] = rlevo[i-1];\n        llevo[i] = llevo[i-1];\n        if (s[i] - min_l &gt; res_levo[i]) {\n            res_levo[i] = s[i] - min_l;\n            rlevo[i] = i;\n            llevo[i] = min_l_ind + 1;\n        }\n\n        if (s[i] &lt; min_l) {\n            min_l = s[i];\n            min_l_ind = i;\n        }\n    }\n\n    max_d = s[n];\n    max_d_ind = n;\n    res = max_d - s[n-1] + res_levo[n-1];\n    if (s[n-1] &gt; max_d) {\n        max_d = s[n-1];\n        max_d_ind = n-1;\n    }\n\n    for(i=n-2; i&gt;0; i--) {\n       if (max_d - s[i] + res_levo[i] &gt; res) {\n           res = max_d - s[i] + res_levo[i];\n           l1 = llevo[i];\n           r1 = rlevo[i];\n           l2 = i+1;\n           r2 = max_d_ind;\n       }\n       if (s[i] &gt; max_d) {\n           max_d = s[i];\n           max_d_ind = i;\n       }\n    }\n\n    printf(\"%lld\\n\", res);\n    printf(\"-&gt; %lld %lld %lld %lld\\n\", l1,r1,l2,r2);\n    printf(\"-&gt; %lld\\n\", s[r1] - s[l1-1] + s[r2] - s[l2-1]);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/drz/04_pelikani/","title":"A1 - Pelikani","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Sa po\u010detkom prole\u0107a, pelikani iz Afrike dole\u0107u u krajeve Srbije sa idealnim klimatskim uslovima. Omiljeno mesto za okuljanje im je veliko kvadratno jezero dimenzija \\(N\\times N\\) metara.</p> <p>Mo\u017eemo zamisliti da je jezero izdeljeno na \\(N\\times N\\) kvadratnih polja povr\u0161ine \\(1m^2\\). Sa \\((i, j)\\) \u0107emo ozna\u010davati polje koje je \\(i\\)-to po redu u odnosu na severnu (gornju) stranu i \\(j\\)-to po redu u odnosu na isto\u010dnu (levu) stranu jezera (npr. \\((1, 1)\\) je gornje-levo a \\(N\\), \\(1\\) donje-levo polje). U svakom trenutku se na proizvoljnom polju mo\u017ee nalaziti najvi\u0161e jedan pelikan.</p> <p>Tako\u0111e sa po\u010detkom prole\u0107a, na jezero dolaze \u0161eta\u010di koji bacaju mrvice bajatog hleba (omiljena hrana pelikana) u jezero. Kada se u nekom trenutku pojavi \u0161eta\u010d na nekoj od \\(4\\) obale jezera (istok, zapad, sever ili jug), svi pelikani krenu istom brzinom ka toj obali u pravcu normale na tu obalu (npr. ako se \u0161eta\u010d pojavi na severu, svi pelikani se kre\u0107u isklju\u010divo u pravcu severa tj. \u201cnagore\u201d; sli\u010dno i za ostale strane sveta) sve dok ne do\u0111u do same obale ili do nekog od pelikana ispred njih tj. \u201csabiju\u201d se ispred odgovaraju\u0107e obale (videti obja\u0161njenje test primera). Ukoliko se posle toga pojavi novi \u0161eta\u010d, oni iz trenutne pozicije ponaljaju kretanje u pravcu nove obale itd.</p> <p>Poznat je po\u010detni raspored pelikana u jezeru i pozanto je da se, redom, de\u0161avalo \\(Q\\) doga\u0111aja jednog od slede\u0107a \\(2\\) tipa:</p> <ul> <li><code>1 i</code> \u2013 pojavio se \u0161eta\u010d na obali \\(i\\) (\\(1\\) \u2013 severna, \\(2\\) \u2013 zapadna, \\(3\\) \u2013 ju\u017ena, \\(4\\) \u2013 isto\u010dna) i pelikani su promenili svoje pozicije na prethodno opisan na\u010din;</li> <li><code>2 i j</code> \u2013 konstatovano je da li se u datom trenutku na polju \\((i, j)\\) nalazi neki pelikan ili ne.</li> </ul> <p>Ispisati odgovor na sve doga\u0111aje tipa \\(2\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Bogdan Petrovi\u0107 Nepoznato"},{"location":"takprog/2013_2014/drz/04_pelikani/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\) \u2013 dimenzija jezera. U narednih \\(N\\) redova nalazi se po jedan string du\u017eine \\(N\\) sastavljen isklju\u010divo od nula i jedinica \u2013 \\(j\\)-ti karakter \\(i\\)-tog stringa je \\(1\\) ukoliko se na po\u010detku na polju \\((i, j)\\) nalazi pelikan, a \\(0\\) ina\u010de.  U narednom redu nalazi se broj \\(Q\\) \u2013 broj doga\u0111aja. U narednih \\(Q\\) redova nalaze se opisi doga\u0111aja u gore pomenutom obliku u redosledu kojim su se dogodili.</p>"},{"location":"takprog/2013_2014/drz/04_pelikani/#izlaz","title":"Izlaz","text":"<p>Za svaki doga\u0111aj tipa \\(2\\) ispisati u posebnom redu (i u redosledu datim na ulazu) odgovaraju\u0107i odgovor \u2013 <code>1</code>, ukoliko se u tom trenutku na datom polju nalazi neki pelikan, odnosno <code>0</code> u suprotnom.</p>"},{"location":"takprog/2013_2014/drz/04_pelikani/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/04_pelikani/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n00000\n01000\n11000\n01010\n00000\n6\n2 5 2\n1 3\n2 5 2\n2 3 2\n1 4\n2 5 2\n</code></pre>"},{"location":"takprog/2013_2014/drz/04_pelikani/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n1\n1\n0\n</code></pre>"},{"location":"takprog/2013_2014/drz/04_pelikani/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Imamo \\(5\\) pelikana u jezeru dimenzija \\(5\\times 5\\) i \\(6\\) doga\u0111aja. Za prvi doga\u0111aj tipa \\(2\\) odgovor je \\(0\\) jer nema pelikana na polju \\((5, 2)\\). Zatim se pojavljuje \u0161eta\u010d na ju\u017enoj obali i svi pelikani idu \u201cnadole\u201d \u2013 pelikani sa polja \\((3, 1)\\), \\((2, 2)\\), \\((3, 2)\\), \\((4, 2)\\) i \\((4, 4)\\) prelaze, redom, na polja \\((5, 1)\\), \\((3, 2)\\), \\((4, 2)\\), \\((5, 2)\\) i \\((5, 4)\\) i jasno je da na poljima \\((5, 2)\\) i \\((3, 2)\\) ima pelikana. Zatim se pojavljuje \u0161eta\u010d na isto\u010dnoj obali; posle nove promene pozicija, pelikani zauzimaju polja \\((5, 3)\\), \\((3, 5)\\), \\((4, 5)\\), \\((5, 4)\\) i \\((5, 5)\\), pa je polje \\((5, 2)\\) prazno.</p>"},{"location":"takprog/2013_2014/drz/04_pelikani/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 1.000\\).</li> <li>\\(1\\leq Q\\leq 300.000\\).</li> <li>U svakom upitu <code>1 i</code> je \\(1\\leq i\\leq 4\\), a u svakom upitu <code>2 i j</code> je \\(1\\leq i, j\\leq N\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(n, m, Q\\leq 100\\).</li> <li>U test primerima vrednim \\(40\\) poena va\u017ei \\(Q\\leq 30.000\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/04_pelikani/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Zbog malih ograni\u010denja prvi podzadatak mo\u017eemo re\u0161iti simuliranjem doga\u0111aja tipa \\(1\\). To se najjednostavnije radi tako \u0161to izbrojimo koliko pelikana ima u svakom redu ako se \u0161eta\u010d pojavio na isto\u010dnoj ili zapadnoj obali, tj. izbrojimo koliko pelikana ima u svakoj koloni ako se \u0161eta\u010d pojavio na severnoj ili ju\u017enoj obali. Nakon toga samo popunimo matricu shodno izbrojanim vrednostima. Na doga\u0111aje tipa \\(2\\) odgovaramo jednostavnom proverom vrednosti matrice na toj poziciji. Vremenska slo\u017eenost je \\(O(QN^2)\\), a memorijska \\(O(N^2)\\).</p>"},{"location":"takprog/2013_2014/drz/04_pelikani/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Drugi podzadatak je unapre\u0111enje tehnike prvog podzadatka. Posmatrajmo broj pelikana u svakom redu i u svakoj koloni. Primetimo da operacija tipa \\(1\\) menja broj pelikana ili u redovima ili u kolonama, ne mo\u017ee da promeni oba. Prema tome, dovoljno je izra\u010dunati samo kako se redovi ili kolone menjaju na slede\u0107i na\u010din: Pretpostavimo da \u0161eta\u010d dolazi sa severne strane, ostali slu\u010dajevi se analogno re\u0161avaju. Broj pelikana za svaku kolonu ostaje isti. Kako svi pelikani idu u redove koji su manjeg indeksa, broj pelikana u redu sa indeksom \\(i\\) posle dolaska \u0161eta\u010da jednak je broju kolona koje imaju \\(\\geq i\\) pelikana. To se u slo\u017eenosti \\(O(N)\\) mo\u017ee izra\u010dunati kori\u0161\u0107enjem tehnike dva pokaziva\u010da. Na doga\u0111aje tipa \\(2\\) odgovaramo tako \u0161to pamtimo na kojoj strani se pojavio poslenji \u0161eta\u010d i proveravamo za tra\u017eeno polje u odgovaraju\u0107em redu ili koloni. Vremenska slo\u017eenost je \\(O(QN)\\), a memorijska \\(O(N^2)\\).</p>"},{"location":"takprog/2013_2014/drz/04_pelikani/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sve rasporede pelikana mo\u017eemo podeliti u \\(3\\) situacije i njih \u0107emo analizirati posebno. Nazovimo doga\u0111aj tipa \\(1\\) gde \u0161eta\u010d dolazi sa severne ili sa ju\u017ene strane vertikalan doga\u0111aj, a doga\u0111aj tipa \\(1\\) gde \u0161eta\u010d dolazi sa isto\u010dne ili sa zapadne strane horizontalan doga\u0111aj.</p> <ol> <li>Pre doga\u0111aja tipa \\(2\\) na koji treba odgovoriti, nije se desio doga\u0111aj tipa \\(1\\). U ovom slu\u010daju samo ispisujemo vrednost tra\u017eenog polja u po\u010detnoj matrici.</li> <li>Pre doga\u0111aja tipa \\(2\\) na koji treba odgovoriti desili su se ili samo horizontalni, ili samo vertikalni doga\u0111aji. U tom slu\u010daju, kao u prethodnom podzadatku, pamtimo za svaki red (ili kolonu u zavisnosti od toga da li su doga\u0111aji tipa \\(1\\) vertikalni ili horizontalni) koliko pelikana ima, i jednostavnim ra\u010dunom u odnosu na obalu poslednjeg \u0161eta\u010da dajemo odgovor.</li> <li>Pre doga\u0111aja tipa \\(2\\) na koji treba odgovoriti desili su se i horizontalni i vertikalni doga\u0111aji. Primetimo da nakon \u0161to su se desili i horizontalni i vertikalni doga\u0111aj, broj pelikana po redovima je monoton niz, to isto va\u017ei i za broj pelikana po kolonama. Drugim re\u010dima, pelikani \u0107e na jezeru imati oblik stepenica, sli\u010dno kao na primeru dole:</li> </ol> \\[ \\begin{matrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{matrix}\\] <p>Primetimo da za pelikane koji obrazuju takav stepenast oblik, svaki doga\u0111aj tipa \\(1\\) simetri\u010dno preslikava izgled jezera. Vertikalan doga\u0111aj preslikava jezero u odnosu na \\(x\\) osu, dok horizontalan doga\u0111aj preslikava jezero u odnosu na \\(y\\) osu.</p> <p>To je zna\u010dajno jer kada izra\u010dunamo matricu jezera koja se dobije nakon obrazovanja stepenaste strukture mo\u017eemo odgovarati na upite direktno iz te matrice tako \u0161to vra\u0107amo polje \\((i,j), (n-i+1,j), (i,n-j+1)\\) ili \\((n-i+1, n-j+1)\\) u zavisnosti od obala poslednjeg vertikalnog i poslednjeg horizontalnog \u0161eta\u010da.</p> <p>Vremenska slo\u017eenost je \\(O(Q + N^2)\\), a memorijska \\(O(N^2)\\).</p> 04_pelikani.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MaxN = 1010;\n\nconst int c = 0;\nconst int u = 1;\nconst int l = 2;\nconst int d = 3;\nconst int r = 4;\nconst int ur = 5;\nconst int ru = 6;\nconst int dr = 7;\nconst int rd = 8;\nconst int dl = 9;\nconst int ld = 10;\nconst int ul = 11;\nconst int lu = 12;\n\nint n, q;\nbool a[MaxN][MaxN], b[MaxN][MaxN];\nint ns[13][5]; // next state\nint col[13][MaxN], row[13][MaxN];\nint cnt[MaxN];\nchar s[MaxN];\nint state, dir;\n\nvoid transform(int old[], int new1[], int new2[], int currDir)\n{\n    for (int i = 0; i &lt;= n; i++)\n        cnt[i] = 0;\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        new1[i] = old[i];\n        cnt[ old[i] ]++;\n    }\n\n    new2[n] = cnt[n];\n    for (int i = n - 1; i &gt;= 1; i--)\n        new2[i] = new2[i + 1] + cnt[i];\n\n    if (currDir &gt; 2)\n    {\n        for (int i = 1; i &lt;= n / 2; i++)\n        {\n            int tmp = new2[i]; new2[i] = new2[n - i + 1]; new2[n - i + 1] = tmp;\n        }\n    }\n}\n\nint answer(int x, int y)\n{\n    if (state == 0) return (a[x][y] ? 1 : 0);\n\n    if (dir == 1) return (col[state][y] &gt;= x ? 1 : 0);\n    if (dir == 2) return (row[state][x] &gt;= y ? 1 : 0);\n    if (dir == 3) return (col[state][y] &gt;= n - x + 1 ? 1 : 0);\n    if (dir == 4) return (row[state][x] &gt;= n - y + 1 ? 1 : 0);\n    return 0;\n\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%s\", s);\n        for (int j = 1; j &lt;= n; j++)\n            a[i][j] = (s[j - 1] == '1' ? true : false);\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        row[c][i] = 0;\n        col[c][i] = 0;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (a[i][j]) row[c][i]++;\n            if (a[j][i]) col[c][i]++;\n        }\n    }\n\n    transform(row[c], row[l], col[l], l);\n    transform(row[c], row[r], col[r], r);\n    transform(col[c], col[u], row[u], u);\n    transform(col[c], col[d], row[d], d);\n\n    transform(row[u], row[ur], col[ur], r);\n    transform(row[u], row[ul], col[ul], l);\n    transform(row[d], row[dr], col[dr], r);\n    transform(row[d], row[dl], col[dl], l);\n\n    transform(col[l], col[lu], row[lu], u);\n    transform(col[l], col[ld], row[ld], d);\n    transform(col[r], col[ru], row[ru], u);\n    transform(col[r], col[rd], row[rd], d);\n\n    ns[c][u] = u; ns[c][l] = l; ns[c][d] = d; ns[c][r] = r;\n\n    ns[u][u] = u; ns[u][l] = ul; ns[u][d] = d; ns[u][r] = ur;\n    ns[l][u] = lu; ns[l][l] = l; ns[l][d] = ld; ns[l][r] = r;\n    ns[d][u] = u; ns[d][l] = dl; ns[d][d] = d; ns[d][r] = dr;\n    ns[r][u] = ru; ns[r][l] = l; ns[r][d] = rd; ns[r][r] = r;\n\n    ns[ul][u] = ul; ns[ul][l] = ul; ns[ul][d] = dl; ns[ul][r] = ur;\n    ns[ur][u] = ur; ns[ur][l] = ul; ns[ur][d] = dr; ns[ur][r] = ur;\n    ns[dl][u] = ul; ns[dl][l] = dl; ns[dl][d] = dl; ns[dl][r] = dr;\n    ns[dr][u] = ur; ns[dr][l] = dl; ns[dr][d] = dr; ns[dr][r] = dr;\n\n    ns[lu][u] = lu; ns[lu][l] = lu; ns[lu][d] = ld; ns[lu][r] = ru;\n    ns[ru][u] = ru; ns[ru][l] = lu; ns[ru][d] = rd; ns[ru][r] = ru;\n    ns[ld][u] = lu; ns[ld][l] = ld; ns[ld][d] = ld; ns[ld][r] = rd;\n    ns[rd][u] = ru; ns[rd][l] = ld; ns[rd][d] = rd; ns[rd][r] = rd;\n\n    scanf(\"%d\", &amp;q);\n    state = 0;\n    dir = 0;\n\n    for (int num = 1; num &lt;= q; num++)\n    {\n        int val, x, y;\n        scanf(\"%d\", &amp;val);\n        if (val == 1)\n        {\n            scanf(\"%d\", &amp;dir);\n            state = ns[state][dir];\n        }\n        else\n        {\n            scanf(\"%d%d\", &amp;x, &amp;y);\n            printf(\"%d\\n\", answer(x, y));\n        }\n\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/","title":"A2 - Porodi\u010dno stablo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 2MB <p>Anitica se bacila na veliko prole\u0107no spremanje svoje sobe. Tokom sre\u0111ivanja je nai\u0161la na veoma zanimljivu sliku \u2013 porodi\u010dno stablo njene porodice. Pored imana predaka primetila je i brojeve, za koje pretpostavlja da predstavljaju njihove sre\u0107ne brojeve. Kako joj je sre\u0111ivanje veoma brzo dosadilo, smislila je zanimljivu igricu sa porodi\u010dnim stablom.</p> <p>Pozvala je svoju simpatiju i pitala ga da zamisli i ka\u017ee joj bilo koji broj.  Zatim bi Anitica tra\u017eila put od nekog \u010dvora porodi\u010dnog stabla do nekog njegovog pretka i na tom putu sabirala neke sre\u0107ne brojeve (drugim re\u010dima nije morala sabrati sve sre\u0107ne brojeve na tom putu ve\u0107 samo one koje ona \u017eeli). Anitica defini\u0161e put, kao nizu predaka tako da je svaki naredni direktni potomak prethodnog, drugim re\u010dima da uvek iz nekog \u010dvora silazimo u \u010dvor nekog njegovog deteta. Anitica \u017eeli da data suma sre\u0107nih brojeva bude \u0161to pribli\u017enija broju koji je njena simpatija rekla.</p> <p>Anitica se dogovorila sa svojom simpatijom da ukoliko na\u0111e najbli\u017eu sumu broju koji je on zamislio, da \u0107e joj on pomo\u0107i u prole\u0107nom sre\u0111ivanju sobe (kada ka\u017eemo pomogne mislimo da \u0107e on sve sam srediti). Pomozimo Anitice kako bi mogla da u\u017eiva u ovim toplim prole\u0107nim danima.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Andreja Ili\u0107 Uro\u0161 Kostadinovi\u0107 Du\u0161an Zdravkovi\u0107"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#ulaz","title":"Ulaz","text":"<p>Prvi red standardnog ulaza sadr\u017ei dva prirodna broj \\(N\\) i \\(S\\), koji predstavljaju broj \u010dvorova u porodi\u010dnom stablu i broj koji je njena simpatija zamislila, redom. U narednih \\(N\\) redova, nalazi se opis porodi\u010dnog stabla. \u0447vorovi stabla su ozna\u010deni brojevima od \\(1\\) do \\(N\\). \\((k+1)\\)-ti red ulaza sadr\u017ei opis \u010dvora, niz brojeva odvojenih znakom razmaka, sa indeksom \\(k\\). Prvi broj, \\(s_k\\), predstavlja sre\u0107an broj datog \u010dvora. Drugi broj \\(d_k\\) predstavlja broj potomaka tog \u010dvora. Narednih \\(d_k\\) brojeva predstavljaju indekse njegovih direktnih potomaka.</p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#izlaz","title":"Izlaz","text":"<p>Prvi i jedini red standardnog izlaza treba da sadr\u017ei najpribli\u017eniju sumu sre\u0107nih brojeva na nekom putu datom broju \\(S\\). Ukoliko postoji vi\u0161e re\u0161enja, \u0161tampati najmanje.</p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#ulaz_1","title":"Ulaz","text":"<pre><code>8 20\n22 3 2 3 4\n7 2 6 5\n100 0\n1 1 7\n10 0\n2 1 8\n2 0\n12 0\n</code></pre>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#izlaz_1","title":"Izlaz","text":"<pre><code>19\n</code></pre>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Najbli\u017ea suma sre\u0107nih brojva broju \\(20\\) je suma brojeva sa \u010dvora \\(2\\) i \u010dvora \\(8\\), gde se dobija suma \\(7+12=19\\). Put je na slici \u201czaokru\u017een\u201d a crnom bojom su obojeni \u010dvorovi sa koji sabiramo vrednosti. Pribli\u017enija suma se ne mo\u017ee dobiti (u ovom slu\u010daju to zna\u010di da ne postoji put koji ima sumu \\(20\\)).</p> <p></p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 10.000\\).</li> <li>\\(1\\leq S\\leq 10.000\\).</li> <li>Sre\u0107ni brojevi \u010dvorova su iz segmenta \\([1, 100.000]\\).</li> <li>Obratiti pa\u017enju na memorijsko ograni\u010denje.</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena va\u017ei \\(N\\leq 10\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N\\leq 100\\) i \\(S\\leq 10000\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N\\leq 1000\\) i \\(S\\leq 10000\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Mo\u017eemo isprobati svih \\(2^n\\) mogu\u0107ih podskupova za re\u0161enje. Proveravamo da li su \u010dvorovi na istom putu koriste\u0107i \\(in\\) i \\(out\\) vreme u DFS obilasku. Vremenska slo\u017eenost \\(O(2^n)\\).</p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Ako nam je optimalno re\u0161enje kada je suma brojeva ve\u0107a od \\(S\\), onda \u0107emo brisanjem bilo kog broja dobiti sumu manju od \\(S\\). Za svaki list posmatrajmo put od korena do njega. Na\u0107i \u0107emo sve mogu\u0107e vrednosti sume manje od \\(S\\) na tom putu koriste\u0107i problem ranca. Kada dodajemo novi \u010dvor u ranac i dobijemo da mo\u017eemo da napravimo neku sumu ve\u0107u od \\(S\\) uze\u0107emo tu sumu kao kandidata za re\u0161enje, kao i sve mogu\u0107e sume manje od \\(S\\). Vremenska slo\u017eenost: \\(O(N^2S)\\). Memorijska slo\u017eenost: \\(O(NS)\\).</p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Za svaki \u010dvor \u010duva\u0107emo niz \\(dp_i\\) tako da je \\(dp_i,s\\) jednako 1 ako je mogu\u0107e da napravimo sumu \\(s\\) u podstablu \u010dvora \\(i\\). DFS obilaskom \u0107emo ra\u010dunati ove vrednosti, tako \u0161to prvo izra\u010dunamo vrednosti za decu nekog \u010dvora i onda radimo sli\u010dno kao u problemu ranca. Vremenska slo\u017eenost: \\(O(NS)\\). Memorijska slo\u017eenost: \\(O(NS)\\).</p>"},{"location":"takprog/2013_2014/drz/05_porodicno_stablo/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>U re\u0161enju za tre\u0107i podzadatak nam je problem memorija. Za svaki \u010dvor \u201cte\u0161ko\u201d dete zovemo ono dete sa najve\u0107im veli\u0107inom podstabla (ako ih ima vi\u0161e izaberemo proizvoljno), dok su sva ostala deca \u201claka\u201d.  U DFS obilasku za \u010dvor \\(u\\) \u0107emo prvo izra\u010dunati vrednosti za te\u0161ko dete i vrednosti za njega upisivati na mesto koje je predvi\u0107eno za \u010dvor \\(u\\), dok kada idemo u lako dete vrednosti \u0107emo upisivati u novi niz. Kada nam neki niz vi\u0161e nije potreban vrati\u0107emo mu sve vrednosti na \\(0\\) i iskoristiti za neki drugi \u010dvor. Na ovaj na\u010din \u0107e nam biti potrebno \\(O(logN)\\) nizova du\u017eine \\(S\\), jer \u0107emo novi niz koristiti samo kada idemo u lako dete, a to \u0107emo uraditi maksimalno \\(O(logN)\\) puta jer svaki put veli\u010dinu podstabla barem prepolovimo. Vremenska slo\u017eenost: \\(O(NS)\\). Memorijska slo\u017eenost: \\(O(SlogN)\\).</p> 05_porodicno_stablo.cpp<pre><code>#include&lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include&lt;vector&gt;\n#include&lt;math.h&gt;\n#include&lt;ctime&gt;\n\n#define MAX_N 10005\n#define MAX_S 10005\n\n\nint N, S, sol, s[MAX_N], parent[MAX_N], added[2 * MAX_S], numAdded[MAX_N], k;\nstd::vector&lt;int&gt; children[MAX_N];\nbool d[MAX_S * 2 + 1], mark[2 * MAX_S + 1];\n\nvoid input()\n{\n    scanf(\"%d %d\", &amp;N, &amp;S);\n    int deg, child;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        parent[i] = -1;\n    }\n    for (int i = 0; i &lt; N; i++)\n    {\n        scanf(\"%d %d\", &amp;s[i + 1], &amp;deg);\n        for (int j = 0; j &lt; deg; j++)\n        {\n            scanf(\"%d\", &amp;child);\n            children[i + 1].push_back(child);\n            parent[child] = i + 1;\n        }\n    }\n#endif\n}\n\nvoid Visit(int node)\n{\n    numAdded[node] = 0;\n    for (int currentS = 2 * MAX_S; currentS &gt;= 0; currentS--)\n    {\n        if (d[currentS])\n        {\n            if ((currentS + s[node] &lt;= 2 * MAX_S) &amp;&amp; (!d[currentS + s[node]]))\n            {\n                added[k] = currentS + s[node];\n                k++;\n                numAdded[node]++;\n                d[currentS + s[node]] = true;\n                mark[currentS + s[node]] = true;\n\n                if (abs(currentS + s [node] - S) &lt; abs(sol - S) ||\n                    ((abs(currentS + s [node] - S) == abs(sol - S)) &amp;&amp; (currentS + s[node] &lt; sol)))\n                {\n                    sol = currentS + s[node];\n                }\n            }\n        }\n    }\n    for(int i = 0; i &lt; children[node].size(); i++)\n    {\n        Visit(children[node][i]);\n    }\n    for (int i = 0; i &lt; numAdded[node]; i++)\n    {\n        d[added[k - i - 1]] = false;\n        added[k - i - 1] = 0;\n    }\n    k = k - numAdded[node];\n}\n\nvoid solve()\n{\n    int rootNode = 1;\n    while (parent[rootNode] != -1)\n    {\n        rootNode++;\n    }\n    for (int i = 1; i &lt;= 2 * MAX_S; i++)\n    {\n        d[i] = false;\n        mark[i] = false;\n    }\n    d[0] = true;\n    sol = 0;\n    k = 0;\n    Visit(rootNode);\n}\n\nvoid output()\n{\n    printf(\"%d\\n\", sol);\n}\n\nint main()\n{\n    input();\n    solve();\n    output();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/drz/06_elektricar/","title":"A3 - Elektri\u010dar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Sa po\u010detkom prole\u0107a, po\u010dinju i odre\u0111eni problemi u gradovima \u0161irom Srbije. Naime, jaki prole\u0107ni vetrovi su o\u0161tetili kablove za struju izme\u0111u svih bandera i spre\u010dili gra\u0111ane u standardnim prole\u0107nim aktivnostima \u2013 gledanju TV-a i programiranju.</p> <p>Grad mo\u017eemo zamisliti kao \\(x\\)-osu na kojoj se nalazi \\(n\\) bandera i \\(m\\) ku\u0107a zadatih svojim koordinatama. Za svaku banderu je poznata cena odr\u017eavanja \\(c_i\\) i svaka bandera mo\u017ee biti povezana kablom sa najvi\u0161e jednom banderom i to samo ako su na rastojanju ne ve\u0107em od \\(D\\). Cena kabla po jedini\u010dnoj du\u017eini je \\(S\\). Za ku\u0107u ka\u017eemo da je snabdevena strujom ukoliko iznad nje prolazi kabl tj. ukoliko postoji bar jedan par bandera koji je povezan kablom i od kojih je jedna levo a druga desno u odnosu na pomenutu ku\u0107u.</p> <p>Cena proizvoljnog sistema povezivanja bandera jednaka je (zbir cena odr\u017eavanja svih bandera koje sadr\u017ee jedan kraj kabla) + (ukupna du\u017eina kablova puta \\(S\\)). Poznati elektri\u010dar Ra\u0161a je pozvan u pomo\u0107 da pove\u017ee neke bandere kablovima tako da je svaka ku\u0107a snabdevena strujom. On je izra\u010dunao cenu najjeftinijeg takvog sistema i ispostavilo se da je to \\(C\\).  Me\u0111utim, on je izgubio papir\u010de na kome je bila napisana cena kabla po jedini\u010dnoj du\u017eini \\(S\\). Pomozite mu da odredi tu cenu ako su vam poznati svi prethodni podaci i \u010dinjenica da je \\(S\\) prirodan broj.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nemanja Majski Marko Bakovi\u0107"},{"location":"takprog/2013_2014/drz/06_elektricar/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se \\(4\\) prirodna broja - \\(n\\), \\(m\\), \\(D\\) i \\(C\\), tim redom, koji predstavljaju odgovaraju\u0107e podatke iz teksta zadatka. U narednom redu nalaze se \\(n\\) prirodnih brojeva; \\(i\\)-ti broj predstavlja cenu odr\u017eavanja \\(i\\)-te bandere.  U narednom redu nalaze se jo\u0161 \\(n\\) prirodnih brojeva u rastu\u0107em poretku; \\(i\\)-ti broj predstalja koordinatu \\(i\\)-te bandere na \\(x\\)-osi. U poslednjem redu nalazi se \\(m\\) prirodnih brojeva koji predstavljaju koordinate ku\u0107a na \\(x\\)-osi. Sve koorinate na \\(x\\)-osi su razli\u010dite.</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati prirodan broj \\(S\\). Garantuje se da \u0107e re\u0161enje uvek postojati. Ako postoji vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/drz/06_elektricar/#ulaz_1","title":"Ulaz","text":"<pre><code>4 2 12 32\n1 5 17 3\n1 5 15 17\n9 10\n</code></pre>"},{"location":"takprog/2013_2014/drz/06_elektricar/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2013_2014/drz/06_elektricar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Imamo \\(4\\) bandere na koorinatama \\(1\\), \\(5\\), \\(15\\), \\(17\\) i cenama odr\u017eavanja \\(1\\), \\(5\\), \\(17\\), \\(3\\), tim redom, kao i \\(2\\) ku\u0107e na koordinatama \\(9\\) i \\(10\\). Bandere se mogu povezivati samo ako rastojanje izme\u0111u njih nije ve\u0107e od \\(12\\) i poznato je da je cena optimalnog sistema jednaka \\(32\\). Primetimo da u optimalnom sistemu ne u\u010destvuje prva bandera jer nju mo\u017eemo povezati samo sa drugom (ostale su udaljene za vi\u0161e od \\(12\\)) a u tom slu\u010daju nijednu ku\u0107u nije mogu\u0107e snabdeti strujom (banderu mo\u017eemo povezati sa najvi\u0161e jednom banderom). Prema tome jedine dve mogu\u0107nosti za sistem u kome je svaka ku\u0107a snabdevena strujom je povezivanje \\(2.\\) i \\(3.\\) ili \\(2.\\) i \\(4.\\) bandere.</p> <p>U prvom slu\u010daju (\\(2.\\) i \\(3.\\)), ukupna cena je \\(c_2+c_3+|5-15|\\cdot S = 22+10S = C = 32\\) odakle dobijamo da je \\(S=1\\). Me\u0111utim, ako je \\(S=1\\), mo\u017eemo povezati \\(2.\\) i \\(4.\\) banderu pri \u010demu dobijamo dobar sistem sa cenom \\(c_2+c_4+|5-17|\\cdot S=20 &lt; C\\) \u0161to je nemogu\u0107e (cena najjeftinijeg sistema je \\(C\\)).</p> <p>U drugom slu\u010daju (\\(2.\\) i \\(4.\\)), ukupna cena je \\(c_2+c_4+|5-17|\\cdot S=32\\) odakle dobijamo \\(S=2\\). Za ovu vrednost broja \\(S\\) je \\(C\\) zaista najjeftinija cena dobrog sistema (jeftinija od jedine preostale mogu\u0107nosti) pa \\(S=2\\) zadovoljava uslove zadatka.</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq n, m \\leq 300.000\\).</li> <li>Koordinate bandera i ku\u0107a i cene odr\u017eavanja bandera su celi brojevi iz segmenta \\([1, 10^9]\\).</li> <li>\\(1\\leq D,C\\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(n, m, C\\leq 100\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(n\\leq 1.000\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(D=10^9\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(n\\leq 50.000\\).</li> <li>U test primerima vrednim \\(20\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/drz/06_elektricar/#opsta-opazanja","title":"Op\u0161ta opa\u017eanja","text":"<p>Recimo da nam je poznata vrednost \\(S\\) i \u017eelimo da izra\u010dunamo \\(C\\). Kasnije \u0107emo re\u0161iti i obrnut problem.</p> <p>Prvo \u0161to treba da shvatimo je da nikada ne\u0107e dva kabla i\u0107i jedan preko drugog. To mo\u017eemo da doka\u017eemo preko kontradikcije. Pretpostavimo suprotno, da je optimalno da na nekom mestu imamo dva kabla koji idu jedan preko drugog. Neka su njihovi po\u010deci i krajevi redom (\\(a_1\\),\\(b_1\\)) i (\\(a_2\\),\\(b_2\\)). Cena odr\u017eavanja tih kablova sigurno nije manja od cena odr\u017eavanja kabla (\\(min(a_1,a_2)\\), \\(max(b_1,b_2)\\)), a taj kabl prekriva sve ku\u0107e koje prekriva barem jedan od ova dva kabla.</p> <p>Tako\u0111e je va\u017eno uo\u010diti da nikada nije optimalno imati kabl koji ne prelazi preko ni jedne ku\u0107e, po\u0161to njegovo sklanjanje smanjuje cenu, a uslov je jo\u0161 uvek ispunjen.</p> <p>Neka grupa bandera predstavlja podniz uzastopnih bandera tako da izme\u0111u njih nema ku\u0107a, a direktno levo i direktno desno od nje je ku\u0107a, ili uop\u0161te nema ni ku\u0107a ni bandera. Potrebani i dovoljni uslovi za pokrivanje svih ku\u0107a kablovima su:</p> <ul> <li>Ne postoje dva kabla \u010diji se intervali presecaju.</li> <li>U svakoj grupi bandera niti po\u010dinje, niti se zavr\u0161ava neki kabl, ili po\u010dinje i zavr\u0161ava se ta\u010dno jedan kabl.</li> <li>Prva i poslednja grupa su izuzetak od prethodnog pravila, u njima po\u010dinje, odnosno zavr\u0161ava ta\u010dno jedan kabl.</li> </ul> <p>Nakon \u0161to smo podelili bandere u grupe, nas je ba\u0161 briga gde se nalaze ku\u0107e. Sada \u017eelimo da izra\u010dunamo vrednost \\(dp[i]\\) \u0161to je minimalna cena da se uslov ispuni za prefiks bandera du\u017eine \\(i\\).</p> <p>Prvo \u0107emo shvatiti da \\(dp[i]\\) ne mo\u017ee da bude ve\u0107i od bilo kog \\(dp[j]\\) gde je \\(j \\le i\\) i bandere sa indeksima \\(i\\) i \\(j\\) su u istoj grupi, po\u0161to mi mo\u017eemo samo kabl da spojimo sa banderom \\(j\\) i bandere posle nje da ignori\u0161emo.</p> <p>Sada \u0107emo pretpostaviti da je optimalno da banderu \\(i\\) spajamo sa nekom banderom \\(j\\). Va\u017eno je da te dve bandere nisu u istoj grupi, da \\(j\\) nema ku\u0107u direktno sa leve strane i da \\(i\\) nema ku\u0107u direktno sa desne strane, kao i da bandere \\(i\\) i \\(j\\) nisu na ve\u0107oj udaljenoti od \\(D\\). Ukoliko to va\u017ei, onda je \\(dp[i]= a_i \\cdot S + c_i + dp[j-1] + c_j - a_j\\cdot S\\).</p> <p>Koriste\u0107u formulu gore mo\u017eemo da izra\u010dunamo \\(dp[i]\\) za sve vrednosti \\(i\\), uz specijalan slu\u010daj da je \\(dp\\) u prvoj grupi jednako 0.</p> <p>Sada smo na\u0161li za \\(S\\) vrednost \\(C\\), kako obrunuto? Va\u017eno je shvatiti da va\u017ei \\(S \\le C\\) po\u0161to postoji barem jedna ku\u0107a. To zna\u010di da mi mo\u017eemo da tra\u017eimo vrednost \\(S\\) takvu da je vrednost optimalnog postavljanja jednaka \\(C\\).</p> <p>Predla\u017eemo da se re\u0161enja za podzadatke \u010ditaju redom po\u0161to je u pitanju samo optimizacija gore opisanog re\u0161enja.</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#resenje-za-nmc-le-100","title":"Re\u0161enje za \\(n,m,C \\le 100\\)","text":"<p>U ovom podzadatku je dovoljno da implementiramo metod opisan gore. Razpore\u0111ivanje u grupe mo\u017eemo da prekalkuli\u0161emo grubom silom, nakon toga mo\u017eemo raditi linearnu pretragu po \\(S\\) i koristiti \\(n^2\\) dp. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(MN + CN^2)\\).</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#resenje-za-nle-1000","title":"Re\u0161enje za \\(n\\le 1000\\)","text":"<p>U ovom podzataku umesto da radimo grubu silu kako bismo rasporedili bandere u grupe, mo\u017eemo da koristimo tehniku dva pokaziva\u010da.</p> <p>Tako\u0111e, primetimo da je funkcija \\(C(S)\\) rastu\u0107a, tako da mi mo\u017eemo binarno pretra\u017eivati vrednost \\(S\\).</p> <p>Jedini spor deo ovog pristupa je samo dinami\u010dko programiranje \u010dija je slo\u017eenost \\(O(n^2)\\).</p> <p>Ukupna vremenska slo\u017eenost je \\(O(m+n+n^2 log C)\\).</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#resenje-za-d109","title":"Re\u0161enje za \\(D=10^9\\)","text":"<p>Neka niz \\(a_i\\) ozna\u010dava poziciju \\(i\\)-te bandere na \\(x\\) osi.</p> <p>U ovom podzataku ne moramo da se brinemo oko toga koliko je duga\u010dak kabl. Definisa\u0107emo \\(b[i]=dp[i-1] + c_i - a_i\\cdot S\\). Sada je formula za spajanje bandere \\(i\\) sa banderom \\(j\\): \\(\\(a_i\\cdot S +c_i + b_j\\)\\) Sada samo za svako \\(i\\) moramo da pamtimo najbolji prethodni \\(b_j\\) (naravno, takav da va\u017ee prethodno pomenu ti uslovi). Po\u0161to je du\u017eina kabla neograni\u010dena, to mo\u017eemo da \u010duvamo u jednoj promenljivoj maksimuma.</p> <p>\u0160to se ti\u010de najbolje vrednosti \\(dp\\) u grupi, to isto mo\u017eemo da radimo preko promenljive. Vremenska slo\u017eenost je \\(O(M+N+Nlog C).\\)</p>"},{"location":"takprog/2013_2014/drz/06_elektricar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Najmanje \\(j\\) koje mo\u017eemo uzeti mo\u017eemo da \u010duvamo preko jednog pokaziva\u010da koji \u0107emo da pomeramo kako idemo kroz \\(i\\). Sada na neki na\u010din moramo da dinami\u010dki ubacujemo i izbacujemo elemente od kojih tra\u017eimo minimum. Za to mo\u017eemo koristiti strukturu podataka \"set\". Vremenska slo\u017eenost je \\(O(N+M + N \\cdot log N \\cdot log C).\\)</p> <p>Re\u0161enje koje umesto seta koristi korensku dekompoziciju je pokriveno podzadatkom gde je \\(N\\le 50.000\\).</p> 06_elektricar.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nconst int MaxN = 300300;\nconst long long INF = 2000000000000000000LL;\n\nstruct Pole\n{\n    int x, c;\n    bool hasHouseOnTheLeft;\n    long long extraVal;\n\n    Pole() {}\n    Pole(int _x, int _c)\n    {\n        x = _x; c = _c;\n    }\n};\n\nint n, m, C, D;\nPole poles[MaxN];\nint hx[MaxN];\nlong long sol[MaxN];\nlong long deQueue[2 * MaxN];\n\n// vraca optimalnu cenu sistema za dato S\nlong long solve(int S)\n{\n    sol[0] = 0LL;\n    int first = 0, last = -1;\n    for (int i = 1; i &lt;= n; i++)\n    {\n\n// --------------- racunanje optimalnog uparivanja 100p ---------------------- */\n        long long optimalPairVal = INF;\n\n        while (first &lt;= last &amp;&amp; poles[i].x - poles[ deQueue[first] ].x &gt; D)\n        {\n            first++;\n        }\n\n        if (first &lt;= last)\n        {\n            optimalPairVal = poles[ deQueue[first] ].extraVal + (long long)(S) * (long long)(poles[i].x) + poles[i].c;\n        }\n\n        if (!poles[i].hasHouseOnTheLeft)\n        {\n            poles[i].extraVal = sol[i - 1] - (long long)(S) * (long long)(poles[i].x) + poles[i].c;\n            while (first &lt;= last &amp;&amp; poles[i].extraVal &lt;= poles[ deQueue[last] ].extraVal)\n            {\n                last--;\n            }\n            deQueue[++last] = i;\n        }\n// --------------------------------------------------------------------------- */\n\n        if (poles[i].hasHouseOnTheLeft) // ako je (odmah) levo od i-te bandere kuca, uparivanje sigurno posotji i moramo ga izvrsiti \n        {\n            sol[i] = optimalPairVal;\n        }\n        else\n        {\n            sol[i] = min(sol[i - 1], optimalPairVal); // inace uzimamo bolju od varijante upariti ili ne upariti (ako ne postoji uparivanje, min(sol[i - 1], INF) = sol[i - 1])\n        }\n\n    }\n\n    return sol[n];\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;D, &amp;C);\n    for (int i = 1; i &lt;= n; i++)\n        scanf(\"%d\", &amp;poles[i].c);\n    for (int i = 1; i &lt;= n; i++)\n        scanf(\"%d\", &amp;poles[i].x);\n    for (int i = 1; i &lt;= m; i++)\n        scanf(\"%d\", &amp;hx[i]);\n\n    // prvo odredimo za svaku banderu da li je odmah levo od nje kuca\n\n    int ind = 1;  // indeks trenutne kuce\n    poles[1].hasHouseOnTheLeft = false;\n    for (int i = 2; i &lt;= n; i++)\n    {\n        poles[i].hasHouseOnTheLeft = (poles[i].x &gt; hx[ind] &amp;&amp; hx[ind] &gt; poles[i - 1].x);\n        while (ind &lt; m &amp;&amp; hx[ind] &lt; poles[i].x) ind++;\n    }\n\n    // S nalazimo uz pomoc binarne pretrage\n\n    int left = 1, right = C, mid;\n    while (left &lt;= right)\n    {\n        int mid = (left + right) / 2;\n        long long val = solve(mid);\n        if (val == C)\n        {\n            printf(\"%d\\n\", mid);\n            return 0;\n        }\n\n        if (val &lt; C)\n        {\n            left = mid + 1;\n        }\n        else\n        {\n            right = mid - 1;\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/","title":"1 - Razli\u010diti brojevi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Pred Zimske olimpijske igre, organizator svakodnevno meri visinu snega. Nekad i vi\u0161e puta dnevno. Rezultati merenja dostupni su svima. Ameri\u010dka reprezentacija veruje da mo\u017ee pomo\u0107i svojim skija\u0161ima ako detaljno analizira ove podatke. Primetili su da se visina snega s vremenom nikako ne smanjuje. Me\u0111utim, \u010desto im je bio potreban odgovor na pitanje: Koliko se razli\u010ditih visina pojavljuje izme\u0111u dva merenja (ra\u010dunaju\u0107i i ta merenja)? Njihovim programerima je trebalo previ\u0161e vremena da odgovore na ova pitanja, pa su zamolili vas za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Bakovi\u0107 Marko Bakovi\u0107 Nepoznato Aleksandar Ivanovi\u0107 <p>Za svaki interval, prolaskom od levog do desnog kraja, mo\u017eemo na\u0107i broj razli\u010ditih brojeva koje sadr\u017ei tako \u0161to \u0107emo brojati samo prvo pojavljivanje svakog broja. Kako \u0107emo znati da je neko pojavljivanje prvo? Znamo da je niz sortiran, pa va\u017ei da je pojavljivanje broja prvo ako je taj broj ili prvi broj unutar intervala, ili je broj razli\u010dit od svog prethodnika (broja levo od njega). Vremenska slo\u017eenost po upitu je \\(O(N)\\), pa je slo\u017eenost ovog re\u0161enja \\(O(N\\cdot Q)\\). Memorijska slo\u017eenost je \\(O(N)\\). Ovo re\u0161enje donosi \\(30\\) poena.</p> <p>Neka je \\(cnt[k][i]\\) broj pojavljivanja broja \\(k\\) u nizu na pozicijama od \\(1\\) do \\(i\\). Va\u017ei slede\u0107e: $$ cnt[k][i] = cnt[k][i\u20131], \\text{ako je } niz[i] \\neq k $$ $$ cnt[k][i] = cnt[k][i\u20131] + 1, \\text{ako je } niz[i] = K $$ Koriste\u0107i ovo, cnt mo\u017eemo odrediti u slo\u017eenosti \\(O(max\\_num\\cdot N)\\) gde je \\(max\\_num\\) najve\u0107i broj u nizu. Za svaki interval mo\u017eemo u slo\u017eenosti \\(O(1)\\) da odredimo da li se broj \\(K\\) pojavljuje unutar intervala tako \u0161to je broj pojavljivanja broja \\(k\\) unutar \\([l, r]\\) jednak \\(cnt[k][r] \u2013 cnt[k][l\u20131]\\). Sada na svaki upit mo\u017eemo odgovoriti prolaskom od \\(1\\) do \\(max\\_num\\) i proverom za svaki broj da li se pojavljuje unutar intervala iz upita. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(Q\\cdot max\\_num + N\\cdot max\\_num)\\), a memorijska \\(O(N\\cdot max\\_num)\\). Ovo re\u0161enje tako\u0111e vredi \\(30\\) poena, ali mo\u017ee se primeniti u kombinaciji sa prethodnim re\u0161enjem tako \u0161to ukoliko je \\(max\\_num \\leq 500\\) radimo u slo\u017eenosti \\(O(Q\\leq max\\_num + N\\leq max\\_num)\\), a ina\u010de u slo\u017eenosti \\(O(N\\cdot Q)\\), i ovakva kombinacija vredi \\(60\\) poena.</p> <p>Analizirajmo sada re\u0161enje za \\(100\\) poena. Posmatrajmo samo prvo pojavljivanje svakog broja u nizu. Neka je \\(dp[i]\\) broj ovih prvih pojavljivanja u nizu na pozicijama od \\(1\\) do \\(i\\). Broj razli\u010ditih brojeva na intervalu jednak je broju prvih pojavljivanja na intervalu. Ve\u0107 smo rekli da je pojavljivanje broja prvo ako je taj broj ili prvi broj unutar intervala, ili je broj razli\u010dit od svog prethodnika. Broj onih koji su razli\u010diti od svog prethodnika na intervalu \\([l, r]\\) jednak je \\(dp[r] \u2013 dp[l-1]\\). Me\u0111utim, u slu\u010daju da je \\(niz[l] = niz[l-1]\\), tada re\u0161enje treba uve\u0107ati za \\(1\\) jer nismo ra\u010dunali broj sa indeksom \\(l\\) jer je on jednak svom prethodniku, a treba ga ra\u010dunati zato \u0161to je prvi broj unutar intervala. Dakle, re\u0161enje za interval \\([l, r]\\) je: $$ dp[r] \u2013 dp[l-1], \\text{ako je } niz[l] \\neq niz[l-1] $$ $$ dp[r] \u2013 dp[l-1] + 1, \\text{ako je } niz[l] = niz[l-1] $$ Niz \\(dp\\) kreiramo u slo\u017eenosti \\(O(N)\\), i kada imamo taj niz, na upite odgovaramo u \\(O(1)\\). Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N + Q)\\), a memorijska \\(O(N)\\).</p> 01_razliciti_brojevi.cpp<pre><code>/*\n    Marko Bakovic\n    Razliciti brojevi O(Q + N)\n*/\n\n#include &lt;cstdio&gt;\n\nconst int maxn = 1e6 + 5;\n\nint n, q, niz[ maxn ], broj_razlicitih[ maxn ], leva_granica, desna_granica;\n\nint main()\n{\n    scanf( \"%d\", &amp;n );\n    for ( int i = 0; i &lt; n; i++ ) scanf( \"%d\", &amp;niz[ i ] );\n    broj_razlicitih[ 0 ] = 1;\n    for ( int i = 1; i &lt; n; i++ )\n    {\n        if ( niz[ i ] != niz[ i - 1 ] ) broj_razlicitih[ i ] = broj_razlicitih[ i - 1 ] + 1;\n        else broj_razlicitih[ i ] = broj_razlicitih[ i - 1 ];\n    }\n    scanf( \"%d\", &amp;q );\n    for ( int i = 0; i &lt; q; i++ )\n    {\n        scanf( \"%d %d\", &amp;leva_granica, &amp;desna_granica );\n        int resenje = broj_razlicitih[ desna_granica ];\n        if ( leva_granica )\n        {\n            resenje -= broj_razlicitih[ leva_granica - 1 ];\n            if ( niz[ leva_granica ] == niz[ leva_granica - 1 ] ) resenje++;\n        }\n        printf( \"%d\\n\", resenje );\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(N\\), broj rezultata merenja. U drugom redu nalazi se \\(N\\) prirodnih brojeva, koji predstavljaju rezultate (visinu snega), u redosledu merenja. U tre\u0107em redu nalazi se broj \\(Q\\), broj upita Ameri\u010dke reprezentacije. U slede\u0107ih \\(Q\\) redova nalaze se dva cela broja \\(L\\) i \\(R\\) koji predstavljaju redne brojeve dva merenja (merenja su indeksirana brojevima od \\(0\\) do \\(N-1\\)).</p>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#izlaz","title":"Izlaz","text":"<p>Standardni izlaz sadr\u017ei \\(Q\\) celih brojeva, svaki u novom redu, koji predstavljaju odgovore na pitanje Ameri\u010dke reprezentacije za data dva merenja. U \\(i\\)-tom redu nalazi se odgovor na \\(i\\)-ti upit.</p>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#ulaz_1","title":"Ulaz","text":"<pre><code>10\n1 2 2 2 4 4 5 6 7 7\n5\n0 9\n1 3\n1 5\n7 9\n4 4\n</code></pre>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n1\n2\n2\n1\n</code></pre>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom upitu rezultati koji se pojavljuju su \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(6\\) i \\(7\\). U drugom to je samo \\(2\\). Izme\u0111u merenja broj \\(1\\) i broj \\(5\\) pojavljuju se rezultati \\(2\\) i \\(4\\).</p>"},{"location":"takprog/2013_2014/kv1/01_razliciti_brojevi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 100.000\\).</li> <li>\\(0 \\leq L \\leq R \\leq N-1\\).</li> <li>Visina snega je ve\u0107a od \\(0\\) a manja od \\(10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U testovima vrednim 30 poena: \\(1 \\leq N, Q \\leq 1000\\).</li> <li>U testovima vrednim 30 poena: \\(10 \\leq N \\leq 10.000\\) i visina snega je manja od 500.</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/","title":"2 - Crtanje brojeva","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 16MB <p>Anitica je nau\u010dila da crta ali ne i da pi\u0161e, no za Zimske olimpijske igre \u017eeli da bodri na\u0161e ekipe tako \u0161to \u0107e ispisati njihova imena na snegu. Za po\u010detak \u017eeli da nau\u010di da pi\u0161e cifre, a slede\u0107e nedelje \u0107e raditi na slovima. Na\u010dula je da je najlak\u0161i na\u010din da to nau\u010di je da prvo crta cifre crticama, sli\u010dno kao na digitalnom displeju. Za tu svrhu je izabrala papir na kvadrati\u0107e kako bi lak\u0161e povla\u010dila crtice.</p> <p>Na po\u010detku Anitica spusti vrh olokve na  bilo koji \u010dvor na papiru. Nakon toga prati komande kako bi iscrtala cifre, pri \u010demu komande mogu biti:</p> <ul> <li>'U' - pomerajnje oloke gore za jednu crticu</li> <li>'L' - pomeranje olovke levo za jednu crticu</li> <li>'D' - pomeranje olovke dole za jednu crticu</li> <li>'R' - pomeranje olokve desno za jednu crticu</li> <li>'_' - spu\u0161tanje olovke na papir</li> <li>'^' - podizanje olokve sa papira.</li> </ul> <p>Kako bi joj olak\u0161ali proveru rezultata, re\u0161ili smo da napi\u0161emo program koji za zadatu listu komandi vra\u0107a cifru koje one ispisuju. Izgled cifara na digitalnom displeju:</p> <p></p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andreja Ili\u0107 Andreja Ili\u0107 Andreja Ili\u0107 Du\u0161an Zdravkovi\u0107 <p>Na prvi pogled, odnosno u na\u0161em slu\u010daju na prvo \u010ditanje, problem deluje jednostavno. Me\u0111utim, pri malo detaljnijoj analizi ili pri poku\u0161aju implementacije mogu se uo\u010diti odre\u0111eni specijalni slu\u010dajevi koji nam, ukoliko se o njima dobro ne razmisli, mogu \u201czagor\u010dati \u017eivot\u201c.</p> <p>Kako je ograni\u010denje za du\u017einu niza komandi malo - simulacija se prosto name\u0107e. Nakon simulacije imamo \u201csliku\u201d koju treba uporediti sa slikama svih cifara. Kao rezultat vra\u0107amo cifru \u010dija se slika poklopila sa slikom koju smo dobili simulacijom. Zato se postavlja pitanje kako izvr\u0161iti samu simulaciju? U zadatku Anitica crta po ivicama re\u0161etke, tako da ukoliko bi papir modelirali matricom potrebno je na\u0107i na\u010din markiranja ivica a ne polja matrice. Samo markiranje i ne predstavlja veliki problem, ali kasnije moramo tu sliku upore\u0111ivati sa slikama drugih cifara, \u0161to mo\u017ee biti problem.</p> <p>Zato se mo\u017eemo poslu\u017eiti trikom da papir modeliramo matricom, ali da se potez simulira tako \u0161to markiramo tri polja matrice (u datom smeru). Naime, u svakom trenutku pamtimo trenutnu poziciju na kojoj se nalazi olovka. Ozna\u010dimo koordinate trenutne pozicije sa \\((currentX, currentY)\\). Ukoliko je, na primer, naredna komanda povla\u010denje olovke desno, tada polja \\((currentX, currentY)\\), \\((currentX, currentY+1)\\) i \\((currentX, currentY+2)\\) treba obojiti ukoliko je olovka na papiru. Za pam\u0107enje stanja olovke, da li je na papriru ili u vazduhu, mo\u017eemo koristiti obi\u010dnu boolean promenjivu koja menja vrednosti kada nai\u0111e na odgovaraju\u0107e komande.</p> <p>Simulacija primera sa papira. Crno polje predstavalja poziciju olovke kada je ona spu\u0161tena, a sivo polje kada je u vazduhy:</p> <p></p> <p>Kako znamo da \u0107e na kraju iscrtana slika predstavljati neku od deset cifara (uslov zadatka), na\u0161a simulacija ne mo\u017ee \u201cnacrtati\u201d sliku dimenzija ve\u0107ih od \\(6\\times 3\\). Na\u017ealost, kako iz samog problema ne znamo ta\u010dnu poziciju iz koje Anitica kre\u0107e da crta (primera radi ne znamo da ona uvek kre\u0107e iz gornjeg-desnog ugla), na\u0161u simulaciju mo\u017eemo zapo\u010deti iz sredine matrice. Ovde se krije jedan mali problem. Naime, ukoliko samu simulaciju vr\u0161imo tako \u0161to se uvek kre\u0107emo po poljima matrice, onda matrica mora biti veoma velika. Ali mi znamo da je deo matrice koji je nama bitan, deo na kome su oboje polja, ne mo\u017ee biti ve\u0107i od gore navedene dimenzije, mi onda mo\u017eemo vr\u0161iti simulaciju samo kada je olovka na papiru. Kada je olovka u vazduhu mi mo\u017eemo samo da menjamo vrednosti trenutne pozicije u matrici. U trenucima kada je olovka na papiru, pored menjanja trenutne pozicije, polja kroz koja prolazimo treba markirati (odnosno obojiti).</p> <p>Sada znamo da je potrebno definisati malu matricu koja \u0107e nam slu\u017eiti za simulaciju, ali se postavlja pitanje kolika dimenzija te matrica je potrebna? Gore smo spomenuli da mi ne znamo u kome smeru \u0107e Anitica crtati cifre, tako da kada krenemo simulaciju iz sredine matrice, ne znamo da li \u0107e Anitica nastaviti crtanje dole desno ili gore levo ili samo dole. Zbog toga mo\u017eemo definisati matricu koja mo\u017ee prihvatiti cifre u svim pravcima. Iz ove analize mo\u017eemo zaklju\u010diti da je dovoljno matricu definisati sa dimenzijama \\((3+3)\\times (6+6)\\).</p> <p>Na\u017ealost, u ovoj analizi nam se podkrao jo\u0161 jedan specijalni slu\u010daj \u2013 \u0161ta ako prva komanda predstavlja podizanje olovke u vazduh. Ukoliko krenemo slimulaciju odmah, mo\u017ee se desiti da prvi trenutak kada Anitica spisti olovku bude mnogo izvan opsega na\u0161e matrice. Ono \u0161to mi znamo jeste da \u010dim povu\u010de prvu crticu, onda \u0107e ostatak slike biti blizu te crtice. Zato je na po\u010detku potretrebno zanemariti deo pre prve crte koju povu\u010de Anitice. Ovo zapravo predstavlja po\u010detni deo niza komndati koji se de\u0161ava \u201cu vazduhu\u201d.</p> <p>Slike cifara: <pre><code>###   #   ###  ###  # #  ###  ###  ###  ###  ###\n# #   #     #    #  # #  #    #      #  # #  # #\n# #   #   ###  ###  ###  ###  ###    #  ###  ###\n# #   #   #      #    #    #  # #    #  # #    #\n###   #   ###  ###    #  ###  ###    #  ###  ###\n</code></pre> Na kraju simulacije imamo stanje matrice iz koje treba prepozanti cifru. Na po\u010detku mo\u017eemo definisati izglede svih deset cifara i njihove slike ubaciti u kod. Sliku koju je nacrtala Anitica mo\u017eemo dobiti tako \u0161to iz matrice izvu\u010demo onaj deo koji je veli\u010dine \\(6\\times 3\\) i koji sadr\u017ei sliku (ostali deo slike nam nije potreban). Kada sve ove vrednosti imamo, mo\u017eemo uporediti navedeni deo podmatrice sa svim ciframa i vratiti onu \u010dija se slika poklapa.</p>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#ulaz","title":"Ulaz","text":"<p>Prvi red standardnog ulaza sadr\u017ei prirodni broj \\(N\\), koji predstavlja broj cifara koje treba proveriti. Narednih \\(N\\) redova sadr\u017ee po jedan string koji opisuje niz komandi. Komande za svaku cifru se izvr\u0161avaju redosledom kojim su zadate.</p>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza \u0161tampati niz od \\(N\\) cifara, koje su odvojene po jednim znakom razmaka. Cifre predstavljaju rezultate nizova komandi u redusledu iz ulaza.</p>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#ulaz_1","title":"Ulaz","text":"<pre><code>2\nUL^D_RDLR^U\nD^LLDRR_U\n</code></pre>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#izlaz_1","title":"Izlaz","text":"<pre><code>3 1\n</code></pre>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N \\leq 10\\).</li> <li>Du\u017eina niza komandi, odnosno stringova iz ulaza, nije ve\u0107a od \\(1000\\).</li> <li>Ishod svakog niza komandi predstavlja validnu cifru. Ulaz \u0107e uvek sadr\u017eati regularni niz komandi.</li> <li>Izgled cifara je dat na slici u tekstu problema.</li> </ul>"},{"location":"takprog/2013_2014/kv1/02_crtanje_brojeva/#generalizacija","title":"Generalizacija","text":"<p>Dve generalizacije ovogo problema su bile razmatrane za ovo takmi\u010denje. Prva je da cifre koje crta Anitica mogu biti sklirane, drugim re\u010dima onda mo\u017ee nacrtana broj jedan veli\u010dine 15 uzastopnih crtica na gore ili na dole. Ovde bi prepoznavanje samih cifara bilo dosta komplikovanije, jer nije dovoljno ipitivati samo puku jednakost dve podmatrice.</p> <p>Druga generalizacije je bila ukoliko cifre nisu skalirane, ali Anitica mo\u017ee da pogre\u0161i i da nacrta bilo \u0161ta. Ovo bi upore\u0111ivanje bilo identi\u010dno kao i u po\u010detnoj verziji problema ali bi bilo potrebno ubaciti jo\u0161 neke specijalne slu\u010dajeve u anazizu. Ovi specijalni slu\u010dajevi bi slu\u017eili da nam pomognu u odluci da li da nastvimo simulaciju ili ne \u2013 na primer ukoliko Anitica po\u010dne da \u0161ara po papiru svuda \u010dime se dobija velika slika koja svakako nije cifra.</p> 02_crtanje_brojeva.cpp<pre><code>/* ===============================================================\nProblem:        Crtanje brojeva\nTakmicenje:     Kvalifikacije 01, februar 2014\nAutor:          Andreja Ilic, andrejko.ilic@gmail.com\n=============================================================== */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_N 11\n#define MAX_LEN 10005\n#define M 10\n\nint n, digit[MAX_N];\nchar comands[MAX_LEN];\nbool board [M][M];\n\n// Binarna reprezentacija cifara 0 - 9. Svaka cifra je predstavljena matricom 5 x 3 na sledeci nacin\n//\n//  ###   #   ###  ###  # #  ###  ###  ###  ###  ###\n//  # #   #     #    #  # #  #    #      #  # #  # #\n//  # #   #   ###  ###  ###  ###  ###    #  ###  ###\n//  # #   #   #      #    #    #  # #    #  # #    #\n//  ###   #   ###  ###    #  ###  ###    #  ###  ###\n//  \n// pri cemu znak # oznacava 1 u binarnom zapisu, a space oznacava 0. Na ovaj nacin je svaka cifra\n// opisana sa 15o bitnim prirodnim brojema, koji se dobija kada se data matrica prebaci u niz, \n// prebacivanjem vrste po vrste. Primera radi broj nula (111101101101111)_2 = (31599)_10\nint digits [10] = { 31599, 18724, 29671, 29647, 23497, 31183, 31215, 29257, 31727, 31695};\n\nint solve()\n{\n    // Inicijalizacija matrice na praznu matricu\n    for(int i = 0; i &lt; M; i++)\n        for(int j = 0; j &lt; M; j++)\n            board [i][j] = false;\n\n    // Polazimo iz sredista matrice, pri cemu je na pocetku olovka spustena\n    int currentX = M / 2, currentY = M / 2;\n    bool pencilDown = true;\n\n    // Preskacemo pocetak komandi sve dok naidjemo na prvu crticu koju povlacimo\n    int startIndex = 0;\n    while (!(pencilDown &amp;&amp; comands[startIndex] != '^' &amp;&amp; comands[startIndex] != '_'))\n    {\n        if (comands[startIndex] == '^')\n            pencilDown = false;\n        if (comands[startIndex] == '_')\n            pencilDown = true;\n        startIndex++;\n    }\n\n    // Simulacija crtanja\n    for(int index = startIndex; index &lt; strlen(comands); index++)\n    {\n        switch(comands[index])\n        {\n        case '_':\n            pencilDown = true;\n            break;\n        case '^':\n            pencilDown = false;\n            break;\n        case 'U':\n            if (pencilDown)\n                board [currentX][currentY] = board [currentX - 1][currentY] = board [currentX - 2][currentY] = true;\n            currentX = currentX - 2;\n            break;\n        case 'D':\n            if (pencilDown)\n                board [currentX][currentY] = board [currentX + 1][currentY] = board [currentX + 2][currentY] = true;\n            currentX = currentX + 2;\n            break;\n        case 'L':\n            if (pencilDown)\n                board [currentX][currentY] = board [currentX][currentY - 1] = board [currentX][currentY - 2] = true;\n            currentY = currentY - 2;\n            break;\n        case 'R':\n            if (pencilDown)\n                board [currentX][currentY] = board [currentX][currentY + 1] = board [currentX][currentY + 2] = true;\n            currentY = currentY + 2;\n            break;\n        default:\n            break;\n        }\n    }\n\n    // Nalazimo prvo polje koje je obojeno olovkom. Ono definise podmatricu koja zapravo sadrzi broj.\n    // (ovo polje je gornje levo polje podmatrice).\n    int startX = -1, startY = -1;\n    for (int i = 0; i &lt; M &amp;&amp; startX == -1; i++)\n        for (int j = 0; j &lt; M &amp;&amp; startX == -1; j++)\n            if(board[i][j])\n            {\n                startX = i;\n                startY  = j;\n            }\n\n    // Za svaku od cifara proveravamo da li se matrica cifre poklapa sa podmatricom\n    for(int digit = 0; digit &lt; 10; digit++)\n    {\n        bool match = true;\n\n        for(int i = 0; i &lt; 5; i++)\n        {\n            for(int j = 0; j &lt; 3; j++)\n            {\n                int index = 14 - (i * 3 + j);\n                bool state = (digits[digit] &amp; (1 &lt;&lt; index)) != 0;\n                if (state != board [startX + i][startY + j])\n                {\n                    match = false;\n                }\n            }\n        }\n\n        if (match)\n            return digit;\n    }\n\n    // Kako su nizovi komandi regularni ovo se nikada nece dostici\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(\"%s\", comands);\n        digit[i] = solve();\n    }\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%d \", digit [i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/03_skakac/","title":"3 - Skaka\u010d","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 16MB <p>Na ovogodi\u0161njim Zimskim olimpijskim igrama u ruskom gradu S(k)o\u010diju u disciplini ski-skokovi na\u0161u zemlju predstavlja prekaljeni skaka\u010d Mi\u0161ke. Teren za skakanje mo\u017eemo zamisliti kao matricu sa \\(n\\) vrsta i \\(m\\) kolona podeljenu na \\(nm\\) polja pri \u010demu se Mi\u0161ke na po\u010detku nalazi na polju u preseku \\(r\\)-te vrste i \\(c\\)-te kolone. Me\u0111utim, osim \u0161to je prekaljeni skaka\u010d, Mi\u0161ke je i prekaljeni igra\u010d \u0161aha pa ume da ska\u010de samo kao figura skaka\u010d u \u0161ahu.</p> <p>Pre nego \u0161to izabere gde \u0107e skakati, Mi\u0161ke \u017eeli da zna na koliko razli\u010ditih polja mo\u017ee zavr\u0161iti ako krene sa svog po\u010detnog polja i napravi ta\u010dno \\(k\\) skokova (\\(k\\) \u0107e uvek biti \\(1\\) ili \\(2\\)). Kako Mi\u0161ke nije prekaljeni programer, na vama je da mu date ovu informaciju koja \u0107e mu pomo\u0107i u borbi za medalju!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161ko Obradovi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Stojiljkovi\u0107 <p>Za kompletno re\u0161enje zadatka, dovoljno je ispitati sva polja na koje skaka\u010d mo\u017ee do\u0107i u jednom, odnosno u dva poteza.  Za ovo je najjednostavnije napraviti dva konstantna niza: \\(dx[1\\ldots 8] = \\{-2, -2, -1, -1, 1, 1, 2, 2\\}\\) i \\(dy[1\\ldots 8] = \\{-1, 1, -2, 2, -2, 2, -1, 1\\}\\); tada skaka\u010d sa polja \\((x, y)\\) mo\u017ee sko\u010diti na polja oblika \\((x+dx[i], y+dy[i])\\), za svako \\(1\\leq i \\leq 8\\), koja su unutar table.</p> <p>Za \\(K=2\\), tako\u0111e generi\u0161emo sve mogu\u0107e (dvo)poteze (njih \\(64\\)) pri \u010demu proveravamo da li je skaka\u010d unutar table i posle prvog i posle drugog poteza. Primetimo da je mogu\u0107e da smo na neko polje stigli na \\(2\\) na\u010dina ali to polje treba ra\u010dunati samo jednom u re\u0161enju. Jedan od na\u010dina za izbacivanje duplikata je da u nizu pamtimo sva razli\u010dita polja do kojih smo do tada mogli do\u0107i u dva poteza i, ukoliko se trenutno polje ne nalazi u nizu, dodajemo ga i pove\u0107avamo re\u0161enje za \\(1\\).</p> <p>Ra\u010dunanje nekog polja \\(2\\) puta smo mogli izbe\u0107i i koriste\u0107i \u010dinjenicu da skaka\u010d posle \\(2\\) poteza mo\u017ee oti\u0107i najvi\u0161e 4 polja u svakom smeru \u2013 dovoljno je \u201codse\u0107i\u201d odgovaraju\u0107i deo table dimenzije ne ve\u0107e od 5\u00d75 i jednostavno markirati odgovaraju\u0107a polja u dobijenoj maloj matrici.</p> <p>Vremenska i memorijska slo\u017eenost algoritma je u svakom slu\u010daju \\(O(1)\\).</p> 03_skakac.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int dx[] = {-2, -2, -1, -1, +1, +1, +2, +2};\nconst int dy[] = {-1, +1, -2, +2, -2, +2, -1, +1};\n\nint X[100], Y[100];\nint n, m, r, c, k, sol;\n\nbool ok(int x, int y)\n{\n    return (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m);\n}\n\nint solveK1()\n{\n    int sol = 0;\n    for (int i = 0; i &lt; 8; i++)\n        if (ok(r + dx[i], c + dy[i])) sol++;\n    return sol;\n}\n\nint solveK2()\n{\n    int num = 0;\n    for (int i = 0; i &lt; 8; i++)\n    {\n        if (ok(r + dx[i], c + dy[i]))\n        {\n            for (int j = 0; j &lt; 8; j++)\n            {\n                if (ok(r + dx[i] + dx[j], c + dy[i] + dy[j]))\n                {\n                    num++;\n                    X[num] = r + dx[i] + dx[j];\n                    Y[num] = c + dy[i] + dy[j];\n                }\n            }\n        }\n    }\n\n    int sol = 0;\n    for (int i = 1; i &lt;= num; i++)\n    {\n        bool moveExists = false;\n        for (int j = 1; j &lt; i; j++)\n        {\n            if (X[i] == X[j] &amp;&amp; Y[i] == Y[j])\n                moveExists = true;\n        }\n        if (!moveExists) sol++;\n    }\n\n    return sol;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;r, &amp;c, &amp;k);\n\n    if (k == 1)\n        printf(\"%d\\n\", solveK1());\n    else\n        printf(\"%d\\n\", solveK2());\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/03_skakac/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se, redom, pet prirodnih brojeva razdvojenih po jednim razmakom: \\(n\\) (broj vrsta), \\(m\\) (broj kolona), \\(r\\) (redni broj vrste u kojoj se Mi\u0161ke nalazi na po\u010detku), \\(c\\) (redni broj kolone u kojoj se Mi\u0161ke nalazi na po\u010detku) i \\(k\\) (broj skokova koje planira da napravi). Vrste i kolone su numerisane po\u010dev\u0161i od broja \\(1\\).</p>"},{"location":"takprog/2013_2014/kv1/03_skakac/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati broj razli\u010ditih polja na koje Mi\u0161ke mo\u017ee zavr\u0161iti posle ta\u010dno \\(k\\) poteza ako krene sa svog po\u010detnog polja.</p>"},{"location":"takprog/2013_2014/kv1/03_skakac/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv1/03_skakac/#ulaz_1","title":"Ulaz","text":"<pre><code>8 8 1 2 1\n</code></pre>"},{"location":"takprog/2013_2014/kv1/03_skakac/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2013_2014/kv1/03_skakac/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Teren je dimenzija \\(8\\times 8\\), Mi\u0161ke se nalazi u preseku prve vrste i druge kolone, tj. na polju \\((1, 2)\\). Posle jednog skoka on mo\u017ee zavr\u0161iti samo na poljima \\((3, 1)\\), \\((3, 3)\\) i \\((2, 4)\\), pa je re\u0161enje \\(3\\).</p>"},{"location":"takprog/2013_2014/kv1/03_skakac/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq r \\leq n \\leq 2\\cdot 10^9\\).</li> <li>\\(1 \\leq c \\leq m \\leq 2\\cdot 10^9\\).</li> <li>\\(1 \\leq k \\leq 2\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(60\\) poena je \\(k=1\\).</li> <li>U test primerima vrednim \\(40\\) poena je \\(k=2\\).</li> </ul>"},{"location":"takprog/2013_2014/kv1/04_turista/","title":"4 - Turista","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 700ms 256MB <p>Gazda Srba i njegova deca su veliki ljubitelji Zimskih olimpijskih igara. Gazda Srba je dve godine prodavao \u0161ljive sa svog vo\u0107njaka \u0161ljiva u srcu \u0160umadije i skupio je dovoljno para da jedno od svoje N dece po\u0161alje turisti\u010dki na ovogodi\u0161nje Zimske olimpijske igre u So\u010diju.</p> <p>On je u dogovoru sa svojom decom organizovao izbore na kojima bi se odlu\u010dio koje dete ide na Zimske olimpijske igre. Svako dete je napisalo na svom glasa\u010dkom listi\u0107u jedno ime i ubacilo u glasa\u010dku kutiju. Gazda Srba je na glasanju bio uzdr\u017ean, predao je prazan listi\u0107.</p> <p>Pravila ovog glasanja nisu uobi\u010dajena. Gazda Srba je veliki ljubitelj palindroma (palindrom je re\u010d koja se \u010dita isto i sa leve i sa desne strane, npr. Ana) i imena sve njegove dece su palindromi. Neka deca su na glasanju bila nesta\u0161na i predala su neva\u017ee\u0107e listi\u0107e, listi\u0107e na kojima pi\u0161u imena koja nisu palindromi. Neka deca su me\u0111utim napisala imena koja su palindromi, ali nisu vodili ra\u010duna o malim i velikim slovima pa su pisala imena kao \u0161to su ANA, BoB, LoL, HaNNAh, \u2026 Gazda Srba je doneo odluku da uva\u017ei takve glasa\u010dke listi\u0107e i zbog toga \u0107e on sve listi\u0107e prepraviti da sadr\u017ee samo mala slova. (ANA -&gt; ana, BoB -&gt; bob, LoL -&gt; lol, HaNNAh -&gt; hannah, \u2026 )</p> <p>Pobednik ovog glasanja je ono dete  koje ima najvi\u0161e glasova, a u slu\u010daju da vi\u0161e dece ima najvi\u0161e glasova onda je pobednik ono dete  koje ima najvi\u0161e glasova i \u010dije je ime leksikografski najmanje.</p> <p>Odredite koje dete je Gazda Srba poslao na Zimske olimpijske igre u So\u010diju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Ivanovi\u0107 Aleksandar Ivanovi\u0107 Aleksandar Ivanovi\u0107 Du\u0161an Zdravkovi\u0107 <p>U ovom zadatku se od takmi\u010dara zahtevalo da u listi re\u010di prona\u0111e od svih palindroma koji se najvi\u0161e pojavljuju u listi od svih re\u010di onaj koji je leksikografski najmanji. Zadatak se pokazao kao jedan od te\u017eih iz ovog seta i samo je devetoro takmi\u010dara osvojilo maksimalan broj poena.</p> <p>Prva stvar koju treba uraditi u svakom re\u0161enju ovog zadatka je izdvojiti palindrome u posebnu listu jer nam re\u010di koje nisu palindromi ne uti\u010du na re\u0161enje i samo nam pove\u0107avaju vremensku slo\u017eenost.</p> <p>Test primeri su bili podeljeni u tri disjunktne grupe.</p> <p>U prvoj grupi se nalazilo \\(20\\%\\) test primera i za test primere iz prve grupe je va\u017eilo da je broj re\u010di u ulaznoj listi \\(N \\leq 1.000\\). Za re\u0161avanje ovog podzadatka je bilo dovoljno proveriti sa dve petlje za fiksiran indeks \\(1 \\leq i \\leq N_{pal}\\) koliko postoji indeksa \\(i \\leq j \\leq N_{pal}\\) takvih da je \\(Pal[i]=Pal[j]\\), gde je \\(Pal\\) lista palindromskih re\u010di.  Slo\u017eenost ovog re\u0161enja je \\(O(N_{pal}^2 \\cdot L)\\), gde je \\(L\\) du\u017eina re\u010di sa ulaza. \\(L\\) po uslovima zadatka nije ve\u0107e od \\(10\\).</p> <p>U drugoj se nalazilo \\(60\\%\\) test primera i za te test primere je va\u017eilo \\(N \\leq 50.000\\). Za re\u0161avanje ove grupe test primera je bilo potrebno da se zaklju\u010di da se ulazne re\u010di mogu sortirati i da \u0107e se onda jednake re\u010di pojavljivati jedna za drugom u listi. Nakon sortiranja re\u010di re\u0161enje se mo\u017ee prona\u0107i jednim prolazom kroz niz tako \u0161to se sve re\u010di u uzastopnom bloku jednakih re\u010di obra\u0111uju odjednom. Ukoliko se koristi efikasan algoritam za sortiranje, re\u0161enje ima slo\u017eenost \\(O(N_{pal}\\cdot \\log(N_{pal}) \\cdot L)\\).</p> <p>U poslednjoj grupi test primera se nalazilo \\(20\\%\\) test primera i za re\u0161avanje ove grupe test primera je bilo potrebno primeniti tehniku he\u0161iranja. Mo\u017eemo primetiti da je u prethodnim re\u0161enjima u slo\u017eenosti figurisala du\u017eina re\u010di \\(L\\). Iako je ta du\u017eina mala mo\u017eemo je izostaviti tako \u0161to \u0107emo ulazne re\u010di he\u0161irati, odnosno pretvoriti u brojeve. He\u0161iranje re\u010di u brojeve je injektivno preslikavanje skupa re\u010di u skup integera. Po\u0161to su ulazne re\u010di kratke mo\u017eemo izbe\u0107i koliziju (pojavu da dve razli\u010dite re\u010di imaju istu he\u0161 vrednost, koja se de\u0161ava pri he\u0161iranju velikih stringova jer se he\u0161iranje mora raditi po nekom modulu) tako \u0161to \u0107emo koristiti slede\u0107u he\u0161 funkciju: $$ h(s)=(s_0-'a'+1)\\cdot 27^{l-1}+(s_1-'a'+1)\\cdot 27^{l-2}+\\ldots+(s_{n-1}-'a'+1)\\cdot 27^0. $$ Primetimo da je dovoljno da he\u0161iramo samo polovinu stringa odnosno prvih \\((l+1)/2\\) karaktera i podatak o tome da li je palindrom parne ili neparne du\u017eine po\u0161to su palindromi simetri\u010dni. Nakon he\u0161iranja dovoljno je da koristimo matricu od \\(275\\) redova i \\(2\\) kolone kako bi smo prebrojali sve palindrome i prona\u0161li re\u0161enje.</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalazi broj \\(N\\) koji predstavlja broj dece Gazda Srbe. U slede\u0107ih \\(N\\) redova se nalaze imena koja su Gazda Srbina deca napisala na svojim glasa\u010dkim listi\u0107ima, u svakom redu po jedno ime.</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza treba ispisati ime deteta koje je Gazda Srba poslao na Zimske olimpijske igre u So\u010diju.</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv1/04_turista/#ulaz_1","title":"Ulaz","text":"<pre><code>7\nAnna\nanA\naNNNa\nIcHaBoD\nAbbiE\nKatRINa\nJEREMY\n</code></pre>"},{"location":"takprog/2013_2014/kv1/04_turista/#izlaz_1","title":"Izlaz","text":"<pre><code>ana\n</code></pre>"},{"location":"takprog/2013_2014/kv1/04_turista/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ichabod, Abbie, Katrina i Jeremy nisu validna imena jer nisu palindromi. Ana, Anna i Annna su palindromi i svako ime ima ta\u010dno jedan glas pa je pobednik ana kao leksikografski najmanje ime.</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^6\\).</li> <li>Du\u017eina najdu\u017eeg imena nije ve\u0107a od 10.</li> <li>Imena Gazda Srbine dece \u0107e se sastojati samo od malih i velikih slova latini\u010dne abecede.</li> <li>Garantuje se da \u0107e barem jedan glasa\u010dki listi\u0107 biti validan.</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe: * U test primerima vrednim \\(20\\) poena va\u017ei \\(N \\leq 1.000\\). * U test primerima vrednim \\(60\\) poena va\u017ei \\(N \\leq 500.000\\). * U test primerima vrednim \\(20\\) poena nema dodatnih ograni\u010denja.</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#napomena","title":"Napomena","text":"<p>String \\(A\\) je leksikografski manji od stringa \\(B\\) ukoliko postoji indeks \\(j\\) takav da za svaki indeks \\(i &lt; j\\) va\u017ei \\(A[i] = B[i]\\) i va\u017ei \\(A[j] &lt; B[j]\\) ili ukoliko je string \\(A\\) prefiks stringa \\(B\\).</p>"},{"location":"takprog/2013_2014/kv1/04_turista/#generalizacija","title":"Generalizacija","text":"<p>Ukoliko ne bi postojalo ograni\u010denje za du\u017einu ulaznih re\u010di ali bi postojalo ograni\u010denje za njihovu sumu \\(1 \\leq L_i \\leq 10^6\\) zadatak bi se mogao re\u0161iti koriste\u0107i strukturu Trie koja je veoma korisna u zadacima sa stringovima. Vi\u0161e o strukturi Trie mo\u017eete pro\u010ditati na linku.</p> 04_turista.cpp<pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint cnt[27*27*27*27*27][2];\n\nint main() {\n\n    int n,l,k,i,j,t1,t2,bb,resbr;\n    string ps,res;\n    char s[15];\n\n    res = \"\";\n    resbr = 0;\n\n    scanf(\"%d\", &amp;n);\n    for(i=0; i&lt;n; i++) {\n        scanf(\"%s\", &amp;s);\n        l=strlen(s);\n        k=(l+1)/2;\n        t2=l&amp;1;\n        t1=0;\n        bb=1;\n        for(j=0; j&lt;k; j++) {\n            t1 = t1*27 + (tolower(s[j]) - 'a' + 1);\n            s[j] = tolower(s[j]);\n            s[l-1-j] = tolower(s[l-1-j]);\n            if (s[j] != s[l-1-j]) bb=0;\n        }\n\n        if (bb) {\n            if( ++cnt[t1][t2] &gt; resbr ) {\n                resbr = cnt[t1][t2];\n                res = string(s);\n            } else if (cnt[t1][t2] == resbr) {\n                ps = string(s);\n                if (ps &lt; res) {\n                    res = ps;\n                }\n            }\n        }\n    }\n\n    printf(\"%s\\n\", res.c_str());\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/05_bakterije/","title":"5 - Bakterije","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Ruski \u0161pijuni otkrili su plan da se onemogu\u0107i odr\u017eavanje Zimskih olimpijskih igara. U planu stoji slede\u0107e:</p> <ul> <li>So\u010di (mesto odr\u017eavanja ZOI) je podeljen na kvadratne regione. Svaki region odre\u0111en je koordinatama \\((x, y)\\). Susedni regioni regionu \\((x, y)\\) su: \\((x-1,y)\\), \\((x+1,y)\\), \\((x,y-1)\\), \\((x, y+1)\\).</li> <li>Odre\u0111eni regioni u odre\u0111enim trenucima bi\u0107e zara\u017eeni odre\u0111enom vrstom bakterije. Svake sekunde, bakterije se \u0161ire na sve susedne regione (ali ne nestaju iz regiona u kojima se ve\u0107 nalaze). Grupu bakterija \u010dine svi povezani regioni na kojima \u017eivi ta bakterija.</li> </ul> <p>Me\u0111utim, plan ima veliki propust koji je organizator uspeo da otkrije. Kada se dve ili vi\u0161e grupa razli\u010ditih bakterija na\u0111e u istom regionu, obe odnosno sve grupe umiru (nestaju sa svih polja) istog trenutka. Ukoliko se susretnu grupe istih bakterija one se spajaju u jednu grupu. Spajanje grupa se odvija br\u017ee od umiranja. Odnosno, ako se u istom trenutku grupa \\(A\\) u nekom regionu susretne (na\u0111e u istom regionu) sa grupom \\(B\\) iste vrste, a u nekom drugom (ili istom) regionu susretne sa grupom \\(C\\) razli\u010dite vrste, tada se prvo spajaju grupe \\(A\\) i \\(B\\), a potom obe umiru zajedno sa grupom \\(C\\).</p> <p>Ovo \u0107e znatno olak\u0161ati borbu protiv bakterija, jer \u0107e neke vrste same nestati. Ali neke nikada ne\u0107e same nestati pa se za njih mora napraviti serum. Organizatoru je neophodna va\u0161a pomo\u0107. Potrebno je da odgovorite na pitanje: Koji je prvi trenutak posle kog nijedna grupa bakterija ne\u0107e vi\u0161e umrti? Za koliko i kojih vrsta bakterija je potrebno napraviti serum? Garantuje se da \u0107e bar jedna grupa bakterija umreti.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Bakovi\u0107 Dimitrije Dimi\u0107 Nepoznato Marko Bakovi\u0107 <p>Najjednostavnije re\u0161enje ovog zadatka bi bila \u010dista simulacija po vremenu. Kratko \u0107emo opisati to re\u0161enje. Za svako polje na mapi \u010duvamo koja se bakterija nalazi na tom polju. U svakom trenutku radimo slede\u0107e:</p> <ul> <li>Pro\u0161irimo sve grupe bakterija koje se nalaze na mapi, tako \u0161to na svako polje koje dodiruje neku vrstu, upi\u0161emo tu vrstu.</li> <li>Da li se neka bakterija pojavljuje u trenutku u kom se nalazimo? Ako se pojavljuje, ubacimo je na mapu tako \u0161to obele\u017eimo da se na polju \\((X, Y)\\) nalazi bakterija vrste \\(S\\).</li> <li>Preostaje nam da uni\u0161timo neke bakterije. To mo\u017eemo da uradimo pu\u0161taju\u0107i BFS (ili DFS) od svih polja na kojima su se spojile dve grupe razli\u010dite vrste i uklanjaju\u0107i te vrste sa mape.</li> </ul> <p>Jedini mogu\u0107i ishodi su jedna ili nijedna pre\u017eivela. Trenutak nakon poslednjeg pojavljivanja bakterija, a u kom se na mapi nalazi samo jedna vrsta ili uop\u0161te nema bakterija je re\u0161enje. Pri implementaciji, obratiti pa\u017enju da ako se na dva susedna polja nalazi bakterija iste vrste, ne mora nu\u017eno da zna\u010di da ta dva polja \u010dine istu grupu. Analizirajmo slo\u017eenost ovog re\u0161enja:</p> <ul> <li>Pro\u0161irivanje bakterija mogu\u0107e je implementirati u slo\u017eenosti \\(O(maxX\\cdot maxY)\\).</li> <li>Pojavljivanje nove bakterije zahteva samo njeno dodavanje na odre\u0111eno polje, pa je slo\u017eenost \\(O(1)\\).</li> <li>Uni\u0161tavanje vrsta mo\u017ee se implementirati u \\(O(maxX\\cdot maxY)\\).</li> </ul> <p>Takmi\u010dari koji su imali ovakvo re\u0161enje osvojili su \\(20\\) poena.</p> <p>U simulaciji po vremenu, zna\u010dajna su samo uni\u0161tavanja i spajanja grupa, \u0161to mo\u017eemo iskoristiti za bolje re\u0161enje. Na po\u010detku svakoj bakteriji dodelimo \u010dvor u grafu i obele\u017eimo sve bakterije kao \u017eive. Sve dok postoje dve \u017eive bakterije razli\u010dite vrste radimo slede\u0107e:</p> <p>Na\u0111emo dve \u017eive bakterije koje \u0107e se prve susresti, ukoliko postoji vi\u0161e takvih prednost dajemo bakterijama iste vrste. Ukoliko su iste vrste pove\u017eemo njihove \u010dvorove u grafu. Ina\u010de, obele\u017eimo obe vrste kao mrtve i od njihovih \u010dvorova pustimo DFS (ili BFS) i obele\u017eimo sve bakterije koje su povezane sa njima (ne nu\u017eno direktno) kao mrtve. Re\u0161enje je maksimum svih trenutaka u kojima se pojavljuju neke bakterije i svih trenutaka u kojim dolazi do uni\u0161tavanja nekih bakterija. Ukoliko postoji neka pre\u017eivela vrsta, lako je na\u0107i koja je.</p> <p>Uni\u0161tavanja mo\u017ee biti najvi\u0161e \\(\\frac{N}{2}\\), me\u0111utim spajanja u najgorem slu\u010daju mo\u017ee biti \\(\\frac{(N-1)\\cdot(N-2)}{2}\\), pa je slo\u017eenost ovog re\u0161enja \\(O(N^4)\\) i ono vredi \\(50\\) poena.</p> <p>Ovo re\u0161enje lako mo\u017eemo dovesti do slo\u017eenosti \\(O(N^2\\cdot \\log N)\\) koja donosi \\(100\\) poena. Napravimo niz svih parova bakterija. Svi parovi \u0107e se nekada spojiti (uni\u0161titi ili povezati). Sortirajmo ovaj niz po vremenima spajanja svakog para, tako \u0161to \u0107emo dati prednost parovima koji se prvi spajaju, a ukoliko se dva para spajaju u istom trenutku, dajemo prednost onom paru koji sadr\u017ei dve bakterije iste vrste (ako takav postoji). Sada prolaskom kroz niz radimo isto \u0161to i u prethodno opisanom re\u0161enju, samo \u0161to sada nema potrebe da tra\u017eimo dve najbli\u017ee bakterije svaki put. Ukoliko je bar jedna bakterija iz para mrtva, presko\u010dimo taj par, ina\u010de spojimo njihove \u010dvorove ako su iste vrste, odnosno ako su razli\u010dite vrste uni\u0161timo njih i sve bakterije povezane sa njima.</p> <p>Napomenimo da i umesto pravljenja grafa i pu\u0161tanja DFS-a (ili BFS-a) mogu\u0107e je i koristiti disjoint-set union.</p> 05_bakterije.cpp<pre><code>/*\n    Marko Bakovic\n    Bakterije\n*/\n\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int maxn = 1e3 + 5;\n\nstruct node\n{\n    int x, y, time, type;\n} event[ maxn ];\n\nint n, dist[ maxn ][ maxn ], time_sol, all_size, dead[ maxn ];\npair &lt; int, int &gt; all[ maxn * maxn ];\nvector &lt; int &gt; adj[ maxn ];\n\nint get_dist( node A, node B )\n{\n    int temp = abs( A.x - B.x ) + abs( A.y - B.y );\n    int diff = max( A.time, B.time ) - min( A.time, B.time );\n    return max( A.time, B.time ) + max( 0, ( temp - diff + 1 ) / 2 );\n}\n\nbool cmp( pair &lt; int, int &gt; A, pair &lt; int, int &gt; B )\n{\n    if ( dist[ A.first ][ A.second ] != dist[ B.first ][ B.second ] ) return dist[ A.first ][ A.second ] &lt; dist[ B.first ][ B.second ];\n    return ( event[ A.first ].type == event[ A.second ].type );\n}\n\nvoid kill( int curr, int time )\n{\n    dead[ curr ] = time;\n    for ( vector &lt; int &gt; :: iterator it = adj[ curr ].begin(); it != adj[ curr ].end(); it++ )\n        if ( dead[ *it ] == -1 ) kill( *it, time );\n}\n\nbool one_dead( int A, int B )\n{\n    if ( dead[ A ] != -1 &amp;&amp; dead[ A ] &lt; dist[ A ][ B ] ) return true;\n    if ( dead[ B ] != -1 &amp;&amp; dead[ B ] &lt; dist[ A ][ B ] ) return true;\n    return false;\n}\n\nint main()\n{\n    scanf( \"%d\", &amp;n );\n    for ( int i = 0; i &lt; n; i++ ) scanf( \"%d %d %d %d\", &amp;event[ i ].x, &amp;event[ i ].y, &amp;event[ i ].time, &amp;event[ i ].type );\n    for ( int i = 0; i &lt; n; i++ )\n        for ( int j = i + 1; j &lt; n; j++ )\n        {\n            all[ all_size++ ] = make_pair( i, j );\n            dist[ i ][ j ] = get_dist( event[ i ], event[ j ] );\n        }\n    sort( all, all + all_size, cmp );\n    memset( dead, -1, sizeof( dead ) );\n    for ( int i = 0; i &lt; all_size; i++ )\n    {\n        if ( one_dead( all[ i ].first, all[ i ].second ) ) continue;\n        if ( event[ all[ i ].first ].type != event[ all[ i ].second ].type )\n        {\n            kill( all[ i ].first, dist[ all[ i ].first ][ all[ i ].second ] );\n            kill( all[ i ].second, dist[ all[ i ].first ][ all[ i ].second ] );\n            time_sol = dist[ all[ i ].first ][ all[ i ].second ];\n        }\n        else\n        {\n            adj[ all[ i ].first ].push_back( all[ i ].second );\n            adj[ all[ i ].second ].push_back( all[ i ].first );\n        }\n     }\n     printf( \"%d\\n\", time_sol );\n     int alive = -1;\n     for ( int i = 0; i &lt; n; i++ )\n        if ( dead[ i ] == -1 )\n        {\n            alive = event[ i ].type;\n            break;\n        }\n    if ( alive == -1 ) printf( \"0\\n\" );\n    else printf( \"1\\n%d\\n\", alive );\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(N\\), broj regiona koji napada\u010di planiraju da zaraze. U slede\u0107ih \\(N\\) redova nalaze se \\(4\\) cela broja, \\(X\\), \\(Y\\), \\(T\\), \\(S\\), gde je \\((X, Y)\\) region koji napada\u010di planiraju da zaraze u trenutku \\(T\\) bakterijom vrste \\(S\\). Napada\u010di ne\u0107e zaraziti isti region dva puta, ali u jednom trenutku mogu zaraziti vi\u0161e regiona.</p>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#izlaz","title":"Izlaz","text":"<p>Standardni izlaz u prvom redu sadr\u017ei ceo broj, odgovor na pitanje: Koji je prvi trenutak posle kog nijedna grupa bakterija ne\u0107e vi\u0161e umrti? U drugom redu nalazi se broj \\(K\\), broj razli\u010ditih vrsta bakterija za koje je potrebno napraviti serum ili \\(0\\) ako \u0107e sve vrste same nestati. U tre\u0107em redu nalaze se \\(K\\) brojeva, vrste bakterija razdvojene razmakom.</p>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv1/05_bakterije/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 1 1 2\n3 1 1 1\n5 1 1 1\n</code></pre>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n0\n</code></pre>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Zara\u017eeno je ukupno \\(3\\) regiona i sva tri su zara\u017eena istovremeno u sekundi \\(1\\). Regioni \\((3, 1)\\) i \\((5, 1)\\) su zara\u017eeni bakerijama vrste \\(1\\) a region \\((1, 1)\\) bakterijom vrste \\(2\\). Posle prve sekunde, bakterije sa regiona \\((3, 1)\\) i \\((1, 1)\\)  se susre\u0107u kao i bakterije sa regiona \\((3, 1)\\)  i \\((5, 1)\\). Prvo se spajaju bakterije vrste \\(1\\) a zatim vrste \\(1\\) i \\(2\\) umiru. Dakle, posle \\(2\\) sekunde ne\u0107e ostati nijedna vrsta i ne\u0107e biti potreban serum.</p>"},{"location":"takprog/2013_2014/kv1/05_bakterije/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 1000\\).</li> <li>\\(1 \\leq X, Y, T, S \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(1 \\leq N, X, Y, T, S \\leq 100\\).</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(1 \\leq N \\leq 100\\) i \\(1 \\leq X, Y, T, S \\leq 10^9\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/01_kripto/","title":"1 - Kripto","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 16MB <p>Mali Perica bez prestanka igra igricu \u201dFlappy Bird\u201d jo\u0161 otkako je komisija odlu\u010dila da je uvede kao razbibrigu za takmi\u010dare izme\u0111u kvalifikacija. Kako je igra veoma frustriraju\u0107a, a Perica nestrpljiv da napreduje na rang listi takmi\u010dara (da bi pove\u0107ao svoje \u0161anse da ode na IOFB \u2013 me\u0111unarodnu olimpijadu u \u201dFlappy Bird\u201d-u), odlu\u010dio je da iskoristi svoje hakerske sposobnosti i po\u0161alje HTTP zahtev za promenu skora. Me\u0111utim, nije slutio da je komisija uvela novu za\u0161titu protiv hakera \u2013 zahtevi sa nerealisti\u010dno velikim skorovima se moduluju (uzima se ostatak pri deljenju) sa nekom vredno\u0161\u0107u pre nego \u0161to se upisuju u bazu podataka.</p> <p>Perica je uspeo da sazna modul koji komisija koristi \u2013 me\u0111utim jo\u0161 uvek nije savladao samu operaciju modulovanja, tako da vas je zamolio da mu pomognete da odredi koliko poena \u0107e biti upisano za neki konkretan zahtev.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Boris Grubi\u0107 <p>Problem Kripto spada u kategoriju lak\u0161ih zadataka na drugim Kvalifikacijama. Zbog jednostavnosti formulacije u tekstu zadatka, nije te\u0161ko prevesti problem u formalno matemati\u010dki oblik; jedna od mogu\u0107ih formi je:</p> <p>Za data dva cela broja \\(N\\) i \\(M\\), odrediti celi broj \\(X\\) tako da va\u017ei \\(0\\leq X &lt; M\\) i \\(N\\equiv X (mod M)\\).</p> <p>Nepa\u017eljivom \u010ditaocu se ovo mo\u017ee \u010diniti kao trivijalan zadatak, i bez obaziranja na ograni\u010denja promenljivih (ili mo\u017eda bez razumevanja tih ograni\u010denja) dobijamo slede\u0107i C++ kod:</p> <pre><code>int N, M;\nscanf(\"%d%d\", &amp;N, &amp;M);\nprintf(\"%d\\n\", N % M);\n</code></pre> <p>Ovakvo re\u0161enje, me\u0111utim, donosi samo oko \\(20\\) bodova; celobrojni tip int ne podr\u017eava brojeve ve\u0107e od oko \\(2\\cdot 10^9\\). Pa\u017eljiviji re\u0161avaoci su primetili da je bolje koristiti 64-bitni tip long long, koji je ujedno i najve\u0107i celobrojni tip koji nam programski jezik nudi. Re\u0161enje se tako transformi\u0161e u slede\u0107i oblik:</p> <pre><code>long long N, M;\nscanf(\"%lld%lld\", &amp;N, &amp;M);\nprintf(\"%lld\\n\", N % M);\n</code></pre> <p>Ovakvo re\u0161enje donosi \\(40\\) bodova; dok je ovaj tip svakako ve\u0107eg kapaciteta, u zadatku mo\u017eemo da o\u010dekujemo brojeve koje imaju i do \\(100000\\) cifara, dok long long mo\u017ee da podr\u017ei cele brojeve samo do oko \\(9\\cdot 10^{18}\\). Jedno mogu\u0107e re\u0161enje za ovaj problem je kreiranje sopstvene klase za velike brojeve, i zatim implementiranje fukncija deljenja i mno\u017eenja nad tim tipovima da bi se do\u0161lo do operacije modulovanja; ali pa\u017eljivim opservacijama mo\u017eemo dosta pojednostaviti ovaj pristup. Najpre primetimo da, po\u0161to je modul uvek unutar 64-bitne promenljive, da \u0107e i re\u0161enje stati u 64-bitni ceo broj. Zatim bi trebalo broj \\(N\\) transformisati u neki oblik koji \u0107e nam omogu\u0107iti da re\u0161enje ra\u010dunamo u koracima, a da nam ono nikad ne isko\u010di iz tih granica. Konkretno, ukoliko je \\(N = \\overline{c_k c_{k-1}\\ldots c_1 c_0 }\\), gde je \\(k\\) broj cifara broja \\(N\\), a \\(c_i\\) njegova \\(i\\)-ta zna\u010dajna cifra, posmatrajmo slede\u0107i polinom, u dve razli\u010dite forme:</p> \\[ P(x) = c_k x^k+c_{k-1} x^{k-1}+\\ldots+c_1 x+c_0 \\] \\[ = c_0+x(c_1+x(c_2+x(\\ldots+x(c_{k-1}+x(c_k+x\\cdot 0))\\ldots))). \\] <p>Ukoliko je \\(x=10\\), onda je ovo o\u010digledno jednako broju \\(N\\). Druga forma nam daje postupan na\u010din za ra\u010dunanje ovog modula; mo\u017eemo, po\u010dev\u0161i od nule, u svakom momentu da mno\u017eimo broj sa \\(10\\) i da mu dodamo slede\u0107u cifru broja \\(N\\) (idu\u0107i sleva nadesno), odr\u017eavaju\u0107i sve vreme rezultat po modulu \\(M\\). Ovo mo\u017eemo uraditi uz pomo\u0107 identiteta vezanih za modul zbira i proizvoda dva cela broja:</p> \\[ (a\\equiv x (mod M)) \\land (b\\equiv y (mod M)) \\Rightarrow a+b \\equiv x+y (mod M) \\] \\[ (a\\equiv x (mod M)) \\land (b\\equiv y (mod M)) \\Rightarrow a\\cdot b \\equiv x\\cdot y (mod M) \\] <p>Kona\u010dno re\u0161enje se onda mo\u017ee izraziti u vidu rekurentne veze:</p> \\[ X_0 = 0 \\] \\[ X_{i+1} = (((10 mod M)\\cdot X_i) mod M+c_{k-i} mod M) mod M \\] <p>gde je X_{k+1} tra\u017eeno re\u0161enje. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(k)\\), dakle \\(O(log\u2061 N)\\), i ono je dovoljno za osvajanje \\(100\\) bodova.</p> <p>Napomena: primetite da je u re\u0161enju kori\u0161\u0107ena promenljiva tipa unsigned long long; ovo je ura\u0111eno zato \u0161to je mogu\u0107e isko\u010diti iz opsega long long promenljive prilikom mno\u017eenja sa 10, me\u0111utim test primeri nisu sankcionisali ovu gre\u0161ku; mogu\u0107e je osvojiti 100 poena i bez kori\u0161\u0107enja ovog tipa:</p> 01_kripto.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Kripto\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;complex&gt;\n\n#define MAX_N 100005\n\n#define DPRINTC(C) printf(#C \" = %c\\n\", (C))\n#define DPRINTS(S) printf(#S \" = %s\\n\", (S))\n#define DPRINTD(D) printf(#D \" = %d\\n\", (D))\n#define DPRINTLLD(LLD) printf(#LLD \" = %lld\\n\", (LLD))\n#define DPRINTLF(LF) printf(#LF \" = %.5lf\\n\", (LF))\n\nusing namespace std;\ntypedef long long lld;\ntypedef unsigned long long llu;\n\nint len;\nchar N[MAX_N];\nlld M;\n\ninline llu kripto()\n{\n    llu ret = 0LL;\n    for (int i=0;i&lt;len;i++)\n    {\n        ret *= (10 % M);\n        ret %= M;\n        ret += ((N[i] - '0') % M);\n        ret %= M;\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%s%lld\", N, &amp;M);\n    len = strlen(N);\n    printf(\"%lld\\n\", kripto());\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv2/01_kripto/#ulaz","title":"Ulaz","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se dva cela broja \\(N\\) i \\(M\\), koji predstavljaju skor koji je Perica poslao u svom zahtevu i komisijin modul, redom.</p>"},{"location":"takprog/2013_2014/kv2/01_kripto/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza treba ispisati vrednost koja \u0107e biti upisana u bazu podataka za dati zahtev.</p>"},{"location":"takprog/2013_2014/kv2/01_kripto/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/01_kripto/#ulaz_1","title":"Ulaz","text":"<pre><code>15 7\n</code></pre>"},{"location":"takprog/2013_2014/kv2/01_kripto/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2013_2014/kv2/01_kripto/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Perica zahteva da mu se upi\u0161e broj \\(15\\), me\u0111utim komisija smatra sve skorove sa \\(7\\) ili vi\u0161e poena nerealnim \u2013 tako da \u0107e zapravo biti upisana vrednost jednaka ostatku pri deljenju \\(15\\) sa \\(7\\), u ovom slu\u010daju \\(1\\).</p>"},{"location":"takprog/2013_2014/kv2/01_kripto/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq N \\leq 10^{100000}\\).</li> <li>\\(1 \\leq M \\leq 10^{18}\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N \\leq 10^9\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N \\leq 10^{18}\\).</li> <li>U test primerima vrednim \\(60\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/02_tabla/","title":"2 - Tabla","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 16MB <p>Srbi je dosadila njegova omiljena igra, \u0161ah. Poku\u0161ao je da igra \u201cFlappy Bird\u201d, ali mu nije bio zanimljiv. Zato je odlu\u010dio da napravi novu verziju \u0161aha, koja \u0107e se igrati na mnogo ve\u0107oj tabli, dimenzija \\(N\\times M\\).</p> <p>Po\u0161to mora da kupi farbu kako bi obojio crna polja, moli vas da mu pomognete i izra\u010dunate koliko \u0107e crnih polja imati njegova \u0161ahovska tabla. Zna se da \u0107e gornji levi ugao table biti obojen u crno.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Mladen Puzi\u0107 Nikola Stojiljkovi\u0107 <p>\ufeff## Re\u0161enje za \\(N, M\\leq1000\\): Tabla dimenzija \\(N\\) i  \\(M\\) ima \\(N\\cdot M\\) polja. U ovom slu\u010daju, to je dovoljno malo polja da ih mo\u017eemo sve obi\u0107i i proveriti da li su crna. Ako numeri\u0161emo redove brojevima od \\(1\\) do \\(N\\) od gore na dole, a kolone brojevima od \\(1\\) do \\(M\\) sleva nadesno, polje u redu \\(i\\) i koloni \\(j\\) je crno ukoliko va\u017ei da je \\(i+j\\) neparno. Vremenska slo\u017eenost: \\(O(N\\cdot M)\\), memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2013_2014/kv2/02_tabla/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalaze dva cela broja, \\(N\\) i \\(M\\).</p>"},{"location":"takprog/2013_2014/kv2/02_tabla/#izlaz","title":"Izlaz","text":"<p>U prvom redu standardnog izlaza, ispisati broj crnih polja na Srbinoj novoj tabli.</p>"},{"location":"takprog/2013_2014/kv2/02_tabla/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/02_tabla/#ulaz_1","title":"Ulaz","text":"<pre><code>10 10\n</code></pre>"},{"location":"takprog/2013_2014/kv2/02_tabla/#izlaz_1","title":"Izlaz","text":"<pre><code>50\n</code></pre>"},{"location":"takprog/2013_2014/kv2/02_tabla/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(50\\) poena va\u017ei \\(1 \\leq N, M \\leq 1.000\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/02_tabla/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Ograni\u010denja su sad prevelika da bismo pro\u0161li kroz svako polje, ali to nam zapravo nije neophodno. Ukoliko je makar jedno od \\(N\\) i \\(M\\) parno, jasno je da je re\u0161enje \\(\\frac{N\\cdot M}{2}\\), jer je u svakom redu (ukoliko je \\(M\\) parno), odnosno koloni (ukoliko je \\(N\\) parno), jednak broj crnih i belih polja. Sli\u010dno tome, kada su oba neparna, mo\u017ee se zaklju\u010diti da je re\u0161enje \\(\\lceil \\frac{N\\cdot M}{2} \\rceil\\), gde je \\(\\lceil x \\rceil\\) gornji ceo deo broja \\(x\\) (najmanji celi broj ve\u0107i ili jednak broju \\(x\\)). Vremenska slo\u017eenost: \\(O(1)\\), a memorijska: \\(O(1)\\). Pri ra\u010dunanju rezultata, obavezno obratiti pa\u017enju da ne do\u0111e do prekora\u010denja pri mno\u017eenju \\(32\\)-bitnih brojeva, tj. potrebno je koristiti \\(64\\)-bitne podatke (npr. long long u C++).</p> 02_tabla.cpp<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    long long n,m;\n\n    scanf(\"%lld%lld\", &amp;n, &amp;m);\n\n    printf(\"%lld\\n\", (n*m+1)/2);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv2/03_split/","title":"3 - Split","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 32MB <p>Nakon uspe\u0161nog napada na bazu podataka za igricu \u201dFlappy Bird\u201d od strane malog Perice, komisija je uvela jake bezbednosne mere da spre\u010di ponovni napad takve vrste. Perica je zato pribegao planu B \u2013 razvoju bota koji bi, nakon \u0161to u\u010dita sve generisane pozicije otvora cevi, igrao igricu umesto njega i tako osvojio velike koli\u010dine bodova. Na njegovu veliku \u017ealost, komisija je ovoga puta bila korak ispred \u2013 unapredila je nepredvidljivost igrice tako da usred jedne igre mo\u017ee da se promeni program koji generi\u0161e cevi na nekom delu mape.</p> <p>Me\u0111utim, ovaj sistem je ipak dovoljno predvidljiv pa se Peri\u010din bot mo\u017ee prilagoditi. Pre svega, svaki program se mo\u017ee identifikovati nekim stringom. U po\u010detku imamo jedan program na celoj mapi veli\u010dine (du\u017eine) \\(N\\), i mogu\u0107e je u bilo kojem trenutku izvr\u0161iti split operaciju na nekom polju; efekat ove operacije je da to polje zadr\u017eava svoj trenutni program, dok sva polja levo i sva polja desno koja su obuhva\u0107ena istim programom dobijaju nove programe.</p> <p>Peri\u010dinog bota \u0107e u odre\u0111enim momentima tokom izvr\u0161avanja igrice zanimati koji program se koristi na nekom odre\u0111enom polju. Na vama je da efikasno odgovorite na njegova pitanja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Boris Grubi\u0107 <p>Problem Split je jedan od te\u017eih problema na drugim Kvalifikacijama, i da bi se potpuno re\u0161io potrebno je znanje naprednijih struktura podataka (nivo Srpske Informati\u010dke Olimpijade). Inspiracija za zadatak je potekla od zadatka \u017detoni sa SIO 2012. kada je autor (tada\u0161nji takmi\u010dar) upotrebio sli\u010dnu metodu \u201dsplitova\u201d da bi re\u0161io zadatak.</p> <p>Zadatak se mo\u017ee prevesti u formalni oblik na vi\u0161e na\u010dina; evo jedne mogu\u0107e interpretacije:</p> <p>Zadata je funkcija sa skupa prirodnih brojeva na skup stringova, \\(f: N\\rightarrow \\Sigma\\), tako da u po\u010detku va\u017ei \\(f(n)=S\\) za sve \\(n\\). Split operacijom na poziciji \\(X\\) sa stringovima \\(S_1\\) u \\(S_2\\) funkcija \\(f\\) se menja u funkciju \\(f'\\) tako da va\u017ei:</p> <ul> <li>\\(f'(x) = S_1\\) ako \\(x &lt; X \\land f(x)=f(X)\\).</li> <li>\\(f'(x) = S_2\\) ako \\(x&gt;X \\land f(x)=f(X)\\).</li> <li>\\(f'(x) = f(x)\\) ina\u010de.</li> </ul> <p>Potrebno je odrediti f(n) svaki put kada se pozove query operacija na poziciji n.</p> <p>Zadatak se mo\u017ee re\u0161iti tako \u0161to odr\u017eavamo strukturu intervala, gde za svaki interval pamtimo neki jedinstveni identifikator, levu i desnu granicu, kao i string koji ozna\u010dava program koji se trenutno izvr\u0161ava na tom intervalu. U po\u010detku postoji samo jedan interval, \\(I_0\\), tako da va\u017ei: \\(I_0.L = 1\\), \\(I_0.R = N\\), \\(I_0.prog=S\\). Neophodno je pamtiti koji je poslednji napravljeni interval.</p> <p>U isto vreme treba odr\u017eavati i niz \\(map\\), tako da \\(map[n]=x\\) zna\u010di da se polje \\(n\\) trenutno nalazi unutar intervala \\(I_x\\). Naravno, u po\u010detku je \\(map[i]=0\\) za sve \\(i\\). Odr\u017eavanjem ovog niza dobijamo jednostavan odgovor na sve \\(QUERY\\) \\(X\\) upite; dovoljno je vratiti \\(I_{map(X)}.prog\\).</p> <p>Posmatrajmo sada kako odr\u017eavati map tokom neke split operacije:</p> <p>Na slici ispod se nalazi niz map, pre i posle split operacije na polju \\(x\\). Polja u intervalu \\([x-2, x+2]\\) su pod kontrolom intervala \\(I_2\\), a poslednji do sada napravljeni interval je \\(I_4\\).</p> <p></p> <p>Split operacija kreira dva nova intervala, \\(I_5\\) i \\(I_6\\), i dodeljuje im slede\u0107e parametre:</p> \\[ I_5.L=I_2.L,     I_5.R=x-1,     I_5.prog=S_1; \\] \\[ I_6.L=x+1,     I_6.R=I_2.R,     I_6.prog=S_2. \\] <p>Tako\u0111e se niz \\(map\\) a\u017eurira kao na slici, i \\(I_2.L = I_2.R = x\\).</p> <p>Naivno re\u0161enje koje odr\u017eava niz map tako \u0161to pri svakoj split operaciji prepisuje sve njegove \u010dlanove obuhva\u0107ene nekim intervalom nije dovoljno efikasno i donosi oko \\(50\\) bodova. Da bismo zakora\u010dili ka kompletnom re\u0161enju ne smemo eksplicitno \u010duvati ovaj niz u memoriji; umesto toga odr\u017eava\u0107emo niz \\(pmap\\), gde \u0107e \\(map[n]\\) biti suma svih elemenata niza \\(pmap\\) od prvog do \\(n\\)-tog; formalnije:</p> \\[ map[n]=\\sum_{i=1}^{n} pmap[i] \\] <p>O\u010digledno je da u po\u010detku \\(pmap[x]=0\\) za sve \\(x\\). Primetimo da, ukoliko \u017eelimo da na nekom intervalu \\([l, r]\\) pove\u0107amo sve vrednosti niza \\(map\\) za \\(k\\), dovoljno je uraditi:</p> \\[ pmap[l] = pmap[l] + k \\] \\[ pmap[r] + 1 = pmap[r+1] - k \\] <p>Nazva\u0107emo ovu metodu \\(update(l,  r,  k)\\). Mogu\u0107e je izvr\u0161iti split operaciju sa konstantnim brojem pozivanja ove metode; ako pretpostavimo da \u017eelimo izvr\u0161iti split operaciju na polju \\(x\\), da je \\(I_{id}\\) interval koji obuhvata \\(x\\), i da je \\(I_w\\) poslednji napravljeni interval do sad, split operacija se mo\u017ee opisati slede\u0107im algoritmom:</p> <ul> <li>Napraviti intervale \\(I_{w+1}\\) i \\(I_{w+2}\\) kao \u0161to je ranije opisano.</li> <li>A\u017eurirati \\(pmap\\) tako da \\(map[n]=0\\) za sve \\(n \\in I_{id} \\rightarrow update(I_{id}.L,  I_{id}.R,  -id)\\).</li> <li>A\u017eurirati \\(pmap\\) tako da \\(map[n] = w+1\\) za sve \\(n \\in I_{w+1} \\rightarrow update(I_{id}.L, x-1, w+1)\\).</li> <li>A\u017eurirati \\(pmap\\) tako da \\(map[n] = w+2\\) za sve \\(n \\in I_{w+2} \\rightarrow update(x+1,  I_{id}.R,  w+2)\\).</li> <li>A\u017eurirati \\(pmap\\) tako da \\(map[n] = id\\) za \\(n=x \\rightarrow update(x,  x,  id)\\).</li> <li>A\u017eurirati interval \\(I_{id}\\) kao \u0161to je ranije opisano.</li> </ul> <p>Napomenimo da se neki od ovih koraka trebaju promeniti ili presko\u010diti u slu\u010daju da je polje \\(x\\) na levoj ili desnoj ivici intervala \\(I_{id}\\). Sa trenutnom implementacijom operacije \\(update\\), koja radi u slo\u017eenosti \\(O(1)\\), neophodno je svaki put ponovo sumirati sve neophodne elemente niza \\(pmap\\) kada imamo komandu \\(QUERY\\); ovo je slo\u017eenosti \\(O(n)\\), tako da je pristup i dalje neefikasan i donosi oko \\(60\\) bodova.</p> <p>Da bismo efikasnije odre\u0111ivali sume prvih \\(n\\) elemenata niza \\(pmap\\), neophodno je koristiti strukturu koja se zove Fenvikovo stablo (Fenwick tree / Binary Indexed Tree / BIT) koje nam omogu\u0107ava da ra\u010dunamo ove sume u vremenskoj slo\u017eenosti \\(O(log n)\\)  po cenu toga da i \\(update\\) operacija mora biti slo\u017eenosti \\(O(log n)\\). Ovo nam daje ukupnu vremensku slo\u017eenost \\(O(N+Q\\cdot log N)\\), koja je dovoljna za dobijanje \\(100\\) bodova.</p> 03_split.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Split\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;complex&gt;\n\n#define MAX_N 100005\n\n#define DPRINTC(C) printf(#C \" = %c\\n\", (C))\n#define DPRINTS(S) printf(#S \" = %s\\n\", (S))\n#define DPRINTD(D) printf(#D \" = %d\\n\", (D))\n#define DPRINTLLD(LLD) printf(#LLD \" = %lld\\n\", (LLD))\n#define DPRINTLF(LF) printf(#LF \" = %.5lf\\n\", (LF))\n\nusing namespace std;\ntypedef long long lld;\ntypedef unsigned long long llu;\n\nint n, q;\nchar frst[55];\nchar kom[10];\nint x;\nchar s1[55], s2[55];\n\nstruct Range\n{\n    int L, R;\n    string S;\n};\nvector&lt;Range&gt; Rs;\nint idd = 0;\n\nint bit[MAX_N];\n\ninline void update(int x, int val)\n{\n    while (x &lt;= n)\n    {\n        bit[x] += val;\n        x += (x &amp; -x);\n    }\n}\n\ninline int read(int x)\n{\n    int ret = 0;\n    while (x &gt; 0)\n    {\n        ret += bit[x];\n        x -= (x &amp; -x);\n    }\n    return ret;\n}\n\ninline void split(int x, string sL, string sR)\n{\n    int idx = read(x);\n\n    int L = Rs[idx].L;\n    int R = Rs[idx].R;\n\n    // Reduce [L..R] to 0\n    update(L, -idx);\n    if (R &lt; n) update(R+1, idx);\n\n    // Convert [L..x-1] to idL\n    if (L &lt; x)\n    {\n        int idL = ++idd;\n\n        update(L, idL);\n        update(x, -idL);\n\n        Range Rl;\n\n        Rl.L = L;\n        Rl.R = x-1;\n        Rl.S = sL;\n\n        Rs.push_back(Rl);\n    }\n\n    // Convert [x+1..R] to idR\n    if (x &lt; R)\n    {\n        int idR = ++idd;\n\n        if (x &lt; n) update(x+1, idR);\n        if (R &lt; n) update(R+1, -idR);\n\n        Range Rr;\n\n        Rr.L = x+1;\n        Rr.R = R;\n        Rr.S = sR;\n\n        Rs.push_back(Rr);\n    }\n\n    // Convert [x..x] to idx\n    update(x, idx);\n    if (x &lt; n) update(x+1, -idx);\n\n    Rs[idx].L = Rs[idx].R = x;\n}\n\ninline void debug()\n{\n    for (int i=1;i&lt;=n;i++)\n    {\n        printf(\"%d \", read(i));\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    scanf(\"%d%d%s\", &amp;n, &amp;q, frst);\n\n    Range R;\n    R.L = 1, R.R = n;\n    R.S = frst;\n    Rs.push_back(R);\n\n    while (q--)\n    {\n        scanf(\"%s\", kom);\n        if (kom[0] == 'S')\n        {\n            scanf(\"%d%s%s\", &amp;x, s1, s2);\n            split(x, s1, s2);\n        }\n        else if (kom[0] == 'Q')\n        {\n            scanf(\"%d\", &amp;x);\n            printf(\"%s\\n\", Rs[read(x)].S.c_str());\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv2/03_split/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja, \\(N\\) i \\(Q\\), koji predstavljaju veli\u010dinu mape i broj upita, redom. U slede\u0107em redu se nalazi string \\(S\\) koji predstavlja po\u010detni program koji se izvr\u0161ava na celoj mapi. U narednih \\(Q\\) redova se nalazi po jedna komanda koja mo\u017ee imati jedan od slede\u0107a dva oblika:</p> <ul> <li><code>SPLIT X S1 S2</code> : izvr\u0161iti split na polju \\(X\\); polja levo, obuhva\u0107ena istim programom kao i polje \\(X\\), dobijaju program \\(S_1\\) a polja desno, obuhva\u0107ena istim programom kao i polje \\(X\\), program \\(S_2\\).</li> <li><code>QUERY X</code> : upit koji pita koji program se trenutno izvr\u0161ava na polju \\(X\\).</li> </ul>"},{"location":"takprog/2013_2014/kv2/03_split/#izlaz","title":"Izlaz","text":"<p>Za svaku komandu tipa <code>QUERY</code> ispisati u novom redu string koji predstavlja tra\u017eeni program.</p>"},{"location":"takprog/2013_2014/kv2/03_split/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/03_split/#ulaz_1","title":"Ulaz","text":"<pre><code>6 6\npicsel\nSPLIT 3 petarv duxserbia\nSPLIT 5 sasav nikolaj\nQUERY 1\nQUERY 3\nQUERY 5\nQUERY 6\n</code></pre>"},{"location":"takprog/2013_2014/kv2/03_split/#izlaz_1","title":"Izlaz","text":"<pre><code>petarv\npicsel\nduxserbia\nnikolaj\n</code></pre>"},{"location":"takprog/2013_2014/kv2/03_split/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U po\u010detku, program <code>picsel</code> deluje na celoj mapi; posle prve i druge split operacije, mapa se menja na slede\u0107i na\u010din:</p> <p><code>[petarv, petarv, picsel, duxserbia, duxserbia, duxserbia]</code></p> <p><code>[petarv, petarv, picsel, sasav, duxserbia, nikolaj]</code></p> <p>Odgovori na upite onda o\u010digledno slede iz kona\u010dne mape.</p>"},{"location":"takprog/2013_2014/kv2/03_split/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 10^5\\).</li> <li>\\(1 \\leq X \\leq N\\).</li> <li>\\(1 \\leq |S|, |S_1|, |S_2| \\leq 50\\). Stringovi \u0107e se sastojati samo od malih slova engleskog alfabeta.</li> <li>Svi nazivi programa \u0107e biti me\u0111usobno razli\u010diti.</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(50\\) poena va\u017ei \\(1 \\leq N, Q \\leq 1000\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/04_carina/","title":"4 - Carina","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 16MB <p>Mali Perica, igraju\u0107i igru \u201dFlappy Bird\u201d, je primetio da ptica uvek ujedna\u010deno skaku\u0107e, bez obzira na to u kojoj je fazi padanja kao i da se nikad ne umara. Ovo je Perici bilo jako neprirodno, tako da je re\u0161io da napravi novu verziju igrice, TheBird\u2122. Me\u0111utim, komisija ga je odmah prijavila policiji za kra\u0111u autorskih prava, tako da su mu mogu\u0107nosti za distribuciju igrice u inostranstvo sada jako ograni\u010dene.</p> <p>Perica je napravio odre\u0111en broj kopija igrice, i namerava da ih prenese od firme (mesto A) do distributera za strano tr\u017ei\u0161te (mesto B). Da bi to uradio, na raspolaganju mu je jedan \u0161leper koji mo\u017ee da prenese ograni\u010den broj igrica odjednom. Na putu od mesta A do mesta B nalazi se odre\u0111en broj kontrolnih punktova carine: ukoliko Perica prevozi bar jednu kopiju igrice u momentu ulaska na punkt, mora pokloniti carinicima jednu kopiju kao mito. Na punktu se kopije mogu istovariti, pa ponovo pokupiti kasnije. Perica tako\u0111e ne \u017eeli da se vra\u0107a nazad u mesto A vi\u0161e od \\(X\\) puta (da ne bi ispao sumnjiv saobra\u0107ajcima).</p> <p>Pericu interesuje koliki je najve\u0107i broj kopija igrice TheBird\u2122 koji se mogu dopremiti do mesta B.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Du\u0161an Zdravkovi\u0107 <p>Zadatak Carina spada u probleme srednje te\u017eine na drugim Kvalifikacijama, i odlikuje se izuzetno kratkim re\u0161enjem; ideja je da re\u0161avaoci mnogo vi\u0161e vremena potro\u0161e na smi\u0161ljanje pravilnog re\u0161enja nego na samu implementaciju.</p> <p>Pre svega, primetimo da je jedini efekat broja \\(X\\) ograni\u010davanje koliko igrica mo\u017eemo izneti iz mesta A; ovo je ekvivalentno tome da je \\(N=\\min\u2061(N, C\\cdot (X+1))\\). Po\u0161to je broj \\(X\\) ograni\u010den sa \\(10^6\\), ovo samo po sebi treba da sugeri\u0161e da je tra\u017eeni algoritam reda veli\u010dine \\(O(X)\\); me\u0111utim da bismo do\u0161li do ovog algoritma neophodno je najpre napraviti nekoliko zapa\u017eanja.</p> <p>Najpre primetimo da je jedna od optimalnih strategija vrlo jednostavna: svaki put punimo \u0161leper do vrha, i donosimo igrice na prvi slede\u0107i punkt, gde gubimo jednu i istovaramo ostale; ovo ponavljamo dok ne prenesemo sve igrice na prvi punkt. Ovim smo izgubili \\(\\lceil \\frac{N}{C}\\rceil\\) igrica, tj. najmanji ceo broj ve\u0107i ili jednak \\(\\frac{N}{C}\\). Ako ovako nastavimo, preneli smo maksimalan mogu\u0107 broj igrica u mesto B; ovo mo\u017eemo naivno predstaviti slede\u0107im C++ kodom:</p> <pre><code>long long carina(long long n, long long c, long long l)\n{\nfor (long long i=0;i&lt;l;i++)\n{\nlong long lost = n/c;\nif (c * lost != n) lost++;\nn -= lost;\n}\nreturn n;\n}\n</code></pre> <p>Ovo re\u0161enje je o\u010digledno slo\u017eenosti \\(O(L)\\), i donosi oko \\(50\\) bodova. Zapa\u017eanje koje nam poma\u017ee da do\u0111emo do br\u017eeg re\u0161enja je da primetimo da se vi\u0161e koraka mogu \u201dspakovati\u201d u jedan, tj. \u010desto \u0107e postojati vi\u0161e od jednog koraka tokom ove strategije gde \u0107emo izgubiti isti broj igrica; ako efikasno odredimo broj koraka koji smemo napraviti tako da u svakom koraku gubimo isti broj igrica, onda mo\u017eemo \u0161leper odmah nositi do te pozicije; tj. ne moramo prelaziti jedan po jedan punkt.</p> <p>Da bismo odredili ovu poziciju, potrebno je posmatrati ostatak pri deljenju \\(N\\) sa \\(C\\).  Nazovimo ovaj ostatak \\(R\\). Neophodan broj povrataka na punkt sa kojeg smo krenuli trenutni korak se smanjuje za bar jedan kada se ovaj ostatak izgubi; kako u svakom jedini\u010dnom koraku gubimo \\(\\lceil \\frac{N}{C}\\rceil\\) igrica, broj potrebnih koraka da se ovo desi je \\(k = \\lceil \\frac{R}{\\lceil \\frac{N}{C} \\rceil} \\rceil\\). Ukoliko je \\(R=0\\), onda mo\u017eemo uzeti \\(R=C\\).</p> <p>Nakon \u0161to odredimo broj potrebnih koraka, mo\u017eemo odmah oti\u0107i sa punkta \\(x\\) na punkt \\(x+k\\) i usput oduzeti \\(k\\cdot \\lceil \\frac{N}{C} \\rceil\\) od \\(N\\), naravno vode\u0107i ra\u010duna o tome da li smo prekora\u010dili mesto B.</p> <p>Primetimo da ovo re\u0161enje u svakom koraku smanjuje broj \u201dpovrataka\u201d \u0161lepera za bar jedan, dakle slo\u017eenost ovog algoritma je \\(O(\\frac{N}{C})\\), \u0161to smo na po\u010detku ograni\u010dili sa \\(O(X)\\). Ovaj algoritam donosi \\(100\\) bodova.</p> 04_carina.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Carina\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;complex&gt;\n\n#define DPRINTC(C) printf(#C \" = %c\\n\", (C))\n#define DPRINTS(S) printf(#S \" = %s\\n\", (S))\n#define DPRINTD(D) printf(#D \" = %d\\n\", (D))\n#define DPRINTLLD(LLD) printf(#LLD \" = %lld\\n\", (LLD))\n#define DPRINTLF(LF) printf(#LF \" = %.5lf\\n\", (LF))\n\nusing namespace std;\ntypedef long long lld;\ntypedef unsigned long long llu;\n\nlld n, c, l, X;\n\ninline lld max1(lld a, lld b)\n{\n    if (a &gt; b) return a;\n    return b;\n}\n\ninline lld min1(lld a, lld b)\n{\n    if (a &lt; b) return a;\n    return b;\n}\n\ninline lld moj_ceil(lld A, lld B)\n{\n    lld ret = A/B;\n    if (B * ret != A) ret++;\n    return ret;\n}\n\ninline lld solve_bruteforce()\n{\n    for (lld i=0;i&lt;l;i++)\n    {\n        n -= moj_ceil(n, c);\n    }\n    return n;\n}\n\ninline lld calc_new_n(lld x)\n{\n    lld V = moj_ceil(n, c);\n    lld rem = n % c;\n    lld ret;\n\n    if (rem == 0 || rem &gt;= x) ret = n - V*x;\n    else ret = n - (V-1)*x - rem;\n\n    return max1(0, ret);\n}\n\ninline lld binsearch(lld initPos)\n{\n    lld i = initPos + 1, j = l;\n    lld V = moj_ceil(n, c);\n\n    while (i &lt; j)\n    {\n        lld mid = (i+j) &gt;&gt; 1;\n        lld newN = calc_new_n(mid - initPos);\n        if (moj_ceil(newN, c) == V) i = mid+1;\n        else j = mid;\n    }\n\n    return i;\n}\n\ninline lld solve()\n{\n    lld ii = 0;\n    while (ii &lt; l &amp;&amp; moj_ceil(n, c) &gt; 1)\n    {\n        lld next_ii = binsearch(ii);\n        lld x = next_ii - ii;\n\n        lld V = moj_ceil(n, c);\n        lld rem = n % c;\n\n        if (rem == 0 || rem &gt;= x) n -= V*x;\n        else n -= (V-1)*x + rem;\n\n        ii = next_ii;\n    }\n    return max1(0LL, n - (l - ii));\n}\n\ninline void debug()\n{\n    srand(time(NULL));\n    for (int i=1;i&lt;=20000;i++)\n    {\n        n = rand() % 100000 + 1;\n        c = rand() % 100000 + 1;\n        l = rand() % 100000 + 1;\n        X = rand() % 100000 + 1;\n\n        lld X1 = moj_ceil(n, c);\n        if (X1 &gt; (X+1)) n = c*(X+1);\n\n        lld storN = n, storC = c, storL = l;\n        lld bf = solve_bruteforce();\n        n = storN, c = storC, l = storL;\n        lld tt = solve();\n        if (i % 1000 == 0) printf(\"Done %d\\n\", i);\n        assert(bf == tt);\n    }\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld%lld\", &amp;n, &amp;c, &amp;l, &amp;X);\n    lld X1 = moj_ceil(n, c);\n    if (X1 &gt; (X+1)) n = c*(X+1);\n    printf(\"%lld\\n\", solve());\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv2/04_carina/#ulaz","title":"Ulaz","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se \u010detiri cela broja, \\(N\\), \\(C\\), \\(L\\) i \\(X\\), koji predstavljaju broj kopija igrice, kapacitet \u0161lepera, broj punktova i maksimalan broj vra\u0107anja u mesto A, redom.</p>"},{"location":"takprog/2013_2014/kv2/04_carina/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati najve\u0107i broj kopija igrice koje se mogu dopremiti.</p>"},{"location":"takprog/2013_2014/kv2/04_carina/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/04_carina/#ulaz_1","title":"Ulaz","text":"<pre><code>4000 1000 1000 1\n</code></pre>"},{"location":"takprog/2013_2014/kv2/04_carina/#izlaz_1","title":"Izlaz","text":"<pre><code>500\n</code></pre>"},{"location":"takprog/2013_2014/kv2/04_carina/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Perica mo\u017ee najpre da napuni \u0161leper sa \\(1000\\) igrica, da ga doveze do \\(500\\)-tog punkta, i da tu istovari \\(500\\) kopija koje su mu ostale u \u0161leperu. Zatim se vra\u0107a u mesto A i na isti na\u010din dovozi jo\u0161 \\(500\\) kopija na \\(500\\)-ti punkt. Tada ponovo puni \u0161leper sa prethodno ostavljenih \\(500\\) kopija, i tako dolazi do mesta B, sa \\(500\\) dopremljenih kopija. Nije mogu\u0107e napraviti strategiju koja donosi vi\u0161e kopija do mesta B.</p>"},{"location":"takprog/2013_2014/kv2/04_carina/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, C, L \\leq 10^{18}\\).</li> <li>\\(0 \\leq X \\leq 10^6\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(40\\) poena va\u017ei \\(N, C, L \\leq 10^6\\).</li> <li>U test primerima vrednim 60 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/05_maxand/","title":"5 - MaxAND","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Mi\u0107ko i dalje nije imao priliku da igra \u201cFlappy Bird\u201d pa jo\u0161 uvek vredno radi i ve\u017eba zadatke. Trenutno se malo zaglavio kod slede\u0107eg problema:</p> <p>Dat je niz \\(A\\) du\u017eine \\(N\\) koji se sastoji od pozitivnih celih brojeva \\(A_i\\) (\\(A_i\\) je \\(i\\)-ti \u010dlan niza). Od datih brojeva odabrati ta\u010dno \\(K\\) tako da je bitwise AND izabranih brojeva \u0161to ve\u0107i. Drugim re\u010dima treba odabrati brojeve \\(A_{i_1}, A_{i_2}, \\ldots, A_{i_k}\\) tako da je \\(A_{i_1} \\text{ AND } A_{i_2} \\text{ AND } \\ldots \\text{ AND } A_{i_k}\\) najve\u0107e mogu\u0107e i \\(i_x \\neq i_y\\) za \\(1\\leq x &lt; y \\leq k\\).</p> <p>Pomozite mu da \u0161to pre re\u0161i ovaj zadatak jer mu je Mom\u010dilo na \u010detu upravo poslao link ka igri.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dimitrije Dimi\u0107 Marko Ili\u0107 Boris Grubi\u0107"},{"location":"takprog/2013_2014/kv2/05_maxand/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja, \\(N\\) i \\(K\\). U drugom redu nalaze se \\(N\\) brojeva \\(A_i\\) razdvojeni razmakom.</p>"},{"location":"takprog/2013_2014/kv2/05_maxand/#izlaz","title":"Izlaz","text":"<p>U jednoj liniji u bilo kom redosledu ispisati \\(K\\) tra\u017eenih brojeva razdvojenih razmakom. Ukoliko postoji vi\u0161e re\u0161enja, \u0161tampati bilo koje od njih.</p>"},{"location":"takprog/2013_2014/kv2/05_maxand/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/05_maxand/#ulaz_1","title":"Ulaz","text":"<pre><code>5 3\n14 10 1 6 6\n</code></pre>"},{"location":"takprog/2013_2014/kv2/05_maxand/#izlaz_1","title":"Izlaz","text":"<pre><code>6 14 6\n</code></pre>"},{"location":"takprog/2013_2014/kv2/05_maxand/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>\\(6 \\text{ AND } 14 \\text{ AND } 6=6\\). Ve\u0107i bitwise AND neka \\(3\\) broja od datih \\(5\\) nije mogu\u0107e dobiti.</p>"},{"location":"takprog/2013_2014/kv2/05_maxand/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq K \\leq N \\leq 10^6\\).</li> <li>\\(1\\leq A_i \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(1\\leq K\\leq N\\leq 20\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(1\\leq K \\leq N\\leq 5.000\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/05_maxand/#resenje-za-n-le-20","title":"Re\u0161enje za \\(n \\le 20\\)","text":"<p>U ovom podzadatku mo\u017eemo pro\u0107i kroz svih \\(2^n\\) izbora elemenata i za one izbore koji sadr\u017ee ta\u010dno \\(k\\) elemenata izra\u010dunati njihovu bitwise AND vrednost. Na kraju treba ispisati onaj izbor koji daje maksimalnu vrednost bitwise AND.</p>"},{"location":"takprog/2013_2014/kv2/05_maxand/#resenje-za-1-le-k-le-n-le-5000","title":"Re\u0161enje za \\(1 \\le k \\le n \\le 5000\\)","text":""},{"location":"takprog/2013_2014/kv2/05_maxand/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ako posmatramo odre\u0111eni bit i ako su nam fiksirani vi\u0161i bitovi, onda nam je uvek bolje da na tom bitu bude jedan, jer i u slu\u010daju kada su svi bitovi manje vrednosti od njega jedan, a on nula, suma vrednosti tih bitova je manja od vrednosti posmatranog bita. Zato treba posmatrati bitove od vi\u0161ih ka ni\u017eim. Ideja je da u svakom momentu imamo niz koji \u0107e nam sadr\u017eati kandidate za re\u0161enje. U po\u010detku su to svi elementi. Kada posmatramo odre\u0107eni bit, ako imamo manje od \\(k\\) brojeva koji imaju jedan na tom bitu, onda svakako ne mo\u017eemo imati jedan u re\u0161enju na tom bitu, pa elementi koji imaju jedan na tom bitu u ovom slu\u010daju nemaju nikakvu prednost u odnosu na one koji imaju nulu, pa \u0107e samim tim svi elementi u nizu kandidata \"pre\u017eiveti\". U slu\u010daju da imamo \\(k\\) ili vi\u0161e elemenata sa jedinicom na posmatranom bitu, onda \u0107e samo oni ostati kao kandidati. Na kraju treba ispisati bilo kojih \\(k\\) elemenata iz niza kandidata.</p> 05_maxand.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nint n, k;\nint a[MAX_N];\nbool mark[MAX_N];\n\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    for (int i = 0; i &lt; n; ++i)\n        scanf(\"%d\", &amp;a[i]);\n\n    for (int i = 0; i &lt; n; ++i) mark[i] = true;\n    for (int i = 29; i &gt;= 0; --i) {\n        int cnt = 0;\n        for (int j = 0; j &lt; n; ++j) {\n            if (mark[j] &amp;&amp; ((a[j] &gt;&gt; i) &amp; 1) == 1)\n                ++cnt;\n        }\n\n        if (cnt &gt;= k) {\n            for (int j = 0; j &lt; n; ++j)\n                if (mark[j] &amp;&amp; ((a[j] &gt;&gt; i) &amp; 1) == 0)\n                    mark[j] = false;\n        }\n    }\n\n    for (int i = 0; i &lt; n &amp;&amp; k &gt; 0; ++i)\n        if (mark[i]) {\n            printf(\"%d \", a[i]);\n            --k;\n        }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/","title":"6 - Trouglovi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Srba pravi novu verziju igrice \u201cFlappy Bird\u201d. Odlu\u010dio je da prepreke vi\u0161e ne budu cevi, ve\u0107 trouglovi koji \u0107e lebdedi u vazduhu.</p> <p>Odlu\u010dio je da \u0107e trouglove crtati tako \u0161to \u0107e na po\u010detku izabrati \\(N\\) razli\u010ditih ta\u010daka u ravni. Svaka prepreka \u0107e biti trougao koji ima temena u neke tri od izabranih ta\u010daka. Nakon \u0161to se prepreka pre\u0111e, pravi se nova prepreka koja nije ista kao ni jedna prethodna (dve prepreke su  razli\u010dite ako odgovaraju\u0107i trouglovi imaju bar jedno razli\u010dito teme).</p> <p>Da bi igra izgledala lep\u0161e, on \u0107e birati samo trouglove \u010diji su svi uglovi o\u0161tri.</p> <p>Malog Srbu zanima kada odabere po\u010detne ta\u010dke, koliko \u0107e igra biti duga, odnosno, koliko \u0107e najvi\u0161e prepreka postojati u igri?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Stojiljkovi\u0107"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalazi jedan ceo broj \\(N\\) koji predstavlja broj ta\u010daka koje je mali Srba izabrao. U slede\u0107ih \\(N\\) redova se nalaze po dva realna broja \\(X_i\\) i \\(Y_i\\) koji predstavljaju koordinate ta\u010daka. Koordinate \u0107e biti zapisane sa najvi\u0161e \\(3\\) decimale.</p>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati broj razli\u010ditih prepreka koje \u0107e postojati u novoj igri.</p>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/kv2/06_trouglovi/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n0.0 0.0\n1.1 0.0\n3.0 0.0\n1.1 2.0\n2.1 2.0\n</code></pre>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Mali Srba mo\u017ee napraviti \\(3\\) razli\u010dita o\u0161trougla trougla, i to su trouglovi koje \u010dine ta\u010dke:</p> <ul> <li>\\((0.0, 0.0)\\), \\((3.0, 0.0)\\) i \\((1.1, 2.0)\\);</li> <li>\\((0.0, 0.0)\\), \\((3.0, 0.0)\\) i \\((2.1, 2.0)\\);</li> <li>\\((1.0, 0.0)\\), \\((3.0, 0.0)\\) i \\((2.1, 2.0)\\).</li> </ul>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N \\leq 1000\\).</li> <li>\\(-10^6 \\leq X_i, Y_i \\leq 10^6\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(50\\) poena va\u017ei \\(1\\leq N\\leq 100\\).</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Potrebno je prebrojati broj o\u0161trouglih trouglova sa temenima u datim ta\u010dkama. To je mogu\u0107e uraditi grubom silom: za svake tri ta\u010dke odredimo du\u017eine stranica \\(a\\), \\(b\\) i \\(c\\). Trougao je o\u0161trougli ako va\u017ei \\(a^2+b^2&gt;c^2\\), \\(b^2+c^2&gt;a^2\\) i \\(c^2+a^2&gt;b^2\\). Vremenska slo\u017eenost je \\(O(N^3)\\).</p>"},{"location":"takprog/2013_2014/kv2/06_trouglovi/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Poku\u0161ajmo da prebrojimo sve tupougle, pravougle i degenerisane trouglove. Fiksirajmo neku du\u017e \\(AB\\). Posmatrajmo normale na tu du\u017e u ta\u010dkama \\(A\\) i \\(B\\). Sve ta\u010dke koje se ne nalaze strogo izme\u0111u njih spadaju u jednu od tri kategorije koju \u017eelimo prebrojati. Kada za svaku fiksiranu du\u017e prebrojimo tra\u017eeno, dobi\u0107emo dvostruku tra\u017eenu vrednost po\u0161to smo svaki takav trougao prebrojali dvaput (po jednom za svaku \"manju\" stranicu kojih ima dve). Nakon \u0161to na\u0111emo tu vrednost, znamo i broj o\u0161trouglih trouglova.</p> <p>Preostalo je odrediti koliko se ta\u010daka nalazi izme\u0111u dve paralelne prave, odnosno, za svaku takvu pravu odrediti koliko se ta\u010daka nalazi sa njene \"leve\" strane (nakon \u0161to se prava usmeri i tada je mogu\u0107e izvr\u0161iti orijentaciju trouglova). Ovo radi po\u0161to je razlika tih rezultata upravo broj ta\u010daka izme\u0111u dve paralelne prave.</p> <p>Fiksirajmo sad jednu ta\u010dku i sortirajmo ostale po uglu u odnosu na nju. Primetimo da ako fiksiramo du\u017ei sa krajem u toj ta\u010dki i drugim krajem redom po ostalim dobijamo to da na\u0161e normale na du\u017e u toj na\u0161oj centralnoj ta\u010dki budu sortirane po uglu. To zna\u010di da mo\u017eemo preko dva pokaziva\u010da za svaku normalu izbrojati koliko ta\u010daka ima \"levo\" od nje.</p> <p>Vremenska slo\u017eenost je \\(O(N^2\\cdot logN)\\).</p> 06_trouglovi.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAXN = 1005;\nconst double EPS = 1e-7;\nconst double PI = 3.1415926535;\n\nint n, m;\n\nstruct Point\n{\n    double x, y;\n    double angle;\n\n    bool operator &lt; (const Point &amp;p) const\n    {\n        return angle &lt; p.angle;\n    }\n\n    Point(){}\n\n    Point(double _x, double _y)\n        : x(_x), y(_y)\n    {\n        angle = atan2(y, x);\n        if (angle &lt; -EPS)\n        {\n            angle += 2.0 * PI;\n        }\n    }\n};\n\ndouble angleDifference(double angle1, double angle2)\n{\n    double angle = angle1 - angle2;\n    if (angle &lt; -EPS)\n    {\n        angle += 2.0 * PI;\n    }\n    return angle;\n}\n\nPoint points[MAXN];\nPoint sorted[MAXN];\n\nbool equals(double a, double b)\n{\n    return fabs(a - b) &lt; EPS;\n}\n\nbool UpdateStart(int j, int &amp;start)\n{\n    while (equals(sorted[start % m].angle, sorted[j].angle)) start++;   // preskocim kolinearne\n\n    while (true)\n    {\n        double diff = angleDifference(sorted[start % m].angle, sorted[j].angle);\n\n        if (diff &gt; PI / 2.0 - EPS &amp;&amp; diff &lt; PI - EPS)   // ako je &gt;= 90 stepeni &amp;&amp; &lt; 180 stepeni (nadje start i prekine)\n        {\n            return true;\n        }\n        else if (diff &gt;= PI - EPS)  // ako je &gt;= 180 stepeni onda nije naisao na ugao koji je izmedju [90, 180) pa kaze nije nasao start\n        {\n            return false;\n        }\n        start++;\n\n        if (equals(sorted[start % m].angle, sorted[j].angle))   // ako sam naisao na neku kolinearnu opet onda znaci da ne postoji nijedan od gore navedenih uglova\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\n// sve isto kao UpdateStart samo sto ovde izlazim kad naidjem na ugao &gt;= 180\nbool UpdateEnd(int j, int &amp;end)\n{\n    while (equals(sorted[end % m].angle, sorted[j].angle)) end++;\n\n    while (true)\n    {\n        double diff = angleDifference(sorted[end % m].angle, sorted[j].angle);\n        if (diff &gt;= PI - EPS)\n        {\n            return true;\n        }\n\n        end++;\n        if (equals(sorted[end % m].angle, sorted[j].angle))\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\nint CalculateDegen()\n{\n    int ans = 0;\n\n    int j = 0;\n    for (int i = 0; i &lt; m; j++)\n    {\n        while (equals(sorted[i].angle, sorted[j].angle))\n        {\n            j++;\n        }\n        ans += (j - i) * (j - i - 1) / 2;\n        i = j + 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(\"%lf%lf\", &amp;points[i].x, &amp;points[i].y);\n    }\n\n    int total = 0;\n    int totalDegen = 0;\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        m = 0;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (i == j)\n            {\n                continue;\n            }\n\n            sorted[m++] = Point(points[j].x - points[i].x, points[j].y - points[i].y);\n        }\n\n        sort(sorted, sorted + m);       // sorted sadrzi tacke koje su sortirane u odnosu na fiksiranu tacku p[i]\n        totalDegen += CalculateDegen();\n\n        int start = 0, end = 0; // start je prvi prav ili tup ugao, end je prvi &gt;= 180 (tj. interval [start, end) predstavlja prave/tupe)\n        int degenStart = 0, degenEnd = 0;\n\n        for (int j = 0; j &lt; m; j++)\n        {\n            // fiksiram drugu tacku, updatujem start i end\n            bool existsStart = UpdateStart(j, start);\n            bool existsEnd = UpdateEnd(j, end);\n\n            // ako start postoji (onda postoji i end sigurno) i updatujem broj tupih/pravih uglova\n            if (existsStart)\n            {\n                total += end - start;\n            }\n            else if (!existsEnd)    // ako ne postoji ni start ni end onda je pretpostavka da dalje ne postoji nijedan tup/prav ugao\n                                    // za trenutno fiksiranu tacku (mislim da je tacno jer ce se uglovi samo smanjivati \n                                    // a kako ne postoji &gt;= 90 nijedan onda su svi ostri)\n            {\n                break;\n            }\n        }\n    }\n\n    int totalTriangles = n * (n - 1) * (n - 2) / 6;\n    totalDegen /= 2;\n    printf(\"%d %d\\n\", total, totalDegen);\n\n    printf(\"%d\\n\", totalTriangles - total - totalDegen);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/01_bojenje/","title":"B1 - Bojenje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Marica, studentkinja prirodno-matemati\u010dkog fakulteta, redovno poha\u0111a ve\u017ebe iz predmeta \u201cTeorija aproksimacija i kvadraturne formule\u201d. Ve\u017ebe su vrlo jednostavne: asistentkinja na tabli napi\u0161e \\(N\\) prirodnih brojeva i od studenata tra\u017ei da ih aproksimiraju a zatim i kvadriraju. Me\u0111utim, Marica ne poznaje dovoljno ovu teoriju pa se koncentri\u0161e na svoju omiljenu razonodu \u2013 bojenje datih brojeva vodenim bojicama.</p> <p>Marica cifre svakog broja boji na specifi\u010dan na\u010din: cifru \\(1\\) boji crvenom, cifru \\(2\\) plavom, cifru \\(3\\) \u017eutom, cifru \\(4\\) narand\u017eastom, cifru \\(5\\) zelenom i cifru \\(6\\) ljubi\u010dastom bojom. Ostale cifre joj nisu zanimljive i njih ne boji. Naravno, ona koristi samo osnovne boje \u2013 crvenu, plavu i \u017eutu. Za bojenje jedne cifre osnovnom bojom potrebno joj je \\(2\\) miligrama (mg) odgovaraju\u0107e boje dok joj je za bojenje ostalim bojama potrebno po \\(1\\) miligram odgovaraju\u0107ih osnovnih boja: za narand\u017eastu \\(1mg\\) crvene i \\(1mg\\) \u017eute, za zelenu \\(1mg\\) \u017eute i \\(1mg\\) plave, za ljubi\u010dastu \\(1mg\\) plave i \\(1mg\\) crvene boje.</p> <p>Za datih \\(N\\) prirodnih brojeva, pomozite Marici da izra\u010duna koliko \u0107e joj biti potrebno miligrama svake od osnovnih boja da bi ih sve obojila.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Milica Mi\u0107i\u0107 Dimitrije Dimi\u0107"},{"location":"takprog/2013_2014/okr/01_bojenje/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\) \u2013 broj brojeva koje Marica planira da oboji. U narednih \\(N\\) redova nalazi se po jedan prirodan broj \\(A_i\\) \u2013 brojevi koje treba obojiti.</p>"},{"location":"takprog/2013_2014/okr/01_bojenje/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati \\(3\\) cela broja odvojena po jednim razmakom \u2013 broj miligrama crvene, plave i \u017eute boje, u tom redosledu, neophodan Marici za tra\u017eeno bojenje.</p>"},{"location":"takprog/2013_2014/okr/01_bojenje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/01_bojenje/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n123\n34086\n</code></pre>"},{"location":"takprog/2013_2014/okr/01_bojenje/#izlaz_1","title":"Izlaz","text":"<pre><code>4 3 5\n</code></pre>"},{"location":"takprog/2013_2014/okr/01_bojenje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Potrebno je obojiti dva broja. Za bojenje prvog broja (\\(123\\)) potrebno je po \\(2mg\\) svake od osnovnih boja. Za bojenje drugog broja: za cifru \\(3\\) je potrebno \\(2mg\\) \u017eute, za cifru \\(4\\) po \\(1mg\\) crvene i \u017eute, cifre \\(0\\) i \\(8\\) se ne boje, za cifru \\(6\\) po \\(1mg\\) plave i crvene. Ukupno je potrebno \\(4mg\\) crvene, \\(3mg\\) plave i \\(5mg\\) \u017eute boje.</p>"},{"location":"takprog/2013_2014/okr/01_bojenje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(1 \\leq A_i \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(1\\leq A_i\\leq 9\\), tj. svi brojevi su jednocifreni.</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(N=1\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/okr/01_bojenje/#resenje-za-1-leq-a_i-leq-9-odnosno-kad-su-svi-brojevi-jednocifreni","title":"Re\u0161enje za \\(1 \\leq A_i \\leq 9\\), odnosno kad su svi brojevi jednocifreni","text":"<p>Sve cifre su ve\u0107 odvojene i njihov broj je poznat po\u0161to je svaki broj jednocifren. Za svaku od cifara je potrebno pro\u0107i kroz slu\u010dajeve kako bi se utvrdilo koja je i u skladu sa brojem treba dodati po \\(1\\) mg odre\u0111ene dve boje (za brojeve \\(4\\), \\(5\\) ili \\(6\\)) ili \\(2\\) mg odre\u0111ene boje (za brojeve \\(1\\), \\(2\\) ili \\(3\\)) ili ni\u0161ta (za sve ostale brojeve). Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2013_2014/okr/01_bojenje/#resenje-za-n1","title":"Re\u0161enje za \\(N=1\\)","text":"<p>Dat je samo jedan broj koji mo\u017ee imati bilo koliko cifara. Tom broju skidamo poslednju cifru i za nju kao u prethodnoj grupi primera proveravamo koje boje je potrebno iskoristiti za farbanje i u kojoj koli\u010dini. Proces se ponavlja dok se celobrojnim deljenjem broja sa \\(10\\) ne dobije nula. Vremenska slo\u017eenost: \\(O(logN)\\), memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2013_2014/okr/01_bojenje/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ideja za re\u0161avanje prethodnog primera se sad koristi na svakom od \\(N\\) brojeva pojedina\u010dno, dok se koli\u010dina crvene, plave i \u017eute farbe potrebnih sabira za sve brojeve. Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(1)\\).</p> 01_bojenje.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nint red, blue, yellow;\nint n, num;\n\nint main()\n{\n    red = 0; blue = 0; yellow = 0;\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%d\", &amp;num);\n        while (num &gt; 0)\n        {\n            switch (num % 10)\n            {\n            case 1: red += 2; break;\n            case 2: blue += 2; break;\n            case 3: yellow += 2; break;\n            case 4: red++; yellow++; break;\n            case 5: yellow++; blue++; break;\n            case 6: blue++; red++; break;\n            }\n            num /= 10;\n        }\n    }\n\n    printf(\"%d %d %d\\n\", red, blue, yellow);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/02_komande1d/","title":"B2 - Komande1D","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Danas je lo\u0161e vreme napolju i student Srba je odlu\u010dio da ne\u0107e izlaziti iz ku\u0107e, pa tako ne\u0107e oti\u0107i ni na fakultet. Ipak, onda bi izgubio bitne bodove na predavanjima, pa je smislio novi na\u010din kako \u0107e prisustvovati njima. Napravio je robota koji \u0107e oti\u0107i umesto njega, \u010dak i zapisivati ono \u0161to pri\u010da profesor.</p> <p>Selo u kome \u017eivi Srba se mo\u017ee zamisliti kao velika brojevna prava. Srbina ku\u0107a se nalazi na koordinati \\(0\\), dok se njegov fakultet nalazi na koordinati \\(X\\).</p> <p>Robotu, koji je mali Srba napravio, se mogu zadati slede\u0107e komande:</p> <ul> <li><code>L</code> \u2013 Idi levo (ukoliko je bio na koordinati \\(x\\) pomeri\u0107e se na \\(x-1\\));</li> <li><code>R</code> \u2013 Idi desno (ukoliko je bio na koordinati \\(x\\) pomeri\u0107e se na \\(x+1\\)).</li> </ul> <p>Student Srba je robotu ve\u0107 zadao \\(N\\) komandi. Me\u0111utim, po\u0161to on odavno nije i\u0161ao na fakultet, zaboravio je ta\u010dan put do njega, a robot je zavr\u0161io u pivnici. Sada robotu treba promeniti komande, i Srba vas moli da mu pomognete. Po\u0161to se ve\u0107 dovoljno namu\u010dio prave\u0107i robota i pi\u0161u\u0107i ove komande, on \u017eeli samo da obri\u0161e ta\u010dno \\(K\\) komandi. Na\u0111ite bilo kojih \\(K\\) komandi koje Srba mo\u017ee da obri\u0161e tako da na kraju stigne u koordinatu \\(X\\) ili ispi\u0161ite \\(-1\\) ukoliko to nije mogu\u0107e.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Milica Mi\u0107i\u0107 Boris Grubi\u0107"},{"location":"takprog/2013_2014/okr/02_komande1d/#ulaz","title":"Ulaz","text":"<p>Svaki test primer se sastoji od \\(3\\) posebna potprimera.</p> <p>Prvi red svakog potprimera sadr\u017ei \\(3\\) broja odvojena po jednim znakom razmaka \u2013 \\(N\\), \\(X\\) i \\(K\\) koji redom predstavljaju broj komandi koje je Srba zadao robotu, koordinatu fakulteta i broj komadi koje Srba treba da izbri\u0161e. Drugi red potprimera sadr\u017ei \\(N\\) karaktera koji predstavljaju komande koje je Srba zadao robotu.</p>"},{"location":"takprog/2013_2014/okr/02_komande1d/#izlaz","title":"Izlaz","text":"<p>Za svaki potprimer u posebnom redu ispisati po \\(K\\) brojeva odvojenih po jednim znakom razmaka, koji predstavljaju indekse komandi koje treba obrisati (komande su indeksirane od \\(1\\)). Ukoliko ne postoji \\(K\\) komandi koje se mogu obrisati i sti\u0107i u tra\u017eenu koordinatu, ispisati \\(-1\\). Ukoliko postoji vi\u0161e mogu\u0107ih re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2013_2014/okr/02_komande1d/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/02_komande1d/#ulaz_1","title":"Ulaz","text":"<pre><code>5 -2 3\nRLLLL\n4 3 2\nRRRL\n6 2 2\nRRLRLR\n</code></pre>"},{"location":"takprog/2013_2014/okr/02_komande1d/#izlaz_1","title":"Izlaz","text":"<pre><code>1 2 5\n-1\n6 5\n</code></pre>"},{"location":"takprog/2013_2014/okr/02_komande1d/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom potprimeru je mogu\u0107e obrisati \\(1.\\) \\(2.\\) i \\(5.\\) komandu, i tako \u0107e ostati samo <code>LL</code> \u0161to \u0107e robota odvesti na koordinatu fakulteta. Druga re\u0161enja bi se tako\u0111e priznala, kao npr. <code>1 2 3</code>. U drugom potprimeru nije mogu\u0107e obrisati nijedne dve komande tako da robot na kraju stigne na koordinatu \\(3\\), pa zato treba ispisati \\(-1\\).</p>"},{"location":"takprog/2013_2014/okr/02_komande1d/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(0 \\leq K \\leq N\\).</li> <li>\\(-10^9 \\leq X \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(40\\) poena va\u017ei \\(N\\leq 1000\\).</li> <li>U test primerima vrednim \\(60\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/okr/02_komande1d/#resenje-za-n-leq-1000","title":"Re\u0161enje za \\(N \\leq 1000\\)","text":"<p>Mo\u017eemo, na primer, fiksirati koliko desnih komandi \u0107emo obrisati. Onda znamo i koliko levih komandi moramo obrisati (\\(l = K-d\\), gde je \\(d\\) broj desnih komandi koje obri\u0161emo, sli\u010dno za \\(l\\)). Uvek mo\u017eemo obrisati prvih \\(l\\) levih komandi i prvih \\(d\\) desnih komandi (naravno, moramo paziti da ih imamo dovoljno). Nakon toga, mo\u017eemo proveriti da li dati niz komandi zaista dovodi do koordinate \\(X\\). Vremenska slo\u017eenost: \\(O(N\\cdot K)\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2013_2014/okr/02_komande1d/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za svaki od tri potprimera pojedina\u010dno  u prvom prolazu kroz komande je potrebno odrediti broj levih i desnih komandi. Tako odre\u0111ujemo koordinatu pivnice (neka bude ozna\u010dena sa \\(P\\)) kao razliku broja desnih i levih kretanja. Neophodno je obrisati \\(X-P\\) pomeranja nalevo u slu\u010daju da je \\(X&gt;P\\) ili \\(P-X\\) pomeranja nadesno, u  suprotnom. U tom trenutku smo ve\u0107 doveli robota do pozicije fakulteta, ali po\u0161to moramo obrisati ta\u010dno \\(K\\) komandi, mo\u017eda nam preostane jo\u0161 komandi koje treba obrisati. Kako se ne bi poremetila pozicija na kojoj \u0107e se robot nalaziti potrebno je obrisati jednaku koli\u010dinu desnih i levih koraka preostalim brisanjima.  Do\u0107i od pozicije pivnice do mesta fakulteta je mogu\u0107e jedino ako su zadovoljeni uslovi da je \\(K-|P-X|\\ge 0\\),  da je \\(K-|P-X|\\) deljiv sa \\(2\\) (da bismo mogli da podelimo preostala brisanja ravnomerno na leve i desne komande), a potrebno je i imati dovoljan broj levih i desnih komandi od preostalih komandi kako bismo ih obrisali. Ako su svi ovi uslovi zadovoljeni dovoljno je jo\u0161 samo pro\u0107i ponovo kroz niz komandi i ispisati mesta gde se prvo nalazi odre\u0111eni broj komandi nalevo i nadesno. Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\).</p> 02_komande1d.cpp<pre><code>#include &lt;stdio.h&gt;\n\nchar s[500555];\n\nint main() {\n\n    int n,x,k,i,R,L,P,oL,oR,tt;\n\n    for(tt=0; tt&lt;3; tt++) {\n        scanf(\"%d%d%d\", &amp;n, &amp;x, &amp;k);\n        scanf(\"%s\", &amp;s);\n\n        R = 0; L = 0;\n        for(i=0; i&lt;n; i++) {\n            if (s[i] == 'R') R++;\n            else L++;\n        }\n\n        P = R - L;\n        oL = 0; oR = 0;\n        if (P &lt; x) {\n            oL = x - P;\n            k -= oL;\n        } else {\n            oR = P - x;\n            k -= oR;\n        }\n\n        if (k &lt; 0 || k%2 == 1) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        oL += k/2;\n        oR += k/2;\n\n        if (oL &gt; L || oR &gt; R) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        for(i=0; i&lt;n; i++) {\n            if (s[i] == 'R' &amp;&amp; oR &gt; 0) {\n                printf(\"%d \", i+1);\n                oR--;\n            }\n\n            if (s[i] == 'L' &amp;&amp; oL &gt; 0) {\n                printf(\"%d \", i+1);\n                oL--;\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/","title":"B3 - Lepr\u0161ava ptica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Mlada studentkinja Mihaela je do sada bila najbolji student u svojoj generaciji sa najboljim ocenama. Me\u0111utim u poslednje vreme je postala lenja i posebno su joj postala dosadna predavanja iz informatike, iako joj je to pre bio omiljeni predmet. Trenutno se nalazi na predavanju iz informatike i kako se ne bi dosa\u0111ivala, ona \u0107e se takmi\u010diti sa svojim drugarima u igrici \u201eLepr\u0161ava ptica\u201c, koja je veoma sli\u010dna popularnoj igrici \u201cFlappy bird\u201d. Ona ima vremena samo za jednu partiju igrice, te ho\u0107e da postigne \u0161to bolji rezultat.</p> <p>Poenta igrice je da navodite lepr\u0161avu pticu tako da ne udari u cevi koje se nalaze sa gornje i donje strane mape. Mapu igrice mo\u017eemo da posmatramo kao matricu visine \\(H\\), dok je du\u017eina matrice neograni\u010dena. Poznato je da postoji ta\u010dno \\(N\\) cevi na mapi i za svaku cev se zna na kojoj poziciji se nalazi, kolika je visina dela cevi koji se prote\u017ee od vrha mape na dole i kolika je visina dela cevi koji se prote\u017ee od donjeg kraja mape na gore. \u0160irina cevi je jednaka \u0161irini jednog polja u matrici.</p> <p>Ptica se na po\u010detku nalazi na po\u010detku mape, tj. poziciji \\(0\\), i na visini \\(\\frac{H+1}{2}\\) ukoliko je \\(H\\) neparan broj, ina\u010de na visini \\(\\frac{H}{2}\\) i zauzima ta\u010dno jedno polje u matrici. U svakom trenutku se lepr\u0161ava ptica pomeri za jedno mesto u desno na mapi, dok od Mihaele zavisi da li \u0107e da se pomeri za jedno mesto na gore ili na dole u matrici. Ukoliko Mihaela pritisne dugme na mi\u0161u lepr\u0161ava ptica \u0107e se pomeriti za jedno mesto na gore, dok \u0107e u suprotnom da se pomeri za jedno mesto na dole. Preciznije re\u010deno, ukoliko se lepr\u0161ava ptica nalazi na polju \\((X,Y)\\) u slede\u0107em trenutku \u0107e se nalaziti ili na poziciji \\((X+1,Y+1)\\) ili na pozicji \\((X+1,Y-1)\\).</p> <p>Va\u0161 zadatak je da odredite maksimalni broj poena koji Mihaela mo\u017ee da osvoji ukoliko vam je poznata cela mapa igrice i ukoliko znate da svaki put kad lepr\u0161ava ptica pro\u0111e kroz prolaz koji je napravljen od cevi dobijate \\(1\\) poen. U trenutku kada lepr\u0161ava ptica udari u cev ili iza\u0111e iz granica mape umire.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Demjan Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Dimitrije Dimi\u0107"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalaze prirodni brojevi brojevi \\(H\\) i \\(N\\) koji redom ozna\u010davaju visinu mape i broj cevi na mapi. U svakom od slede\u0107ih \\(N\\) redova se nalaze po tri prirodna broja \\(X\\), \\(H_d\\) i \\(H_g\\) koji ozna\u010davaju redom koliko je cev udaljena od po\u010detka mape, du\u017einu dela cevi koji po\u010dinje sa gornjeg dela i visinu dela cevi koji po\u010dinje sa donjeg dela mape. Cevi \u0107e biti zadate u rastu\u0107em poretku po poziciji gde se nalaze i ne\u0107e postojati dve cevi sa istom pozicijom.</p>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati maksimalan broj poena koji Mihaela mo\u017ee osvojiti.</p>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#ulaz_1","title":"Ulaz","text":"<pre><code>5 4\n4 2 1\n6 1 2\n9 2 2\n11 1 1\n</code></pre>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<pre><code>5| .  .  .  .  #  .  #  .  .  #  .  #  .  .  .\n4| .  .  .  .  .  .  #  .  .  #  .  .  .  .  .\n3| P  .  .  .  .  .  .  .  .  .  .  .  .  .  .\n2| .  .  .  .  #  .  .  .  .  #  .  .  .  .  .\n1| .  .  .  .  #  .  #  .  .  #  .  #  .  .  .\n----------------------------------------------\n0  1  2  3  4  5  6  7  8  9 10 11 12 13 14\n</code></pre> <p>(<code>P</code> \u2013 ptica na po\u010detku, <code>#</code> - cevi) Lepr\u0161ava ptica ne mo\u017ee da pro\u0111e kroz prolaz koji je napravljen od tre\u0107e cevi.</p>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 10^5\\).</li> <li>Svi ostali brojevi iz ulaza su prirodni brojevi ne ve\u0107i od \\(10^9\\).</li> <li>Za svaku cev iz ulaza \u0107e va\u017eiti \\(H_g + H_d \\leq H\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(H, X\\leq 1000\\).</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei \\(H\\cdot X\\leq 10^6\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Neka je \\(W\\) maksimalno mogu\u0107e \\(X\\). Pamtimo za svih \\(W\\cdot H\\) polja da li je mogu\u0107e do\u0107i do njih u matrici tipa \\(boolean\\). Do polja \\((x,y)\\) je mogu\u0107e do\u0107i ukoliko ono nije zid i mogu\u0107e je pre njega do\u0107i do \\((x-1,y-1)\\) ili \\((x-1,y+1)\\). \"Najdesnije\" polje odre\u0111uje maksimalan mogu\u0107i broj poena. Slo\u017eenost je \\(O(W\\cdot H)\\).</p>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Po\u0161to nije mogu\u0107e napraviti \\(10^5\\cdot 10^5\\) stati\u010dku matricu, polja moramo skladi\u0161titi u druga\u010dijoj strukturi; Dinami\u010dka matrica (tip vector&lt;vector&lt; bool&gt; &gt;) ili niz sa indeksiranjem polja \\((i,j)\\) kao \\(i\\cdot H + j\\) zadovoljavaju uslov zadatka.</p>"},{"location":"takprog/2013_2014/okr/03_leprsava_ptica/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za svaku cev \u0107emo pamtiti maksimalno gornje polje do kog je mogu\u0107e sti\u0107i, kao i minimalno donje polje. Ukoliko odredimo da do neke nije mogu\u0107e sti\u0107i, potrebno je samo ispisati indeks te cevi kao re\u0161enje zadatka (brojimo sve cevi pre nje kroz koje smo uspe\u0161no pro\u0161li). Ako smo trenutno kod cevi \\(i\\) sa i znamo maksimalnu i minimalnu i minimalnu visinu na kojoj se mo\u017eemo na\u0107i - \\(G_i\\) i \\(D_i\\), a treba do\u0107i do cevi \\(i+1\\), Nova visinska ograni\u010denja postaju \\(\\(G_{i+1}=min(G_i+X_{i+1}-X_i,H-H_g-1)\\)\\) \\(\\(D_{i+1}=max(D_i-X_{i+1}+X_i,H_d+1)\\)\\) Potrebno je ispitati da li je \\(G_{i+1}&lt;D_{i+1}\\); u tom slu\u010daju je nemogu\u0107e pre\u0107i taj zid. Slo\u017eenost je \\(O(N)\\).</p> 03_leprsava_ptica.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;stdio.h&gt;\nusing namespace std;\n\n#define MaxN 1000010\n\nint n,h;\nint x[MaxN];\nint hg[MaxN];\nint hd[MaxN];\n\nint currUp, currDown;\n\nint main()\n{\n    scanf(\"%d%d\",&amp;h,&amp;n);\n    for (int i = 0; i &lt; n; ++i) {\n        scanf(\"%d%d%d\",&amp;x[i],&amp;hd[i],&amp;hg[i]);\n    }\n\n    if ( h % 2 == 1 ) currUp = currDown = (h+1) / 2;\n    else currUp = currDown = h / 2;\n\n    int ret = 0;\n    int currPosition = 0;\n    while ( ret &lt; n &amp;&amp; currDown &lt;= currUp ) {\n        int distance = x[ret] - currPosition;\n        int maxH = currUp + distance;\n        int minH = currDown - distance;\n\n        int newCurrUp = min( h - hg[ret], maxH );\n        int newCurrDown = max( hd[ret] + 1, minH );\n\n        if ( distance % 2 == 1 ) {\n            if ( currUp % 2 == newCurrUp % 2 ) --newCurrUp;\n            if ( currDown % 2 == newCurrDown % 2 ) ++newCurrDown;\n        }\n        else {\n            if ( currUp % 2 != newCurrUp % 2 ) --newCurrUp;\n            if ( currDown % 2 != newCurrDown % 2 ) ++newCurrDown;\n        }\n\n        currPosition = x[ret];\n        currUp = newCurrUp;\n        currDown = newCurrDown;\n        if ( currDown &lt;= currUp ) ++ret;\n    }\n\n    printf(\"%d\\n\",ret);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/","title":"A1 - Polaganje ispita","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Anitica je ovog vikenda polagala ispit iz Op\u0161te-narodne medicine i umetnosti. Princip polaganja ovog ispita je druga\u010diji od ostalih: na ispitu student izvla\u010di \\(N\\) pitanja, odgovara na svako od njih, a krajnji broj bodova se dobija sumom bodova najboljih \\(K\\) pitanja. Svako pitanje vredi isti broj bodova. Kako je ovo jako bitan ispit, ukoliko student po\u010dne da \u201clupa gluposti\u201d mo\u017ee osvojiti i negativan broj bodova na  nekom od pitanja.</p> <p>Anitica je uspe\u0161no polo\u017eila ispit ali nije zadovoljna svojim brojem bodova. Ovo je njoj jako bitno, jer nije uspela da dobije ocenu potrebnu da u fakultetskoj poslasti\u010dari osvoji besplatne \u010dvarke i kavurmu kao nagradu. Zato je re\u0161ila da na\u0111e drugi na\u010din ocenjivanja kako bi dobila ve\u0107i broj bodova. Na\u010din koji je odabrala je da umesto \\(K\\) najboljih odgovora, mo\u017ee da izabere bilo kojih  \\(K\\) pri \u010demu je ukupan broj bodova jednak proizvodu bodova osvojenih na izabranih \\(K\\) pitanja.</p> <p>Pomozite Anitici da utvrdi koji je najve\u0107i broj bodova koji ona mo\u017ee da osvoji preko svog na\u010dina bodovanja ispita.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Andreja Ili\u0107 Andreja Ili\u0107 Boris Grubi\u0107 <p>Polaganje ispita je bio najlak\u0161i problem za A kategoriju i kao takav nije zahtevao neku specijalnu teoriju. Me\u0111utim, iako ideja re\u0161enja nije te\u0161ka (uz malo analize se prosto name\u0107e), ukoliko se implementaciji pristupi olako mo\u017ee do\u0107i do pregr\u0161t specijalnih slu\u010dajeva. Ovo se obi\u010dno javlja kod geometrijskih problema \u2013 laka ideja ali naporna implementacija ukoliko se ne provede malo vi\u0161e vremena uz papir i olovku.</p> <p>Problem mo\u017eemo prevesti na malo formalniji jezik: za dati niz celih brojeva du\u017eine \\(n\\), izabrati podniz, ne nu\u017eno uzastopnih elemenata, du\u017eine \\(k\\) koji ima maksimalni proizvod. Prvu stvar koju mo\u017eemo zapaziti jeste da \u017eelimo da brojevi koji ulaze u dati podniz budu \u201c\u0161to ve\u0107i\u201d, kako bi i njihov proizvod bio \u0161to ve\u0107i. Izraz \u201c\u0161to ve\u0107i\u201d je stavljen pod navodnike, a uskoro \u0107em objasniti razlog za to.</p> <p>Posmatrajmo za po\u010detak jednostavniju verziju problema \u2013 kada su elementi niza prirodni brojevi (drugim re\u010dima nule i pozitivne vrednosti). Kako nema negativnih vrednosti, najvi\u0161e nam se isplati da uzimamo brojeve koji su najve\u0107i \u2013 najve\u0107ih \\(k\\) elemenata niza. Dakle, re\u0161enje jednostavnijeg problema zahteva sortiranje niza a za rezultat se vra\u0107a najve\u0107ih \\(k\\) elemanata.</p> <p>\u0160ta se toliko razlikuje kada dozvoljavamo da brojevi budu negativni? Dosta toga se menja, po\u010dev od toga da ukoliko posmatramo dva najmanja elementa koja su negativna, njihov proizvod je pozitivan i mo\u017ee biti ve\u0107i od proizvoda dva najve\u0107a elementa niza (koja su pozitivna). Specijalan slu\u010daj kada imamo niz za svim negativnim brojevima tako\u0111e mo\u017ee da nam zada glavobolje ukoliko ga ne primetimo na po\u010detku. Npr. ukoliko su svi elementi niza negativni, a imamo da je \\(k\\) neparan broj, tada imamo da je proizvod bilo kog podniza du\u017eine \\(k\\) negativan. Zato re\u0161enje u tom slu\u010daju predstavljaju najve\u0107ih \\(k\\) elemenata niza. Iz izlo\u017eenog vidimo da se moramo malo vi\u0161e posvetiti analizom problema kako ne bi ima gomilu if pre\u0107enim else u kodu.</p> <p>Primer sa negativnim vrednostima kada je \\(k\\) neparno:</p> <p></p> <p>Kako se mogu uobli\u010diti gore izneseni primeri? Mi \u017eelimo da izaberemo \\(k\\) elemenata sa najve\u0107om apsolutnom vredno\u0161\u0107u, ali pod uslovom da negativnih brojeva ima paran broj. Na taj na\u010din se dobija pozitivno re\u0161enje. Me\u0111utim, nekada nije mogu\u0107e izabrati brojeve tako da imamo paran broj negativnih elemenata. Da li taj slu\u010daj mo\u017eemo lako opisati? Ukoliko imamo barem jedan pozitivan broj, tada on mo\u017ee promeniti parnost broja izabranih negativnih elemenata. Drugim re\u010dima, ukoliko imamo barem jedna pozitivan element, tada podniz koji daje re\u0161enje ima nenegativan proizvod. Dakle, prvi slu\u010daj predstavlja niz koji nema pozitivne elemente i kada je \\(k\\) neparno. U ovom slu\u010daju imamo da je re\u0161enje proizvod \\(k\\) najve\u0107ih elemenata \u2013 pogledati primer na slici \\(1\\).</p> <p>Razmotrimo sada generalniji slu\u010daj \u2013 kada imamo barem jedan pozitivan element niza. Pretpostavimo da je dati niz sortiran u neopadaju\u0107em poretku. Kako smo ve\u0107 napomenuli, \u017eelimo da uzimamo elemente sa najve\u0107im apsolutnim vrednostima, ali tako da imamo paran broj elemenata koji su manji od nule. OK, za\u0161to onda ne bi smo uzeli upravo najve\u0107ih \\(k\\) elemenata niza po apsolutnoj vrednosti. Ukoliko imamo paran broj negativnih, na\u0161li smo re\u0161enje. \u0160ta u slu\u010daju da ih imamo nepran broj? Tada ili ubacujemo jo\u0161 jedan negativan a izbacujemo pozitivan, ili obrnuto. Naravno ponovo nam se isplati da uba\u010deni ima \u0161to ve\u0107u apsolutno vrednost. Dakle, imamo dva slu\u010daja:</p> <ul> <li>Izbacujemo najmanji pozitivan broj, a ubacujemo slede\u0107i najve\u0107i negativni broj</li> <li>Izbacujemo najve\u0107i negativan broj, a ubacujemo slede\u0107i najve\u0107i pozitivan broj</li> </ul> <p>Naravno, uzimamo onu opciju koja nam daje ve\u0107i proizvod. Za ovo nije potrebno ra\u010dunati sam proizvod, po\u0161to se u ova dva slu\u010daju izabrani podnizovi od \\(k\\) elemenata razlikuju samo u dva elementa. Zato je dovoljno samo uporediti promene nastale ovim zamenama.</p> <p>Mo\u017eemo prokomentarisati i na\u010din sortiranja niza. Naime, kako maksimalna vrednost elemenata ne prelazi \\(10^6\\) po apsolutnoj vrednosti, niz mo\u017eemo sortirati metodom prebrojavanja (eng. counting sort). Me\u0111utim, kako se koristi ovaj sort u slu\u010daju kada imamo i negativne vrednosti (po\u0161to ne mo\u017eemo indeksirati elemente niza negativnim brojevima). Ovo se mo\u017ee re\u0161iti tako \u0161to na po\u010detku svim vrednostima dodamo \\(10^6\\), \u010dime dobijamo da su svi elementi pozitivni i iz segmenta \\([0, 2\\cdot 10^6]\\). Sada mo\u017eemo primeniti metod prebrojavanja. Nakon sortiranja, svim vrednostima elementa oduzimamo \\(10^6\\), \u010dime dobijamo sortirani po\u010detni niz. Ovo se mo\u017ee optimizovati za manje slu\u010dajeve time \u0161to se ne dodaje odnosno oduzima vrednost \\(10^6\\), ve\u0107 apsolutna vrednost minimalnog elementa.</p> <p>Slo\u017eenost ovog algoritma je \\(O(m+k)\\), gde je \\(m\\) apsolutna vrednost minimalnog elementa. Zaista, slo\u017eenost opisanog sortiranja je \\(O(m)\\), dok je navedeni algoritam za tra\u017eenje podniza linearne slo\u017eenosti po du\u017eini podniza.</p> 04_polaganje_ispita.cpp<pre><code>#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#define MAX_N 5005\n#define MAX_VALUE 1000005\n\nint n, k, a [MAX_N], count [2 * MAX_VALUE];\nbool marked [MAX_N];\n\nvoid input()\n{\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    for (int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;a [i]);\n}\n\nvoid output()\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (marked [i])\n        {\n            printf(\"%d \", a [i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\n\nvoid count_sort()\n{\n    for (int i = 0; i &lt; 2 * MAX_VALUE; i++)\n        count [i] = 0;\n    for (int i = 0; i &lt; n; i++)\n        count [MAX_VALUE + a [i]]++;\n    int index = 0;\n    for (int i = 0; i &lt; 2 * MAX_VALUE; i++)\n    {\n        while (count [i] &gt; 0)\n        {\n            a [index] = i - MAX_VALUE;  \n            index++;\n            count[i]--;\n        }\n    }\n}\n\nvoid solve()\n{\n    count_sort();\n\n    for (int i = 0; i &lt; MAX_N; i++)\n        marked [i] = false;\n\n    int indexA = 0, indexB = n - 1, sign = 1;\n    while (indexA + (n - 1 - indexB) &lt; k)\n    {\n        if (abs(a [indexA]) &gt; a [indexB] &amp;&amp; a [n - 1] &gt;= 0)\n        {\n            marked [indexA] = true;\n            if (a [indexA] &lt; 0)\n                sign *= -1;\n            indexA++;\n        }\n        else\n        {\n            marked [indexB] = true;\n            indexB--;\n        }\n    }\n\n    if (sign == -1)\n    {\n        if (indexB == n - 1)\n        {\n            marked [indexA - 1] = false;\n            marked [indexB] = true;\n        }\n        else\n        {\n            if ((a [indexA] * a [indexA - 1]) &gt; (a [indexB] * a [indexB + 1]))\n            {\n                marked [indexB + 1] = false;\n                marked [indexA] = true;\n            }\n            else\n            {\n                marked [indexA - 1] = false;\n                marked [indexB] = true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    input();\n    solve();\n    output();\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja, odvojena jednim znakom razmaka, \\(N\\) i \\(K\\), koji ozna\u010davaju ukupan broj pitanja i broj pitanja koji ulaze u ra\u010dunanje broja bodova za ispit. Drugi red ulaza sadr\u017ei \\(N\\) celih brojeva, odvojenih po jednim znakom razmaka, koji predstavljaju broj bodova za svako od izvu\u010denih pitanja.</p>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#izlaz","title":"Izlaz","text":"<p>Prvi i jedini red standardnog izlaza treba da sadr\u017ei \\(K\\) celih brojeva \u2013 vrednosti pitanja koje treba izabrati za ra\u010dunanje broja bodova po metodi Anitice. Pitanja \u0161tampati u proizvoljnom redosledu. Ukoliko ima vi\u0161e re\u0161enja, \u0161tampati bilo koje.</p>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#ulaz_1","title":"Ulaz","text":"<pre><code>7 5\n-1 4 2 3 1 5 -3\n</code></pre>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#izlaz_1","title":"Izlaz","text":"<pre><code>-1 4 3 5 -3\n</code></pre>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Proizvod izabranih pitanja je \\(180 = (-1)\\cdot 4\\cdot 3\\cdot 5\\cdot (-3)\\). Ovo je maksimalni proizvod koji daju pet odgovora datog niza pitanja.</p>"},{"location":"takprog/2013_2014/okr/04_polaganje_ispita/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq K \\leq N \\leq 5.000\\).</li> <li>Elementi niza su iz segmenta \\([-1.000.000, 1.000.000]\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(1\\leq N\\leq 15\\) i elementi niza su iz segmenta \\([-3, 3]\\).</li> <li>U test primerima vrednim \\(80\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/okr/05_veciti/","title":"A2 - Ve\u010diti","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Ivica, ve\u010diti student matemati\u010dkog fakulteta, najvi\u0161e od svega voli da gleda fudbalske utakmice, pije pivo i izlazi na ispite iz Topologije. Interesantno je da je on za taj ispit u\u010dio samo jednom u \u017eivotu ali i da profesor na svakom ispitu daje iste zadatke \u0161to za posledicu ima da svaki put kada Ivica iza\u0111e na ispit iz ovog predmeta, on osvoji \\(A\\) poena.</p> <p>Jednog dana, izvesna vra\u010dara je Ivici gledala u dlan i rekla mu je da se (jasno kao dan) vidi da \u0107e on zavr\u0161iti fakultet onog trenutka kada ukupna suma njegovih poena na ispitima iz Topologije bude po\u010dinjala istim nizom cifara kao misti\u010dni broj \\(B\\). Sada Ivica ne mo\u017ee da spava od nestrpljenja i zanima ga kolika \u0107e biti ukupna suma njegovih poena u trenutku kada zavr\u0161i fakultet. Pomozite mu!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Vladimir Brankovi\u0107 Boris Grubi\u0107"},{"location":"takprog/2013_2014/okr/05_veciti/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(A\\), broj poena koje Ivica osvaja na svakom ispitu iz Topologije. U drugom redu standardnog ulaza nalazi se prirodan broj \\(B\\) \u2013 misti\u010dni broj.</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standarnog izlaza ispisati jedan prirodan broj \u2013 broj poena koje \u0107e Ivica imati u zbiru na ispitima iz Topologije u trenutku kada zavr\u0161i fakultet. Ukoliko se to nikada ne\u0107e desiti, ispisati \\(-1\\) (bez navodnika).</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/05_veciti/#ulaz_1","title":"Ulaz","text":"<pre><code>15\n43\n</code></pre>"},{"location":"takprog/2013_2014/okr/05_veciti/#izlaz_1","title":"Izlaz","text":"<pre><code>435\n</code></pre>"},{"location":"takprog/2013_2014/okr/05_veciti/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ivica osvaja \\(15\\) poena po ispitu i zavr\u0161i\u0107e fakultet kada ukupna suma po\u010dinje nizom cifara <code>43</code>. To \u0107e se prvi put desiti posle \\(29\\) ispita (ne mo\u017ee ranije) i tada \u0107e  imati \\(29\\cdot 15 = 435\\) poena.</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq A \\leq 10^9\\).</li> <li>\\(B\\) je prirodan broj i ima\u0107e najvi\u0161e \\(10^5\\) cifara.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(15\\) poena va\u017ei \\(1\\leq B\\leq 9\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(1\\leq A, B \\leq 10^3\\).</li> <li>U test primerima vrednim \\(35\\) poena va\u017ei \\(1\\leq A,B\\leq 10^9\\).</li> <li>U test primerima vrednim \\(30\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/okr/05_veciti/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Neka brojevi \\(A\\) i \\(B\\) imaju, redom, \\(n\\) i \\(m\\) cifara. Brojevi \\(B\\cdot10^{n}\\), \\(B\\cdot10^{n}+1\\),  . . .   \\(B\\cdot10^{n}+A-1\\) daju razli\u010dite ostatke po modulu A, \u0161to zna\u010di da je jedan od njih deljiv sa A i ima \\(n+m\\) cifara. Sada kada znamo da re\u0161enje uvek postoji, prolaskom kroz niz \\(B\\), \\(B+1\\), . . .\\(B\\cdot10^{n}+A-1\\) (brojevi su manji od \\(10^{n}\\) ) na\u0111emo najmanji broj deljiv sa A. Ovih brojeva ima     \\(1\\) + \\(10^{2}\\) + . . . + \\(10^{n}\\) = \\(\\cfrac{10^{n+1}-1}{9}\\), pa je slo\u017eenost algoritma \\(O\\Big(\\cfrac{10^{n+1}-1}{9}\\Big)\\) , gde je \\(n\\) broj cifara broja A.</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Koristimo sli\u010dnu ideju, proveravamo brojeve \\(B\\), \\(B+1\\), . . .\\(B\\cdot10^{n}+A-1\\) (brojevi su manji od \\(10^{n+m}\\) ). Slo\u017eenost algoritma je \\(O\\Big(\\cfrac{10^{n+1}-1}{9}\\Big)\\).</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Ovog puta, umesto da posmatramo sve brojeve, za svako \\(i\\) od \\(1\\) do \\(n\\) tra\u017eimo najmanji \\(i\\)-tocifreni broj \\(C\\) (mo\u017ee imati vode\u0107e nule) takav da je broj \\(B\\cdot10^{i}+C\\) deljiv sa A. To mo\u017eemo u \\(O(1)\\), jer je \\(C\\) kongruentno sa \\(-B\\cdot10^{i}\\) po modulu A. Slo\u017eenost je \\(O(n)\\).</p>"},{"location":"takprog/2013_2014/okr/05_veciti/#etvrti-podzadatak","title":"\u0447etvrti podzadatak","text":"<p>Sli\u010dna ideja kao u pro\u0161lom podzadatku, ali je sada \\(B\\) preveliko da bi direktno ra\u010dunali ostatak po modulu A, tako da pravimo pomo\u0107ni niz \\(p\\), gde je \\(p_i\\) ostatak broja \\(10^{i}\\) po modulu A i ostatak broja \\(B\\) je \\(B[0]\\cdot p[m-1]+B[1]\\cdot p[m-2]+. . .+B[m-1]\\cdot p[0]\\). Kako nam je potrebno samo prvih \\(m\\) \u010dlanova niza \\(p\\) ,slo\u017eenost ovog algoritma je \\(O(n+m)\\).</p> 05_veciti.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nconst int MaxN = 100100;\n\nint n, a, digCount;\nint digits[20];\nlong long curr, deg;\nchar b[MaxN];\n\nint main()\n{\n    scanf(\"%d\", &amp;a);\n    scanf(\"%s\", b);\n    n = strlen(b);\n\n    curr = 0LL;\n    for (int i = 0; i &lt; n; i++)\n        curr = (curr * 10 + (b[i] - '0')) % a;\n\n    deg = 1;\n    digCount = 0;\n    while ((a - curr) % a &gt;= deg)\n    {\n        deg = deg * 10;\n        digCount++;\n        curr = (curr * 10) % a;\n    }\n\n    curr = (a - curr) % a;\n    for (int i = 1; i &lt;= digCount; i++)\n    {\n        digits[i] = curr % 10;\n        curr = curr / 10;\n    }\n\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%c\", b[i]);\n    for (int i = digCount; i &gt; 0; i--)\n        printf(\"%d\", digits[i]);\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/","title":"A3 - Komande2D","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>Danas je lo\u0161e vreme napolju i student Srba je odlu\u010dio da ne\u0107e izlaziti iz ku\u0107e, pa tako ne\u0107e oti\u0107i ni na fakultet. Ipak, onda bi izgubio bitne bodove na predavanjima, pa je smislio novi na\u010din kako \u0107e prisustvovati njima. Napravio je robota koji \u0107e oti\u0107i umesto njega, \u010dak i zapisivati ono \u0161to pri\u010da profesor.</p> <p>Selo u kome \u017eivi Srba je kvadratnog oblika, i nalazi se na povr\u0161ini koju obuhvata kvadrat koji ima temena u koordinatama \\((-K, K)\\), \\((K, K)\\), \\((K, -K)\\), \\((-K, K)\\). Srbina ku\u0107a se nalazi na koordinatama \\((0,0)\\), dok se njegov fakultet nalazi na koordinatama \\((X_f, Y_f)\\).</p> <p>Robotu, koji je mali Srba napravio, se mogu zadati slede\u0107e komande:</p> <ul> <li><code>U</code> \u2013 Idi gore (ukoliko je bio na koordinatama \\((x, y)\\) pomeri\u0107e se na \\((x,  y+1)\\));</li> <li><code>D</code> \u2013 Idi dole (ukoliko je bio na koordinatama \\((x, y)\\) pomeri\u0107e se na \\((x,  y-1)\\));</li> <li><code>L</code> \u2013 Idi levo (ukoliko je bio na koordinatama \\((x, y)\\) pomeri\u0107e se na \\((x-1,  y)\\));</li> <li><code>R</code> \u2013 Idi desno (ukoliko je bio na koordinatama \\((x, y)\\) pomeri\u0107e se na \\((x+1,  y)\\)).</li> </ul> <p>Student Srba je robotu ve\u0107 zadao \\(N\\) komandi. Me\u0111utim, po\u0161to on odavno nije i\u0161ao na fakultet, zaboravio je ta\u010dan put do njega, a robot je zavr\u0161io u pivnici. Sada robotu treba promeniti komande, i Srba vas moli da mu pomognete. Po\u0161to se ve\u0107 dovoljno namu\u010dio prave\u0107i robota i pi\u0161u\u0107i ove komande, on \u017eeli samo da obri\u0161e neki uzastopni niz komandi, i to po mogu\u0107stvu najkra\u0107i. Na\u0111ite najkra\u0107i takav niz ukoliko on postoji, ili ispi\u0161ite \\(-1\\) ukoliko ne postoji.</p> <p>Obratite pa\u017enju da robot ni u jednom trenutku ne sme pre\u0107i granice sela (ne sme iza\u0107i iz kvadrata koji ga predstavlja), jer \u0107e se izgubiti. Preciznije, dok se izvr\u0161ava kona\u010dan skup komandi nakon brisanja, robot uvek mora ostati u kvadratu (iako je mo\u017eda tokom izvr\u0161avanja po\u010detnog niza komandi, pre brisanja, mogao odlutati van kvadrata).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 - Boris Grubi\u0107 06_komande2d.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAX_N = 1000005;\nconst int MAX_K = 1005;\n\nint n, k, x, y;\nchar s[MAX_N];\nint pos[2 * MAX_K][2 * MAX_K];\nvector&lt;int&gt; List[2 * MAX_K][2 * MAX_K];\n\nint dx[] = {0,  -1, 1,  0};\nint dy[] = {1,   0, 0, -1};\n\nint decode(char ch) {\n    if (ch == 'U') return 0;\n    if (ch == 'L') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &amp;n, &amp;k, &amp;x, &amp;y);\n    scanf(\"%s\", s);\n    int sx = 0;\n    int sy = 0;\n    for (int i = 0; i &lt; n; ++i) {\n        sx += dx[decode(s[i])];\n        sy += dy[decode(s[i])];\n        if (sx &lt; -k || sx &gt; k) break;\n        if (sy &lt; -k || sy &gt; k) break;\n        List[sx + k][sy + k].push_back(i);\n    }\n\n    for (int i = 0; i &lt; 2 * MAX_K; ++i)\n        for (int j = 0; j &lt; 2 * MAX_K; ++j)\n            pos[i][j] = List[i][j].size() - 1;\n\n    sx = x;\n    sy = y;\n    int res = 987654321;\n    int sta, end;\n    for (int i = n - 1; i &gt;= 0; --i) {\n        sx += dx[3 - decode(s[i])];\n        sy += dy[3 - decode(s[i])];\n        if (sx &lt; -k || sx &gt; k) break;\n        if (sy &lt; -k || sy &gt; k) break;\n        while (pos[sx + k][sy + k] &gt;= 0 &amp;&amp; \n               List[sx + k][sy + k][pos[sx + k][sy + k]] &gt;= i)\n            --pos[sx + k][sy + k];\n\n        if (pos[sx + k][sy + k] &gt;= 0) {\n            int tmp = i - List[sx + k][sy + k][pos[sx + k][sy + k]];\n            if (res &gt; tmp) {\n                res = tmp;\n                sta = i - tmp + 1;\n                end = i - 1;\n            }\n        }\n    }\n\n    if (res != 987654321) printf(\"%d %d\\n\", sta + 1, end + 1);\n    else printf(\"-1\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalaze \\(4\\) broja \u2013 \\(N\\), \\(K\\), \\(X_f\\), \\(Y_f\\) koji redom predstavljaju broj komandi koje je Srba zadao robotu, granice sela i koordinate fakulteta. U drugom redu se nalazi \\(N\\) karaktera koji predstavljaju komande koje je Srba zadao robotu.</p>"},{"location":"takprog/2013_2014/okr/06_komande2d/#izlaz","title":"Izlaz","text":"<p>U prvi i jedini red standardnog izlaza ispisati \\(2\\) broja koji, redom, predstavljaju indeks po\u010detne i krajnje komande najkra\u0107eg niza komandi koji se mo\u017ee izbrisati (komande su indeksirane od \\(1\\)). Ukoliko ne postoji takav niz, ispisati \\(-1\\). Ukoliko postoji vi\u0161e najkra\u0107ih nizova, ispisati bilo koji.</p>"},{"location":"takprog/2013_2014/okr/06_komande2d/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2013_2014/okr/06_komande2d/#ulaz_1","title":"Ulaz","text":"<pre><code>11 100 2 3\nUUURRDRDRUU\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/#izlaz_1","title":"Izlaz","text":"<pre><code>7 10\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2013_2014/okr/06_komande2d/#ulaz_2","title":"Ulaz","text":"<pre><code>8 2 1 2\nRRRUULLL\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/#izlaz_2","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2013_2014/okr/06_komande2d/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru treba obrisati niz <code>RDRU</code> koji se nalazi od \\(7\\). do \\(10\\). komande. Primetimo da se i brisanjem niza <code>DRDRUU</code> od \\(6\\). do \\(11\\). pozicije, na kraju sti\u017ee u tra\u017eene koordinate \\((2, 3)\\), ali je prethodni niz kra\u0107i.</p> <p>U drugom primeru nije mogu\u0107e do\u0107i u koordinate \\((1,2)\\) bez izlaska iz sela.</p>"},{"location":"takprog/2013_2014/okr/06_komande2d/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 10^6\\).</li> <li>\\(1\\leq K\\leq 1000\\).</li> <li>\\(-K\\leq X_f,  Y_f \\leq K\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(40\\) poena va\u017ei \\(N\\leq 1000\\).</li> <li>U test primerima vrednim \\(60\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/01_restorani/","title":"1 - Restorani","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Kako svi dobro znamo, ove godine \u0107e se IOI odr\u017eati na Tajvanu. Jedan od najpoznatijih restorana na Tajvanu \u201cDin Tai Fung\u201d, koji je izabran kao restoran u kojem \u0107e takmi\u010dari jesti, je ve\u0107 polako krenuo da sprema meni za takmi\u010dare i nabavlja sastojke.</p> <p>S vremena na vreme, \u0161ef kuhinje se seti novog jela i naru\u010di odre\u0111ene koli\u010dine sastojaka za to jelo. Dobro je poznato da nikada ne naru\u010duje jedan te isti sastojak vi\u0161e od jednom, i da su naru\u010dene koli\u010dine uvek razli\u010dite. Po\u0161to dobije sastojke, on ih spremi u ostavu.</p> <p>Me\u0111utim, najve\u0107i konkurent ovom restoranu je restoran \u201cFuda Shangong Zhengijao Dawang\u201d, i njihova \u017eelja je da oni budu glavni restoran na IOI-u. Kako bi u toj nameri uspeli oni su saznali gde \u201cDin Tai Fung\u201d dr\u017ei svu naru\u010denu hranu, pa s vremena na vreme odu i uzmu dobar deo nje. Ali, kako \u201cDin Tai Fung\u201d ne bi primetio odmah \u0161ta se de\u0161ava, oni svaki put uzmu \\(\\lfloor \\frac{n}{2}\\rfloor\\) sastojaka (gde \\(n\\) predstavlja broj sastojaka u ostavi u tom trenutku) kojih ima najmanje.</p> <p>Preciznije, ukoliko sa \\(A[i]\\) predstavimo koli\u010dine sastojaka koji su trenutno u ostavi,  i sortiramo u rastu\u0107em redosledu (ne postoje dva sastojka sa istim koli\u010dinama), prvih \\(\\lfloor \\frac{n}{2}\\rfloor\\) sastojaka \u0107e biti ukradeno.</p> <p>Njima bi bilo veoma lagano ovo da urade, me\u0111utim izgubili su informacije o koli\u010dinama sastojaka, jedino \u0161to imaju je poredak koli\u010dine sastojaka. Ta\u010dnije, za bilo koja dva naru\u010dena sastojka, oni znaju da li je prvog sastojka naru\u010deno manje ili vi\u0161e od drugog.</p> <p>Va\u0161 zadatak je da pomognete restoranu \u201cFuda Shangong Zhengijao Dawang\u201d u nameri da budu glavni restoran na IOI-u (po\u0161to je u ovom restoranu bolja hrana), tako \u0161to \u0107ete im govoriti koje sastojke treba da uzmu, tako da ih konkurent ne bi primetio.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Boris Grubi\u0107 - Du\u0161an Zdravkovi\u0107 01_restorani.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdlib&gt;\n\n#include \"restorani.h\"\n\nusing namespace std;\n\nstatic int m;\nstatic int n;\nstatic int cur;\nstatic int *a;\n\nvoid Init(int M) {\n    n = 0;\n    m = M;\n    cur = 0;\n    a = (int*) malloc(M * sizeof(int));\n}\n\nvoid NoviSastojak() {\n    a[n++] = ++cur;\n    int p = n - 1;\n    while (p &gt; 0 &amp;&amp; Uporedi(a[p], a[p - 1]) == -1) {\n        swap(a[p], a[p - 1]);\n        --p;\n    }\n}\n\nvoid Nadji() {\n    int t = n / 2;\n    for (int i = 0; i &lt; t; ++i) Izbaci(a[i]);\n    for (int i = t; i &lt; n; ++i)\n        a[i - t] = a[i];\n    n = n - t;\n}\n</code></pre>"},{"location":"takprog/2013_2014/sio/01_restorani/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate slede\u0107e tri funkcije:</p> <ol> <li><code>Init(int M)</code> - ova funkcija se poziva samo jednom na po\u010detku i broj \\(M\\) predstavlja ukupan broj poziva funkcija <code>NoviSastojak()</code> i <code>Nadji()</code>;</li> <li><code>NoviSastojak()</code> \u2013 ova funkcija \u0107e biti pozvana svaki put kada \u0161ef naru\u010di novi sastojak;</li> <li><code>Nadji()</code> \u2013 ova funkcija \u0107e biti pozvana svaki put kada se od vas tra\u017ei da na\u0111ete \\(\\lfloor \\frac{n}{2}\\rfloor\\) (\\(n\\) predstavlja broj sastojaka trenutno u ostavi) najmanjih sastojaka. Po\u0161to na\u0111ete sastojke koje treba, potrebno je ta\u010dno \\(\\lfloor \\frac{n}{2}\\rfloor\\) puta pozvati funkciju <code>Izbaci(i)</code> koja \u0107e izbaciti \\(i\\)-ti naru\u010deni sastojak.</li> </ol> <p>Na raspolaganju vam je funkcija <code>Uporedi(i, j)</code> koja vra\u0107a:</p> <ul> <li>\\(1\\) ukoliko je \\(i\\)-toj naru\u010denog sastojka vi\u0161e naru\u010deno od \\(j\\)-tog;</li> <li>\\(-1\\) ukoliko je \\(i\\)-tog sastojka naru\u010deno manje od \\(j\\)-tog.</li> </ul> <p>Primetimo da su naru\u010divanja numerisana od \\(1\\).</p>"},{"location":"takprog/2013_2014/sio/01_restorani/#primer-1","title":"Primer 1","text":"<p>Neka je \\(M=8\\) i neka su operacije date u slede\u0107em redosledu:</p> <ol> <li><code>NoviSastojak()</code> \u2013 ubaci sastojak koli\u010dine \\(5\\) - trenutni sastojci \\([5]\\);</li> <li><code>NoviSastojak()</code> - ubaci sastojak koli\u010dine \\(4\\) - trenutni sastojci \\([5,4]\\);</li> <li><code>Nadji()</code> \u2013 izbaci manji sastojak (\\(2\\). naru\u010deni sastojak) - trenutni sastojci \\([5]\\);</li> <li><code>NoviSastojak()</code> \u2013 ubaci sastojak koli\u010dine \\(7\\) - trenutni sastojci \\([5,7]\\);</li> <li><code>NoviSastojak()</code> - ubaci sastojak koli\u010dine \\(9\\) - trenutni sastojci \\([5,7,8]\\);</li> <li><code>NoviSastojak()</code> - ubaci sastojak koli\u010dine \\(8\\) - trenutni sastojci \\([5,7,9,8]\\);</li> <li><code>NoviSastojak()</code> \u2013 ubaci sastojak koli\u010dine \\(1\\) - trenutni sastojci \\([5,7,9,8,1]\\);</li> <li><code>Nadji()</code> \u2013 izbaci \\(2\\) najmanja sastojka (\\(1\\). i \\(7\\). naru\u010deni) trenutni sastojci \\([7,8,9]\\).</li> </ol> <p>Na prvi poziv va\u0161e funkcije <code>Nadji()</code> u ovom slu\u010daju treba da pozove funkciju <code>Izbaci(2)</code>, dok drugi poziv funkcije <code>Nadji()</code> treba da pozove <code>Izbaci(1)</code> i <code>Izbaci(7)</code>.</p>"},{"location":"takprog/2013_2014/sio/01_restorani/#ogranicenja","title":"Ograni\u010denja","text":"<p>Ozna\u010dimo sa \\(M\\) ukupan broj poziva funkcija <code>NoviSastojak()</code> i <code>Nadji()</code> zajedno, a sa \\(P\\) ozna\u010dimo broj poziva funkcije <code>Uporedi(i, j)</code> koje va\u0161 program uradi.</p> <ul> <li>\\(1\\leq M\\leq 100.000\\).</li> <li>\\(1\\leq P\\leq 1.000.000\\).</li> </ul> <p>Drugo ograni\u010denje zna\u010di da \u0107e se va\u0161 program dobiti \\(0\\) poena na test primeru ukoliko pozove funkciju <code>Uporedi(i,j)</code> vi\u0161e od \\(1.000.000\\) puta.</p> <ul> <li>PODZADATAK \\(1\\) [\\(20\\) POENA]:\\(1\\leq M\\leq 1000\\).</li> <li>PODZADATAK \\(2\\) [\\(35\\) POENA]: \\(1\\leq M\\leq 20.000\\).</li> <li>PODZADATAK \\(3\\) [\\(45\\) POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/01_restorani/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom <code>restorani.c</code>, <code>restorani.cpp</code> ili <code>restorani.pas</code>, koji implementira gore pomenute funkcije. Osim tra\u017eenih funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161e funkcije/procedure moraju biti slede\u0107eg oblika: <pre><code>C/C++:\nvoid Init(int M);\nvoid NoviSastojak();\nvoid Nadji();\nPascal:\nProcedure Init(M : LongInt);\nProcedure NoviSastojak();\nProcedure Nadji();\n</code></pre></p> <p>Na raspolaganju su vam slede\u0107e funkcije: <pre><code>C/C++:\nint Uporedi(int i, int j);\nvoid Izbaci(int i);\nPascal:\nFunction Uporedi(i,j : LongInt) : Integer;\nFunction Izbaci(i : LongInt);\n</code></pre></p> <p>C/C++: Implementacije ovih funkcija su date u fajlu <code>grader.cpp</code>, a njihovi potpisi u fajlu <code>restorani.h</code>. Zbog toga je obavezno u va\u0161em fajlu <code>restorani.cpp</code> staviti <code>#include \u201crestorani.h\u201d</code>.</p> <p>Pascal: Implementacije ovih funkcija su date u fajlu <code>graderhelplib.pas</code> \u2013 da biste ih mogli koristiti potreno je u va\u0161em fajlu <code>restorani.pas</code> dodati <code>Uses graderhelplib;</code>.</p> <p>Va\u0161i template fajlovi ve\u0107 sadr\u017ee sve potrebne stvari \u2013 dovoljno je samo implementirati va\u0161e funkcije. Implementacije funkcija <code>Uporedi</code> i <code>Izbaci</code> nisu nu\u017eno iste kao na zvani\u010dnom grejderu.</p>"},{"location":"takprog/2013_2014/sio/01_restorani/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (<code>restorani.c</code>, <code>restorani.cpp</code>, <code>restorani.pas</code>) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (<code>grader.c</code>, <code>grader.cpp</code>, <code>grader.pas</code>, <code>restorani.h</code>, <code>graderhelplib.pas</code>) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj M</li> <li>U narednih M redova nalaze se upiti slede\u0107eg tipa:</li> <li><code>1 x</code> \u2013 ubaci novi sastojak koli\u010dine \\(x\\);</li> <li><code>2</code> - izvaci najmanjih \\(\\lfloor \\frac{n}{2} \\rfloor\\) sastojaka.</li> </ul> <p>zatim pozivaju va\u0161u funkciju <code>Init(int M)</code> iz odgovaraju\u0107eg fajla (<code>restorani.c</code>, <code>restorani.cpp</code>, <code>restorani.pas</code>) i potom se pozivaju va\u0161e funkcije <code>Ubaci()</code> i <code>Nadji()</code>. Na kraju \u0107e vam se ispisati korisne informacije (npr. broj poziva funkcije <code>Uporedi(int I, int j)</code> koje je va\u0161 program izvr\u0161io). Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2013_2014/sio/02_hoteli/","title":"2 - Hoteli","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 32MB <p>Tajvan, drevna ostrvska zemlja, nadaleko je poznata po nind\u017eama, Acer-u i duga\u010dkim i lepim pla\u017eama. Du\u017e jedne od takvih pla\u017ea nalazi se \\(N\\) odmarali\u0161ta, numerisanih brojevima od \\(1\\) do \\(N\\), redom, s leva na desno. Rastojanje izme\u0111u dva uzastopna odmarali\u0161ta je ta\u010dno \\(1\\) km; specijalno, rastojanje izme\u0111u odmarali\u0161ta broj \\(i\\) i odmarali\u0161ta broj \\(j\\) je \\(|i-j|\\) kilometara za svako \\(1\\leq i,j\\leq N\\).</p> <p>Ovih dana, aktuelna je vest da sumnjivi ruski biznismeni iz Crne Gore planiraju da u nekim odmarali\u0161tima sagrade luksuzne hotele. Za svako odmarali\u0161te je poznato da li je u njemu mogu\u0107e sagraditi hotel ili ne (ukoliko je mogu\u0107e, nije nu\u017eno sagraditi hotel u njemu). Kada se hoteli budu sagradili, odredi\u0107e se poredak odmarali\u0161ta po popularnosti na slede\u0107i na\u010din: odmarali\u0161te \\(i\\) \u0107e biti popularnije od odmarali\u0161ta \\(j\\) ako i samo ako je:</p> <ul> <li>Rastojanje od odmarali\u0161ta \\(i\\) do njemu najbli\u017eeg hotela manje od rastojanja odmarali\u0161ta \\(j\\) do njemu najbli\u017eeg hotela; ili</li> <li>prethodno pomenuta rastojanja su ista i va\u017ei \\(i&lt;j\\).</li> </ul> <p>Na primer, ukoliko imamo \\(8\\) odmarali\u0161ta i hoteli su sagra\u0111eni u odmarali\u0161tima broj \\(2\\), \\(6\\) i \\(7\\) tada je poredak odmarali\u0161ta po popularnosti (po\u010dev\u0161i od najpopularnijeg): \\(2\\), \\(6\\), \\(7\\), \\(1\\), \\(3\\), \\(5\\), \\(8\\), \\(4\\). Na primer, odmarali\u0161te \\(6\\) je popularnije od odmarali\u0161ta \\(5\\) jer je odmarali\u0161tu \\(6\\) najbli\u017ei hotel na rastojanju \\(0\\), dok je odmarali\u0161tu \\(5\\) najbli\u017ei hotel na rastojanju \\(1\\). Sli\u010dno, odmarali\u0161te \\(3\\) je popularnije od odmarali\u0161ta \\(5\\) jer su im najbli\u017ei hoteli podjednako udaljeni i va\u017ei \\(3&lt;5\\), itd.</p> <p></p> <p>Me\u0111utim, stari naturalizovani tajvanac Stanoje Hvang poseduje odmarali\u0161te broj \\(X\\), sre\u0107ni broj \\(P\\) i ve\u0107inu ruskih biznismena pa, sasvim prirodno, \u017eeli da se hoteli sagrade tako da odmarali\u0161te broj \\(X\\) bude \\(P\\)-to po popularnosti. Na koliko na\u010dina se to mo\u017ee uraditi?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Uglje\u0161a Stojanovi\u0107 - Nikola Milosavljevi\u0107 02_hoteli.cpp<pre><code>#include \"hoteli.h\"\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n#define MOD 1000000007L\nusing namespace std;\n\nint leftdp[310][310];\nint rightdp[310][310];\n\nint diagonalSum[310][310];\nint columnSum[310][310];\n\nint getDiagonalSum (int i, int j)\n{\n    if (i&lt;0 || j&lt;0) return 0;\n    return diagonalSum[i][j];\n}\nint getColumnSum(int i, int j)\n{\n     if (i&lt;0 || j&lt;0) return 0;\n    return columnSum[i][j];\n}\nint BrojIzgradnji(int n,int x, int p, int* H)\n{\n    int sol=0;\n    p--;\n    for (int k=0;x+k&lt;n || x-k&gt;0;k++)\n    {\n        int r = 2*k+1;\n\n        if (x-k+1&gt;0 &amp;&amp; k!=0) H[x-k]=0;\n        if (x+k-1&lt;=n &amp;&amp; k!=0)H[x+k-2]=0;\n\n        //solve left side\n        leftdp[0][0]=diagonalSum[0][0]=columnSum[0][0]=1;\n        for (int i=1;i&lt;=x;i++)\n        {\n            for (int j=0;j&lt;=i;j++)\n            {\n                if ( i-1-k &lt; 0 || H[i-1-k]==0)leftdp[i][j]=0;\n                else\n                {\n                    leftdp[i][j] = getDiagonalSum(i-1,j-1)-getDiagonalSum(i-r,j-r);\n                    leftdp[i][j]=(leftdp[i][j]+MOD)%MOD;\n                    leftdp[i][j]+=getColumnSum(i-r,j-r);\n                    leftdp[i][j]%=MOD;\n                }\n                diagonalSum[i][j] = ((i&gt;0 &amp;&amp; j&gt;0)?diagonalSum[i-1][j-1]:0) + leftdp[i][j];\n                diagonalSum[i][j]%=MOD;\n                columnSum[i][j] = columnSum[i-1][j] + leftdp[i][j];\n                columnSum[i][j]%=MOD;\n            }\n        }\n        //solve right side\n       r-=2;\n       rightdp[0][0]=diagonalSum[0][0]=columnSum[0][0]=1;\n       if (k!=0)\n       for (int i=1;n-i&gt;=x;i++)\n       {\n            for (int j=0;j&lt;=i;j++)\n            {\n                if (n-i+k-1&gt;=n || H[n-i+k-1]==0)rightdp[i][j]=0;\n                else\n                {\n                    rightdp[i][j] = getDiagonalSum(i-1,j-1)-getDiagonalSum(i-r,j-r);\n                    rightdp[i][j]=(rightdp[i][j]+MOD)%MOD;\n                    rightdp[i][j]+=getColumnSum(i-r,j-r);\n                    rightdp[i][j]%=MOD;\n                }\n                diagonalSum[i][j] = ((i&gt;0 &amp;&amp; j&gt;0)?diagonalSum[i-1][j-1]:0) + rightdp[i][j];\n                diagonalSum[i][j]%=MOD;\n                columnSum[i][j] = columnSum[i-1][j] + rightdp[i][j];\n                columnSum[i][j]%=MOD;\n            }\n        }\n        //sum the solution\n        if (k==0)\n        {\n            long long solI = leftdp[x][p+1];\n            solI%=MOD;\n            for (int i=x;i&lt;n;i++)\n            {\n                if (H[i]==1)\n                {\n                    solI*=2;\n                    solI%=MOD;\n                }\n            }\n            sol+=solI;\n            sol%=MOD;\n        }\n        else\n        {\n            for (int i=0;i&lt;=p;i++)\n            {\n                long long leftLastTaken = 0;\n                long long leftLastNotTaken = 1;\n                if (i!=0)\n                {\n                    leftLastTaken =i+1&lt;=x?leftdp[x][i+1]:0;\n                    leftLastNotTaken = 0;\n                    for (int j=1;j&lt;x;j++)\n                    {\n                        leftLastNotTaken += leftdp[j][i];\n                        leftLastNotTaken%=MOD;\n                    }\n                }\n                long long rightLastTaken = 0;\n                long long rightLastNotTaken = 1;\n                if (i!=p)\n                {\n                    rightLastTaken = rightdp[n-x][p-i];\n                    rightLastNotTaken = 0;\n                    for (int j=1;j&lt;n-x;j++)\n                    {\n                        rightLastNotTaken+=rightdp[j][p-i];\n                        rightLastNotTaken%=MOD;\n                    }\n                }\n                long long solForI = (leftLastTaken * rightLastNotTaken )%MOD;\n                solForI+=(leftLastTaken*rightLastTaken)%MOD;\n                solForI%=MOD;\n                solForI+=(leftLastNotTaken*rightLastTaken)%MOD;\n                solForI%=MOD;\n                sol+=solForI;\n                sol%=MOD;\n            }\n        }\n    }\n    return sol;\n}\n</code></pre>"},{"location":"takprog/2013_2014/sio/02_hoteli/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju:</p> <ul> <li><code>BrojIzgradnji(N, X, P, H[])</code>;</li> </ul> <p>gde je \\(N\\) \u2013 broj odmarali\u0161ta, \\(X\\) \u2013 redni broj odmarali\u0161ta koje poseduje Stanoje, \\(P\\) \u2013 Stanojev sre\u0107ni broj i \\(H\\) \u2013 niz du\u017eine \\(N\\) (indeksiran od \\(1\\)) koji ozna\u010dava u kojim odmarali\u0161tima se mogu sagraditi hoteli: ukoliko je \\(H_i=1\\), u i-tom odmarali\u0161tu se mo\u017ee sagradati hotel; u suprotnom je \\(H_i=0\\). Ova funkcija mora da vrati jedan ceo broj \u2013 broj na\u010dina na koji se mogu izgraditi hoteli tako da svi pomenuti uslovi budu zadovoljeni po modulu \\(1.000.000.007\\) \\((10^9+7)\\).</p>"},{"location":"takprog/2013_2014/sio/02_hoteli/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N=10\\), \\(X=5\\), \\(P=4\\) i \\(H=[0, 0, 0, 1, 0, 1, 0, 0, 1, 1]\\). Tada postoji ta\u010dno \\(4\\) na\u010dina da se izgrade hoteli tako da odmarali\u0161te broj \\(5\\) bude \\(4\\). po popularnosti i ti na\u010dini su:</p> <p></p> <p>Prema tome, u ovom slu\u010daju va\u0161a funkcija mora da vrati \\(4 \\text{ MOD } 1.000.000.007=4\\).</p>"},{"location":"takprog/2013_2014/sio/02_hoteli/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 300\\).</li> <li>\\(1 \\leq X \\leq N\\).</li> <li>\\(1 \\leq P \\leq N\\).</li> <li>Za svako \\(1 \\leq i \\leq N\\) va\u017ei \\(H[i] \\in \\{0, 1\\}\\).</li> </ul> <p>Podzadaci:</p> <ul> <li>PODZADATAK \\(1\\) [\\(12\\) POENA]: \\(N\\leq 20\\).</li> <li>PODZADATAK \\(2\\) [\\(13\\) POENA]: \\(N\\leq 25\\), \\(X=1\\) i \\(H[i]=1\\) za svako \\(1\\leq i \\leq N\\).</li> <li>PODZADATAK \\(3\\) [\\(18\\) POENA]: \\(P=N\\).</li> <li>PODZADATAK \\(4\\) [\\(21\\) POENA]: \\(N\\leq 100\\).</li> <li>PODZADATAK \\(5\\) [\\(36\\) POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/02_hoteli/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom <code>hoteli.c</code>, <code>hoteli.cpp</code> ili <code>hoteli.pas</code>, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika: <pre><code>C/C++:\nint BrojIzgradnji(int N, int X, int P, int* H);\nPascal:\nfunction BrojIzgradnji(N, X, P : longint; H : array of longint) : longint;\n</code></pre></p>"},{"location":"takprog/2013_2014/sio/02_hoteli/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (<code>hoteli.c</code>, <code>hoteli.cpp</code>, <code>hoteli.pas</code>) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (<code>grader.c</code>, <code>grader.cpp</code>, <code>grader.pas</code>) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\), \\(X\\) i \\(P\\), redom, razdvojene razmakom;</li> <li>U drugom redu niz \\(H \u2013 N\\) brojeva \\(H[i]\\) razdvojenih razmakom;</li> </ul> <p>zatim pozivaju va\u0161u funkciju <code>BrojIzgradnji</code> iz odgovaraju\u0107eg fajla (<code>hoteli.c</code>, <code>hoteli.cpp</code>, <code>hoteli.pas</code>) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2013_2014/sio/03_caj/","title":"3 - \u010caj","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>U tajvanskom urbanom gradu Tajpeiju, nalazi se \\(N\\) drevnih \u010dajd\u017einica numerisanih brojevima od \\(1\\) do \\(N\\). Vlasnici ovih \u010dajd\u017einica su sagradili i \\(M\\) jednosmernih tajnih prolaza \u2013 svaki tajni prolaz spaja neke dve \u010dajd\u017einice a u njemu su stra\u017eari koji propu\u0161taju posetioce (sumnjive tajvanske tajkune) samo u odgovaraju\u0107em smeru.</p> <p>Jedan od najsumnjivijih tajvanskih tajkuna je naturalizovani tajvanac Zvonko Lim koji osobito voli da se napije pirin\u010danog vina a zatim da pose\u0107uje pomenute tajvanske \u010dajd\u017einice. On ima listu tih \\(N\\) \u010dajd\u017einica u redosledu  od najomiljenije do najmanje omiljene (na prvoj poziciji je najomiljenija). Vlasnici \u010dajd\u017einica ne znaju njegovu listu ali \u0107e poku\u0161ati da je rekonstrui\u0161u na osnovu poznavanja Zvonkovih navika prilikom obilaska \u010dajd\u017einica. Naime, kada se Zvonko napije pirin\u010danog vina, on umisli da je DFS i pose\u0107uje \u010dajd\u017einice na slede\u0107i na\u010din:</p> <ol> <li>Na po\u010detku se spusti helikopterom u prvu \u010dajd\u017einicu sa svoje liste.</li> <li>Ako se trenutno nalazi u \u010dajd\u017einici broj \\(X\\), tada posmatra skup svih \u010dajd\u017einica do kojih mo\u017ee do\u0107i nekim tajnim prolazom iz \u010dajd\u017einice \\(X\\) a koje ve\u0107 nije obi\u0161ao:</li> <li>Ukoliko je taj skup neprazan, on od svih \u010dajd\u017einica iz tog skupa bira najomiljeniju (na osnovu liste), ide tajnim prolazom do nje usput podmi\u0107uju\u0107i stra\u017eare i, kada stigne, ponavlja korak \\(2\\).</li> <li>Ukoliko je taj skup prazan, on se vra\u0107a iz \u010dajd\u017einice \\(X\\) onim tajnim prolazom kojim je do\u0161ao do \\(X\\) (iako je taj prolaz u suprotnom smeru on je ve\u0107 podmitio stra\u017eare dolaze\u0107i u \\(X\\) pa mu oni dozvoljavaju da pro\u0111e) i ponavlja korak \\(2\\). Me\u0111utim, ukoliko je u \\(X\\) do\u0161ao helikopterom a ne tajnim prolazom, on odlazi helikopterom u najomiljeniju \u010dajd\u017einicu koju do tada nije posetio i ponavlja korak \\(2\\).</li> </ol> <p>Kada obi\u0111e sve \u010dajd\u017einice na ovaj na\u010din, Zvonko Lim odlazi ku\u0107i da spava</p> <p>Vlasnici \u010dajd\u017einica ne znaju u kom redosledu je Zvonko obilazio \u010dajd\u017einice ali poznaju strukturu tajnih prolaza i otkrili su sve podmi\u0107ene stra\u017eare. Pomozite im da otkriju kako izgleda Zvonkova lista! Uz to, ako postoji vi\u0161e re\u0161enja, \u010dajd\u017einica broj \\(1\\) \u0107e vas \u010dastiti dodatnim poenima ako je stavite \u0161to bli\u017ee po\u010detku liste.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 - Demjan Grubi\u0107 03_caj.cpp<pre><code>#include \"caj.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;memory.h&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MaxN = 100100;\nconst int LogMaxN = 18;\nconst int MaxM = 200200;\n\nvector&lt;int&gt; adjT[MaxN];  // lista suseda racunajuci samo tree-edges\nvector&lt;int&gt; ADJ[MaxN];   // lista suseda u grafu koji pravimo od datog: u-&gt;v ako u mora pre v\nvector&lt;int&gt; ADJ_REV[MaxN];\nint inDeg[MaxN];\nint currRoot;\nint time;\nint dfsIn[MaxN], dfsOut[MaxN];\nint level[MaxN], parent[MaxN];\nint P[MaxN][LogMaxN];\n\nvoid DFS(int u)\n{\n    dfsIn[u] = ++time;\n\n    if (u != 0)\n    {\n        if (inDeg[u] == 0)\n            currRoot = u;\n        else\n            ADJ[currRoot].push_back(u); // Koren svakog DFS stabla mora biti pre sve svoje dece u listi\n    }\n\n    for (int i = 0; i &lt; (int)adjT[u].size(); i++)\n    {\n        int v = adjT[u][i];\n        parent[v] = u;\n        level[v] = level[u] + 1;\n        DFS(v);\n    }\n\n    dfsOut[u] = ++time;\n}\n\nint kthAnc(int u, int k)\n{\n    int i = 0;\n    while (k &gt; 0)\n    {\n        if ((k &amp; 1) != 0)\n            u = P[u][i];\n        i++;\n        k = k &gt;&gt; 1;\n    }\n\n    return u;\n}\n\nint lca(int u, int v)\n{\n    if (level[u] &lt; level[v])\n    {\n          int tmp = u; u = v; v = tmp;\n    }\n\n    int log = 1;\n    while ((1 &lt;&lt; log) &lt;= level[u]) \n        log++;\n    log--;\n\n    for (int i = log; i &gt;= 0; i--)\n    {\n        if ((1 &lt;&lt; i) &lt;= level[u] - level[v])\n              u = P[u][i];\n    }\n\n    if (u == v)\n        return u;\n\n    for (int i = log; i &gt;= 0; i--)\n          if (P[u][i] != -1 &amp;&amp; P[v][i] != -1 &amp;&amp; P[u][i] != P[v][i])\n          {\n              u = P[u][i];\n              v = P[v][i];\n          }\n\n    return parent[u];\n}\n\nvoid TopSort(int N, int* L)\n{\n    memset(inDeg, 0, sizeof(inDeg));\n    for (int u = 1; u &lt;= N; u++)\n    {\n        for (int i = 0; i &lt; (int)ADJ[u].size(); i++)\n        {\n            int v = ADJ[u][i];\n            ADJ_REV[v].push_back(u);\n            inDeg[u]++;\n        }\n    }\n\n    int first = 0, last = 0;\n\n    for (int u = 2; u &lt;= N; u++)  // od 2\n        if (inDeg[u] == 0)\n            L[++last] = u;\n\n    if (last == 0)\n    {\n        L[++last] = 1;\n        if (inDeg[1] != 0) { printf(\"FAIL\\n\"); return; }\n    }\n\n    while (first &lt; last)\n    {\n        first++;\n        int u = L[first];\n\n        for (int i = 0; i &lt; (int)ADJ_REV[u].size(); i++)\n        {\n            int v = ADJ_REV[u][i];\n            inDeg[v]--;\n            if (inDeg[v] == 0 &amp;&amp; v != 1)\n                L[++last] = v;\n        }\n\n        if (first == last &amp;&amp; last != N)\n        {\n            L[++last] = 1;\n            if (inDeg[1] != 0) { printf(\"FAIL\\n\"); return; }\n        }\n    }\n\n    if (last != N) { printf(\"FAIL\\n\"); return; }\n\n    for (int i = 1; i &lt;= N / 2; i++)\n    {\n        int tmp = L[i]; L[i] = L[N - i + 1]; L[N - i + 1] = tmp;\n    }\n}\n\nvoid OdrediListu(int N, int M, int* c1, int* c2, int* g, int* L)\n{\n    memset(inDeg, 0, sizeof(inDeg));\n    for (int i = 1; i &lt;= M; i++)\n    {\n        if (g[i] == 1)\n        {\n            adjT[ c1[i] ].push_back(c2[i]);\n            inDeg[ c2[i] ]++;\n        }\n    }\n\n    for (int i = 1; i &lt;= N; i++)\n    {\n        if (inDeg[i] == 0)\n            adjT[0].push_back(i);\n    }\n\n    level[0] = 0;\n    parent[0] = -1;\n    time = 0;\n    DFS(0);\n\n    // racunamo tablicu za LCA\n    for (int i = 0; i &lt;= N; i++)\n        P[i][0] = parent[i];\n\n    for (int j = 1; (1 &lt;&lt; j) &lt;= N; j++) \n        for (int i = 0; i &lt;= N; i++)\n            if (P[i][j - 1] != -1)\n                P[i][j] = P[ P[i][j - 1] ][j - 1];\n            else\n                P[i][j] = -1;\n\n    // na osnovu \"cross\" i \"forward\" edges dodajemo jos grana u novom grafu\n    for (int i = 1; i &lt;= M; i++)\n    {\n        if (g[i] == 0)\n        {\n            int u = c1[i], v = c2[i];\n\n            if (dfsIn[u] &lt; dfsIn[v] &amp;&amp; dfsOut[v] &lt; dfsOut[u]) // forward edge\n            {\n                int v1 = kthAnc(v, level[v] - level[u] - 1);\n                ADJ[v1].push_back(v);\n            }\n\n            if (dfsOut[u] &lt; dfsIn[v] || dfsOut[v] &lt; dfsIn[u]) // cross edge\n            {\n                int x = lca(u, v);\n                int u1 = kthAnc(u, level[u] - level[x] - 1);\n                int v1 = kthAnc(v, level[v] - level[x] - 1);\n                ADJ[v1].push_back(u1);\n            }\n        }\n    }\n\n    TopSort(N, L);\n}\n</code></pre>"},{"location":"takprog/2013_2014/sio/03_caj/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju:</p> <ul> <li><code>OdrediListu(N, M, c1[], c2[], g[], L[])</code></li> </ul> <p>gde je \\(N\\) \u2013 broj \u010dajd\u017einica, \\(M\\) broj tajnih prolaza a \\(c1\\), \\(c2\\) i \\(g\\) nizovi du\u017eine \\(M\\) koji opisuju tajne prolaze: za svako \\(1 \\leq i\\leq M\\), \\(i\\)-ti tajni prolaz vodi od \u010dajd\u017einice broj \\(c1[i]\\) do \u010dajd\u017einice broj \\(c2[i]\\) i, ukoliko je \\(g[i]=0\\), stra\u017eari u tom tajnom prolazu nisu bili podmi\u0107eni (tj. Zvonko se tuda nije kretao) a ukoliko je \\(g[i]=1\\), stra\u017eari u tom tajnom prolazu su bili podmi\u0107eni (tj. tuda se Zvonko kretao). Niz \\(L\\) du\u017eine \\(N\\) predstavlja Zvonkovu listu koju vi trebate da \u201cpopunite\u201d (na prvom mestu staviti indeks njegove najomiljenije \u010dajd\u017einice i tako redom do najmanje omiljene). Svi nizovi su indeksirani od \\(1\\).</p>"},{"location":"takprog/2013_2014/sio/03_caj/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N=8\\), \\(M=10\\), \\(c1=[4, 5, 1, 8, 8, 6, 7, 5, 3, 5]\\), \\(c2=[7, 7, 3, 6, 1, 8, 2, 3, 2, 2]\\) i \\(g=[0, 1, 0, 1, 1, 0, 1, 1, 0, 0]\\). Tada imamo \\(5\\) tajnih prolaza u kojima su podmi\u0107eni stra\u017eari (tj. kojim je Zvonko prolazio) \u2013 oni su ozna\u010deni zadebljanim strelicama na slici. U ovoj situaciji, jedna od mogu\u0107ih Zvonkovih listi omiljenih \u010dajd\u017einica je \\(L=[5, 8, 7, 6, 4, 1, 3, 2]\\). Zaista, tada bi Zvonkovo kretanje izgledalo ovako: Na po\u010detku se helikopterom spusti u njemu najomiljeniju \u010dajd\u017einicu \\((5)\\); Iz ove \u010dajd\u017einice on mo\u017ee do\u0107i do \u010dajd\u017einica \\(2\\), \\(3\\) ili \\(7\\).</p> <p>Kako mu je od njih \\(7\\) najomiljenija, od ide do nje i podmi\u0107uje stra\u017eare u prolazu \\(5\\rightarrow 7\\). Zatim iz \\(7\\) odlazi do \\(2\\) (nadalje se podmi\u0107ivanje podrazumeva). Sada nema gde, pa se vra\u0107a odakle je do\u0161ao (u \u010dajd\u017einicu \\(7\\), ovog puta u suprotnom smeru). Sada tako\u0111e nema gde iz \\(7\\) pa se vra\u0107a u \\(5\\). Iz \u010dajd\u017einice broj \\(5\\) ide u \\(3\\) jer je to njegova najomiljenija \u010dajd\u017einica do koje mo\u017ee do\u0107i iz \\(5\\) a da je ve\u0107 nije posetio. Sada iz \\(3\\) nema gde pa se vra\u0107a u \\(5\\). Sada iz \\(5\\) nema gde a kako je u \u010dajd\u017einicu broj \\(5\\) do\u0161ao helikopetrom a ne tajnim prolazom, onda uzima helikopter i sle\u0107e u slede\u0107u najominjeniju \u010dajd\u017einicu koju do sada nije posetio \u2013 broj \\(8\\). Zatim ide u \\(6\\) (omiljenija mu je od \\(1\\)), zatim se istim prolazom (a ne prolazom \\(6\\rightarrow 8\\)) vra\u0107a u \\(8\\), pa zatim ide u \\(1\\) pa ponovo nazad u \\(8\\) odakle helikopterom odlazi u \\(4\\). Iz \\(4\\) nema prolaza koji vode do neobi\u0111ene \u010dajd\u017einice a ovo je ujedno poslednja obi\u0111ena \u010dajd\u017einica pa Zvonko odlazi da spava.</p> <p>Pomenuta Zvonkova lista nije najoptimalnija \u2013 \u010dajd\u017einica \\(1\\) mo\u017ee biti bolje plasirana od \\(6\\) mesta na listi. Lista \\(L=[5, 8, 1, 7, 6, 4, 3, 2]\\) je jedna od najoptimalnijih \u2013 u njoj je \u010dajd\u017einica \\(1\\) na poziciji \\(3\\) (bolje od ovoga ne mo\u017ee). Tako\u0111e primetimo da npr. lista \\(L=[5, 8, 2, 7, 6, 4, 1, 3]\\) nije korektna: posle spu\u0161tanja helikopterom u \\(5\\), Zvonko bi oti\u0161ao u \u010dajd\u017einicu broj \\(2\\) prolazom \\(5\\rightarrow 2\\), a znamo da tu nije podmi\u0107ivao stra\u017eare, tj. da nije prolazio tuda.</p> <p></p>"},{"location":"takprog/2013_2014/sio/03_caj/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2\\leq N\\leq 100.000\\).</li> <li>\\(1\\leq M\\leq 300.000\\).</li> <li>Za svako \\(1\\leq i\\leq M\\) va\u017ei \\(1\\leq c1[i], c2[i]\\leq N\\), \\(c1[i]\\neq c2[i]\\) i \\(g[i]\\in\\{0,1\\}\\).</li> <li>Izme\u0111u svake dve \u010dajd\u017einice postoji najvi\u0161e jedan tajni prolaz u jednom smeru.</li> <li>Garantuje se da re\u0161enje, ne nu\u017eno jedinstveno, uvek postoji.</li> </ul> <p>U svakom podzadatku, ukoliko va\u0161 program vrati bilo koju korektnu Zvonkovu listu (u svim test primerima) dobijate \\(70\\%\\) poena od odgovaraju\u0107eg podzadatka. Ukoliko je u svakom test primeru podzadatka \u010dajd\u017einica \\(1\\) najbli\u017ee mogu\u0107e po\u010detku liste (a lista je i dalje korektna) dobijate svih \\(100\\%\\) poena tog podzadatka.</p> <ul> <li>PODZADATAK \\(1\\) [\\(11\\) POENA]: \\(N\\leq 8\\) i \\(M\\leq 20\\).</li> <li>PODZADATAK \\(2\\) [\\(9\\) POENA]: Ima ta\u010dno \\(N-1\\) tajnih prolaza u kojima su podmi\u0107eni stra\u017eari i oni obrazuju put du\u017eine \\(N-1\\).</li> <li>PODZADATAK \\(3\\) [\\(9\\) POENA]: Nema podmi\u0107enih stra\u017eara, tj. Zvonko Lim je uvek koristio helikopter.</li> <li>PODZADATAK \\(4\\) [\\(17\\) POENA]: \\(N\\leq 500\\) i \\(M\\leq 10.000\\).</li> <li>PODZADATAK \\(5\\) [\\(21\\) POENA]: \\(N\\leq 2.000\\).</li> <li>PODZADATAK \\(6\\) [\\(33\\) POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/03_caj/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom <code>caj.c</code>, <code>caj.cpp</code> ili <code>caj.pas</code>, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika: <pre><code>C/C++:\nvoid OdrediListu(int N, int M, int* c1, int* c2, int* g, int* L);\nPascal:\nprocedure OdrediListu(N, M : longint; var c1, c2, g, L : array of longint);\n</code></pre></p> <p>Parametri funkcije/procedure su ranije opisani; \\(N\\), \\(M\\) i nizovi \\(c1\\), \\(c2\\), \\(g\\) su ulazni parametri dok je niz \\(L\\) izlazni parametar.</p>"},{"location":"takprog/2013_2014/sio/03_caj/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (<code>caj.c</code>, <code>caj.cpp</code>, <code>caj.pas</code>) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (<code>grader.c</code>, <code>grader.cpp</code>, <code>grader.pas</code>) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(M\\), razdvojene razmakom;</li> <li>U slede\u0107ih \\(M\\) redova brojeve \\(c1[i]\\), \\(c2[i]\\), \\(g[i]\\) razdvojene razmakom;</li> </ul> <p>zatim pozivaju va\u0161u funkciju <code>OdrediListu</code> iz odgovaraju\u0107eg fajla (<code>caj.c</code>, <code>caj.cpp</code> ili <code>caj.pas</code>) sa u\u010ditanim parametrima i na kraju vrednosti niza <code>L</code> ispisuju na standardni izlaz \u2013 <code>N</code> brojeva razdvojenih razmakom u jednom redu. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/","title":"4 - Antimaterijski top","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Profesor \u0110uri\u0107, sada ve\u0107 malo nagluv, je na Tavanu prona\u0161ao svoj antimaterijski top iz mladih dana. Oduvav\u0161i pra\u0161inu, prisetio se eksperimenta koji je nekada izvodio sa njim.</p> <p>U poljima matrice sa \\(N\\) redova i \\(M\\) kolona nalazili su se pozitroni, elektroni i gravitoni. Svako polje sadr\u017ealo je ta\u010dno jednu od \u010destica. Namena antimaterijskog topa bila je da promeni sve elemente u jednom redu njihovim odgovaraju\u0107im anti\u010desticama. Pozitron je anti\u010destica elektrona, i ubrnuto, dok je graviton anti\u010destica sam sebi. Cilj eksperimenta bio je da primenom antimaterijskog topa na neke vrste dobijemo unapred odre\u0111eni broj pozitrona u svakoj koloni. Sada se profesor \u0110iri\u0107 pita na koliko na\u010dina je to moglo da se uradi.</p> <p>Izra\u010dunajte tra\u017eeni broj umesto profesora i time mu pomozite da \u0161to pre si\u0111e sa Tavana.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Demjan Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Marko Savi\u0107"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju:</p> <ul> <li><code>BrojNacina(N, M, matrica, vektor)</code></li> </ul> <p>gde je \\(N\\) - broj redova u matrici, \\(M\\) - broj kolona u matrici, \\(matrica\\) \u2013 matrica karaktera dimenzija \\(N\\times M\\) gde se na polju \\((i,j)\\) matrice mo\u017ee nalaziti jedan od slede\u0107a tri karaktera <code>p</code>, <code>e</code>, <code>g</code> koji redom ozna\u010davaju da se na polju \\((i,j)\\) nalazi pozitron, elektron ili graviton, \\(vektor\\) \u2013 niz du\u017eine \\(M\\) gde \\(i\\)-ti broj ozna\u010dava da se nakon upotrebe antimaterijskog topa u koloni \\(i\\) treba nalaziti \\(vektor[i]\\) pozitrona.</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N = 5\\), \\(M = 3\\), a matrica neka je data slede\u0107om tabelom:</p> <pre><code>gee\nepg\nppg\ngpp\nege\n</code></pre> <p>\\(vector = \\{1, 2, 2\\}\\)</p> <p>Tra\u017eeni broj pozitrona po kolona se mo\u017ee dobiti na \\(3\\) na\u010dina:</p> <ol> <li>Ako primenimo antimaterijski top na vrste \\(3\\) i \\(5\\);</li> <li>Ako primenimo antimaterijski top na vrste \\(1\\), \\(2\\) i \\(3\\);</li> <li>Ako primenimo antimaterijski top na vrste \\(1\\), \\(3\\), \\(4\\) i \\(5\\).</li> </ol>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#primer-2","title":"Primer 2","text":"<p>Neka je \\(N = 2\\), \\(M = 2\\), a matrica data slede\u0107om tabelom: <pre><code>pe\npp\n</code></pre></p> <p>\\(vector = \\{1,1\\}\\)</p> <p>Tra\u017eeni broj pozitrona po kolona se ne mo\u017ee dobiti.</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 30\\).</li> <li>Svaki element matrice \u0107e biti iz skupa {<code>p</code>, <code>e</code>, <code>g</code>}.</li> </ul> <p>Podzadaci:</p> <ul> <li>PODZADATAK \\(1\\) [\\(11\\) POENA]: \\(1\\leq N, M\\leq 15\\).</li> <li>PODZADATAK \\(2\\) [\\(15\\) POENA]: \\(M = 1\\).</li> <li>PODZADATAK \\(3\\) [\\(19\\) POENA]: Dovoljno je odgovoriti da li postoji barem jedan na\u010din da se dobije zadati raspored pozitrona po kolonama. Poeni se dobijaju u slu\u010daju da je broj na\u010dina \\(0\\) i va\u0161 program je ispisao \\(0\\), ili ukoliko je broj na\u010dina ve\u0107i od \\(0\\), a va\u0161 program je ispisao prirodan broj manji od \\(10^18\\).</li> <li>PODZADATAK \\(4\\) [\\(55\\) POENA] : Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom <code>top.c</code>, <code>top.cpp</code> ili <code>top.pas</code>, koji implementira gore pomenuty funkcijy. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161e funkcije/procedure moraju biti slede\u0107eg oblika: <pre><code>C/C++:\nlong long BrojNacina(int N, int M, char **mapa, int *vektor);\nPascal:\nfunction BrojNacina(N: integer; M: integer; mapa: array of array of char; vector: array of integer)\n</code></pre></p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (<code>top.c</code>, <code>top.cpp</code>, <code>top.pas</code>) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (<code>grader.c</code>, <code>grader.cpp</code>, <code>grader.pas</code>) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\), \\(M\\) razdvojene razmakom;</li> <li>U narednih \\(N\\) redova po \\(M\\) odgovaraju\u0107ih karaktera;</li> <li>U poslednjoj liniji \\(M\\) celih brojeva koji predstavljaju promenljivu \\(vektor\\);</li> </ul> <p>zatim pozivaju va\u0161u funkciju <code>BrojNacina</code> iz odgovaraju\u0107eg fajla (<code>top.c</code>, <code>top.cpp</code>, <code>top.pas</code>) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Generi\u0161imo svih \\(2^N\\) vektora koji predstavljaju krajnje zbirove po kolonama nakon kori\u0161\u0107enja antimaterijskog topa. Potrebno je za svaki proveriti da li se podudara sa tra\u017eenim vektorom. Slo\u017eenost je \\(O(2^N \\cdot M)\\).</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Potrebno je proveriti na koliko na\u010dina mo\u017eemo izabrati podskup na\u0161eg skupa tako da je njegov zbir jednak tra\u017eenom broju. Po\u0161to je \\(n\\leq 30\\), to radimo tehnikom meet in the middle: Podelimo na\u0161 skup na dve jednake polovine, generi\u017eemo svih \\(2^{\\frac{N}{2}}\\) mogu\u0107nosti za oba skupa, i preko sortiranja i dva pokaziva\u010da odredimo koliko ima zbirova dva broja iz oba skupa koji su jednaki datom broju. Slo\u017eenost je \\(O(2^{\\frac{N}{2}} \\cdot N)\\).</p>"},{"location":"takprog/2013_2014/sio/04_antimaterijski_top/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Opet koristimo meet in the middle, ali ovaj put mapiramo vektore. Deljenjem matrice na gornji i donji deo koji su pribli\u017eno jednaki mo\u017eemo generisati sve mogu\u0107e vektore. Zatim je potrebno proveriti za dva skupa na koliko na\u010dina mo\u017eemo izabrati po jedan vektor iz svakog tako da njihov zbir bude jednak tra\u017eenom vektoru. To radimo tako \u0161to za prvi skup mapiramo sve vektore (map&lt;vector&lt; int&gt;, int&gt;, brojimo koliko ima svakog od vektora) a za svaki vektor iz drugog skupa proveravamo koliko ima vektora iz prvog koji su jednaki razlici tra\u017eenog vektora i vektora iz drugog skupa. Slo\u017eenost je \\(O(2^{\\frac{N}{2}}\\cdot N \\cdot M)\\).</p> 04_antimaterijski_top.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;stdio.h&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int MaxN = 35;\nconst long long MaxSetSize = (1 &lt;&lt; (MaxN/2));\n\nclass Vector\n{\nprivate:\n    int M;\n    int vector[MaxN];\n\npublic:\n    Vector() {\n    }\n\n    Vector( int _M ) {\n        M = _M;\n        memset(vector, 0, sizeof(vector));\n    }\n\n    Vector( int *value, int _M ) {\n        M = _M;\n        for (int i = 0; i &lt; M; ++i)\n            vector[i] = value[i];\n    }\n\n    void set( int position, int value ) {\n        vector[position] = value;\n    }\n\n    void add( int position, int value ) {\n        vector[position] += value;\n    }\n\n    int get( int position ) const {\n        return vector[position];\n    }\n\n    void copy( Vector _vector )\n    {\n        M = _vector.M;\n        for (int i = 0; i &lt; M; ++i)\n            vector[i] = _vector.get(i);\n    }\n\n    Vector operator + ( Vector &amp;other ) {\n        Vector ret = other;\n        for (int i = 0; i &lt; M; ++i)\n            ret.add( i, get(i) );\n        return ret;\n    }\n\n    bool operator &lt; (const Vector &amp;other) const {\n        for (int i = 0; i &lt; M; ++i) {\n            if ( get(i) &lt; other.get(i) ) return true;\n            if ( get(i) &gt; other.get(i) ) return false;\n        }\n\n        return false;\n    }\n\n    bool operator == (const Vector &amp;other) const {\n        for (int i = 0; i &lt; M; ++i)\n            if ( get(i) != other.get(i) ) return false;\n        return true;\n    }\n\n    int Equals(const Vector &amp;other) const {\n        for (int i = 0; i &lt; M; ++i) {\n            if ( get(i) &lt; other.get(i) ) return -1;\n            if ( get(i) &gt; other.get(i) ) return 1;\n        }\n\n        return 0;\n    }\n};\n\nint N, M;\nchar **mapa;\nint vector[MaxN];\n\nlong long dva[MaxN];\n\nVector vector1[MaxSetSize];\nint pvector1;\nVector vector2[MaxSetSize];\nint pvector2;\n\nvoid MakeSet( int start, int end, int M, char **mapa, Vector *vector, int &amp;pvector )\n{\n    long long maxBitMask = dva[end - start];\n\n    for (int bitmask = 0; bitmask &lt; maxBitMask; ++bitmask) {\n        Vector positronVektor = Vector(M);\n\n        for (int row = start; row &lt; end; ++row) {\n            int index = row - start;\n            bool inBitmask = (bitmask &gt;&gt; index) &amp; 1;\n\n            for (int j = 0; j &lt; M; ++j) {\n                if ( !inBitmask &amp;&amp; mapa[row][j] == 'p' ) positronVektor.add( j, 1 );\n                if ( inBitmask &amp;&amp; mapa[row][j] == 'e' ) positronVektor.add( j, 1 );\n            }\n        }\n\n        vector[ pvector++ ] = positronVektor;\n    }\n}\n\nlong long FindSame( Vector *vector, int pvector, int &amp;position, int step )\n{\n    long long ret = 1LL;\n\n    position += step;\n    while ( position &gt;= 0 &amp;&amp; position &lt; pvector &amp;&amp; vector[position-step] == vector[position] ) {\n        ret++;\n        position += step;\n    }\n\n    return ret;\n}\n\nlong long BrojNacina( int N, int M, char **mapa, int *_vector )\n{\n    Vector vector = Vector(_vector, M);\n\n    long long ret = 0LL;\n\n    dva[0] = 1LL;\n    for (int i = 1; i &lt;= N; ++i)\n        dva[i] = 2LL * dva[i-1];\n\n    MakeSet( 0, N/2, M, mapa, vector1, pvector1 );\n    MakeSet( N/2, N, M, mapa, vector2, pvector2 );\n\n    sort( vector1, vector1 + pvector1 );\n    sort( vector2, vector2 + pvector2 );\n\n    int p1 = 0;\n    int p2 = pvector2 - 1;\n\n    while ( p1 &lt; pvector1 &amp;&amp; p2 &gt;= 0 ) {\n        Vector sum = vector1[p1] + vector2[p2];\n\n        int equal = sum.Equals(vector);\n\n        if ( equal == -1 ) {\n            p1++;\n        }\n        else if ( equal == 1 ) {\n            p2--;\n        }\n        else {\n            long long number1 = FindSame( vector1, pvector1, p1, +1 );\n            long long number2 = FindSame( vector2, pvector2, p2, -1 );\n\n            ret += number1 * number2;\n        }\n    }\n\n    return ret;\n}\n</code></pre>"},{"location":"takprog/2013_2014/sio/05_poplava/","title":"5 - Poplava","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 64MB <p>Mali Perica je zahvaljuju\u0107i va\u0161oj pomo\u0107i u prethodnim fazama takmi\u010denja odneo pobedu na IOFB (Me\u0111unarodnoj Flappy Bird olimpijadi). Sada je prona\u0161ao novu igricu \u2013 \u201dPoplavu\u201d. Pravila igre su jednostavna \u2013 na po\u010detku je data tabla popunjena nekim bojama, i sva polja koja su susedna i popunjena istim bojama pripadaju jednom skupu polja. Dva polja table su susedna ukoliko imaju zajedni\u010dku ivicu. U jednom potezu, Perica ima pravo da promeni boju gornjeg levog skupa (skupa koji sadr\u017ei gornje levo polje); ukoliko skup ima neki susedan skup te boje, oni se spajaju. Igra se zavr\u0161ava kada je cela tabla prekrivena istom bojom, tj. kad na tabli postoji samo jedan skup.</p> <p>Da bi mogao da se plasira na IOP (Me\u0111unarodnu olimpijadu u \u201dPoplavi\u201d) u Tajvanu, Perica mora da savlada komisijske table u \u0161to manje poteza. Uspeo je da provali u bazu podataka i sazna sve table koje komisija mo\u017ee da mu postavi; pomozite mu tako \u0161to \u0107ete napraviti program koji odre\u0111uje poteze koje Perica treba da odigra. Na slikama dole se nalaze tri stanja table: po\u010detno stanje, stanje nakon \u0161to Perica odigra crvenu boju, pa zelenu boju.</p> <p></p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Petar Veli\u010dkovi\u0107 - Marko Savi\u0107 05_poplava.cpp<pre><code>// Na\u017ealost nemamo ovo re\u0161enje.\n</code></pre>"},{"location":"takprog/2013_2014/sio/05_poplava/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju:</p> <ul> <li><code>ResiTablu(N, M, C, T[], P[]);</code></li> </ul> <p>ova funkcija se poziva samo jednom na po\u010detku programa i ozna\u010dava da treba re\u0161avati tabelu koja ima \\(N\\) redova, \\(M\\) kolona i \\(C\\) razli\u010ditih boja ozna\u010denih od \\(0\\) do \\(C-1\\). U nizu \\(T\\) veli\u010dine \\(N\\cdot M\\) nalazi se sama tabela koju treba re\u0161avati, tako da prvih \\(M\\) polja predstavljaju boje kolona prvog reda, slede\u0107ih \\(M\\) polja boje kolona drugog reda, itd.</p> <p>Niz \\(P\\) predstavlja niz poteza koji \u017eelite da predlo\u017eite Perici da izvr\u0161i; ovaj niz vi trebate da \u201dpopunite\u201d (na prvom mestu stavite boju prvog poteza, i tako dalje sve dok cela tabla ne bude re\u0161ena). Svi nizovi su indeksirani od \\(1\\). Va\u0161a funkcija mora da kao povratnu vrednost vrati du\u017einu niza \\(P\\), tj. ukupan broj poteza.</p>"},{"location":"takprog/2013_2014/sio/05_poplava/#primer-1","title":"Primer 1","text":"<p>Pretpostavimo da je va\u0161 program dobio naredbu da izvr\u0161i: <code>ResiTablu(2, 2, 3, [1, 0, 1, 2], P)</code>.</p> <p>Jedno od mogu\u0107ih re\u0161enja je: \\(P= [0, 2]\\); povratna vrednost funkcije je \\(2\\).</p> <p>Stanja table na po\u010detku i posle svakog poteza su:</p> \\[ (1 0 1 2) \\rightarrow (0 0 0 2) \\rightarrow (2 2 2 2) \\]"},{"location":"takprog/2013_2014/sio/05_poplava/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,M,C\\leq 100\\).</li> <li>\\(0\\leq Ti &lt; C\\).</li> <li>Va\u0161 program ne sme da napravi vi\u0161e od \\(10000\\) poteza.</li> </ul> <p>U formuli koja sledi, \\(|P|\\) je povratna vrednost va\u0161e funkcije <code>ResiTablu</code>. Zadatak se sastoji od \\(20\\) test primera.  Za svaki korektno re\u0161eni test primer, dobijate:</p> <ul> <li>\\(5\\) poena ukoliko je \\(|P| \\leq A\\);</li> <li>\\(0.05\\) poena ukoliko \\(|P| \\geq B\\);</li> <li>\\(5\\cdot \\frac{A\\cdot(B-|P|)}{|P|\\cdot(B-A)}\\) poena ina\u010de.</li> </ul> <p>\\(A\\) i \\(B\\) su konstante koje zavise od test primera:</p> <ul> <li>U \\(25\\%\\) test primera va\u017ei \\(N=M=C=6\\); \\(A=11\\), \\(B=30\\).</li> <li>U \\(25\\%\\) test primera va\u017ei \\(N=M=26\\),  \\(C=8\\); \\(A=55\\), \\(B=110\\).</li> <li>U \\(25\\%\\) test primera va\u017ei \\(N=M=100\\),  \\(C=6\\); \\(A=140\\), \\(B=250\\).</li> <li>U \\(25\\%\\) test primera va\u017ei \\(N=M=C=100\\); \\(A=1100\\), \\(B=1400\\).</li> </ul>"},{"location":"takprog/2013_2014/sio/06_pirinac/","title":"6 - Pirina\u010d","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mladi tajvanac Teo Lin se sprema da do\u010deka takmi\u010dare, profesore i goste koji \u0107e do\u0107i ove godine na IOI. Kao dobar doma\u0107in, on \u0107e svakom takmi\u010daru pokloniti po kutiju pirin\u010da kada stigne. Kako je poznato da \u0107e do\u0107i \\(N\\) ljudi, on je ve\u0107 spremio \\(N\\) (praznih) kutija i postavio ih u niz, jednu do druge.</p> <p>Svakog dana kada se vrati sa svog polja, on izabere nekih uzastopnih \\(2^k\\) kutija, a zatim u svaku ubaci \\(2^v\\) zrnca pirin\u010da (Teo Lin mnogo voli \"okrugle\" brojeve, tj. stepene dvojke).</p> <p>Nekad, kada mu je dosadno, on malo izme\u0161a kutije. To radi tako \u0161to izabere grupu od \\(2^k\\) uzastopnih kutija, a zatim zameni njihov redosled tako sto uzme prvih pola \\((2^{k-1})\\) kutija iz te grupe, i stavi ih na mesto drugih pola kutija, i obrnuto. Drugim re\u010dima, ukoliko imamo \\(7\\) kutija, redom obele\u017eene brojevima \\([1,2,3,4,5,6,7]\\), a onda Teo izabere grupu od \\(2^2\\) kutije: \\([3,4,5,6]\\), redosled kutija nakon me\u0161anja \u0107e biti: \\([1,2,5,6,3,4,7]\\). Ovaj postupak je prikazan i na slici:</p> <p></p> <p>Pre nego \u0161to ubacuje pirina\u010d u kutije, Tea zanima koliko zapravo trenutno ima ukupno pirin\u010da u izabranih \\(2^k\\) kutija. Zbog previ\u0161e me\u0161anja, on je i zaboravio gde ih je koliko ubacivao, a kako nema vremena da izbroji, zamolio je vas da mu pomognete, i odgovorite na neka pitanja koje vas bude pitao - Koliko ima ukupno zrnaca pirin\u010da u \\(2^k\\) uzastopnih kutija koje je izabrao.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Aleksandar Vi\u0161nji\u0107 Dimitrije Dimi\u0107"},{"location":"takprog/2013_2014/sio/06_pirinac/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate slede\u0107e \\(4\\) funkcije:</p> <ul> <li><code>Init(N,  subtask)</code> \u2013 ova funkcija se poziva samo jednom na po\u010detku programa i ozna\u010dava da ima ta\u010dno \\(N\\) kutija, i da je taj test primer iz podzadatka \\(subtask\\). Mo\u017eete je iskoristiti da postavite po\u010detne vrednosti svojih globalnih promenljivih/nizova.</li> <li><code>Ubaci(pos,  k,  v)</code> \u2013 ova funkcija ozna\u010dava da se u \\(2^k\\) uzastopnih kutija, po\u010dev\u0161i od pozicije \\(pos\\) ubacuje \\(2^v\\) zrnca pirin\u010da. Ova funkcija se poziva vi\u0161e puta u toku programa sa potencijalno razli\u010ditim parametrima.</li> <li><code>Izmesaj(pos,  k)</code> \u2013 ova funkcija ozna\u010dava da \u0107e Teo Lin izme\u0161ati \\(2^k\\) uzastopnih kutija, po\u010dev\u0161i od pozicije \\(pos\\) kao \u0161to je opisano u zadatku. Ova funkcija se poziva vi\u0161e puta u toku programa sa potencijalno razli\u010ditim parametrima.</li> <li><code>Prebroji(pos,  k)</code> \u2013 ova funkcija predstavlja pitanje \u201cKoliko ima ukupno zrnaca pirin\u010da u \\(2^k\\) uzastopnih kutija, po\u010dev\u0161i od pozicije \\(pos\\)\u201d; potrebno je odgovoriti na pitanje, tj. Odgovor vratiti kao vrednost funkcije. Ova funkcija se poziva vi\u0161e puta u toku programa sa potencijalno razli\u010ditim parametrima.</li> </ul> <p>Pozicije kutija su indeksirane od \\(1\\).</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#primer-1","title":"Primer 1","text":"<p>U slede\u0107oj listi je prikazan mogu\u0107i redosled poziva va\u0161ih funkcija:</p> <ul> <li><code>Init(10, 1)</code> - Dobijate informaciju (samo jednom na po\u010detku) da je Teo pripremio \\(10\\) kutija, i da test primer ispunjava ograni\u010denja iz prvog podzadatka. Na po\u010detku je broj zrnaca pirin\u010da po kutijama: \\([0,0,0,0,0,0,0,0,0,0]\\).</li> <li><code>Ubaci(3, 2, 5)</code> - Dodajemo po \\(32\\) (\\(2^5\\)) zrnca pirin\u010da u \\(4\\) (\\(2^2\\)) kutije po\u010dev od pozicije \\(3\\). Broj zrnaca pirin\u010da po kutijama je sada: \\([0,0,32,32,32,32,0,0,0,0]\\).</li> <li><code>Ubaci(6, 1, 7)</code> - Dodajemo po \\(128\\) (\\(2^7\\)) zrnca pirin\u010da u \\(2\\) (\\(2^1\\)) kutije po\u010dev od pozicije \\(6\\). Broj zrnaca pirin\u010da po kutijama je sada: \\([0,0,32,32,32,160,128,0,0,0]\\).</li> <li><code>Prebroji(5, 2)</code> - Potrebno je vratiti \\(320\\) \\((32 + 160 + 128 + 0)\\), jer toliko zrnaca ima ukupno u \\(4\\) (\\(2^2\\)) kutije po\u010dev od pozicije \\(5\\).</li> <li><code>Izmesaj(4, 2)</code> - Izme\u0161amo \\(4\\) kutije, koje po\u010dinju od pozicije \\(4\\). Broj zrnaca pirin\u010da po kutijama je sada: \\([0,0,32,160,128,32,32,0,0,0]\\).</li> <li><code>Prebroji(5, 2)</code> - Potrebno je vratiti \\(192\\) \\((128 + 32 + 32 + 0)\\), jer toliko zrnaca ima ukupno u \\(4\\) (\\(2^2\\)) kutije po\u010dev od pozicije \\(5\\).</li> <li><code>Izmesaj(1, 3)</code> - Izme\u0161amo \\(8\\) kutije, koje po\u010dinju od pozicije \\(1\\). Broj zrnaca pirin\u010da po kutijama je sada: \\([128,32,32,0, 0,0,32,160,0,0]\\)</li> <li><code>Prebroji(4, 2)</code> - Potrebno je vratiti \\(32\\) \\((0 + 0 + 0 + 32)\\), jer toliko zrnaca ima ukupno u \\(4\\) (\\(2^2\\)) kutije po\u010dev od pozicije \\(4\\).</li> <li><code>Prebroji(3, 3)</code> - Potrebno je vratiti \\(224\\) \\((32 + 0 + 0 + 0 + 32 + 160 + 0 + 0)\\), jer toliko zrnaca ima ukupno u \\(8\\) (\\(2^3\\)) kutije po\u010dev od pozicije \\(3\\).</li> </ul>"},{"location":"takprog/2013_2014/sio/06_pirinac/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Funkcija <code>Init(N,  subtask)</code> se poziva ta\u010dno jednom (na po\u010detku) i va\u017ei \\(1\\leq N\\leq 100.000\\) i \\(1\\leq subtask\\leq 5\\).</li> <li>Funkcije <code>Ubaci</code>, <code>Izmesaj</code> i <code>Prebroji</code> se ukupno pozivaju ne vi\u0161e od \\(300.000\\) puta.</li> <li>Prilikom svakog poziva <code>Ubaci(pos, k,  v)</code> va\u017ei \\(k\\geq 0\\), \\(1\\leq pos\\leq pos+2^k-1\\leq N\\), i \\(0\\leq v\\leq 30\\).</li> <li>Prilikom svakog poziva <code>Izmesaj(pos,  k)</code> va\u017ei \\(k\\geq 1\\), \\(1\\leq pos\\leq pos+2^k-1\\leq N\\).</li> <li>Prilikom svakog poziva <code>Prebroji(pos,  k)</code> va\u017ei \\(k\\geq 0\\), \\(1\\leq pos\\leq pos+2^k-1\\leq N\\).</li> </ul> <p>Ozna\u010dimo sa \\(numUbaci\\) broj poziva funkcije <code>Ubaci</code>, sa \\(numIzmesaj\\) broj poziva funkcije <code>Izmesaj</code>, sa \\(numPrebroji\\) broj poziva funkcije <code>Prebroji</code>, i sa \\(Q = numUbaci+numIzmesaj+numPrebroji\\):</p> <ul> <li>PODZADATAK \\(1\\) [\\(7\\) POENA]: \\(N\\leq 1024\\), \\(Q\\leq 1024\\).</li> <li>PODZADATAK \\(2\\) [\\(17\\) POENA]: Prilikom svakog poziva funkcije <code>Ubaci</code> \u0107e va\u017eiti \\(k=0\\) i prilikom svakog poziva funkcije <code>Izmesaj</code> \u0107e va\u017eiti \\(k=1\\).</li> <li>PODZADATAK \\(3\\) [\\(18\\) POENA]: \\(numIzmesaj=0\\).</li> <li>PODZADATAK \\(4\\) [\\(25\\) POENA]: \\(N\\leq 16384\\).</li> <li>PODZADATAK \\(5\\) [\\(33\\) POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2013_2014/sio/06_pirinac/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom <code>pirinac.c</code>, <code>pirinac.cpp</code> ili <code>pirinac.pas</code>, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika: <pre><code>C/C++:\n    void Init(int N, int subtask);\n    void Ubaci(int pos, int k, int v);\n    void Izmesaj(int pos, int k);\n    long long Prebroji(int pos, int k);\nPascal:\n    procedure Init(N, subtask : longint);\n    procedure Ubaci (pos, k, v : longint);\n    procedure Izmesaj (pos, k : longint);\n    function Prebroji(pos, k : longint) : int64;\n</code></pre></p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (<code>pirinac.c</code>, <code>pirinac.cpp</code>, <code>pirinac.pas</code>) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (<code>grader.c</code>, <code>grader.cpp</code>, <code>grader.pas</code>) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(Q\\) i \\(subtask\\), razdvojene razmakom; \\(N\\) je broj kutija, \\(Q\\) ukupni broj upita (ne ra\u010dunaju\u0107i <code>Init</code>), a subtask je redni broj podzadatka;</li> <li>U narednih \\(Q\\) redova nalazi se prvo broj \\(t\\); ukoliko je \\(t = 1\\), tada trenutni red predstavlja upit <code>Ubaci</code> i u nastavku reda se u\u010ditavaju jo\u0161 \\(3\\) broja (\\(pos\\), \\(k\\), \\(v\\)) sa kojima se poziva funkcija; ukoliko je \\(t = 2\\), tada trenutni red predstavlja upit <code>Izmesaj</code> i u nastavku reda se u\u010ditavaju jo\u0161 \\(2\\) broja (\\(pos\\), \\(k\\)) sa kojima se poziva funkcija; ukoliko \\(t = 3\\), tada trenutni red predstavlja upit <code>Prebroji</code> i u nastavku reda se u\u010ditavaju jo\u0161 \\(2\\) broja (\\(pos\\), \\(k\\)) sa kojima se poziva funkcija.</li> </ul> <p>Na po\u010detku se poziva va\u0161a funkcija <code>Init</code> sa parametrima \\(N\\), \\(subtask\\), a zatim se za svaki u\u010ditani upit poziva va\u0161a odgovaraju\u0107a funkcija iz odgovaraju\u0107eg fajla (<code>pirinac.c</code>, <code>pirinac.cpp</code>, <code>pirinac.pas</code>) sa u\u010ditanim parametrima. Posle svakog poziva va\u0161oj funkciji <code>Prebroji</code>, rezultat koji ona vra\u0107a se ispisuje na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Na upite odgovaramo naivnim prolaskom kroz niz jednom petljom, zamenjuju\u0107i ili dodavanjem na elemente niza direktno. Slo\u017eenost je \\(O(N \\cdot Q)\\).</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Funkcija Ubaci pove\u0107ava jedan element niza, a funkcija Izmesaj zamenjuje dva susedna njegova elementa (odnosno jedan pove\u0107ava, a drugi smanjuje). Ovim imamo linearan broj upita pove\u0107avanja i imamo upite zbira na segmentu, \u0161to nas navodi da zadatak re\u0161avamo segmentnim stablom u slo\u017eenosti \\(O(N+QlogN)\\).</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Kako ne pozivamo funkciju Izmesaj, zadatak se svodi na upite raspona pove\u0107anja i sume. Segmentno stablo sa lenjom propagacijom re\u0161ava ovaj podzadatak u \\(O(N+QlogN)\\).</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#cetvrti-podzadatak","title":"\u010cetvrti podzadatak","text":"<p>Niz se mo\u017ee podeliti u listu blokova veli\u010dine \\(\\sqrt N\\); svaki blok \u010duva listu celih brojeva koji ozna\u010davaju same elemente niza i jo\u0161 jedan ceo broj koji ozna\u010dava za koliko jo\u0161 dodatno treba uve\u0107ati svaki element te liste. Ubaci i Prebroji nije te\u0161ko implementirati u \\(O(\\sqrt N)\\). \u0160to se ti\u010de funkcije Izmesaj, ona \u0107e prvo po potrebi podeliti blokove u kojima se nalaze krajevi njenog raspona na dva bloka (kako radimo sa listama to je efikasno, tako\u0111e uvek nastaje najvi\u0161e 4 nova bloka). Zatim treba da \"izme\u0161amo\" odre\u0111ene cele blokove, ali to je opet samo izbacivanje iz i dodavanje u listu (koja sadr\u017ei liste). Napomenimo samo da se nakon \\(\\sqrt N\\) poziva funkcije Izmesaj blokovi moraju napraviti iznova u \\(O(N)\\) kako bi njihov broj ostao korenskog reda. Ukupna slo\u017eenost je \\(O(N+Q\\sqrt N)\\).</p>"},{"location":"takprog/2013_2014/sio/06_pirinac/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Napravimo segmentno stablo, ali u kom \u0107e veli\u010dina svakog \u010dvora biti stepen dvojke. Tako\u0111e uradimo to iterativno: za najmanje \\(k\\) takvo da \\(2^k\\geq N\\) najni\u017ei nivo \u0107e obuhvatati segmente \\([0,0],[1,1],[2,2],...[2^k-1,2^k-1]\\), slede\u0107i \u0107e \\([0,1],[2,3],..,[2^k-2,2^k-1]\\), ... koren \u0107e obuhvatati jedan segment \\([0,2^k-1]\\). Upite uve\u0107anja i zbira radimo isto kao u tre\u0107em podzadatku, a za me\u0161anje moramo uo\u010diti jednu lepu stvar kod rastavljanja segmenta na \u010dvorove u ovakvom stablu. Najpre primetimo da svi segmenti u upitu imaju veli\u010dinu stepena dvojke, kao i njihove polovine. To \u010dini da rastavljanje leve i desne polovine upita na \u010dvorove topolo\u0161ki imaju istu strukturu. Formalnije, ako se leva polovina, redom, rastavlja na \u010dvorove \\(x_1,x_2,...,x_p\\), a desna na \\(y_1,y_2,...,y_q\\), va\u017ei\u0107e \\(p = q\\) i</p> \\[size(x_1)=size(y_1),size(x_2)=size(y_2),...,size(x_p)=size(y_q)\\] <p>gde \\(size(t)\\) predstavlja veli\u010dinu segmenta koji taj \u010dvor predstavlja. Ovo \u010dini da se svaki \u010dvor mo\u017ee lako zameniti sa njegovim odgovaraju\u0107im, potrebno je samo stablo implementirati implicitno. Vremenska slo\u017eenost je \\(O(N+QlogN)\\).</p> 06_pirinac.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define STIZE(x) fprintf(stderr, \"STIZE%d\\n\", x);\n#define PRINT(x) fprintf(stderr, \"%s = %d\\n\", #x, x);\n#define NL(x) printf(\"%c\", \" \\n\"[(x)]);\n#define lld long long\n#define pii pair&lt;int,int&gt;\n#define pb push_back\n#define fi first\n#define se second\n#define mid (l+r)/2\n#define endl '\\n'\n#define all(a) begin(a),end(a)\n#define sz(a) int((a).size())\n#define LINF 1000000000000000LL\n#define INF 1000000000\n#define EPS 1e-9\nusing namespace std;\n#define MAXN (1&lt;&lt;18)\nstruct SegNode{\n    lld val, lazy;\n    int l, r, parent;\n};\nSegNode seg[4*MAXN+10];\nvoid propagate(int node, int l, int r) {\n    if(seg[node].lazy != 0) {\n        seg[node].val += (lld)(r-l+1) * seg[node].lazy;\n        if(l &lt; r) {\n            seg[seg[node].l].lazy += seg[node].lazy;\n            seg[seg[node].r].lazy += seg[node].lazy;\n        }\n        seg[node].lazy = 0;\n    }\n}\n///INIT//////////////////////////////////////////////////////////////////////\nint timer;\nvoid init(int node, int l, int r, int parent) {\n    seg[node].val = seg[node].lazy = 0;\n    seg[node].parent = parent;\n    if(l == r) return;\n    seg[node].l = ++timer;\n    seg[node].r = ++timer;\n    init(seg[node].l, l, mid, node);\n    init(seg[node].r, mid+1, r, node);\n}\nvoid Init(int N, int subtask) {\n    timer = 1;\n    init(1, 1, MAXN, 0);\n}\n///UPD///////////////////////////////////////////////////////////////////////\nvoid update(int node, int l, int r, int L, int R, lld val) {\n    propagate(node, l, r);\n    if(r &lt; l || r &lt; L || l &gt; R) return;\n    if(L &lt;= l &amp;&amp; r &lt;= R) {\n        seg[node].lazy += val;\n        propagate(node, l, r);\n        return;\n    }\n    update(seg[node].l, l, mid, L, R, val);\n    update(seg[node].r, mid+1, r, L, R, val);\n    seg[node].val = seg[seg[node].l].val + seg[seg[node].r].val;\n}\nvoid Ubaci(int pos, int k, int v) {\n    update(1, 1, MAXN, pos, pos+(1&lt;&lt;k)-1, (1&lt;&lt;v));\n}\n///QUERY//////////////////////////////////////////////////////////////////////\nlld query(int node, int l, int r, int L, int R) {\n    propagate(node, l, r);\n    if(r &lt; l || r &lt; L || l &gt; R) return 0;\n    if(L &lt;= l &amp;&amp; r &lt;= R) {\n        return seg[node].val;\n    }\n    return query(seg[node].l, l, mid, L, R) + query(seg[node].r, mid+1, r, L, R);\n}\nlld Prebroji(int pos, int k) {\n    return query(1, 1, MAXN, pos, pos+(1&lt;&lt;k)-1);\n}\n///SHUFFLE////////////////////////////////////////////////////////////////////\nvector&lt;int&gt; a, b;\nvoid shuffle(int node, int l, int r, int L, int R, vector&lt;int&gt; &amp;v) {\n    propagate(node, l, r);\n    if(r &lt; l || r &lt; L || l &gt; R) return;\n    if(L &lt;= l &amp;&amp; r &lt;= R) {\n        v.pb(node);\n        return;\n    }\n    shuffle(seg[node].l, l, mid, L, R, v);\n    shuffle(seg[node].r, mid+1, r, L, R, v);\n}\nvoid zameni(int a, int b) {\n    int pa = seg[a].parent, pb = seg[b].parent;\n    seg[a].parent = pb;\n    seg[b].parent = pa;\n    if(pa == pb) {\n        swap(seg[pa].l, seg[pa].r);\n        return;\n    }\n    if(seg[pa].l == a) seg[pa].l = b;\n    if(seg[pa].r == a) seg[pa].r = b;\n\n    if(seg[pb].l == b) seg[pb].l = a;\n    if(seg[pb].r == b) seg[pb].r = a;\n}\nvoid Izmesaj(int pos, int k) {\n    k--;\n    a.clear(); b.clear();\n    shuffle(1, 1, MAXN, pos, pos+(1&lt;&lt;k)-1, a);\n    int pos1 = pos + (1&lt;&lt;k);\n    shuffle(1, 1, MAXN, pos1, pos1+(1&lt;&lt;k)-1, b);\n    for(int i = 0; i &lt; sz(a); i++) {\n        zameni(a[i], b[i]);\n    }\n    update(1, 1, MAXN, pos, pos+(1&lt;&lt;k)-1, 0);\n    update(1, 1, MAXN, pos1, pos1+(1&lt;&lt;k)-1, 0);\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/","title":"B1 - Apsolutno broj","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 200ms 64MB <p>Nakon celodnevnog rada na zadacima i test primerima, \u010dlanovi Tajne komisije iz senke ostaju da podele poslove za sutra tradicionalnim algoritmom.</p> <p>Najpre zapi\u0161u dva niza \\(A\\) i \\(B\\), svaki sa \\(N\\) celih brojeva. Nakon toga, \\(N\\) puta ra\u010dunaju slede\u0107u sumu \\(\\sum_{i=1}^N |A_i-B_i|\\) i nakon svakog ra\u010dunanja rotiraju niz A za jedno mesto u desno. Sve rezultate na kraju saberu i ovo re\u0161enje nazovu \u201esuma svih suma\u201c.</p> <p>\u010clanovi komisije koriste \u201esumu svih suma\u201c da odre\u0111enim algoritmom podele poslove. Kako ra\u010dunanje ove sume oduzima mnogo vremena, komisija je odlu\u010dila da napi\u0161e program. Ali da bi podela poslova bila fer, zamolili su Vas da im pomognete i napi\u0161ete program koji \u0107e izra\u010dunati \u201esumu svih suma\u201c.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Dimi\u0107 Marko Bakovi\u0107 Uro\u0161 Vuki\u0107evi\u0107 Petar Veli\u010dkovi\u0107"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se ceo broj \\(N\\). U slede\u0107a dva reda nalazi se po \\(N\\) celih brojeva razdvojenih razmakom, nizovi \\(A\\) i \\(B\\) redom.</p>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza nalazi se jedan ceo broj, tra\u017eena \u201esuma svih suma\u201c.</p>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#ulaz","title":"Ulaz","text":"<pre><code>3\n4 2 8\n2 7 3\n</code></pre>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#izlaz","title":"Izlaz","text":"<pre><code>24\n</code></pre>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Za po\u010detni niz 4 2 8 suma razlika je 2 + 5 + 5 = 12. Nakon rotiranja niz A je 8 4 2, a suma razlika 6 + 3 + 1 = 10. Nakon jo\u0161 jednog rotiranja, niz A je 2 8 4, a suma razlika 0 + 1 + 1 = 2. Posle ra\u010dunanja tre\u0107e sume, rotiramo niz \\(A\\) ali ne ra\u010dunamo nikakvu sumu. Tra\u017eena \u201esuma svih suma\u201c je 12 + 10 + 2 = 24.</p>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>U 30% test primera va\u017ei \\(1\\leq N\\leq 10^3\\)  i \\(|A_i|,|B_i| \\leq 10^3\\)</li> <li>U narednih 20% test primera va\u017ei \\(1\\leq N\\leq 10^5\\)  i \\(A_i,B_i \\in \\{0,1\\}\\)</li> <li>U preostalim test primerima va\u017ei \\(1\\leq N\\leq 10^5\\) i \\(|A_i|, |B_i| \\leq 10^6\\)</li> </ul>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#resenje-za-1-leq-n-leq-103-i-a_i-b_i-leq-103","title":"Re\u0161enje za \\(1 \\leq N \\leq 10^3\\) i \\(|A_i|, |B_i| \\leq 10^3\\):","text":"<p>Ograni\u010denje za \\(N\\) je dovoljno malo da simuliramo proces iz teksta zadatka, postoja\u0107e \\(N\\) rotacija, a za svaku rotaciju imamo \\(N\\) ra\u010dunanja, pa je krajnja vremenska slo\u017eenost \\(O(N^2)\\). Memorijska slo\u017eenost: \\(O(N)\\). </p>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#resenje-za-a_i-b_i-in-0-1","title":"Re\u0161enje za \\(A_i, B_i \\in \\{0, 1\\}\\):","text":"<p>Sa obzirom da \u0107e svaki element u nekom trenutku biti na svakoj od pozicija u nizu ukupna suma \u0107e zapravo biti \\(\\sum_{i=1}^{n}\\sum_{j=1}^{n}|A_i-B_j|\\), odnosno, tra\u017ei nam se zbir apsolutnih razlika svakog elementa niza \\(A\\) sa svakim elementom niza \\(B\\). Iz ove sume se vidi da svaki element mo\u017eemo da gledamo zasebno. Svaka jedinica iz niza \\(A\\) daje apsolutnu razliku \\(1\\) sa svim nulama iz niza \\(B\\), dok svaka nula iz niza \\(A\\) daje apsolutno razliku \\(1\\) sa svim jedinicama iz niza \\(B\\). Sve ostale apsolutne razlike iznose \\(0\\). Samim tim, krajnji rezultat je \\(cntA_0\\cdot cntB_1 + cntA_1\\cdot cntB_0\\), gde je npr. \\(cntA_0\\) broj nula u nizu \\(A\\). Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(1)\\). </p>"},{"location":"takprog/2014_2015/drz/01_apsolutno_broj/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Primenimo istu sumu iz prethodnog re\u0161enja, samo je sada komplikovanije da je izra\u010dunamo. Nakon \u0161to sortiramo niz \\(B\\), za svaki element \\(A_i\\) mogli bismo da razdvojimo niz \\(B\\) uspravnom linijom, gde bi nam sa desne strane te linije svi elementi bili ve\u0107i od \\(A_i\\) (ako ih ima), dok bi nam sa leve strane bili svi elementi manji ili jednaki od \\(A_i\\) (ako ih ima). To bi zna\u010dilo da bi sve apsolutne razlike sa leve strane bile \\(A_i-B_j\\), dok bi sa desne strane bile \\(B_j-A_i\\). Liniju mo\u017eemo prona\u0107i pomo\u0107u binarne pretrage, a sumu sa leve i desne strane linije uz pomo\u0107 prefiksnih suma. Nakon toga, za dato \\(A_i\\), rezultat je \\((brojLevo\\cdot A_i - sumaLevo) + (sumaDesno - brojDesno\\cdot A_i)\\). Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(N)\\).</p> 01_apsolutno_broj.cpp<pre><code>/*\n    Drzavno takmicenje iz programiranja\n    21. mart 2015. godine\n\n    B1 Apsolutno broj\n    Trazeno resenje, 100 poena\n*/\n\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, a[maxn], b[maxn];\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);\n    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;b[i]);\n\n    sort(a, a + n);\n    sort(b, b + n);\n\n    long long sol = 0, left_sum = 0, right_sum = 0, first_in_right = 0;\n    for (int i = 0; i &lt; n; i++) right_sum += b[i];\n    for (int i = 0; i &lt; n; i++)\n    {\n        while (first_in_right &lt; n &amp;&amp; b[first_in_right] &lt; a[i])\n        {\n            left_sum += b[first_in_right];\n            right_sum -= b[first_in_right];\n            first_in_right++;\n        }\n        sol += first_in_right * a[i] - left_sum +\n               right_sum - (n - first_in_right) * a[i];\n    }\n\n    printf(\"%lld\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/","title":"B2 - Izmena","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali \u0110urica, biv\u0161i \u010dlan Tajne komisije iz senke, je kupio robota. \u0110urica je postavio robota na veliku tablu (radi jednostavnosti zamisli\u0107emo da tabla ima beskona\u010dnu du\u017einu i \u0161irinu) preko koje je postavljen koordinantni sistem.</p> <p>Uz robota je dobio i niz komandi \\(Q\\), du\u017eine \\(N\\), koji se sastoji od slova \\(L\\), \\(R\\), \\(D\\) i \\(U\\). Kad robot na poziciji \\((x, y)\\) u\u010dita slovo \\(q\\) pomera se na poziciju \\((w, z)\\) na slede\u0107i na\u010din: ako \\(q = L\\) onda \\((w, z) = (x \u2013 1, y)\\), tj. ide levo; ako \\(q = R\\) onda \\((w, z) = (x + 1, y)\\), tj. ide desno; ako \\(q = U\\) onda \\((w, z) = (x, y + 1)\\), tj. ide gore; i ako \\(q = D\\) onda \\((w, z) = (x, y - 1)\\), tj. ide dole. Pored ovoga, mali \u0110urica je izabrao koordinatu \\((r, s)\\).</p> <p>Malog \u0110uricu zanima slede\u0107e:</p> <ul> <li>broj \\(A\\) \u2013 koliki je najmanji broj komandi koje treba izmeniti u nizu \\(S\\) tako da kad robot u\u010dita izmenjeni niz i krene sa pozicije \\((0, 0)\\) u nekom momentu pro\u0111e kroz koordinatu \\((r, s)\\);</li> <li>broj \\(B\\) \u2013 koliki je najmanji komandi koje treba izmeniti u nizu \\(S\\) tako da kad robot u\u010dita izmenjeni niz i krene sa pozicije \\((0, 0)\\) zavr\u0161i na koordinati \\((r, s)\\).</li> </ul> <p>Pomozite malom \u0110urici i izra\u010dunajte \\(A\\) i \\(B\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Slobodan Mitrovi\u0107 Dragan Uro\u0161evi\u0107 - Demjan Grubi\u0107 02_izmena.cpp<pre><code>/*\n  author: Slobodan Mitrovic\n*/\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main() {\n  int N, r, s;\n  cin &gt;&gt; N &gt;&gt; r &gt;&gt; s;\n  string Q;\n  cin &gt;&gt; Q;\n  int L = 0, R = 0, D = 0, U = 0;\n  int A = N + 1, B = N + 1;\n  for (int i = 1; i &lt;= Q.size(); i++) {\n    char ch = Q[i - 1];\n    if (ch == 'L')\n      L++;\n    else if (ch == 'R')\n      R++;\n    else if (ch == 'D')\n      D++;\n    else\n      U++;\n\n    if (i &lt; abs(r) + abs(s))\n      continue;\n    if (i % 2 != (abs(r) + abs(s)) % 2)\n      continue;\n\n    int toUse = 0, x = R - L, y = U - D;\n    if (r &lt; x)\n      toUse += min(x - r, R);\n    else if (r &gt; x)\n      toUse += min(r - x, L);\n\n    if (s &lt; y)\n      toUse += min(y - s, U);\n    else if (s &gt; y)\n      toUse += min(s - y, D);\n\n    int toChange = abs(x - r) + abs(y - s);\n    if (toChange % 2)\n      cout &lt;&lt; \"Error!\" &lt;&lt; endl;\n    int tmp = min(toChange, 2 * toUse);\n    B = tmp / 2 + toChange - tmp;\n    A = min(A, B);\n  }\n  cout &lt;&lt; A &lt;&lt; \" \" &lt;&lt; B &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se tri broja \\(N\\), \\(r\\) i \\(s\\) razdvojena razmakom. U drugom redu se nalazi string \\(Q\\) du\u017eine \\(N\\).</p>"},{"location":"takprog/2014_2015/drz/02_izmena/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati broj \\(A\\) i broj \\(B\\) razdvojeni jednim razmakom.</p>"},{"location":"takprog/2014_2015/drz/02_izmena/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/02_izmena/#ulaz","title":"Ulaz","text":"<pre><code>6 0 2\nRRRRRR\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/#izlaz","title":"Izlaz","text":"<pre><code>2 4\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2014_2015/drz/02_izmena/#ulaz_1","title":"Ulaz","text":"<pre><code>13 3 -4\nUURRRDUUDRLLL\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/#izlaz_1","title":"Izlaz","text":"<pre><code>3 4\n</code></pre>"},{"location":"takprog/2014_2015/drz/02_izmena/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru ako robot prati niz UURRRR, koji se razlikuje u 2 karaktera od onog na ulazu, na\u0107i \u0107e se na koordinati (0, 2) posle druge u\u010ditane komande. Ako robot prati niz komandi LRLRUU na\u0107i \u0107e se na koordinati (0, 2) nakon \u0161to u\u010dita ceo niz.</p> <p>U drugom primeru mogu\u0107i nizovi komandi koji odgovaraju izlazu su UDRRRDDDDRLLL i DURRRDDDDRRLL.</p>"},{"location":"takprog/2014_2015/drz/02_izmena/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 500 000\\).</li> <li>\\(Q\\) je sastavljen od karaktera \\(L\\), \\(R\\), \\(D\\) i \\(U\\), kao \u0161to je opisano u postavci problema.</li> <li>\\(|r| + |s| &gt; 0\\).</li> <li>Niz \u0107e uvek mo\u0107i da se izmeni tako da brojevi \\(A\\) i \\(B\\) postoje.</li> </ul>"},{"location":"takprog/2014_2015/drz/02_izmena/#napomena","title":"Napomena","text":"<ul> <li>Ako takmi\u010dar ispi\u0161e ta\u010dno broj \\(A\\) dobija 60% poena na datom test primeru.</li> <li>Ako takmi\u010dar ispi\u0161e ta\u010dno broj \\(B\\) dobija 40% poena na datom test primeru.</li> </ul> <p>Test primeri su podeljeni u 4 disjuntkne grupe:</p> <ul> <li>U test primerima vrednim 10 poena va\u017ei \\(s = 0\\) i \\(Q\\) se sastoji samo od karaktera \\(L\\) i \\(R\\).</li> <li>U test primerima vrednim 10 poena va\u017ei \\(1 \\leq N \\leq 10\\).</li> <li>U test primerima vrednim 30 poena va\u017ei \\(1 \\leq N \\leq 1 000\\).</li> <li>U test primerima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/","title":"B3 - Anti-\u017emurke","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>\u010clanovi Tajne komisije u senci su prili\u010dno besposleni ovih dana pa u obli\u017enjem parku igraju anti-\u017emurke. Anti-\u017emurke su potezna de\u010dja igra u kojoj se jedan igra\u010d krije dok ga jedan ili vi\u0161e igra\u010da, koje nazivamo traga\u010dima, tra\u017ei.</p> <p>Park je pravougaonih dimenzija i podeljen je na jedini\u010dne kvadrate. Svako kvadratno polje predstavlja \u017ebun u kojem se igra\u010d mo\u017ee sakriti. Za svakog traga\u010da je poznata njegova po\u010detna pozicija kao i brzina koja predstavlja koliko polja mo\u017ee pre\u0107i u jednom potezu. Sa trenutnog polja traga\u010d mo\u017ee pre\u0107i samo na neko od \u010detiri susedna polja. Dva polja su susedna ukoliko imaju zajedni\u010dku stranicu. Svi traga\u010di u isto vreme kre\u0107u sa potragom.</p> <p>Red je na malog Zokija da se sakrije. On \u017eeli da bude \u0161to bolji u ovoj igri pa \u017eeli da se sakrije u \u017ebunu na polju \u010dija je skrivenost najve\u0107a mogu\u0107a. Skrivenost nekog polja je celobrojna vrednost koja predstavlja u koliko najmanje poteza neki od traga\u010da mo\u017ee sti\u0107i do tog polja kre\u0107u\u0107i se najkra\u0107im putem. Pomozite Zokiju da prona\u0111e polje sa najve\u0107om skriveno\u0161\u0107u jer su traga\u010di ve\u0107 po\u010deli sa odbrojavanjem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Dimi\u0107 Dimitrije Dimi\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Milosavljevi\u0107"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\), \\(M\\) i \\(K\\), koji predstavljaju dimenzije parka i broj traga\u010da, tim redom. U narednih \\(K\\) redova slede koordinate po\u010detne pozicije \\(X_i\\) i \\(Y_i\\) (redni broj reda i kolone) i brzina \\(V_i\\) za svakog od traga\u010da. Redovi su numerisani od \\(1\\) do \\(N\\) odozgo nadole a kolone od \\(1\\) do \\(M\\) sleva nadesno.</p>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati dva broja \\(i\\) i \\(j\\) \u2013 redni broj reda i kolone polja na kojem se Zoki treba sakriti u skladu sa svojim zahtevom. Ukoliko postoji vi\u0161e re\u0161enja ispisati bilo koje.</p>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#ulaz","title":"Ulaz","text":"<pre><code>5 7 2\n1 2 3\n4 4 1\n</code></pre>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#izlaz","title":"Izlaz","text":"<pre><code>3 7\n</code></pre>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<pre><code>Slika 1  Slika 2  Slika 3\n1011122  6543456  1011122\n1111222  5432345  1111222\n1112223  4321234  1111223\n2122233  3210123  2110123\n2222333  4321234  2221233\n</code></pre> <p>Slike 1 i 2 predstavljaju koliko najmanje poteza je potrebno prvom i drugom traga\u010du da do\u0111u do odgovaraju\u0107ih polja u parku, tim redom. Na slici 3 vidimo skrivenost svakog polja. Primetimo da je najve\u0107a skrivenost nekog polja jednaka 3 i da ukupno takvih polja ima 4. Bilo koje od tih polja je re\u0161enje.</p>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,M,K \\leq 1.000\\)</li> <li>\\(1\\leq V_i \\leq 10^9\\)</li> <li>Nikoja dva traga\u010da ne\u0107e imati iste koordinate.</li> </ul>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u 5 disjuntknih grupa:</p> <ul> <li>U test primerima vrednim 10 poena va\u017ei \\(K=1\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(1\\leq N,M\\leq 100\\).</li> <li>U test primerima vrednim 20 poena va\u017ei da su brzine svih traga\u010da jednake.</li> <li>U test primerima vrednim 20 poena va\u017ei \\(1\\leq V_i\\leq 50\\).</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#prva-dva-podzadatka","title":"Prva dva podzadatka:","text":"<p>Traga\u010d \\(i\\) \u010dini da neko polje \\((x,y)\\) ima skrivenost najvi\u0161e \\(\\lceil\\frac{|X_i-x|+|Y_i-y|}{V_i}\\rceil\\). Skrivenost polja je minimalna skrivenost od svih traga\u010da. Ako za svako polje to odredimo preko grube sile imamo algoritam slo\u017eenosti \\(O(N\\cdot M\\cdot K)\\).</p>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Potrebno je br\u017ee proveriti skrivenost svakog polja. Po\u0161to su brzine jednake, to mo\u017eemo uraditi pretragom u \u0161irini sa izvorom u koordinatama svakog traga\u010da. Izra\u010duna\u0107emo polje koje ima najve\u0107u udaljenost od svakog traga\u010da i podeli\u0107emo je sa konstantnom brzinom kako bismo dobili skrivenost. Slo\u017eenost je \\(O(N\\cdot M)\\).</p>"},{"location":"takprog/2014_2015/drz/03_anti_zmurke/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Kada brzine nisu jednake, mo\u017eemo raditi binarnu pretragu po re\u0161enju: potrebno je proveriti da li je datu skrivenost mogu\u0107e posti\u0107i. Ta\u010dnije, ako je skrivenost \\(S\\) mogu\u0107a, za svakog traga\u010da \\(i\\) znamo da pokriva sva polja na udaljenosti \\(S\\cdot V_i\\) i da nakon toga ostaje bar jedno slobodno polje (i njega je potrebno ispisati za najve\u0107u skrivenost). Ako ne ostaje slobodno polje, tra\u017eena skrivenost nije mogu\u0107a.  Proveru da li ono postoji radimo pretragom u \u0161irini, ali ne preko reda nego preko niza vektora: za svaku \"dubinu\" pamtimo sva polja koja se nalaze na njoj. Susedna polja koja nisu pose\u0107ena u slede\u0107em koraku imaju dubinu za jednu manju od trenutne. Najmanja mogu\u0107a dubina pose\u0107enog polja je \\(0\\). Izvori imaju koordinate \\((X_i,Y_i)\\) i dubinu \\(S\\cdot V_i\\).</p> 03_anti_zmurke.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 2010;\nconst int MAX_K = 1000100;\n\nstruct seeker\n{\n    int x, y, v;\n};\n\nint n, m, k;\nseeker s[MAX_K];\nint solX, solY;\nint d[MAX_N][MAX_N];\n\nbool covered(int time)\n{\n    memset(d, 0, sizeof(d));\n    for (int i = 1; i &lt;= k; i++)\n    {\n        int r = time * s[i].v;  // time &lt;= n + m, s[i].v &lt;= n + m\n        if (r &gt; n + m) r = n + m;  // r &lt;= n + m\n\n        int x = s[i].x - r;  // od vrha do sredine\n        int y = s[i].y;\n        for (int j = 0; j &lt;= r; j++)\n        {\n            d[max(x + j, 1)][max(y - j, 1)] += 1;\n            d[max(x + j, 1)][min(y + j, m) + 1] -= 1;\n        }\n\n        x = s[i].x + r;  // od dna do sredine\n        y = s[i].y;\n        for (int j = 0; j &lt; r; j++)\n        {\n            d[min(x - j, n)][max(y - j, 1)] += 1;\n            d[min(x - j, n)][min(y + j, m) + 1] -= 1;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int sum = 0;\n        for (int j = 1; j &lt;= m; j++)\n        {\n            sum = sum + d[i][j];\n            if (sum == 0)\n            {\n                solX = i;\n                solY = j;\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);\n    for (int i = 1; i &lt;= k; i++)\n    {\n        scanf(\"%d%d%d\", &amp;s[i].x, &amp;s[i].y, &amp;s[i].v);\n        if (s[i].v &gt; n + m) s[i].v = n + m;\n    }\n\n    int l = 0, r = n + m;\n    while (l &lt;= r)\n    {\n        int mid = (l + r) / 2;\n        if (covered(mid))\n            r = mid - 1;\n        else\n            l = mid + 1;\n    }\n\n    printf(\"%d %d\\n\", solX, solY);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/04_zamena/","title":"A1 - Zamena","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Mali Piksel, dugogodi\u0161nji \u010dlan Tajne Komisije u senci, je odlu\u010dio da posle mnogo godina odane slu\u017ebe Komisiji podnese ostavku. Me\u0111utim, kako ne \u017eeli da njegov odlazak protekne nezapa\u017eeno, odlu\u010dio je da \u0161ifrira svoj poslednji predlog zadatka za Dr\u017eavno takmi\u010denje iz programiranja, koriste\u0107i klju\u010d koji je samo njemu poznat. Ostalim \u010dlanovima Komisije ostavio je samo jedan niz koji sadr\u017ei sve njihove identifikacione brojeve (identifikacioni brojevi su fiksne du\u017eine i ne moraju biti jedinstveni), kao i tekst problema koji \u010dlanovi Komisije moraju re\u0161iti da bi do\u0161li do klju\u010da:</p> <p>Piksel je najpre prolazio kroz niz, od prvog elementa prema poslednjem, sve dok nije odabrao jedan identifikacioni broj i zapamtio ga. Zatim je nastavio prolaz kroz niz, i ukoliko bi nai\u0161ao na veoma sli\u010dan identifikacioni broj (takav da se razlikuje od zapam\u0107enog najvi\u0161e u jednoj cifri) imao bi dve opcije:</p> <ul> <li>da zapamti novi broj umesto starog i da nastavi dalje kroz niz na isti na\u010din;</li> <li>da nastavi dalje bez promene zapam\u0107enog broja.</li> </ul> <p>Piksel tako\u0111e \u010duva ukupan broj \u201dbodova\u201d koji je osvojio pri prolazu kroz niz; u po\u010detku broj bodova je 0, me\u0111utim pri svakom pam\u0107enju novog broja, broj bodova se pove\u0107ava za apsolutnu razliku cifre starog i novog broja na onoj poziciji u kojoj se novi broj razlikuje od starog (npr. ukoliko je prethodno zapam\u0107eni broj bio 1234, a novi zapam\u0107eni broj je 1274, onda se broj bodova pove\u0107ava za 4). Potrebno je odrediti najve\u0107i mogu\u0107i osvojen broj bodova.</p> <p>Dr\u017eavno takmi\u010denje iz programiranja je ve\u0107 po\u010delo, a Komisija nije uspela de\u0161ifrovati zadatak i nije u mogu\u0107nosti da takmi\u010darima ponudi novi. Stoga su vas zamolili za pomo\u0107 pri de\u0161ifrovanju; kao dodatnu motivaciju nude vam 100 dodatnih bodova na Dr\u017eavnom takmi\u010denju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vanja Petrovi\u0107 Tankovi\u0107 Petar Veli\u010dkovi\u0107 Aleksandar Vi\u0161nji\u0107 Vanja Petrovi\u0107 Tankovi\u0107"},{"location":"takprog/2014_2015/drz/04_zamena/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\), koji predstavlja ukupan broj \u010dlanova Tajne komisije u senci. U svakom od narednih \\(N\\) redova nalazi se po jedan ceo broj \\(A_i\\), koji predstavlja identifikacioni broj teku\u0107eg \u010dlana Komisije u nizu.</p>"},{"location":"takprog/2014_2015/drz/04_zamena/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati broj \\(M\\), koji predstavlja maksimalan broj bodova koji je Mali Piksel mogao da osvoji.</p>"},{"location":"takprog/2014_2015/drz/04_zamena/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/04_zamena/#ulaz","title":"Ulaz","text":"<pre><code>6\n8823\n2145\n2185\n3385\n4145\n4445\n</code></pre>"},{"location":"takprog/2014_2015/drz/04_zamena/#izlaz","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2014_2015/drz/04_zamena/#objasenjenje-primera","title":"Obja\u0161enjenje primera","text":"<p>Piksel najpre bira da zapamti broj 2145. Zatim odmah ima opciju da zapamti 2185, me\u0111utim on odbija to da u\u010dini \u2013 po\u0161to ukoliko odabere da zapamti tek 4145, pa 4445 nedugo zatim, osvaja 5 bodova:</p> \\[ 2145\\rightarrow 4145\\rightarrow 4445 \\Rightarrow br\\_bodova=(4-2)+(4-1)= 5 \\] <p>Ne postoji ni jedna strategija kojom Piksel mo\u017ee osvojiti vi\u0161e od 5 bodova.</p>"},{"location":"takprog/2014_2015/drz/04_zamena/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena va\u017ei \\(N\\leq 1.000\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(A_i&lt;100\\).</li> <li>U test primerima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/drz/04_zamena/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Zadatak re\u0161avamo dinami\u010dkim programiranjem. Neka \\(dp_i\\) predstavlja maksimalan broj bodova koji je mogu\u0107e ostvariti ako Piksel zavr\u0161ava sa pam\u0107enjem na indeksu \\(i\\). Odgovor na zadatak je maksimalna vrednost niza \\(dp\\). Rekurentna jedna\u010dina je</p> \\[ dp_i=max(dp_j+f(i,j) | j&lt;i) \\] <p>gde funkcija \\(f(i,j)\\) predstavlja koliko se bodova dobija ako se sa prethodno zapam\u0107enog broja na poziciji \\(j\\) zapamti broj \\(i\\). Ona tako\u0111e iznosi \\(-\\infty\\) ako se novi broj razlikuje od starog za vi\u0161e od jedne cifre (nemogu\u0107 slu\u010daj). Slo\u017eenost ovog algoritma je \\(O(N^2 \\cdot C)\\), gde je \\(C\\) broj cifara svakog broja.</p>"},{"location":"takprog/2014_2015/drz/04_zamena/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Koristimo sli\u010dnu ideju, ali primetimo da je broj razli\u010ditih vrednosti \\(A_i\\) mali. Neka \\(dp_{i,j}\\) sada predstavlja maksimalan broj bodova koji je mogu\u0107e ostvariti na prefiksu niza \\(A_1,...,A_i\\) ako je poslednji zapam\u0107en broj jednak \\(j\\). Rekurentna jedna\u010dina je </p> \\[ dp_{i,j}=max(dp_{i-1,k}+f(A_i,k)) \\] <p>Funkcija \\(f(a,b)\\) se sli\u010dno defini\u0161e kao ranije - broj bodova koji se ostvaruje datim prelazom. Vremenska i memorijska slo\u017eenost je \\(O(N\\cdot maxAi)\\).</p>"},{"location":"takprog/2014_2015/drz/04_zamena/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Koristi\u0107emo sli\u010dno re\u0161enje kao i ranije. Najpre, primetimo da ima najvi\u0161e \\(10\\cdot C\\) razli\u010ditih mogu\u0107nosti za stari broj ako posmatramo neki odre\u0111eni novi koji pamtimo (\\(C\\) je broj cifara). Napravimo niz \\(dp_i\\) koji predstavlja matricu iz drugog podzadatka, samo \u0161to ne\u0107emo pamtiti ni\u0161ta za prefiks nego \u0107emo je redom popunjavati kako bismo u\u0161tedeli memoriju. To zna\u010di da za dato \\(i\\) rekurentna jedna\u010dina postaje</p> \\[ dp_{A_i}=dp_k+f(A_i,k) \\] <p>gde je \\(k\\) svaka mogu\u0107a mogu\u0107nost starog broja za koje smo ranije rekli da ih nema mnogo. Vremenska slo\u017eenost je \\(O(N\\cdot C\\cdot L)\\), a memorijska \\(O(maxAi)\\). \\(L\\) predstavlja broj razli\u010ditih cifara u dekadnom sistemu, odnosno iznosi \\(10\\)</p> 04_zamena.cpp<pre><code>/*\n Petar 'PetarV' Velickovic\n Task: Zamena\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX_N 100001\n#define MAX_NUM 10000000\n\nint n, len;\nint A[MAX_N];\n\nint dp[MAX_NUM];\nbool in[MAX_NUM];\n\nint ret = 0;\n\ninline int fetch_kth(int x, int k)\n{\n    for (int i=0;i&lt;k;i++) x /= 10;\n    return x % 10;\n}\n\ninline int set_kth(int x, int k, int v)\n{\n    int prev = fetch_kth(x, k);\n    int deg = 1;\n    for (int i=0;i&lt;k;i++) deg *= 10;\n    return x + (v - prev) * deg;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i=0;i&lt;n;i++)\n    {\n        scanf(\"%d\", &amp;A[i]);\n    }\n    len = 0;\n    int aa = A[0];\n    while (aa) { len++; aa /= 10; }\n\n    in[A[0]] = true;\n    for (int i=1;i&lt;n;i++)\n    {\n        int max_score = 0;\n        for (int j=0;j&lt;len;j++)\n        {\n            int stor = fetch_kth(A[i], j);\n            for (int dig=0;dig&lt;=9;dig++)\n            {\n                int curr = set_kth(A[i], j, dig);\n                int score = abs(stor - dig);\n                if (in[curr] &amp;&amp; dp[curr] + score &gt; max_score) max_score = dp[curr] + score;\n            }\n        }\n        dp[A[i]] = max_score;\n        in[A[i]] = true;\n    }\n\n    for (int i=0;i&lt;n;i++) if (dp[A[i]] &gt; ret) ret = dp[A[i]];\n\n    printf(\"%d\\n\", ret);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/05_brojanje/","title":"A2 - Brojanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 128MB <p>Mali haker Drejko redovno poku\u0161ava da izbegne izradu doma\u0107ih zadataka. Kako ih nije radio kada je bilo vreme, a pribli\u017eava se kontrolna ve\u017eba, shvatio je da mu se nakupilo \\(N\\) zadataka koje nije uradio. Me\u0111utim, umesto da se istog trenutka baci na posao, uo\u010dio je mnogo zanimljivu temu za razmi\u0161ljanje nakon \u0161to je svakom zadatku dodelio, po svojoj proceni, neki prirodan broj koji predstavlja koliko je dosadan (zadaci kojima su dodeljeni ve\u0107i brojevi su dosadniji).</p> <p>Drejkova odluka je da re\u0161i neki podniz uzastopnih zadataka iz zbirke. Me\u0111utim, taj podniz zadataka \u0107e odabrati tako da je najdosadnijem odabranom zadatku pridru\u017een neki dati broj \\(k\\). Postoji potencijalno mnogo ovakvih izbora zadataka, a svakog iole pristojnog hakera zanima koliko takvih izbora postoji. Po\u0161to je ovo muka i ve\u0107eg dela Tajne Komisije u Senci, koja broji \\(Q\\)  \u010dlanova (pri \u010demu su svi saglasni sa Drejkovom metrikom dosade), pomenuta Komisija \u0107e vas bogato nagraditi ukoliko joj re\u0161ite problem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Bakovi\u0107 Andrej Iva\u0161kovi\u0107 Milo\u0161 Puri\u0107 Marko Bakovi\u0107 <p>Podniz niza \\(A\\) od indeksa \\(i\\) do indeksa \\(j\\) ozna\u010davamo sa \\([i,j]\\), gde je \\(1 \\leq i,j \\leq N\\).</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se zadaje prirodan broj \\(N\\). U narednom redu se zadaje \\(N\\) prirodnih brojeva koji predstavljaju koliko je odgovaraju\u0107i zadatak u zbirci dosadan. U tre\u0107em redu se zadaje prirodan broj \\(Q\\), nakon \u010dega se u narednih \\(Q\\) redova nalazi po jedan prirodan broj \\(k\\), koji predstavlja upit \"koliko postoji podnizova uzastopnih zadataka iz zbirke takvih da je vrednost najdosadnijeg zadatka \\(k\\)?\".</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(Q\\) redova standardnog izlaza ispisati odgovore na upite iz ulaza onim redom kojim su bili zadati. Po\u0161to su izlazni brojevi potencijalno veliki, ispisati odgovore po modulu \\(10^9+7\\).</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/05_brojanje/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 2 3 4 3\n3\n2\n3\n4\n</code></pre>"},{"location":"takprog/2014_2015/drz/05_brojanje/#izlaz","title":"Izlaz","text":"<pre><code>2\n4\n8\n</code></pre>"},{"location":"takprog/2014_2015/drz/05_brojanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedini podnizovi uzastopnih zadataka \u010diji je maksimum dosade jednak 2 su [2] i [1,2].</p> <p>Podnizovi \u010diji je maksimum dosade jednak 3 su [1,2,3], [2,3], [3] i [3].</p> <p>Podnizovi \u010diji je maksimum dosade jednak 4 su [1,2,3,4], [1,2,3,4,3], [2,3,4], [2,3,4,3], [3,4], [3,4,3], [4], [4,3].</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 10^6\\)</li> <li>\\(1\\leq Q\\leq 10^6\\)</li> <li>\"Dosadnosti\" zadataka su prirodni brojevi koji nisu ve\u0107i od \\(10^9\\).</li> <li>Za sve \\(k\\) iz ulaza va\u017ei \\(1\\leq k\\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u disjunktne grupe.</p> <ul> <li>U test primerima vrednim 10 poena va\u017ee ograni\u010denja: \\(N\\leq 10\\), \\(Q\\leq 10\\), \"dosadnosti\" zadataka nisu ve\u0107e od \\(10\\).</li> <li>U test primerima dalje vrednim 10 poena je zadovoljeno \\(N\\leq 1000\\) i nijednom zadatku ne\u0107e biti pridru\u017eena \"dosadnost\" ve\u0107a od \\(1000\\).</li> <li>U test primerima dalje vrednim 30 poena je zadovoljeno \\(N\\leq 100\\).</li> <li>U preostalim test primerima nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/drz/05_brojanje/#resenje-za-1-leq-nqa_i-leq-10","title":"Re\u0161enje za \\(1 \\leq N,Q,A_i \\leq 10\\):","text":"<p>Dovoljno je za svaki upit isprobati svaki mogu\u0107i podniz uzastopnih brojeva.</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#resenje-za-1-leq-na_i-leq-1000","title":"Re\u0161enje za \\(1 \\leq N,A_i \\leq 1000\\) :","text":"<p>Mo\u017eemo za svaki podniz \\([i,j]\\) na\u0107i najve\u0107i broj u njemu \\(M\\) i pove\u0107ati broj podnizova sa maksimalnim elementom \\(M\\) za jedan. Tada na upite odgovaramo u konstantnom vremenu. Vremenska slo\u017eenost: \\(O(N^2+Q)\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#resenje-za-1-leq-n-leq-100","title":"Re\u0161enje za \\(1 \\leq N \\leq 100\\) :","text":"<p>Mo\u017eemo koristiti isto re\u0161enje kao u prethodnom podzadatku uz izmenu da umesto niza za brojanje podnizova sa maksimalnim elementom \\(M\\) koristimo C++ map-u. Vremenska slo\u017eenost: \\(O(N^2 \\cdot \\log(10^{9})+Q \\cdot \\log(10^{9}))\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2014_2015/drz/05_brojanje/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Ukoliko \u017eelimo da ba\u0161 element \\(A_i\\) bude najve\u0107i broj u nekom podnizu, mo\u017eemo to zamisliti kao da po\u010dinjemo od jedno\u010dlanog podniza \\([i,i]\\) koji poku\u0161avamo da \u0161to je vi\u0161e mogu\u0107e pro\u0161irimo ulevo i udesno uz uslov da njegov najve\u0107i element ostane \\(A_i\\). Mogu\u0107e je da pri tome stignemo do levog ili desnog kraja niza. Drugim re\u010dima, mo\u017eemo prona\u0107i indekse \\(l\\) i \\(r\\) takve da je \\(1 \\leq l \\leq i \\leq r \\leq N\\) i da za svaki indeks \\(j\\) od \\(l\\) do \\(r\\) va\u017ei \\(A_j \\leq A_i\\), i na kraju, da va\u017ei ili da je \\(l=1\\) ili \\(A_{l-1} &gt; A_i\\) kao i da va\u017ei ili \\(r=N\\) ili \\(A_{r+1} &gt; A_i\\). Neka \\(L_i\\) i \\(R_i\\) ozna\u010davaju upravo ove jedinstvene vrednosti \\(l\\) i \\(r\\) za fiskiran indeks \\(i\\).</p> <p>Vrednosti \\(L_i\\) i \\(R_i\\) mo\u017eemo izra\u010dunati pomo\u0107u strukture podataka poput C++ stack-a. Slede\u0107i pseudokod predstavlja algoritam za pronala\u017eenje \\(R_i\\) (za \\(L_i\\) je  postupak sli\u010dan):</p> <pre><code>S #prazan stek\nfor i = 1 . . . n:\nwhile(!S.empty &amp;&amp; a[i] &gt; a[S.top]) #dodeljujemo vrednosti R[i] manjim elementima u steku\nR[S.top] = i-1\nS.pop\nS.push(i)\n\nwhile(!S.empty)\nR[S.top] = N\nS.pop\n</code></pre> <p>Ove vrednosti nam govore dokle je dozvoljeno produ\u017eiti podniz u obe strane tako da najve\u0107a vrednost i dalje ostane \\(A_i\\). Zato je broj podnizova u kojima je najve\u0107i element ba\u0161 \\(A_i\\) jednak </p> \\[ C_i=(i-L_i+1) \\cdot (R_i-i+1) \\] <p>jer je bilo koja kombinacija dozvoljenih produ\u017eenja jedno\u010dlanog podniza \\([i,i]\\) ulevo i udesno validna - ulevo smemo produ\u017eiti za najvi\u0161e \\(i-L_i\\) pozicija a udesno za najvi\u0161e \\(R_i-i\\) pozicija.</p> <p>Kada bi svi elementi niza bili razli\u010diti, re\u0161enje bi prosto bilo \\(\\sum_{i=1}^{N} C_i\\). Me\u0111utim, kada postoje jednaki elementi, mo\u017ee se desiti da smo u vrednostima \\(C_i\\) za razli\u010dite indekse brojali iste podnizove vi\u0161e puta. Na primer, ako se vrednost \\(v\\) pojavljuje ta\u010dno dva puta, tj. \\(A_p = A_q=v\\) za \\(p &lt; q\\),  i ako je \\(L_q \\leq p\\) tada se neki podnizovi koje smo brojali u \\(C_q\\), a koji sadr\u017ee \\(A_p\\), pojavljuju i u \\(C_p\\). \u0160tavi\u0161e, kako je \\(L_q \\leq p\\), onda mora va\u017eiti i \\(R_q \\geq q\\), pa smo,  u stvari, sve podnizove koje smo brojali u \\(C_q\\), a koji sadr\u017ee \\(A_p\\), brojali i u \\(C_p\\) (\u010dak va\u017ei i potpuna jednakost ovih parametara, tj. \\(L_p=L_q\\) i \\(R_p=R_q\\), ali to je manje va\u017eno). Ovo zapa\u017eanje olak\u0161ava stvari jer sada broj podnizova u kojima je \\(v\\) najve\u0107a vrednost, bez vi\u0161estrukog brojanja istih podnizova, mo\u017eemo dobiti kao \\(C_p+C_q^{\\prime}\\), gde je \\(C_q^{\\prime}\\) ista vrednost \\(C_q\\), ali izra\u010dunata koriste\u0107i \\(L_q^{\\prime}=p+1\\) umesto stare vrednosti \\(L_q\\), tj. \\(C_q^{\\prime}=(q-(p+1)+1) \\cdot (R_q-q+1)\\).</p> <p>\u010cak i ako se dogodi da postoje vi\u0161e od dva pojavljivanja vrednosti \\(v\\) u nizu, na pozicijama \\(p_1,p_2, \\dots  ,p_k\\) (\\(1 \\leq p_1 &lt; p_2 &lt; \\dots &lt; p_k \\leq N\\)), broj podnizova u kojima je \\(v\\) najve\u0107a vrednost, bez vi\u0161estrukog brojanja istih podnizova, \u0107e biti</p> \\[ T_v=C_{p_1}+\\sum_{j=2}^{k} C_{p_j}^{\\prime} \\] <p>gde je \\(C_{p_j}^{\\prime}\\) vrednost \\(C_{p_j}\\) izra\u010dunata koriste\u0107i \\(L_{p_j}^{\\prime}=p_{j-1}+1\\) umesto stare vrednosti \\(L_{p_j}\\) u slu\u010daju da va\u017ei \\(L_{p_j} \\leq p_{j-1}\\), ili samo \\(C_{p_j}\\) ina\u010de. Zna\u010di:</p> \\[ C_{p_j}^{\\prime}=\\left\\{ \\begin{array}{l}       (p_j-(p_{j-1}+1)+1) \\cdot (R_{p_j}-p_j+1), \\text{ ako }  L_{p_j} \\leq p_{j-1}\\\\       C_{p_j}, \\text{ ina\u010de} \\end{array} \\right. \\] <p>Dakle, ako leva granica za pro\u0161irivanje podniza \\([i,i]\\) trenutnog elementa \\(A_i\\) obuhvata prethodni element iste vrednosti \\(A_j\\) \\((j &lt; i)\\), dovoljno je na ovaj na\u010din promeniti \\(L_i\\) da bismo izbegli vi\u0161estruko brojanje. Sada mo\u017eemo izra\u010dunati \\(T_v\\) za svaku vrednost \\(v\\) koja se pojavljuje u nizu, \u010duvati je u C++ map-i i tako dati odgovor na svaki od \\(Q\\) upita u \\(O(\\log (10^{9}))\\). </p> <p>Vremenska slo\u017eenost: \\(O((N+Q) \\cdot \\log(10^9))\\), memorijska slo\u017eenost: \\(O(N)\\).</p> 05_brojanje.cpp<pre><code>/*\n    ZADATAK: brojanje, A2 drzavno 2015.\n    AUTOR ZADATKA: Marko Bakovic\n    AUTOR RESENJA: Andrej Ivaskovic\n\n    Za ovo resenje je predvidjeno 100 poena. Zasniva se na\n    \"postepenom\" izbacivanju elemenata iz niza, i to u rastucem\n    (odnosno neopadajucem) redosledu. Pri izbacivanju nastaju\n    \"supljine\" u kojima mogu da budu granice podnizova. Uz\n    pazljivo belezenje podataka o ovim supljinama je moguce u\n    O(1) slozenosti dobiti broj podnizova ciji je maksimum neki\n    element na nekoj poziciji.\n    (U slucaju jednakosti elemenata ipak uvodimo neki proizvoljan\n    poredak medju njima.)\n\n    Slozenost ovog resenja je O((Q + N) log N), pri cemu log N\n    faktor potice od sortiranja i od binarne pretrage.\n*/\n\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int maxN = 1000000;\nconst long long MOD = 1000000007;\n\nstruct parVredIdx\n{\n    int v;\n    long long idx;\n    long long r;\n} p[maxN];\n\nstruct parVredRez\n{\n    int v;\n    long long r;\n} q[maxN];\n\nbool operator &lt;(parVredIdx x, parVredIdx y)\n{\n    return x.v &lt; y.v || (x.v == y.v &amp;&amp; x.idx &lt; y.idx);\n}\n\nint N, Q;\nint A[maxN];\nint k;\nbool suplje[maxN];\nint levo[maxN], desno[maxN];\nint brojVrednosti;\nint poz;\n\nint binPret(int vred)\n{\n    int l = 0, d = brojVrednosti - 1, s;\n    while (l &lt; d)\n    {\n        s = (l + d) / 2;\n        if (vred == q[s].v)\n            l = d = s;\n        else if (vred &lt; q[s].v)\n            d = s - 1;\n        else\n            l = s + 1;\n    }\n    if (q[l].v == vred)\n        return l;\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;N);\n    for (int i = 0; i &lt; N; i++)\n    {\n        scanf(\"%d\", &amp;A[i]);\n        p[i].v = A[i];\n        p[i].idx = i;\n        p[i].r = 0L;\n        suplje[i] = false;\n        levo[i] = desno[i] = -1;\n    }\n    sort(p, p + N);\n    for (int i = 0; i &lt; N; i++)\n    {\n        suplje[p[i].idx] = true;\n        levo[p[i].idx] = desno[p[i].idx] = p[i].idx;\n        if (p[i].idx - 1 &gt;= 0 &amp;&amp; suplje[p[i].idx - 1])\n            levo[p[i].idx] = levo[p[i].idx - 1];\n        if (p[i].idx + 1 &lt; N &amp;&amp; suplje[p[i].idx + 1])\n            desno[p[i].idx] = desno[p[i].idx + 1];\n        p[i].r = (p[i].idx - levo[p[i].idx] + 1) * (desno[p[i].idx] - p[i].idx + 1) % MOD;\n        levo[desno[p[i].idx]] = levo[p[i].idx];\n        desno[levo[p[i].idx]] = desno[p[i].idx];\n    }\n    brojVrednosti = 1;\n    q[0].v = p[0].v;\n    q[0].r = p[0].r;\n    for (int i = 1; i &lt; N; i++)\n    {\n        if (p[i].v == p[i - 1].v)\n        {\n            q[brojVrednosti - 1].r += p[i].r;\n            q[brojVrednosti - 1].r %= MOD;\n        }\n        else\n        {\n            q[brojVrednosti].v = p[i].v;\n            q[brojVrednosti].r = p[i].r;\n            brojVrednosti++;\n        }\n    }\n    scanf(\"%d\", &amp;Q);\n    for (int i = 0; i &lt; Q; i++)\n    {\n        scanf(\"%d\", &amp;k);\n        poz = binPret(k);\n        if (poz == -1)\n            printf(\"0\\n\");\n        else\n            printf(\"%lld\\n\", q[poz].r);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/","title":"A3 - Kontra-\u017emurke","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>\u010clanovi Tajne komisije u senci su prili\u010dno besposleni ovih dana pa u obli\u017enjem parku igraju kontra-\u017emurke. Kontra-\u017emurke su potezna de\u010dja igra u kojoj se jedan igra\u010d krije dok ga jedan ili vi\u0161e igra\u010da, koje nazivamo traga\u010dima, tra\u017ei.</p> <p>Park je pravougaonih dimenzija i podeljen je na jedini\u010dne kvadrate. Svako kvadratno polje predstavlja ili prohodni \u017ebun ili neprohodno drvo. Za svakog traga\u010da je poznata njegova po\u010detna pozicija kao i brzina koja predstavlja koliko polja mo\u017ee pre\u0107i u jednom potezu. Sa trenutnog polja traga\u010d mo\u017ee pre\u0107i samo na neko od \u010detiri susedna polja. Dva polja su susedna ukoliko imaju zajedni\u010dku stranicu. Svi traga\u010di u isto vreme kre\u0107u sa potragom.</p> <p>Red je na malog Zokija da se sakrije. On \u017eeli da bude \u0161to bolji u ovoj igri pa \u017eeli da se sakrije u \u017ebunu na polju \u010dija je skrivenost najve\u0107a mogu\u0107a. Skrivenost nekog polja je celobrojna vrednost koja predstavlja u koliko najmanje poteza neki od traga\u010da mo\u017ee sti\u0107i do tog polja kre\u0107u\u0107i se najkra\u0107im putem. Pomozite Zokiju da prona\u0111e polje sa najve\u0107om skriveno\u0161\u0107u jer su traga\u010di ve\u0107 po\u010deli sa odbrojavanjem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Dimi\u0107 Dimitrije Dimi\u0107 Aleksandar Vi\u0161nji\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(M\\), koji predstavljaju dimenzije parka. Svaki od narednih \\(N\\) redova sadr\u017ei niz od \\(M\\) cifara iz skupa \\(\\{0, 1\\}\\) bez razmaka \u2013 izgled parka. \\(0\\) ozna\u010dava da se na odgovaraju\u0107em mestu nalazi \u017ebun, a \\(1\\) drvo. Zatim sledi broj traga\u010da \\(K\\) i u narednih \\(K\\) redova koordinate po\u010detne pozicije \\(X_i\\) i \\(Y_i\\) (redni broj reda i kolone) i brzina \\(V_i\\) za svakog od njih. Redovi su numerisani od \\(1\\) do \\(N\\) odozgo nadole a kolone od \\(1\\) do \\(M\\) sleva nadesno.</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati dva broja \\(i\\) i \\(j\\) \u2013 redni broj reda i kolone polja na kojem se Zoki treba sakriti u skladu sa svojim zahtevom. Ukoliko postoji vi\u0161e re\u0161enja ispisati bilo koje.</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#ulaz","title":"Ulaz","text":"<pre><code>5 7\n0010000\n0100000\n0000110\n0000000\n0000000\n2\n1 2 3\n4 4 1\n</code></pre>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#izlaz","title":"Izlaz","text":"<pre><code>2 6\n</code></pre>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<pre><code>Slika 1   Slika 2   Slika 3\n10X3344   67X3456   10X3344\n1X23334   5X32345   1X22334\n1222XX4   4321XX4   1221XX4\n2223334   3210123   2210123\n2233344   4321234   2221234\n</code></pre> <p>Na datim slikama neprohodna polja ozna\u010dena su X-om. Slike 1 i 2 predstavljaju koliko najmanje poteza je potrebno prvom i drugom traga\u010du da do\u0111u do odgovaraju\u0107ih polja u parku, tim redom. Na slici 3 vidimo skrivenost svakog polja. Primetimo da je najve\u0107a skrivenost nekog polja jednaka 4 i da ukupno takvih polja ima 5. Bilo koje od tih polja je re\u0161enje.</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,M \\leq 1,000\\)</li> <li>\\(1\\leq K\\leq 1,000,000\\)</li> <li>\\(1\\leq V_i\\leq 10^9\\)</li> <li>U parku \u0107e biti prohodnog puta od svakog do svakog \u017ebuna.</li> <li>Nikoja dva traga\u010da ne\u0107e imati iste koordinate.</li> <li>Po\u010detne pozicije traga\u010da \u0107e biti na polju sa \u017ebunom.</li> </ul>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u 4 disjuntkne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei da su brzine svih traga\u010da jednake.</li> <li>U test primerima vrednim 20 poena va\u017ei \\(1\\leq N,M\\leq 400\\), \\(1\\leq V_i\\leq 400\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(1\\leq K\\leq 1,000\\) i sva polja su prohodna.</li> <li>U test primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Dat je lavirint predstavljen matricom. Skrivenost polja u ovom podzadatku jednaka je udaljenosti od najbli\u017eeg traga\u010da. Te udaljenosti tra\u017eimo primenom pretrage u \u0161irinu. Potrebno je postaviti vi\u0161e izvora - u svakom traga\u010du. Slo\u017eenost je \\(O(NM)\\).</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>U ovom podzadatku mogu\u0107e je implementirati odvojeni algoritam pretrage u \u0161irinu za svakog traga\u010da nezavisno. Napomenimo da traga\u010de koji imaju istu brzinu smatarmo istim - sli\u010dno kao i ranije, za svakog takvog postavljamo vi\u0161e izvora. Simuliramo svaki trenutak vremena, i u njemu za svakog traga\u010da odredimo najve\u0107u \"dubinu\" do koje mo\u017ee sti\u0107i. Te dubine a\u017euriramo standardno u algoritmu pretrage. Potrebno je prona\u0107i poslednji trenutak u kome postoji slobodno polje. On je brojno jednak skrivenosti. Direktna implementacija navedenog daje re\u0161enje slo\u017eenosti \\(O(NMV)\\), gde \\(V\\) predstavlja najve\u0107u brzinu nekog traga\u010da.</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Koristimo prethodnu ideju za posmatranje trenutaka. Primetimo da ako u nekom trenutku \\(T\\) postoji skriveno polje, onda postoji i u trenutku \\(T-1\\). Dok ako u trenutku \\(T\\) ne postoji, onda ne postoji ni u \\(T+1\\). Odavde zaklju\u010dujemo da su trenuci binarno pretra\u017eivi, tj. koristi\u0107emo binarnu pretragu po vrednosti re\u0161enja. Ta\u010dnije, ako je skrivenost \\(S\\) mogu\u0107a, za svakog traga\u010da \\(i\\) znamo da pokriva sva polja na udaljenosti \\(S\\cdot V_i\\) i da nakon toga ostaje bar jedno slobodno polje (i njega je potrebno ispisati za najve\u0107u skrivenost). Ako ne ostaje slobodno polje, tra\u017eena skrivenost nije mogu\u0107a.  Proveru da li ono postoji radimo pretragom u \u0161irini, ali ne preko reda nego preko niza vektora: za svaku \"dubinu\" pamtimo sva polja koja se nalaze na njoj. Susedna polja koja nisu pose\u0107ena u slede\u0107em koraku imaju dubinu za jednu manju od trenutne. Najmanja mogu\u0107a dubina pose\u0107enog polja je \\(0\\). Izvori imaju koordinate \\((X_i,Y_i)\\) i dubinu \\(S\\cdot V_i\\). </p> <p>Slo\u017eenost ovog re\u0161enja je \\(O((NM+K)\\log (NM)\\).</p>"},{"location":"takprog/2014_2015/drz/06_kontra_zmurke/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Re\u0161enje se su\u0161tinski ne razlikuje od prethodnog. Potrebno je ura\u010dunati blokirana polja, i eventualno optimizovati re\u0161enje. Slo\u017eenost je \\(O((NM+K)\\log (NM)\\).</p> 06_kontra_zmurke.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define DEBUG (false)\nusing namespace std;\n\nstruct tragac{\n    int x,y,v;\n    inline friend bool operator &lt;(tragac a,tragac b){\n        return a.v &lt; b.v;\n    }\n};\n\nint N,M,K;\ntragac T[1000005];\nchar A[1005][1005];\n\nvoid ucitaj_matricu(){\n    int i;\n    scanf(\"%d%d\",&amp;N,&amp;M);\n    for (i=1; i&lt;=N; i++){\n        scanf(\"%s\",A[i]+1);\n    }\n}\n\nvoid ucitaj_tragace(){\n    scanf(\"%d\",&amp;K);\n    int i;\n    for (i=1; i&lt;=K; i++){\n        scanf(\"%d%d%d\",&amp;T[i].x,&amp;T[i].y,&amp;T[i].v);\n    }\n    sort(T+1,T+K+1);\n}\n\nint D[1005][1005];\n\nint Qx[2000005],Qy[2000005],qs,qe; //mozda treba veci queue\nint K2;\n\nvoid citaj_red(int &amp;x,int &amp;y){\n    //T[0].x tj. y je inic. na 0, ok\n    if (K2==0 || D[Qx[qs]][Qy[qs]] &gt; D[T[K2].x][T[K2].y] &amp;&amp; qs&lt;=qe){\n        x = Qx[qs];\n        y = Qy[qs++];\n    } else {\n        x = T[K2].x;\n        y = T[K2--].y;\n    }\n    if (DEBUG) printf(\"dequeue %d %d %d\\n\",x,y,D[x][y]);\n}\n\nvoid upisi_red(int x,int y,int d){\n    if (D[x][y]==-1) return;\n    if (d &lt;= D[x][y]) return;\n    D[x][y] = d;\n    if (DEBUG) printf(\"enqueue %d %d %d\\n\",x,y,d);\n    Qx[++qe] = x;\n    Qy[qe] = y;\n}\n\nvoid bfs_debug(){\n    int i,j;\n    puts(\"----------------------\");\n    for (i=1; i&lt;=N; i++){\n        for (j=1; j&lt;=M; j++){\n            printf(\"%3d \",D[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nvoid bfs(int mult,int &amp;x0,int &amp;y0){\n    int i,j,k,x,y,d;\n    x0=y0=-1;\n    memset(D,255,sizeof(D)); //postavi -1\n    for (i=1; i&lt;=N; i++){\n        for (j=1; j&lt;=M; j++){\n            if (A[i][j]=='0') D[i][j] = 0;\n        }\n    }\n    //mnozimo brzine sa mult i ubacujemo u matricu\n    for (i=1; i&lt;=K; i++){\n        D[T[i].x][T[i].y] = ((1ll*T[i].v*mult+1) &gt; 12345678)?12345678:(T[i].v*mult+1);\n    }\n    //krecemo u bfs\n    K2=K;\n    qs=1;\n    qe=0;\n    while (qs&lt;=qe || K2&gt;0){\n        citaj_red(x,y);\n        d = D[x][y]-1;\n        upisi_red(x-1,y,d);\n        upisi_red(x+1,y,d);\n        upisi_red(x,y-1,d);\n        upisi_red(x,y+1,d);\n    }\n    if (DEBUG){\n        printf(\":::::: %d\\n\",mult);\n        bfs_debug();\n    }\n    for (i=1; i&lt;=N; i++){\n        for (j=1; j&lt;=M; j++){\n            if (D[i][j] == 0){\n                x0 = i;\n                y0 = j;\n                goto doublebreak;\n            }\n        }\n    }\n    doublebreak:;\n}\n\nvoid resi(){\n    int l,r,m,x,y,xo,yo;\n    l=1;\n    r=12345678;\n    xo=yo=-1;\n    while (l&lt;=r){\n        m = (l+r)/2;\n        bfs(m,x,y);\n        if (x==-1){\n            r = m-1;\n        } else {\n            xo = x;\n            yo = y;\n            l = m+1;\n        }\n    }\n    if (xo==-1){\n        if (DEBUG) printf(\"trigger\\n\");\n        for (l=1; l&lt;=N; l++){\n            for (r=1; r&lt;=M; r++){\n                if (A[l][r]=='0'){\n                    xo=l;\n                    yo=r;\n                    goto dbb;\n                }\n            }\n        }\n    }\n    dbb:\n    printf(\"%d %d\\n\",xo,yo);\n}\n\nint main(){\n    ucitaj_matricu();\n    ucitaj_tragace();\n    resi();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/01_misterija/","title":"1 - Misterija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Trenutno se vodi veliki sajber-rat izme\u0111u dve najve\u0107e hakerske grupe; \u201dAnonimni\u201d i \u201dHakerinati\u201d. Mali Perica, \u010dlan Anonimnih, je dobio naizgled te\u017eak zadatak: da probije \u201dMisteriju\u201d, ma\u0161inu preko koje se \u0161ifriraju sve poruke unutar Hakerinata. Algoritam koji ova ma\u0161ina koristi je nepoznat, ali se zna da se za \u0161ifrovanje i de\u0161 ifrovanje koriste celobrojni klju\u010devi \\(A\\) i \\(B\\), koji se povremeno menjaju.</p> <p>Perica je, me\u0111utim, saznao da vo\u0111a Hakerinata obave\u0161tava celu grupu o promeni klju\u010da na jako nesiguran na\u010din - tako \u0161to objavi fajl koji u sebi sadr\u017ei dva cela broja koja predstavljaju zbir i razliku novih klju\u010deva. Fajl se samouni\u0161tava posle 50 sekundi, a Perici treba ta\u010dno 49.9 da bi probio na mre\u017eu i pristupio mu; samim tim, nema dovoljno vremena da prepi\u0161e ove brojeve. Na vama je da napi\u0161ete program koji \u0107e mu pomo\u0107i da otkrije nove klj u\u010deve</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Boris Grubi\u0107 <p>Problem Misterija bio je ubedljivo najlak\u0161i zadatak na ovogodi\u0161njim Kvalifikacijama, i predstavlja \u0161kolski tip problema. Svi takmi\u010dari su poku\u0161ali ovaj zadatak ove godine, od \u010dega je 564 takmi\u010dara uspe\u0161no osvojilo 100 bodova; prose\u010dan broj osvojenih poena je 92.072, \u0161to \u010dini ovaj problem definitivno najlak\u0161im na svim Kvalifikacijama do sada.</p> <p>Problem se jednostavno formuli\u0161e na slede\u0107i na\u010din:</p> <p>Za data dva cela broja \\(Z\\) i \\(R\\), odrediti cele brojeve \\(A\\) i \\(B\\) tako da va\u017ei: \\(A+B=Z\\), \\(A-B=R\\).</p> <p>Do ta\u010dnog re\u0161enja dolazimo jednostavnim preme\u0161tanjem ovog sistema jedna\u010dina:</p> \\[ Z=A+B \\rightarrow B=Z-A \\] \\[ R=A-B \\rightarrow R=A-(Z-A) \\rightarrow A=(Z+R)/2 \\] \\[ B=Z-\\frac{Z+R}{2} \\rightarrow B=\\frac{Z-R}{2} \\]"},{"location":"takprog/2014_2015/kv1/01_misterija/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se dva cela broja, \\(Z\\) i \\(R\\), odvojena razmakom, koji predstavljaju zbir i razliku klju\u010deva \\(A\\) i \\(B\\), redom.</p>"},{"location":"takprog/2014_2015/kv1/01_misterija/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati tra\u017eene klju\u010deve \\(A\\) i \\(B\\), odvojene razmakom.</p>"},{"location":"takprog/2014_2015/kv1/01_misterija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/01_misterija/#ulaz","title":"Ulaz","text":"<pre><code>11 1\n</code></pre>"},{"location":"takprog/2014_2015/kv1/01_misterija/#izlaz","title":"Izlaz","text":"<pre><code>6 5\n</code></pre>"},{"location":"takprog/2014_2015/kv1/01_misterija/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Za \\(A=6\\) i \\(B=5\\) va\u017ei:</p> \\[ Z = A+B = 11; \\] \\[ R = A-B = 1. \\]"},{"location":"takprog/2014_2015/kv1/01_misterija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(-15000 \\leq A, B \\leq 15000\\).</li> </ul>"},{"location":"takprog/2014_2015/kv1/01_misterija/#uobicajene-greske","title":"Uobi\u010dajene gre\u0161ke","text":"<p>Takmi\u010dari uglavnom nisu imali problema sa implementacijom re\u0161enja za ovaj zadatak. Jedna zanimljiva gre\u0161ka potkrala se kod takmi\u010dara koji su ispitivali da li su ulazni podaci u intervalu [-15000,15000], i odbijali da re\u0161e test primer ukoliko to ne bi bio slu\u010daj. Me\u0111utim, u tekstu zadatka je jasno re\u010deno da su ova ograni\u010denja data za izlazne promenljive \\(A\\) i \\(B\\), a ne za ulazne promenljive \\(Z\\) i \\(R\\), tako da je odre\u0111en broj test primera pao ovim takmi\u010darima.</p> <p>Odre\u0111eni takmi\u010dari su poku\u0161avali da promenljive \\(A\\) i \\(B\\) na\u0111u dvostrukom for petljom po njima; ovo re\u0161enje na ve\u0107ini primera prekora\u010duje vremensko ograni\u010denje. Tako\u0111e je bilo takmi\u010dara koji su promenljive \\(A\\) i \\(B\\) \u010duvali u realnim tipovima i ispisivali ih sa decimalnim zarezom i odre\u0111enim brojem nula iza zareza (iako je nagla\u0161eno da \u0107e uvek biti celi); me\u0111utim, ocenjiva\u010d je u tom slu\u010daju odmah obave\u0161tavao takmi\u010dare da im je neta\u010dan izlaz na primeru iz teksta zadatka, te se nadamo da su ovu \u201dgre\u0161ku\u201d uspeli da isprave.</p> 01_misterija.cpp<pre><code>#include &lt;stdio.h&gt;\n\nint pl, mi;\n\nint main()\n{\n    scanf(\"%d%d\", &amp;pl, &amp;mi);\n    printf(\"%d %d\\n\", (pl + mi) / 2, (pl - mi) / 2);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/02_igra/","title":"2 - Igra","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>\u0110urica i Dragan\u010de se i pod stare dane takmi\u010de ko je vrsniji haker. Prethodnih decenija su to uvek poku\u0161avali da odrede igraju\u0107i razne, \u010desto vrlo komplikovane igre. Sada porede svoje ve\u0161tine pri radu sa upadima na ra\u010dunarske mre\u017ee.</p> <p>Odabrane su mre\u017ee ra\u010dunara koji su pore\u0111ani u niz. Mre\u017ea se sastoji od \\(N\\) ra\u010dunara, pri \u010demu se svaki od njih nalazi u posebnoj klasi u mre\u017ei, te va\u017ei da, ukoliko se bilo koji ra\u010dunar iz klase isklju\u010di, tada nijedan ra\u010dunar iz te klase vi\u0161e ne mo\u017ee da funkcioni\u0161e, te se automatski isklju\u010duje. \u0110urica i Dragan\u010de su od ovoga napravili igru: na izmeni\u010dno \u0107e isklju\u010divati neki od krajnjih uklju\u010denih ra\u010dunara u nizu. \u0110urica igra prvi. Pobednik je onaj igra\u010d nakon \u010dijeg poteza su svi ra\u010dunari isklju\u010deni. Zbog \u010dinjenice da jedna partija ove igre nije reprezentativna, \u0110urica i Dragan\u010de su odlu\u010dili da odigraju tri partije.</p> <p>Me\u0111utim, oni su zauzeti drugim poslovima i ne mogu sada da se igraju, pa su ostavili takmi\u010darima ovaj posao. Neophodno je odrediti koji igra\u010d \u0107e pobediti u kojoj rundi. Ukoliko ispravno odredite ko ima pobedni\u010dku strategiju, oni \u0107e vas nagraditi poenima na kvalifikacijama za okru\u017eno takmi\u010denje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Ivan Sto\u0161i\u0107 Milo\u0161 Puri\u0107 Boris Grubi\u0107"},{"location":"takprog/2014_2015/kv1/02_igra/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom, tre\u0107em i petom redu standardnog ulaza se nalaze redom prirodni brojevi \\(N_1\\), \\(N_2\\) i \\(N_3\\), brojevi ra\u010dunara u odgovaraju\u0107im partijama. U drugom, \u010detvrtom i \u0161estom redu se nalaze nizovi prirodnih brojeva \\(A\\), \\(B\\), \\(C\\) \u010dije su du\u017eine redom \\(N_1\\), \\(N_2\\), \\(N_3\\), pri \u010demu vrednost nekog elementa \\(A[i]\\) (odnosno \\(B[i]\\), \\(C[i]\\)) predstavlja redni broj klase u kojoj se nalazi \\(i\\)-ti ra\u010dunar iz prve runde (odnosno druge, tre\u0107e).</p>"},{"location":"takprog/2014_2015/kv1/02_igra/#opis-izlaza","title":"Opis izlaza","text":"<p>U tri reda standardnog izlaza ispisati brojeve koji predstavljaju ko ima pobedni\u010dku strategiju u prvoj, drugoj i tre\u0107oj partiji (tim redom). Ukoliko je u nekoj rundi pobednik \u0110urica, ispisa ti 1; u suprotnom, ispisati 2.</p>"},{"location":"takprog/2014_2015/kv1/02_igra/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/02_igra/#ulaz","title":"Ulaz","text":"<pre><code>4\n6 1 6 1\n3\n2 5 2\n2\n1 1\n</code></pre>"},{"location":"takprog/2014_2015/kv1/02_igra/#izlaz","title":"Izlaz","text":"<pre><code>2\n2\n1\n</code></pre>"},{"location":"takprog/2014_2015/kv1/02_igra/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvoj partiji, ma kako \u0110urica igrao na po\u010detku, osta\u0107e uklju\u010dena dva ra\u010dunara koji se nalaze u istoj klasi. Dragan\u010de ih u narednom potezu isklju\u010duje.</p>"},{"location":"takprog/2014_2015/kv1/02_igra/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N_1, N_2, N_3 \\leq 1000\\).</li> <li>Klase kojima ra\u010dunari pripadaju su predstavljene prirodnim brojevima ne ve\u0107im od \\(10^9\\).</li> <li>U test primerima ukupno vrednim \\(20\\) poena va\u017ei: \\(1 \\leq N_1, N_2, N_3 \\leq 2\\).</li> <li>U test primerima ukupno vrednim \\(20\\) poena va\u017ei: \\(1 \\leq N_1, N_2, N_3 \\leq 20\\).</li> </ul>"},{"location":"takprog/2014_2015/kv1/02_igra/#resenje-za-1-leq-n-leq-2","title":"Re\u0161enje za \\(1 \\leq N \\leq 2\\):","text":"<p>\\(N\\) je dovoljno malo da mo\u017eemo efikasno proveriti svaki mogu\u0107i potez igra\u010da i na taj na\u010din utvrditi ko pobe\u0111uje u igri. Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2014_2015/kv1/02_igra/#resenje-za-1-leq-n-leq-20","title":"Re\u0161enje za \\(1 \\leq N \\leq 20\\):","text":"<p>Mo\u017eemo simulirati igru isprobavaju\u0107i svaki mogu\u0107i sled poteza. U svakom potezu igra\u010d mo\u017ee isklju\u010diti neki od dva ra\u010dunara sa kraja niza, pa bi ovakav pristup imao vremensku slo\u017eenost \\(O(2^N)\\) i memorijsku slo\u017eenost \\(O(N)\\).</p>"},{"location":"takprog/2014_2015/kv1/02_igra/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Nakon svakog poteza jednog od igra\u010da, broj razli\u010ditih klasa iz kojih postoje upaljeni ra\u010dunari se smanji za jedan. Dakle, ukoliko je na po\u010detku broj razli\u010ditih klasa ra\u010dunara paran, u igri \u0107e pobediti Dragan\u010de, a u suprotnom \u0110urica. Po\u0161to brojevi u nizu mogu biti ne\u0161to ve\u0107i, mo\u017eemo koristiti strukturu poput C++ map-e za brojanje razli\u010ditih vrednosti, pa bi vremenska slo\u017eenost re\u0161enja bila \\(O(N \\cdot \\log(10^9))\\) a memorijska slo\u017eenost \\(O(N)\\).</p> <p>Alternativno re\u0161enje mo\u017eete videti na slede\u0107oj adresi.</p> 02_igra.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint A[1005],N,t,i,br;\n\nint main(){\n    for (t=1; t&lt;=3; t++){\n        scanf(\"%d\",&amp;N);\n        for (i=1; i&lt;=N; i++) scanf(\"%d\",A+i);\n        sort(A+1,A+N+1);\n        br = 1;\n        for (i=2; i&lt;=N; i++) if (A[i]!=A[i-1]) br++;\n        printf(\"%d\\n\",2-br%2);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/","title":"3 - Retrovirus","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Mali Perica, haker i bioinformati\u010dar, je uspe\u0161no izveo svoj najve\u0107i hakerski poduhvat do sada \u2013 uspe\u0161no je pristupio strogo \u010duvanoj bazi podataka ZBO-a (Zavoda za Biotehnolo\u0161ko Oru\u017eje), za koji se sumnja da je kreator mnogobrojnih virusa koji su izazivali pandemije u pro\u0161losti. U ovoj bazi je na\u0161ao, me\u0111u brojnim tajnim projektima, i prototip nove vrste retrovirusa koji bi potencijalno mogao izazvati novu, neizle\u010divu, bolest.</p> <p>Retrovirusi sve svoje genetske informacije pomo\u0107u kojih napadaju \u0107elije doma\u0107ina \u010duvaju u jednoj niti ribonukleinske kiseline (RNK). RNK nit se sastoji iz niza nukleotida, koji mogu biti adenin (A), uracil (U), citozin (C) ili guanin (G).</p> <p>Perica je saznao da je prototip zapravo mutirana verzija poznatog retrovirusa \u2013 samim tim, o\u010dekuje se da postoje regioni (podnizovi) u kojima su ova dva virusa izrazito \u201dsli\u010dna\u201d. Sli\u010dnost dva regiona iste du\u017eine \u0107emo definisati kao broj mesta na kojima im se nukleotidi poklapaju; na primer, sli\u010dnost regiona \"ACAGU\" sa regionom \"AGAGA\" je 3 (nukleotidi se poklapaju na prvoj, tre\u0107oj i \u010detvrtoj poziciji u regionima). </p> <p>Perica je identifikovao potencijalne sli\u010dne regione; na vama je da napi\u0161ete program koji \u0107e izra\u010dunati vrednost sli\u010dnosti za sve njih.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Nemanja Majski Aleksandar Ivanovi\u0107"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\), koji predstavlja du\u017einu RNK niti starog i novog retrovirusa. U drugom i tre\u0107em redu nalaze se dva stringa, \\(RV_1\\) i \\(RV_2\\), koji predstavljaju strukturu ovih niti.</p> <p>U \u010detvrtom redu nalazi se prirodan broj \\(Q\\), koji predstavlja broj parova regiona koje treba ispitati; zatim, u \\(Q\\) narednih redova nalaze se opisi tih parova u obliku tri cela broja, \\(X\\), \\(Y\\) i \\(L\\), odvojenih razmakom, redom; treba ispitati sli\u010dnost regiona du\u017eine \\(L\\) koji po\u010dinje na poziciji \\(X\\) u RNK niti prvog retrovirusa sa regionom du\u017eine \\(L\\) koji po\u010dinje na poziciji \\(Y\\) u RNK niti drugog.</p>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz potrebno je ispisati \\(Q\\) celih brojeva, svaki u zasebnom redu, tako da se u \\(k\\)-tom redu nalazi sli\u010dnost \\(k\\)-tog para regiona iz ulaza.</p>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/03_retrovirus/#ulaz","title":"Ulaz","text":"<pre><code>7\nAUGCAAG\nGGAUGCG\n2\n1 3 4\n6 1 2\n</code></pre>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#izlaz","title":"Izlaz","text":"<pre><code>4\n1\n</code></pre>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ozna\u010dimo sa \\(A[i..j]\\) podstring stringa \\(A\\) od \\(i\\)-tog do \\(j\\)-tog \u010dlana.</p> <p>Prvi upit koji imamo je izme\u0111u regiona \\(RV_1[1..4]\\)=\"AUGC\" i \\(RV_2[3..6]\\)=\"AUGC\". Ova dva regiona se potpuno poklapaju, tako da je sli\u010dnost jednaka du\u017eini regiona, tj. 4.</p> <p>Drugi upit je izme\u0111u regiona \\(RV_1 [6..7]\\)=\"AG\" i \\(RV_2 [1..2]\\)=\"GG\". Ovi regioni se poklapaju samo na drugoj poziciji, tako da je tra\u017eeni odgovor 1.</p>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 1000\\).</li> <li>\\(|RV_1| = |RV_2| = N\\).</li> <li>\\(RV_1\\) i \\(RV_2\\) su sastavljeni samo od slova iz skupa {'A','U','C','G'}.</li> <li>\\(1\\leq Q \\leq 10^6\\).</li> <li>\\(1\\leq X,Y,L \\leq N\\).</li> <li>\\(X+L-1 \\leq N\\).</li> <li>\\(Y+L-1 \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim 50 poena va\u017ei \\(Q\u22641000\\).</li> <li>U test primerima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#resenje-za-q-le-1000","title":"Re\u0161enje za \\(Q \\le 1000\\):","text":"<p>Za svai upit \u0107emo pro\u0107i petljom kroz oba intervala i proveriti koliko se elemenata poklapa. Vremenska slo\u017eenost ovog pristupa je \\(O(NQ)\\).</p>"},{"location":"takprog/2014_2015/kv1/03_retrovirus/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Zadatak \u0107emo re\u0161iti tehnikom korenske dekompozicije (Square Root Decomposition). Neka je \\(D= \\lceil \\sqrt N \\ \\rceil\\). Sada oba stringa delimo na \\(N-D+1\\)  blokova tako da svaki blok \u010dini \\(D\\) uzastopnih elemenata. Defini\u0161emo po\u010detak bloka kao najmanji indeks \\(i\\) tako da element stringa na \\(i\\)-toj poziciji pripada bloku. Svi blokovi istog stringa imaju razli\u010dite po\u010detke.</p> <p>Nakon \u0161to smo podelili oba stringa u blokove prolazimo kroz sve parove blokova \\((a,b)\\), gde je \\(a\\) blok napravljen iz prvog stringa, a \\(b\\) blok napravljen od drugog stringa. Za svaki par \u0107emo izra\u010dunati sli\u010dnost blokova prolaskom kroz oba bloka. Vremenska slo\u017eenost ove prekalkulacije je \\(O(N^2 \\sqrt N)\\).</p> <p>Recimo da treba da ispitamo sli\u010dnost intervala \\([L_1, R_1]\\) iz prvog stringa i intervala \\([L_2, R_2]\\) iz drugog stringa. Razlikujemo dva slu\u010daja:</p> <ul> <li>\\(L_1+D-1&gt;R_1\\) - U ovom slu\u010daju mo\u017eemo da pro\u0111emo petljom kroz oba intervala i izra\u010dunamo sli\u010dnost.</li> <li>\\(L_1+D-1\\le R_1\\) - Neka je \\(a\\) blok od prvog stringa \u010diji je po\u010detak \\(L_1\\), a \\(b\\) blok od drugog stringa \u010diji je po\u010detak \\(L_2\\). Njihovu sli\u010dnost znamo zbog ranije prekalkulacije i pristupamo joj u \\(O(1)\\) vremenu. Da dobijemo sli\u010dnost celog intervala rezultat sabiramo sa sli\u0161no\u0161\u0107u intervala \\([L_1+D,R_1]\\) i \\([L_2+D,R_2]\\), za \u010dije ra\u010dunanje koristimo isti postupak.</li> </ul> <p>Vremenska slo\u017eenost ovakvog pristupa je \\(O(\\sqrt N)\\) po upitu po\u0161to u prvom koraku proverimo najvi\u0161e \\(\\sqrt N\\) indeksa, a drugi korak se izvr\u0161i najvi\u0161e \\(O(\\sqrt N)\\) puta. </p> <p>Ukupna vremenska slo\u017eenost je \\(O(N^2\\sqrt N + Q\\sqrt N\\)) , a memorijska \\(O(N^2)\\).</p> <p>Napomena: Postoji i sli\u010dno re\u0161enje koje umesto korenske dekompozicije koristi strukturu Sparse Table da napravi blokove veli\u010dine \\(1, 2, 4, 8 ...\\) Vremenska slo\u017eenost tog re\u0161enja je \\(O(N^2logN + Qlog N)\\), a memorijska \\(O(N^2 \\log N)\\).</p> 03_retrovirus.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Retrovirus\n*/\n\n#include &lt;stdio.h&gt;\n\n#define MAX_N 1001\n\nint n, q;\nchar A[MAX_N], B[MAX_N];\n\nint dp[MAX_N][MAX_N];\n\nint x, y, l;\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    scanf(\"%s%s\", A, B);\n\n    for (int i=1;i&lt;=n;i++)\n    {\n        for (int j=1;j&lt;=n;j++)\n        {\n            dp[i][j] = dp[i-1][j-1] + (A[i-1] == B[j-1]);\n        }\n    }\n\n    scanf(\"%d\", &amp;q);\n\n    while (q--)\n    {\n        scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;l);\n        printf(\"%d\\n\", dp[x+l-1][y+l-1] - dp[x-1][y-1]);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/04_levi/","title":"4 - Levi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Mali Perica je na skupu hakera koji se odr\u017eava u Severnoj Koreji. Perica je na\u010duo da \u0107e grupa hakera iskoristiti skup da probije za\u0161titu i ukrade zadatke za jedno takmi\u010denje iz programiranja. Perica, koji je ina\u010de \u010dlan komisije, \u017eeli da ih zaustavi ali prvo mora da ih prona\u0111e.</p> <p>Pjongjang (glavni grad Severne Koreje u kome su sme\u0161teni hakeri) je organizovan kao koordinatni sistem, i svi objekti imaju celobrojne koordinate. U gradu postoje ta\u010dno odre\u0111ena mesta na kojima je dostupan internet. Ra\u010dunarski centar ima koordinate (0, 0), a mre\u017eni kabl se od centra pru\u017ea na veoma \u010dudan na\u010din. Kabl kre\u0107e u pravcu (1, 1) i tu skre\u0107e na levo za 90 stepeni i pru\u017ea se dve jedini\u010dne dijagonale (do koordinata (-1, 3)), pa opet skre\u0107e na levo za 90 stepeni i pru\u017ea se tri jedini\u010dne dijagonale (do koordinata (-4, 0)), i tako dalje. Internet je dostupan u svim objektima kroz koje kabl prolazi, uklju\u010duju\u0107i ra\u010dunarski centar.</p> <p>Mali Perica zna da se hakeri nalaze u nekom objektu, ali Pjongjang je veliki grad tako da Perica nema vremena da proveri sve objekte u kojima je dostupan internet. Zato je odabrao \\(Q\\) koordinata i re\u0161io da proveri samo objekte na tim koordinatama. Me\u0111utim, Perica ne \u017eeli da gubi vreme proveravaju\u0107i objekte u kojima internet nije dostupan, a kako je u velikoj \u017eurbi, pitao je vas za pomo\u0107. Pomozite Perici i za svaki objekat sa njegove liste odgovorite da li je u tom objektu dostupan internet. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161ko Obradovi\u0107 Du\u0161ko Obradovi\u0107 Nemanja Majski Marko Bakovi\u0107"},{"location":"takprog/2014_2015/kv1/04_levi/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se ceo broj \\(Q\\). Slede\u0107ih \\(Q\\) redova sadr\u017ei po dva cela broja odvojena razmakom, \\(X\\) i \\(Y\\) koordinate objekta, redom.</p>"},{"location":"takprog/2014_2015/kv1/04_levi/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki objekat u novom redu standardnog izlaza odgovoriti sa \u201eDA\u201c (bez navodnika) ukoliko je u objektu dostupan internet, ina\u010de sa \u201eNE\u201c (bez navodnika).</p>"},{"location":"takprog/2014_2015/kv1/04_levi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/04_levi/#ulaz","title":"Ulaz","text":"<pre><code>1\n-2 2\n</code></pre>"},{"location":"takprog/2014_2015/kv1/04_levi/#izlaz","title":"Izlaz","text":"<pre><code>DA\n</code></pre>"},{"location":"takprog/2014_2015/kv1/04_levi/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Vidimo da mre\u017eni kabl prolazi kroz objekat sa koordinatama (-2, 2).</p>"},{"location":"takprog/2014_2015/kv1/04_levi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>U 20% test primera \\(Q=1\\), \\(|X|,|Y|\\leq 20\\)</li> <li>U slede\u0107ih 20% test primera \\(Q\u2264100\\), \\(|X|,|Y|\\leq 100\\)</li> <li>U slede\u0107ih 60% test primera \\(Q\\leq 10^5\\), \\(|X|,|Y|\u226410^9\\)</li> </ul>"},{"location":"takprog/2014_2015/kv1/04_levi/#resenje-za-q1-xle-20y-le-20","title":"Re\u0161enje za \\(Q=1, |X|\\le 20,|Y| \\le 20\\):","text":"<p>U ovom podzadatku je dovoljno ru\u010dno iskodirati proveru za svaku ta\u010dku koja se nalazi na kablu.</p>"},{"location":"takprog/2014_2015/kv1/04_levi/#resenje-za-qle100-xle-100y-le-100","title":"Re\u0161enje za \\(Q\\le100, |X|\\le 100,|Y| \\le 100\\):","text":"<p>U ovom podzadatku je potrebno napraviti matricu koja \u0107e za svako polje pamtiti da li se na njemu nalazi kabel. To je mogu\u0107e uraditi tako \u0161to se pusti petlja koja \u0107e pratiti put kabla i obele\u017eiti svaku ta\u010dku gde se on nalazi.</p>"},{"location":"takprog/2014_2015/kv1/04_levi/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Koordinatni sistem \u0107emo podeliti u 4 kvadranta. Onda \u0107emo za svaku ta\u010dku prvo videti u kom se kvadrantu nalazi, a onda proveriti da li se nalazi na kablu. Podela na kvadrante je prikazana na slici. Primetite da se kabel uvek nalazi na \"dijagonali\" kvadranta. Prvo \u0107emo proveriti u kom se kvadrantu nalazi svaka ta\u010dka, a onda da li je na njegovoj dijagonali. Ukoliko je ta\u010dka na granici vi\u0161e kvadranata, ne zanima nas u koji od tih je smestimo.</p> <p></p> <ul> <li>Kvadrant 1, \\(x\\ge -1\\) i \\(y\\ge 1\\). Ta\u010dka se nalazi na kablu ako i samo ako \\((x+y)\\) \\(mod\\) \\(4=2\\), gde \\(mod\\) \\(4\\) predstavlja ostatak deljenja broja sa \\(4\\).</li> <li>Kvadrant 2, \\(x\\le -1\\) i \\(y\\ge 0\\). Ta\u010dka se nalazi na kablu ako i samo ako \\((x-y)\\) \\(mod\\) \\(4=0\\), gde \\(mod\\) \\(4\\) predstavlja ostatak deljenja broja sa \\(4\\).</li> <li>Kvadrant 3, \\(x\\le 0\\) i \\(y\\le 0\\). Ta\u010dka se nalazi na kablu ako i samo ako \\((x+y)\\) \\(mod\\) \\(4=0\\), gde \\(mod\\) \\(4\\) predstavlja ostatak deljenja broja sa \\(4\\).</li> <li>Kvadrant 4, ako ta\u010dka ne pripada ostalim kvadrantima. Ta\u010dka se nalazi na kablu ako i samo ako \\((x-y)\\) \\(mod\\) \\(4=0\\), gde \\(mod\\) \\(4\\) predstavlja ostatak deljenja broja sa \\(4\\).</li> </ul> 04_levi.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nint x,y,q;\nbool ok;\n\ninline bool upright() {\n  int b=y-x;\n  if (b&gt;0) return false;\n  if (b%4!=0) return false;\n  if (y&lt;b or y&gt;1) return false;\n  return true;\n}\ninline bool upleft() {\n  int b=y+x;\n  if (b&lt;0) return false;\n  if (b%4!=2) return false;\n  if (y&lt;1 or y&gt;b+1) return false;\n  return true;\n}\ninline bool downleft() {\n  int b=y-x;\n  if (b&lt;0) return false;\n  if (b%4!=0) return false;\n  if (y&lt;0 or y&gt;b-1) return false;\n  return true;\n}\ninline bool downright() {\n  int b=y+x;\n  if (b&gt;0) return false;\n  if (b%4!=0) return false;\n  if (y&gt;0 or y&lt;b) return false;\n  return true;\n}\nint main() {\n  //freopen(\"levi.10.in\", \"r\", stdin);\n  //freopen(\"levi.10.sol\", \"w\", stdout);\n  scanf(\"%d\", &amp;q);\n  for (int i=1; i&lt;=q; i++) {\n    scanf(\"%d %d\",&amp;x, &amp;y);\n    if (upright  ()) {printf(\"DA\\n\"); continue;}\n    if (upleft   ()) {printf(\"DA\\n\"); continue;}\n    if (downleft ()) {printf(\"DA\\n\"); continue;}\n    if (downright()) {printf(\"DA\\n\"); continue;}\n    printf(\"NE\\n\");\n  }\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/","title":"5 - Klasifikacija figura","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Acko je jako uzbu\u0111en povodom pu\u0161tanja nove igre kompanije Me\u0107ava^TM, zvane Junaci Oluje, u zatvorenu beta fazu. Na\u017ealost, Acko nije bio jedan od sre\u0107nika koji su dobili beta klju\u010d, i zbog toga ne mo\u017ee da igra ovu igru. Me\u0111utim, njegov prijatelj mali Perica, poznat kao veliki haker, je odlu\u010dio da mu pomogne tako \u0161to \u0107e da provali bazu kompanije Me\u0107ava^TM i ukrade jedan beta klju\u010d.</p> <p>Perica je probio sve nivoe za\u0161tite, osim poslednjeg. Poslednji nivo je jedna matemati\u010dka zagonetka; zadat je jedan fajl u kome se nalazi \\(T\\) zapisa. Jedan zapis se sastoji od broja \\(N\\) i niza ta\u010daka \\((X_1,Y_1)\\),\\((X_2,Y_2)\\),\\(\\ldots\\),\\((X_N,Y_N)\\). Za svaki zapis se postavlja pitanje: \u201cKada bi povukao izlomljenu liniju \\((X_1,Y_1)-(X_2,Y_2)-\\ldots-(X_N,Y_N)-(X_1,Y_1)\\) koju bi figuru uo\u010dio na slici?\u201d.</p> <p>Perica je uspeo da prona\u0111e misteriozni fajl Klase.txt koji sadr\u017ei sve mogu\u0107e klase figura koje kompanija  Me\u0107ava^TM raspoznaje. Sadr\u017eina fajla je slede\u0107a:</p> <pre><code>1.Duz\n2.Trougao\n  a.Jednakokraki\n  b.Pravougli\n  c.Jednakostranicni\n3.Cetvorougao\n  a.Paralelogram\n  b.Romb\n  c.Trapez\n  d.Pravougaonik\n  e.Kvadrat\n4.Ostalo\n</code></pre> <p>Kako je Perica poznato lo\u0161 sa geometrijom, zamolio vas je za pomo\u0107 sa ovim zadatkom.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Ivanovi\u0107 Ivan Sto\u0161i\u0107 - Demjan Grubi\u0107 05_klasifikacija_figura.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct tacka{\n    int x,y;\n};\n\nint sp(tacka a,tacka b){\n    return a.x*b.x+a.y*b.y;\n}\n\ntacka minus(tacka a,tacka b){\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\nbool je0(tacka a,tacka b){\n    return a.x*b.y == b.x*a.y;\n}\n\nbool kolin(tacka a,tacka b,tacka c){\n    return je0(minus(a,b),minus(b,c));\n}\n\nbool prav_ugao(tacka a,tacka b,tacka c){\n    return sp(minus(b,a),minus(b,c)) == 0;\n}\n\nbool paralelne(tacka a,tacka b,tacka c,tacka d){\n    //a-b i c-d\n    return je0(minus(a,b),minus(c,d));\n}\n\nint kv(int x){\n    return x*x;\n}\n\nint d2(tacka a,tacka b){\n    return kv(a.x-b.x)+kv(a.y-b.y);\n}\n\nbool pravougli_trougao(tacka a,tacka b,tacka c){\n    return prav_ugao(a,b,c)||prav_ugao(b,c,a)||prav_ugao(c,a,b);\n}\n\nbool jednakokraki_trougao(tacka a,tacka b,tacka c){\n    int x=d2(a,b);\n    int y=d2(b,c);\n    int z=d2(c,a);\n    return (x==y)||(y==z)||(z==x);\n}\n\nbool paralelogram(tacka a,tacka b,tacka c,tacka d){\n    return paralelne(a,b,c,d) &amp;&amp; paralelne(b,c,d,a);\n}\n\nbool romb(tacka a,tacka b,tacka c,tacka d){\n    return paralelogram(a,b,c,d) &amp;&amp; d2(a,b)==d2(b,c);\n}\n\nbool trapez(tacka a,tacka b,tacka c,tacka d){ //i paralelogram je trapez\n    return paralelne(a,b,c,d) || paralelne(b,c,d,a);\n}\n\nbool pravougaonik(tacka a,tacka b,tacka c,tacka d){\n    return paralelogram(a,b,c,d) &amp;&amp; prav_ugao(a,b,c);\n}\n\nbool jednakostranicni(tacka a,tacka b,tacka c){\n    return false; //hehe\n}\n\nbool kvadrat(tacka a,tacka b,tacka c,tacka d){\n    return romb(a,b,c,d) &amp;&amp; prav_ugao(a,b,c);\n}\n\ntacka A[15],B[15];\nint N,T,i,j,k;\n\nvoid lep_print(int &amp;x){\n    if (j==0) printf(\" - \");\n    else printf(\", \");\n    j++;\n}\n\nint main(){\n    scanf(\"%d\",&amp;T);\n    while (T--){\n        scanf(\"%d\",&amp;N);\n        for (i=1; i&lt;=N; i++) scanf(\"%d%d\",&amp;A[i].x,&amp;A[i].y);\n        A[0] = A[N];\n        A[N+1] = A[1];\n        k=0;\n        for (i=1; i&lt;=N; i++){\n            if (!kolin(A[i-1],A[i],A[i+1])){\n                k++;\n                B[k] = A[i];\n            }\n        }\n        if (k&lt;=2){\n            printf(\"Duz\\n\");\n        } else\n        if (k==3){\n            printf(\"Trougao\");\n            j=0;\n            if (jednakokraki_trougao(B[1],B[2],B[3])){\n                lep_print(j);\n                printf(\"Jednakokraki\");\n            }\n            if (pravougli_trougao(B[1],B[2],B[3])){\n                lep_print(j);\n                printf(\"Pravougli\");\n            }\n            printf(\"\\n\");\n        } else\n        if (k==4){\n            printf(\"Cetvorougao\");\n            j=0;\n            if (paralelogram(B[1],B[2],B[3],B[4])){\n                lep_print(j);\n                printf(\"Paralelogram\");\n            }\n            if (romb(B[1],B[2],B[3],B[4])){\n                lep_print(j);\n                printf(\"Romb\");\n            }\n            if (trapez(B[1],B[2],B[3],B[4])){\n                lep_print(j);\n                printf(\"Trapez\");\n            }\n            if (pravougaonik(B[1],B[2],B[3],B[4])){\n                lep_print(j);\n                printf(\"Pravougaonik\");\n            }\n            if (kvadrat(B[1],B[2],B[3],B[4])){\n                lep_print(j);\n                printf(\"Kvadrat\");\n            }\n            printf(\"\\n\");\n        } else {\n            printf(\"Ostalo\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza se nalazi broj zapisa \\(T\\). Potom slede podaci o svakom zapisu pojedina\u010dno. Svaki zapis se sastoji od broja ta\u010daka \\(N\\) i potom u svakom redu zasebno koordinatama svake ta\u010dke \\((X_i,Y_i)\\).</p>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#opis-izlaza","title":"Opis izlaza","text":"<p>Izlaz se sastoji od \\(T\\) linija u formatu</p> <pre><code>PrimarnaKlasa - SekundarnaKlasa1,SekundarnaKlasa2, ...\n</code></pre> <p>Primarne klase su obele\u017eene brojevima, a sekundarne slovima. Redosled klasa treba biti isti kao u fajlu Klase.txt.</p>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#ulaz","title":"Ulaz","text":"<pre><code>2\n3\n1 1\n2 3\n4 7\n5\n1 1\n7 1\n8 3\n4 3\n2 3\n</code></pre>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#izlaz","title":"Izlaz","text":"<pre><code>Duz\nCetvorougao - Paralelogram, Trapez\n</code></pre>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Figure iz test primera se nalaze na slici dole. Crvenom bojom je ozna\u010dena figura 1, a plavom figura 2.</p> <p>Prva figura je du\u017e od ta\u010dke (1, 1) do ta\u010dke (4, 7), a druga je \u010detvorougao izme\u0111u ta\u010daka (1, 1), (7, 1), (8, 3) i (2, 3).</p> <p></p>"},{"location":"takprog/2014_2015/kv1/05_klasifikacija_figura/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq T\\leq 50.000\\), \\(-10.000\\leq X_i,Y_i\\leq 10.000\\).</li> <li>Ta\u010dke obrazuju konveksan mnogougao i date su ili u smeru kazaljke na satu, ili u obrnutom smeru, osim u slu\u010daju kada je re\u0161enje du\u017e, a tada su date redom kako se pojavljuju na du\u017ei.</li> <li>Za 20% test primera va\u017ei \\(2\\leq N\\leq 3\\).</li> <li>Za ostalih 80% test primera va\u017ei \\(2\\leq N\\leq 10\\).</li> </ul>"},{"location":"takprog/2014_2015/kv1/06_segfault/","title":"6 - Segfault","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Mali Perica i njegov kolega, haker mali Nikolaj, kao i svi hakeri, vole da u slobodno vreme igraju igricu \u00abSIGSEGV\u00bb, u kojoj se dva hakera takmi\u010de za prevlast nad tu\u0111om RAM memorijom. Da bi uspeli u svom cilju, treba da naprave programe koji zauzimaju \u0161to vi\u0161e polja te memorije za njih. </p> <p>Pravila igre su slede\u0107a:</p> <ul> <li>RAM memorija je predstavljena kao matrica RAM[,]; svako polje te matrice mo\u017ee da bude ili slobodno, ili da pripada nekom od hakera, ili da pripada korisniku ma\u0161ine.</li> <li>Programi koje Perica i Nikolaj pi\u0161u kre\u0107u iz nekog polja matrice, i smeju da izvr\u0161e samo jednu vrstu komande: \u201dpomeri se na polje direktno gore, dole, levo ili desno, i poku\u0161aj da ga zauzme\u0161\u201d. </li> <li>Ukoliko program poku\u0161a da zauzme polje koje ne pripada njegovom hakeru, a nije slobodno, dobija segfault (segmentation fault) i prestaje sa radom; me\u0111utim haker zadr\u017eava za sebe svu memoriju koju je taj program zauzeo.</li> <li>Hakeri mogu paralelno da pokrenu vi\u0161e ovakvih programa, ukoliko imaju pristup procesoru sa vi\u0161e jezgara. Programi se mogu pokretati samo na po\u010detku igre</li> </ul> <p>Oba hakera su na razli\u010dite na\u010dine stekli nepo\u0161tene prednosti u ovoj igri:</p> <ul> <li>Nikolaj je uspeo da u\u010dini zahteve zauzimanja brzim, tako da ukoliko i Perica i Nikolaj poku\u0161aju da u isto vreme zauzmu neko slobodno polje, Nikolajev program \u0107e ga zauzeti a Peri\u010din program \u0107e prestati sa radom.</li> <li>Nikolaj poseduje procesor sa \\(K\\) jezgara, tako da mo\u017ee da pokrene \\(K\\) programa na po\u010detku.</li> <li>Nikolaj je ubacio virus u Peri\u010dine programe, \u010diji efekat je da svi Peri\u010dini programi moraju krenuti iz istog polja.</li> <li>Perica je saznao celokupno po\u010detno stanje memorije, kao i sve Nikolajeve programe; po\u0161to Nikolaj ne zna stanje memorije, svi Nikolajevi programi se uvek kre\u0107u u jednom smeru.</li> <li>Perica je tako\u0111e ubacio virus u Nikolajeve programe; efekat je da Nikolajevi programi kre\u0107u sa radom tek nakon \u0161to Peri\u010dini zauzmu po\u010detno polje.</li> <li>Perica poseduje najnoviji Pintel Core i\u221e procesor koji ima beskona\u010dno jezgara; tako da Perica na startu igre mo\u017ee pokrenuti bilo koji broj programa.</li> </ul> <p>Pericu interesuje koliko najvi\u0161e polja ove matrice mo\u017ee zauzeti ukoliko igra optimalno. Pomozite mu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Nemanja Majski Aleksandar Ivanovi\u0107"},{"location":"takprog/2014_2015/kv1/06_segfault/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(M\\), odvojena razmakom, koji predstavljaju dimenzije RAM memorije. </p> <p>U narednih \\(N\\) redova nalazi se po \\(M\\) karaktera koji predstavljaju po\u010detno stanje memorije (RAM[i,j] je predstavljen \\(j\\)-tim karakterom u \\(i\\)-tom redu):</p> <ul> <li>karakter '.' predstavlja slobodno polje;</li> <li>karakter '#' predstavlja polje koje je zauzeo korisnik ma\u0161ine;</li> <li>karakter 'S' predstavlja polje iz kojeg moraju po\u0107i svi Peri\u010dini programi.</li> </ul> <p>U narednom redu nalazi se prirodan broj \\(K\\), koji predstavlja broj jezgara koje ima Nikolajev procesor. U svakom od narednih \\(K\\) redova nalazi se opis jednog od Nikolajevih programa u obliku \\(X\\) \\(Y\\) \\(DIR\\) (parametri odvojeni razmakom), gde su \\(X\\) i \\(Y\\) prirodni brojevi koji predstavljaju po\u010detno polje teku\u0107eg programa (koje nije zauzeto pre po\u010detka igre), a \\(DIR\\) je karakter koji ozna\u010dava jedini smer u kome \u0107e teku\u0107i Nikolajev program da se kre\u0107e: 'U' - gore, 'D' - dole, 'L' - levo, 'R' - desno.</p>"},{"location":"takprog/2014_2015/kv1/06_segfault/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati broj polja memorije koje Perica mo\u017ee zauzeti ukoliko igra optimalno.</p>"},{"location":"takprog/2014_2015/kv1/06_segfault/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/kv1/06_segfault/#ulaz","title":"Ulaz","text":"<pre><code>6 5\n#.S.#\n.....\n..... \n...##\n##...\n...##\n2\n2 1 R\n3 5 L\n</code></pre>"},{"location":"takprog/2014_2015/kv1/06_segfault/#izlaz","title":"Izlaz","text":"<pre><code>18\n</code></pre>"},{"location":"takprog/2014_2015/kv1/06_segfault/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ukoliko Perica pokrene program koji \u0107e da napravi prva dva koraka nadole, stanje table se menja na slede\u0107i na\u010din (ozna\u010dimo sa 'P' polja koja poseduje Perica a 'N' polja koja poseduje Nikolaj):</p> <pre><code>#.P.#    #.P.#    #.P.#\n.....    N.P..    NNP..\n..... =&gt; ....N =&gt; ..PNN\n...## =&gt; ...## =&gt; ...##\n##...    ##...    ##...\n...##    ...##    ...##\n</code></pre> <p>U narednom koraku, oba Nikolajeva programa \u0107e dobiti segfault, \u0161to ostavlja Pericu slobodnim da zauzme sva preostala slobodna polja (sveukupno \u0107e imati po tri u svakom redu matrice, tj. 18).</p>"},{"location":"takprog/2014_2015/kv1/06_segfault/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 1000\\)</li> <li>RAM[i,j] pripada skupu {\u2018.\u2019,\u2018#\u2019,\u2018S\u2019}.</li> <li>Ta\u010dno jedno polje u matrici \ud835\udc45\ud835\udc34\ud835\udc40[,] \u0107e biti \u2018\ud835\udc46\u2019.</li> <li>\\(1\\leq K \\leq 5\\cdot 10^5\\)</li> <li>\\(1\\leq X\\leq N\\)</li> <li>\\(1\\leq Y \\leq M\\)</li> <li>RAM[X, Y] \\(\\neq\\) '#'</li> <li>DIR pripada skupu {\u2018U\u2019,\u2018D\u2019,\u2018L\u2019,\u2018R\u2019}</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 50 poena va\u017ei \\(N,M,K\\leq 600\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(K\\leq 1000\\).</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/kv1/06_segfault/#resenje-za-nmk-le-600","title":"Re\u0161enje za \\(N,M,K \\le 600\\)","text":"<p>Kako Perica mo\u017ee da pusti beskona\u010dno mnogo programa, a programa du\u017eine \\(N\\cdot M\\) ima kona\u010dno mnogo, mo\u017eemo da pretpostavimo da \u0107e Perica da pusti sve njih. To zna\u010di da ako je Percija zauzeo neko polje, on \u0107e u slede\u0107em potezu zauzeti sva njegova susedna polja, osim ako ih Nikolaj ili korisnik ma\u0161ine nije ve\u0107 zauzeo. </p> <p>Za ovaj podzadatak je dosta da se radi simulacija Pericinog zauzimanja, \u0161to mo\u017ee da se uradi preko BFS-a. Samo treba za svako polje koje Perica zauzme da se proveri da li ga je Nikolaj zauzeo pre njega, \u0161to mo\u017eemo da uradimo preko for petlje.</p> <p>Vremenska slo\u017eenost je \\(O(N\\cdot M\\cdot K)\\).</p>"},{"location":"takprog/2014_2015/kv1/06_segfault/#resenje-za-k-le-1000","title":"Re\u0161enje za \\(K \\le 1000\\)","text":"<p>Ovde je neophodno odratiti prekalkulaciju. Za svako polje, treba da odredimo trenutak kada \u0107e neki od Nikolajevih programa da zauzme to polje pod pretpostavkom da ih pre toga ne zauzme Perica. Ta prekalkulacija mo\u017ee da se uradi dvostrukom petljom u slo\u017eenosti \\(O(K \\cdot max(N,M))\\). </p> <p>Nakon toga \u0107emo pustiti BFS kao u pro\u0161lom podzadatku. Ali, umesto da proveravamo petljama da li je Nikolaj ve\u0107 zauzeo to polje, mo\u017eemo da pogledamo da li je prekalkulisano vreme zauzimanja manje ili jednako od vremena kada Pericin program stigne na to polje.</p> <p>Ukupna vremenska slo\u017eenost je \\(O(K \\cdot max(N,M) + N\\cdot M)\\).</p>"},{"location":"takprog/2014_2015/kv1/06_segfault/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Glavna ideja je da ako program koji ide na neku stranu do\u0111e na polje gde je bio neki drugi program koji ide na istu tu stranu, originalni program mo\u017ee da prestane sa radom po\u0161to \u0107e drugi program do\u0107i na svako slede\u0107e polje pre njega. Sa ovom modifikacijom, slo\u017eenost prekalkulacije je amortizovano \\(O(N \\cdot M + K)\\), a ukupna slo\u017eenost \\(O(N\\cdot M + K)\\).</p> 06_segfault.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Segfault\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;queue&gt;\n\n#define MAX_N 1001\n#define INF 987654321\n\nusing namespace std;\n\nint n, m, l;\n\nchar line[MAX_N];\nbool blok[MAX_N][MAX_N];\nbool mark[MAX_N][MAX_N];\n\nint sx, sy;\nint lx, ly;\nchar ldir[5];\n\nqueue&lt;int&gt; lqX, lqY, lqI, lqT, pqX, pqY, pqT;\nbool lmark[MAX_N][MAX_N][4];\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ninline int BFS()\n{\n    int ret = 0;\n    int curr_t = 0;\n\n    while (!pqX.empty() || !lqX.empty())\n    {\n        while (!lqX.empty() &amp;&amp; lqT.front() == curr_t)\n        {\n            int xt = lqX.front(); lqX.pop();\n            int yt = lqY.front(); lqY.pop();\n            int it = lqI.front(); lqI.pop();\n            int tt = lqT.front(); lqT.pop();\n\n            if (lmark[xt][yt][it]) continue;\n            if (blok[xt][yt]) continue;\n            if (mark[xt][yt]) continue;\n\n            lmark[xt][yt][it] = true;\n\n            int xt1 = xt + dx[it];\n            int yt1 = yt + dy[it];\n\n            if (xt1 &lt; 0 || xt1 &gt; n - 1 || yt1 &lt; 0 || yt1 &gt; m - 1) continue;\n            if (blok[xt1][yt1]) continue;\n            if (lmark[xt1][yt1][it]) continue;\n            if (mark[xt1][yt1]) continue;\n\n            lqX.push(xt + dx[it]);\n            lqY.push(yt + dy[it]);\n            lqI.push(it);\n            lqT.push(tt + 1);\n        }\n\n        while (!pqX.empty() &amp;&amp; pqT.front() == curr_t)\n        {\n            int xt = pqX.front(); pqX.pop();\n            int yt = pqY.front(); pqY.pop();\n            int tt = pqT.front(); pqT.pop();\n\n            if (lmark[xt][yt][0] || lmark[xt][yt][1] || lmark[xt][yt][2] || lmark[xt][yt][3]) continue;\n            if (blok[xt][yt]) continue;\n            if (mark[xt][yt]) continue;\n\n            mark[xt][yt] = true;\n            ret++;\n\n            for (int i=0;i&lt;4;i++)\n            {\n                int xt1 = xt + dx[i];\n                int yt1 = yt + dy[i];\n                int tt1 = tt + 1;\n\n                if (xt1 &lt; 0 || xt1 &gt; n - 1 || yt1 &lt; 0 || yt1 &gt; m - 1) continue;\n                if (lmark[xt1][yt1][0] || lmark[xt1][yt1][1] || lmark[xt1][yt1][2] || lmark[xt1][yt1][3]) continue;\n                if (blok[xt1][yt1]) continue;\n                if (mark[xt1][yt1]) continue;\n\n                pqX.push(xt1);\n                pqY.push(yt1);\n                pqT.push(tt1);\n            }\n        }\n\n        curr_t++;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;m);\n\n    for (int i=0;i&lt;n;i++)\n    {\n        scanf(\"%s\", line);\n        for (int j=0;j&lt;m;j++)\n        {\n            if (line[j] == 'S') sx = i, sy = j;\n            else if (line[j] == '#') blok[i][j] = true;\n        }\n    }\n\n    scanf(\"%d\", &amp;l);\n\n    while (l--)\n    {\n        scanf(\"%d%d%s\", &amp;lx, &amp;ly, ldir);\n        lx--; ly--;\n\n        int idd;\n        if (ldir[0] == 'U') idd = 0;\n        else if (ldir[0] == 'R') idd = 1;\n        else if (ldir[0] == 'D') idd = 2;\n        else if (ldir[0] == 'L') idd = 3;\n\n        lqX.push(lx);\n        lqY.push(ly);\n        lqI.push(idd);\n        lqT.push(1);\n    }\n\n    pqX.push(sx);\n    pqY.push(sy);\n    pqT.push(0);\n\n    printf(\"%d\\n\", BFS());\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/01_front/","title":"B1 - Front","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Mali Perica je, zahvaljuju\u0107i va\u0161oj pomo\u0107i na prethodnom nivou takmi\u010denja, uspeo da pomogne malom Acku da dobije beta klju\u010d za najnoviju igricu kompanije Me\u0107ava. Kako je i sam krenuo da igra ovu igricu, jako mu se svidela, pa je odlu\u010dio da isproba i neke starije naslove ovog izdava\u010da.</p> <p>Igrica koju je slede\u0107u odabrao je klasik \u201dRatni Zanat\u201d, a protivnik mu je njegov kolega mali Nikolaj. U ovoj igrici se dva igra\u010da takmi\u010de za prevlast nad protivni\u010dkom bazom. Baze se nalaze na suprotnim krajevima mape (Nikolajeva u donjem levom uglu mape, Peri\u010dina u gornjem desnom), i mogu se napadati ili braniti pomo\u0107u vojnika (koji se u svakom momentu nalaze na nekom paru \\((x, y)\\) koordinata na mapi).</p> <p>Perica je u klju\u010dnom trenutku pogledao Nikolajev monitor i uspe\u0161no prepisao sve pozicije na kojima je Nikolaj rasporedio svoje vojnike, sortirane u neopadaju\u0107em poretku po x koordinati. Da bi isplanirao efikasan napad, Pericu sada zanima koliko Nikolajevih vojnika je na najranjivijim polo\u017eajima, tj. na frontu.</p> <p>Vojnik \\(V(x, y)\\) se nalazi na frontu ukoliko ne postoji nijedan drugi vojnik \\(V'(x', y')\\) takav da va\u017ei \\(x \\leq x', y \\leq y'\\)</p> <p>tj. ukoliko ne postoji nijedan drugi vojnik koji je \u201dgore-desno\u201d u odnosu na tog vojnika.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Uro\u0161 Vuki\u0107evi\u0107 Aleksandar Ivanovi\u0107"},{"location":"takprog/2014_2015/okr/01_front/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\), koji predstavlja broj Nikolajevih vojnika. U svakom od narednih \\(N\\) redova nalaze se dva cela broja \\(x_i\\) i \\(y_i\\), koji predstavljaju koordinate Nikolajevog teku\u0107eg vojnika. Svi vojnici \u0107e biti sortirani u neopadaju\u0107em poretku po x koordinati.</p>"},{"location":"takprog/2014_2015/okr/01_front/#izlaz","title":"Izlaz","text":"<p>U prvi i jedini red standardnog izlaza ispisati prirodan broj \\(F\\), koji predstavlja broj Nikolajevih vojnika koji se nalaze na frontu.</p>"},{"location":"takprog/2014_2015/okr/01_front/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(1 \\leq N \\leq 10^6\\)</li> <li>\\(0 \\leq x_i,y_i \\leq 10^9\\)</li> <li>Nikoja dva vojnika ne\u0107e biti na istoj poziciji.</li> <li>\\(x_1 \\leq x_2 \\leq \\ldots x_N\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U testovima vrednim 30 poena: \\(N \\leq 500\\); \\(x_i,y_i \\leq 1000\\); ne\u0107e biti vojnika sa istom \\(x\\) koordinatom.</li> <li>U testovima vrednim 40 poena: \\(N \\leq 1000\\)</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/okr/01_front/#primer","title":"Primer:","text":""},{"location":"takprog/2014_2015/okr/01_front/#ulaz_1","title":"Ulaz","text":"<pre><code>6\n0 1\n1 5\n3 5\n3 2\n4 4\n</code></pre>"},{"location":"takprog/2014_2015/okr/01_front/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2014_2015/okr/01_front/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Front se sastoji od slede\u0107eg skupa vojnika: \\(\\{ (3, 5), (4,4), (5,1) \\}\\).</p>"},{"location":"takprog/2014_2015/okr/01_front/#resenje-za-nleq20-i-x_iy_ileq1000","title":"Re\u0161enje za \\(N\\leq20\\) i  \\(x_i,y_i\\leq1000\\):","text":"<p>Sa obzirom da su vrednosti \\(x_i\\) i \\(y_i\\) male mo\u017eemo svaku ta\u010dku da sa\u010duvamo u matrici \\(mat\\) gde je  \\(mat[i][j]=1\\) ako je uneta ta\u010dka sa koordinatama \\(i\\) i \\(j\\), a \\(mat[i][j] = 0\\) u suprotnom. Sada za svaku unetu ta\u010dku mo\u017eemo proveriti da li postoji neka ta\u010dka u matrici koja je gore-desno od date ta\u010dke i tako izbrojati ta\u010dke na frontu. Vremenska slo\u017eenost: \\(O(N\\cdot maxX^2)\\), memorijska slo\u017eenost: \\(O(N + maxX^2)\\), gde je \\(maxX\\) najve\u0107a dozvoljena koordinata (u ovom slu\u010daju \\(1000\\)).</p>"},{"location":"takprog/2014_2015/okr/01_front/#resenje-za-nleq1000","title":"Re\u0161enje za \\(N\\leq1000\\):","text":"<p>Zbog toga \u0161to su \\(x_i,y_i\\leq10^9\\) (ne mo\u017eemo da napravimo toliku matricu) moramo da proverimo broj ta\u010daka na frontu bez matrice.  Broj ta\u010daka na frontu mo\u017eemo izbrojati tako \u0161to \u0107emo za svaku ta\u010dku pro\u0107i  kroz sve ostale ta\u010dke i proveriti da li postoji neka koja je gore-desno od nje. Vremenska slo\u017eenost: \\(O(N^2)\\), memorijska slo\u017eenost: \\(O(N)\\)</p>"},{"location":"takprog/2014_2015/okr/01_front/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Znamo da \u0107e se za svaku \\(x\\) koordinatu najvi\u0161e jedna ta\u010dka nalaziti na frontu. Po\u0161to su ta\u010dke pore\u0111ane po \\(x\\) koordinati, kre\u0107emo sa kraja niza (odnosno, mo\u017eemo zamisliti zdesna nalevo) i pratimo koja je najve\u0107a \\(y\\) koordinata koju smo do sad videli (neka to bude \\(maxy\\)), kao i poslednju \\(x\\) koordinatu za koju je \\(maxy\\) ostvareno (nazovimo to \\(maxx\\)). Za trenutno \\(x_i\\) dodamo jedan na rezultat ukoliko je \\(y_i &gt; maxy\\) i \\(x_i \\neq maxx\\). Pritom odr\u017eavamo vrednosti \\(maxx\\) i \\(maxy\\).  Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\)</p> 01_front.cpp<pre><code>/* \n Author: Petar 'PetarV' Velickovic\n Task: Front\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;algorithm&gt;\n\n#define MAX_N 1000001\n\nusing namespace std;\n\nint n;\nint X[MAX_N], Y[MAX_N];\nint currX, currmY, maxY;\nint sol;\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i=0;i&lt;n;i++) scanf(\"%d%d\", &amp;X[i], &amp;Y[i]);\n\n    currX = X[n - 1], currmY = Y[n - 1], maxY = -1;\n    for (int i=n-1;i&gt;=0;i--)\n    {\n        if (X[i] == currX) currmY = max(currmY, Y[i]);\n        else\n        {\n            if (currmY &gt; maxY) maxY = currmY, sol++;\n            currmY = Y[i];\n            currX = X[i];\n        }\n    }\n    if (currmY &gt; maxY) sol++;\n\n    printf(\"%d\\n\", sol);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/02_sifra/","title":"B2 - \u0160ifra","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Poznati programer koji stalno putuje po svim takmi\u010denjima, koga su zgodno nazvali Turista, je jedini za sada uradio zadatak iz informatike za koji se dobija milion dinara. On je poznat po tome \u0161to je skroman, te ne\u0107e da objavi svoje re\u0161enje u narednih godinu dana kako bi drugi imali \u0161ansu da dobiju milion dinara. On je zaklju\u010dao svoje re\u0161enje na internetu nizom brojeva, i veruje da niko ne mo\u017ee da provali tu \u0161ifru.</p> <p>Mladi programer Kopi je umesto da poku\u0161a da re\u0161i problem, re\u0161io da poku\u0161a lak\u0161im putem da do\u0111e do milion dinara. On \u0107e poku\u0161ati da provali \u0161ifru kojom je zaklju\u010dano re\u0161enje i tako uzme zasluge za to re\u0161enje i nezaslu\u017eeno osvoji milion dinara. Po\u0161to je u pro\u0161losti ve\u0107 krao re\u0161enja od Turista, mo\u017ee da pretpostavi kako je Turist do\u0161ao do svoje \u0161ifre.</p> <p>Naime, on zna da su Turistu dva omiljena broja ba\u0161 \\(M\\) i \\(K\\). Kako je pro\u010ditao tekst problema uvideo je da se u njemu pojavljuje ta\u010dno \\(N\\) celih nenegativnih razli\u010ditih brojeva. Veoma dobro poznaje kako Turista razmi\u0161lja, te je shvatio kako je Turist do\u0161ao do svoje \u0161ifre.</p> <p>Turista je napravio sve mogu\u0107e \\(M\\)-torke sa\u010dinjene od \\(N\\) brojeva koji se nalaze u tekstu problema (brojevi mogu da se ponavljaju u jednoj \\(M\\)-torki) i tako je dobio niz mogu\u0107ih \u0161ifri (\\(M\\)-torki). Kako je ve\u0107 spomenuto, Turista voli broj \\(K\\), te Kopi pretpostavlja da je Turist sortirao sve mogu\u0107e \u0161ifre (\\(M\\)-torke) u rastu\u0107em poretku i  odabrao \\(K\\)-tu po redu da bude \u0161ifra zaklju\u010danog re\u0161enja.</p> <p>Znamo da je svaka mogu\u0107a \u0161ifra sa\u010dinjena od \\(M\\) brojeva te znamo i kako da ih upore\u0111ujemo. Za mogu\u0107u \u0161ifru \\(a=(a_1,a_2,\\ldots,a_M)\\) ka\u017eemo da je manja od mogu\u0107e \u0161ifre \\(b=(b_1,b_2,\\ldots,b_M)\\) ako i samo ako postoji prirodan broj \\(i\\), \\(1\\leq i \\leq M\\), takav da va\u017ei \\(a_j=b_j\\) za svako \\(j&lt;i\\) i \\(a_i&lt;b_i\\) (klasi\u010dno leksikografsko sortiranje).</p> <p>Kako Kopi ne zna dobro da programira, zamolio vas je da mu pomognete oko pronala\u017eenja \u0161ifre.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161ko Obradovi\u0107 Demjan Grubi\u0107 Nemanja Majski Marko Savi\u0107"},{"location":"takprog/2014_2015/okr/02_sifra/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se tri prirodna broja \\(N\\), \\(M\\) i \\(K\\), koji redom ozna\u010davaju koliko ima prirodnih brojeva u tekstu misterioznog problema, i dva omiljena broja Turista. U narednom redu se nalazi N celih nenegativnih razli\u010ditih brojeva \\(A_1,A_2,A_3,\\ldots,A_N\\) koji predstavljaju brojeve koji se nalaze u misterioznom problemu, date u rastu\u0107em poretku.</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati \\(M\\) brojeva koji predstavljaju \u0161ifru za otklju\u010davanje re\u0161enja.</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\)</li> <li>\\(1 \\leq M \\leq 10^5\\)</li> <li>\\(1 \\leq K \\leq 10^{18}\\)</li> <li>\\(0 \\leq A_i \\leq 10^9\\), \\(A_1 &lt; A_2 &lt; \\ldots A_N\\)</li> <li>Postoji \\(K\\)-ta \\(M\\)-torka.</li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena va\u017ei \\(M=1\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(M=10\\), \\(A_1=0, A_2=1, A_3=2, \\ldots , A_{10}=9\\).</li> <li>U test primerima vrednim 15 poena va\u017ei \\(N\\leq 3, M\\leq 9\\).</li> <li>U test primerima vrednim 15 poena va\u017ei \\(N,M \\leq 15\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(N \\leq 10\\,000\\), \\(M \\leq 1\\,000\\).</li> <li>U test primerima vrednim 20 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/okr/02_sifra/#primer","title":"Primer:","text":""},{"location":"takprog/2014_2015/okr/02_sifra/#ulaz_1","title":"Ulaz","text":"<pre><code>3 4 37\n6 11 533\n</code></pre>"},{"location":"takprog/2014_2015/okr/02_sifra/#izlaz_1","title":"Izlaz","text":"<pre><code>11 11 6 6\n</code></pre>"},{"location":"takprog/2014_2015/okr/02_sifra/#resenje-za-m1","title":"Re\u0161enje za \\(M=1\\):","text":"<p>U ovom podzadatku nam se tra\u017ei K-ti najmanji element niza. To mo\u017eemo da na\u0111emo tako \u0161to  samo ispi\u0161emo element na K-toj poziciji u nizu, po\u0161to je niz ve\u0107 sortiran. Vremenska slo\u017eenost je \\(O(N+M)\\).</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#resenje-za-n10-i-a_10-a_21-a_109","title":"Re\u0161enje za \\(N=10\\) i \\(A_1=0, A_2=1, ...A_{10}=9\\):","text":"<p>[Ima gre\u0161ka u tekstu zadatka, pi\u0161e \\(M=10\\), ali u primerima je \\(N=10\\)]</p> <p>U ovom podzataku je \\(K\\)-ta \\(M\\)-torka sam broj \\(K-1\\), samo je va\u017eno dodati vode\u0107e nule tako da \\(K-1\\) bude \\(M\\)-tocifren broj. Na primer, za \\(M=5\\) i \\(K=100\\), \\(K-ta\\) \\(M-torka\\) je \\(0 0 0 9 9\\). Vremenska slo\u017eenost je \\(O(N+M)\\).</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#resenje-za-nle3-mle9","title":"Re\u0161enje za \\(N\\le3, M\\le9\\):","text":"<p>U ovom podzadatku najvi\u0161e ima \\(3^9=19683\\) \\(M\\)-torki. Tako da mo\u017eemo da idemo redom kroz svaku dok ne do\u0111emo do \\(K\\)-te. To mo\u017eemo uraditi pomo\u0107u rekurzije. Vremenska slo\u017eenost je \\(O(N^M)\\).</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#resenje-za-nle15-mle15","title":"Re\u0161enje za \\(N\\le15, M\\le15\\):","text":"<p>Zamislimo da je \\(A_i=i-1\\) za svako \\(1\\le i \\le N\\). Onda je tra\u017eeno re\u0161enje broj \\(K-1\\) zapisan kao \\(M\\)-tocifren broj u brojevnom sistemu sa osnovom \\(N\\). </p> <p>Dugim re\u010dima, recimo da je niz \\(B_1, B_2 ... B_M\\) \u0161ifra za otklju\u010davanje, onda va\u017ei:</p> \\[ K-1= B_1 \\cdot N^{M-1} + B_2 \\cdot N^{M-2} + ... + B_{M-1} \\cdot N^{1} + B_M \\cdot N^0 \\] <p>Na primer, za \\(N=3\\) i \\(M=5\\): \\(\\(K-1 = B_1\\cdot 3^4 + B_2\\cdot 3^3 + B_3 \\cdot 3^2 + B_4 \\cdot 3^1 + B_5 \\cdot 3^0\\)\\)</p> <p>Kako va\u017ei \\(0 \\le B_i &lt; N\\) za svako \\(1\\le i \\le M\\), jedna\u010dina iznad ima jedinstveno re\u0161enje. Ono mo\u017ee da se na\u0111e slede\u0107im postupkom:</p> <p>Idemo od \\(B_1\\), koji \u0107e na po\u010detku da bude 0. Nakon toga mi njega pove\u0107avamo tako da bude najve\u0107a mogu\u0107a vrednost, ali takva da je desna strana jedna\u010dine manja ili jednaka levoj. Kada smo ga pove\u0107ali do takve vrednosti, prelazimo na \\(B_2\\) i ponavljamo postupak.</p> <p>Ali, \u0161ta da radimo ukoliko \\(A_i \\ne i-1\\)? Opet \u0107emo broj K-1 predstaviti u brojevnom sistemu \\(N\\), neka su cifre tako predstavljenog broja \\(B_1, B_2 ... B_M\\). Sada kada \u017eelimo da ispi\u0161emo re\u0161enje, umesto da ispisujemo redom \\(B_i\\) za svako \\(1\\le i \\le M\\), ispisa\u0107emo \\(A_{B_i+1}.\\)  Vremenska slo\u017eenost je \\(O(N\\cdot M)\\).</p>"},{"location":"takprog/2014_2015/okr/02_sifra/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Isto kao re\u0161enje za prethodni podzatadak, samo moramo paziti na to da nam vrednosti ne pre\u0111u maksimalnu granicu. To mo\u017eemo da uradimo tako \u0161to \u0107emo svuda gde je \\(N^{M-i} &gt;K\\) staviti \\(B_i=0\\). Proveru mo\u017eemo raditi koriste\u0107i funckiju logaritma. Slo\u017eenost ovog pristupa je \\(O(Nlog_N K + M)\\). Re\u0161enja koja su re\u0161ila problem prelaska preko granice, ali rade u \\(O(N\\cdot M)\\) prolaze za podzadatak gde je \\(N\\le 10000\\) i \\(M\\le 1000\\).</p> <p>Napomena: Kori\u0161\u0107enjem operacije deljenja za nala\u017eenje vrednosti \\(B_i\\) mo\u017ee da se zadatak re\u0161i u slo\u017eenosti \\(O(N+M)\\).</p> 02_sifra.cpp<pre><code>#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;stdio.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n#define MaxN 100005\n#define MaxM 100005\n\nint n, m;\nlong long k;\nint a[MaxN];\n\nvector&lt;int&gt; KbaseM;\n\nint main()\n{\n    scanf(\"%d%d%lld\", &amp;n, &amp;m, &amp;k);\n    for (int i = 0; i &lt; n; ++i)\n        scanf(\"%d\", &amp;a[i]);\n    --k;\n\n    if (n == 1) {\n        printf(\"%d\", a[0]);\n        for (int i = 1; i &lt; m; ++i)\n            printf(\" %d\", a[0]);\n        printf(\"\\n\");\n    }\n    else {\n\n        while (k &gt; 0) {\n            KbaseM.push_back(k % n);\n            k /= n;\n        }\n\n        bool first = true;\n        for (int i = 0; i &lt; m - KbaseM.size(); ++i) {\n            if (first) first = false; else printf(\" \");\n            printf(\"%d\", a[0]);\n        }\n\n        for (int i = KbaseM.size() - 1; i &gt;= 0; --i) {\n            if (first) first = false; else printf(\" \");\n            printf(\"%d\", a[ KbaseM[i] ]);\n        }\n        printf(\"\\n\");\n\n    }\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/03_sudari/","title":"B3 - Sudari","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Mali Drejko je sino\u0107 imao no\u0107nu moru u kojoj se na\u0161ao u lavirintu bez izlaza i, jo\u0161 gore, zaboravio sve \u0161to zna o algoritmima. U tom snu je poku\u0161avao da na\u0111e izlaz jednim neispravnim, pogre\u0161no interpretiranim (odnosno neve\u0161to prepisanim) postupkom: umesto rezona \u201cdr\u017ei levu ruku uz zid\u201d, dr\u017eao se heuristike \u201ci\u0107i \u0107u napred dok ne naletim na zid i, kad se to desi, skrenu\u0107u levo i ponoviti isti postupak\u201d. Ko\u0161mar je toliko potresao Drejka da je zaboravio detalje sna, ali se ipak se\u0107a nekih stvari.</p> <p>Drejko je upamtio da je lavirint mogao da se predstavi kao pravougaona matrica \\(n\\times m\\), pri \u010demu su elementi te matrice ili zidovi ili slobodna polja, a uspeo je da se seti i svih polja u ovoj matrici. Drejko ne mo\u017ee da se seti koja je polja obi\u0161ao u lavirintu, ali se se\u0107a svog po\u010detnog polo\u017eaja, \u010dinjenice da se prvo kretao ju\u017eno, da je \\(k\\) puta udario glavom o zid i da se probudio neposredno nakon  \\(k\\)-tog sudara sa zidom. \u010citaju\u0107i sanovnik, shvatio je da je za potpuno tuma\u010denje neophodno da zna ta\u010dan polo\u017eaj u kom se nalazio neposredno pre bu\u0111enja.</p> <p>Drejko je vrstan programer, ali je trenutno toliko uzbu\u0111en i potresen da ne mo\u017ee da razmi\u0161lja o ovom zadatku. Pomozite Drejku da protuma\u010di svoj san.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Dragan Uro\u0161evi\u0107 Andrej Iva\u0161kovi\u0107 Petar Veli\u010dkovi\u0107"},{"location":"takprog/2014_2015/okr/03_sudari/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza se nalaze prirodni brojevi \\(n\\) i \\(m\\), broj vrsta i kolona matrice, redom. </p> <p>U drugom redu se nalaze prirodni brojevi \\(y\\) i \\(x\\), gde \\((y,x)\\) predstavlja polje na kom se Drejko nalazio na po\u010detku sna (\\((1,1)\\) je gornji levi ugao matrice, a \\((n,m)\\) donji desni). </p> <p>U tre\u0107em redu se zadaje prirodan broj \\(k\\) \u2013 ukupan broj sudara Drejkove glave sa zidom. U narednih \\(n\\) redova standardnog ulaza se nalazi po m znakova \u2018#\u2019 ili \u2018.\u2019 (bez navodnika), gde \u2018#\u2019 predstavlja zid, a \u2018.\u2019 slobodno polje. Po\u010detno Drejkovo polje \\((y,x)\\) \u0107e uvek biti \u2018.\u2019. Smatrati da je sudar Drejka sa granicom matrice \u2013 sudar sa zidom.</p>"},{"location":"takprog/2014_2015/okr/03_sudari/#izlaz","title":"Izlaz","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati koordinate \\((y',x')\\) poslednjeg polja na kome se Drejko na\u0161ao u toku sna, razdvojene jednim znakom razmaka.</p>"},{"location":"takprog/2014_2015/okr/03_sudari/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(1\\leq n,m \\leq 500\\)</li> <li>\\(1 \\leq k \\leq 10^{18}\\) </li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena va\u017ei \\(1\\leq k \\leq 1000\\).</li> <li>U test primerima vrednim 40 poena va\u017ei \\(1 \\leq k \\leq 10^7\\).</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/okr/03_sudari/#primeri","title":"Primeri:","text":""},{"location":"takprog/2014_2015/okr/03_sudari/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2014_2015/okr/03_sudari/#ulaz_1","title":"Ulaz","text":"<pre><code>4 5  \n2 1  \n4  \n...#.  \n.#...  \n....#  \n#....\n</code></pre>"},{"location":"takprog/2014_2015/okr/03_sudari/#izlaz_1","title":"Izlaz","text":"<pre><code>2 3\n</code></pre>"},{"location":"takprog/2014_2015/okr/03_sudari/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2014_2015/okr/03_sudari/#ulaz_2","title":"Ulaz","text":"<pre><code>3 5  \n2 1  \n3  \n.....  \n...#.  \n....#\n</code></pre>"},{"location":"takprog/2014_2015/okr/03_sudari/#izlaz_2","title":"Izlaz","text":"<pre><code>3 4\n</code></pre>"},{"location":"takprog/2014_2015/okr/03_sudari/#resenje-za-kleq1000","title":"Re\u0161enje za \\(k\\leq1000\\):","text":"<p>U slu\u010daju \\(k\\leq1000\\) je dovoljno da se primeti da \u0107e izme\u0111u svaka dva sudara biti najvi\u0161e \\(\\{ m,n \\}\\)  koraka: u najgorem slu\u010daju se Drejko kretao od jednog do drugog kraja matrice. Stoga je simulacija ovog kretanja prihvatljivo re\u0161enje \u010dija je vremenska slo\u017eenost \\(O(k \\cdot \\{ m,n \\} )\\)</p> <p>Iako iza ovog re\u0161enja ne postoji nikakva prava \u201cideja\u201d, ono se pokazuje izuzetno te\u0161kim za ispravnu implementaciju. Konkretno, u jednom pristupu bismo morali da razmatramo sve mogu\u0107e \u201cre\u017eime\u201d kretanja i, u zavisnosti od toga da li se Drejko kre\u0107e ka severu, jugu, zapadu ili istoku, imali bismo razne slu\u010dajeve. Pojedina\u010dno oni nisu naro\u010dito te\u0161ki, ali problem nastaje ukoliko \u017eelimo da uvedemo izmene u logiku, nakon \u010dega moraju analogne (ali ne identi\u010dne!) izmene da se uvedu u svim slu\u010dajevima \u2013 tada nastaju vrlo neprijatne gre\u0161ke. Zato \u0107emo predstaviti opis nekih uobi\u010dajenih tehnika koje sva \u010detiri slu\u010daja spajaju u jedan op\u0161ti.</p> <p>Numeri\u0161imo re\u017eime kretanja brojevima \\(0, 1, 2, 3\\)  (\\(0\\) \u2013 ju\u017eno, \\(1\\) \u2013 isto\u010dno, \\(2\\) \u2013 severno, \\(3\\) \u2013 zapadno). Tada je o\u010digledno da se nakon svakog sudara numeracija na\u0161eg re\u017eima uve\u0107a za \\(1\\) (po modulu \\(4\\): prelaz \\(3 \\rightarrow 0\\)).</p> <p>Re\u017eim kretanja mo\u017ee da se opi\u0161e time \u0161to u svakom re\u017eimu postoji zajedni\u010dko pona\u0161anje: napravi\u0107emo korak \\((x,y) \\rightarrow (x+dx,y+dy)\\) ukoliko je polje \\((x+dx,y+dy)\\) slobodno; u suprotnom, menja se re\u017eim kretanja jer je do\u0161lo do sudara. O\u010digledno \\((dx,dy)\\) varira u zavisnosti od re\u017eima kretanja, te su nam neophodna dva niza \\(dx\\) i \\(dy\\).</p>"},{"location":"takprog/2014_2015/okr/03_sudari/#resenje-za-kleq107","title":"Re\u0161enje za \\(k\\leq10^7\\):","text":"<p>O\u010digledno je da u ovom slu\u010daju tra\u017eimo re\u0161enje koje je linearno po promenljivoj \\(k\\). Dakle, ukoliko bismo iterirali \u201cpo sudarima\u201d, izme\u0111u svaka dva sudara \u017eelimo da imamo konstantan broj operacija koje nam govore do kog polja sti\u017eemo. Ovo nagove\u0161tava neko preprocesiranje.</p> <p>Primetimo da je jedno Drejkovo stanje opisano polo\u017eajem i aktuelnim re\u017eimom kretanja i da jedinstveno odre\u0111uje stanje nakon slede\u0107eg sudara sa zidom. Konkretno, imamo nekoliko slu\u010dajeva:</p> <ul> <li>o\u010digledno je nemogu\u0107e da se Drejko na\u0111e \u201eu zidu\u201c, pa nas takvi slu\u010dajevi ne zanimaju;</li> <li>ako je Drejko odmah pored nekog zida i ukoliko je usmeren ka njemu, stanje \u0107e odgovarati samo promenjenom re\u017eimu kretanja;  </li> <li>u suprotnom, sudar (tj. stanje nakon narednog sudara) do kog nas vodi trenutno kretanje odgovara sudaru do kog nas vodi polje na kom \u0107emo se nalaziti u slede\u0107em koraku.</li> <li>Poslednja \u010dinjenica je najva\u017enija i poprili\u010dno uslo\u017enjava re\u0161enje. Dakle, neophodno je odrediti za svaki par re\u017eim,polo\u017eaj naredno stanje. Ovo o\u010digledno mo\u017ee da se predstavi pomo\u0107u tri niza sa po tri koordinate (koordinate su re\u017eim, \\(x\\) i \\(y\\)), ali kako ih izra\u010dunati? Rekurentna veza je postavljena, odakle po\u010deti?</li> </ul> <p>Primetimo da nam pri izra\u010dunavanju parametara narednog stanja pri fiksiranom re\u017eimu uop\u0161te ne uti\u010du rezultati iz drugih re\u017eima. Dakle, odgovore za \u201cseverno\u201d, \u201cju\u017eno\u201d, \u201cisto\u010dno\u201d i \u201czapadno\u201d mo\u017eemo da ra\u010dunamo potpuno nezavisno. Iz definicije re\u017eima kretanja dolazimo do zaklju\u010daka:</p> <ul> <li>naredno stanje ukoliko je re\u017eim kretanja \u201cju\u017eno\u201d \u0107e prvo biti izra\u010dunato u smeru jug\u2013sever;    </li> <li>naredno stanje ukoliko je re\u017eim kretanja \u201cseverno\u201d \u0107e prvo biti izra\u010dunato u smeru sever\u2013jug;</li> <li>naredno stanje ukoliko je re\u017eim kretanja \u201cisto\u010dno\u201d \u0107e prvo biti izra\u010dunato u smeru istok\u2013zapad;   </li> <li>naredno stanje ukoliko je re\u017eim kretanja \u201cju\u017eno\u201d \u0107e prvo biti izra\u010dunato u smeru zapad\u2013istok.</li> </ul> <p>Dakle, mo\u017eemo da popunjavamo stanja u \u010detiri matrice (u nekim implementacijama mo\u017eda i osam matrica \u2013 Drejkova usmerenost i vrsta koordinate na koju se odnosi)</p> <p>Sada je uop\u0161tavanje svih ovih slu\u010dajeva ne\u0161to komplikovanije i jedna procedura koja bi generisala naredna stanja pri fiksnom re\u017eimu bi bila imala ne\u0161to nerazumljiviji oblik. Zato se predla\u017ee da se u ovom re\u0161enju \u201c\u017ertvuje\u201d modularnost koda zarad jednostavnosti.</p> <p>Dakle, za re\u0161enje u kom se najpre preprocesiraju \u201clanci\u201d stanja u \\(O(nm)\\), nakon \u010dega se u \\(O(k)\\) razmotre svi sudari.</p>"},{"location":"takprog/2014_2015/okr/03_sudari/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Uvedimo pojam stanja kao u prethodnom podzadatku. Primetimo da ih nema vi\u0161e od \\(O(4mn)\\): za svaki polo\u017eaj postoje \u010detiri re\u017eima kretanja. Ukoliko je dat bilo koji dovoljno duga\u010dak niz stanja (du\u017eine bar \\(4mn+1\\)), u njemu \u0107e se neko stanje sigurno na\u0107i bar dva puta (Dirihleov princip). Me\u0111utim, po\u0161to je naredno stanje uvek unapred odre\u0111eno, zaklju\u010dujemo da je niz stanja periodi\u010dan.</p> <p>Ova \u010dinjenica nije toliko neobi\u010dna, ali nam poma\u017ee da do\u0111emo do re\u0161enja \u010dija vremenska slo\u017eenost ne\u0107e zavisiti od \\(k\\). Dovoljno je da se simulira kretanje sve dok ne stignemo do \\(k\\)-tog sudara ili ne nai\u0111emo na polje koje smo ve\u0107 obi\u0161li (voditi ra\u010duna o oba slu\u010daja!).</p> <p>U pomenutom drugom slu\u010daju, za simulaciju mo\u017ee da se koristi re\u0161enje prethodnog podzadatka, ali nije nu\u017eno zbog prirode problema \u2013 dovoljno je koristiti prostu simulaciju iz prvog podzadatka (pomenutih \\(O(4mn)\\) stanja nisu samo ona kada se menja re\u017eim kretanja!).</p> <p>Nakon odre\u0111ivanja perioda i rednog broja sudara koji je prvi u ciklusu, uz malo modularne aritmetike se jednostavno odredi zavr\u0161no stanje. Konkretno, ukoliko je redni broj prvog sudara u ciklusu \\(p\\), du\u017eina ciklusa \\(T\\), a tra\u017eimo \\(k\\)-ti polo\u017eaj, tada je redni broj sudara koji nas zanima u ovom ciklusu \\(k-p \\mod T\\). Poku\u0161ajmo da opravdamo: prvih \\(p\\) koraka u simulaciji su pre ciklusa, stoga smo u toku cikli\u010dnog obilaska imali \\(k-p\\) koraka; nulto i \\(T\\)-to stanje u ciklusu su identi\u010dni, te je dovoljno posmatrati modul \\(T\\).</p> <p>Dakle, re\u0161enje prvog podzadatka je dovoljno pro\u0161iriti uvo\u0111enjem pomo\u0107nih matrica koje nam govore kada smo prvi put do\u0161li do nekog stanja. Vode\u0107i se idejom kompaktnosti zapisa, predla\u017ee se da se i dalje koristi jedna jedina matrica, ali \u0107e imati tri dimenzije \u2013 dodatna koordinata je indeks smera! Pre nego \u0161to se prvi put dospe u neko stanje, vreme neophodno da se do njega do\u0111e se najpre podesi na neko nemogu\u0107e (na primer, \\(-1\\)). Pri obilasku nekog stanja se najpre ispita da li je re\u010d o nekom ranije obi\u0111enom stanju (tako \u0161to se vidi da li je u tom polju pomenuta \u201enemogu\u0107a\u201c vrednost), nakon \u010dega nije te\u0161ko odrediti period.</p> <p>Opet, neophodno je obratiti pa\u017enju na slu\u010daj kada do tra\u017eenog sudara do\u0111e pre ulaska u ciklus!</p> 03_sudari.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;stdlib.h&gt;\n\n# define MAXN 510\n\nlong long k;\nint m, n;\nint ip, jp;\nint op[MAXN][MAXN];\nint zid[4][MAXN][MAXN];\nint bio[4][MAXN][MAXN];\n\nvoid citaj() {\n  char zn;\n  int i, j;\n  scanf(\"%d%d\", &amp;n, &amp;m);\n  scanf(\"%d%d\", &amp;ip, &amp;jp);\n  scanf(\"%lld\", &amp;k);\n  for (j = 0; j &lt;= m+1; j++) \n    op[0][j] = op[n+1][j] = 1;\n  for (i = 0; i &lt;= n+1; i++) \n    op[i][0] = op[i][m+1] = 1;\n  for (i = 1; i &lt;= n; i++) {\n    for (j = 1; j &lt;= m; j++) {\n      zn = getchar();\n      if (zn == '#') op[i][j] = 1; else op[i][j] = 0;\n    }\n    if (i &lt; n)\n      while ((zn = getchar()) != '\\n');\n  }\n}\n\nvoid pripremi() {\n  int p;\n  int i, j;\n  int ip, jp;\n  for (j = 1; j &lt;= m; j++) {\n    i = n;\n    while ((i &gt;= 1) &amp;&amp; op[i][j]) {\n      zid[0][i][j] = -1; \n      i--;\n    }\n    ip = i+1;\n    while (i &gt;= 1) {\n      if (op[i][j] == 0) {\n        zid[0][i][j] = ip-1;\n      } else {\n        zid[0][i][j] = -1;\n        ip = i;\n      }\n      i--;\n    }\n  } \n  for (i = 1; i &lt;= n; i++) {\n    j = m;\n    while ((j &gt;= 1) &amp;&amp; op[i][j]) {\n      zid[1][i][j] = -1;\n      j--;\n    }\n    jp = j+1;\n    while (j &gt;= 1) {\n      if (op[i][j] == 0) {\n        zid[1][i][j] = jp-1;\n      } else {\n        zid[1][i][j] = -1;\n        jp = j;\n      }\n      j--;\n    }\n  }\n  for (j = 1; j &lt;= m; j++) {\n    i = 1;\n    while ((i &lt;= n) &amp;&amp; op[i][j]) {\n      zid[2][i][j] = -1; \n      i++;\n    }\n    ip = i-1;\n    while (i &lt;= n) {\n      if (op[i][j] == 0) {\n        zid[2][i][j] = ip+1;\n      } else {\n        zid[2][i][j] = -1;\n        ip = i;\n      }\n      i++;\n    }\n  } \n  for (i = 1; i &lt;= n; i++) {\n    j = 1;\n    while ((j &lt;= m) &amp;&amp; op[i][j]) {\n      zid[3][i][j] = -1;\n      j++;\n    }\n    jp = j-1;\n    while (j &lt;= m) {\n      if (op[i][j] == 0) {\n        zid[3][i][j] = jp+1;\n      } else {\n        zid[3][i][j] = -1;\n        jp = j;\n      }\n      j++;\n    }\n  }\n  for (p = 0; p &lt; 4; p++)\n    for (i = 1; i &lt;= n; i++)\n      for (j = 1; j &lt;= m; j++)\n        bio[p][i][j] = -1;\n  bio[3][ip][jp] = 0;\n}\n\nvoid obidji() {\n  long long kt; \n  int pt, ps;\n  int it, jt, is, js;      \n  pt = 0; it = ip; jt = jp;\n  kt = 0;\n  while (kt &lt; k) {\n    kt++;\n    switch (pt) {\n      case 0:\n        is = zid[0][it][jt];\n        js = jt;\n        ps = 1;\n        break;\n      case 1:\n        is = it;\n        js = zid[1][it][jt];\n        ps = 2;\n        break;\n      case 2:\n        is = zid[2][it][jt];\n        js = jt;\n        ps = 3;\n        break;\n      case 3:\n        is = it;\n        js = zid[3][it][jt];\n        ps = 0;\n        break;\n    }\n    it = is;\n    jt = js;\n    pt = ps;\n//    printf(\"%d %d\\n\", it, jt);\n    if (bio[pt][it][jt] &gt;= 0) break;\n    bio[pt][it][jt] = kt;\n  }        \n//  printf(\"%d\\n\", kt);\n  if (kt == k) {\n    printf(\"%d %d\\n\", it, jt);\n  } else {\n    long long kp;\n    kp = kt - bio[pt][it][jt];\n    kt = kt + (k - kt) / kp * kp;\n    while (kt &lt; k) {\n      kt++;\n      switch (pt) {\n        case 0:\n          is = zid[0][it][jt];\n          js = jt;\n          ps = 1;\n          break;\n        case 1:\n          is = it;\n          js = zid[1][it][jt];\n          ps = 2;\n          break;\n        case 2:\n          is = zid[2][it][jt];\n          js = jt;\n          ps = 3;\n          break;\n        case 3:\n          is = it;\n          js = zid[3][it][jt];\n          ps = 0;\n          break;\n      }\n      it = is;\n      jt = js;\n      pt = ps;\n    }\n    printf(\"%d %d\\n\", it, jt);\n  }      \n}\n\nint main() {\n  citaj();\n  pripremi();\n  obidji();\n//  system(\"pause\");\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/04_kodovi/","title":"A1 - Kodovi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nemanja Majski Marko Savi\u0107 04_kodovi.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 100010;\n\nint n;\nlong long x, solCount = 0, solTime = 0;\nlong long p[MAX_N], h[MAX_N];\nint left = 0, right = 1;\n\nint main()\n{\n    scanf(\"%d%lld\", &amp;n, &amp;x);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%lld%lld\", &amp;p[i], &amp;h[i]);\n        if (p[i] &lt; x) left = i;\n    }\n    right = left + 1;\n\n    while (left != 0 &amp;&amp; right != n + 1)\n    {\n        int Height = (h[right] &lt;= h[left] ? h[right] : h[left]);\n\n        solCount += Height * 2;\n        solTime += (p[right] - p[left]) * Height * 2;\n        h[left] -= Height;\n        h[right] -= Height;\n\n        if (h[right] == 0LL) \n            right++;\n        else\n            left--;\n    }\n\n    if (right == n + 1)\n    {\n        solTime -= (x - p[left]);\n    }\n    else\n    {\n        solCount++;\n        solTime += (p[right] - x);\n    }\n\n    printf(\"%lld\\n%lld\\n\", solCount, solTime);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/05_skrinja/","title":"A2 - \u0160krinja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Perice su drugari iz klupa. Oni jednostavno ne prepisuju. Sre\u0111uju\u0107i \u0161kolski tavan prona\u0161li su \u0161krinju, a u njoj drevni .pdf pun algoritama. .pdf je pisao stari u\u010ditelj Huang-Cu, i posuo blagim mirisom tre\u0161nje. Skinuli su pra\u0161inu sa njega i pogledali o \u010demu se tu zapravo radi.</p> <p>.pdf se sastoji od poglavlja sastavljenih od odre\u0111enog broja strana. Svako poglavlje detaljno opisuje jednu drevnu tehniku algoritama. Po\u0161to su tehnike stvarno komplikovane, i po\u0161to se algoritmi najbolje u\u010de tako \u0161to neko objasni, odlu\u010dili su da podele posao. Svaka tehnika bi\u0107e dodeljena jednom i samo jednom Perici da je nau\u010di i prezentuje ostalima. Kao dobri drugari tehnike \u0107e podeliti tako da je razlika izme\u0111u broja strana Perice koji ima najvi\u0161e strana da nau\u010di i Perice koji ima najmanje strana da nau\u010di najmanja mogu\u0107a. Po\u0161to Perice jo\u0161 uvek nisu nau\u010dile drevne ve\u0161tine Huang-Cua, ne znaju sami da izvr\u0161e tu podelu. Ti \u0107e\u0161 im pomo\u0107i.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dimitrije Dimi\u0107 Bogdan Petrovi\u0107 Nikola Milosavljevi\u0107 05_skrinja.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 20;\nconst int MAX_SUM = 2000000001;\n\nint n, k, sol;\nlong long counter = 0LL, counter2 = 0LL;\nint a[MAX_N], b[MAX_N], sum[MAX_N], part[MAX_N];\n\nvoid check()\n{\n    for (int i = 0; i &lt; k; i++) sum[i] = 0;\n    int minSum = MAX_SUM, maxSum = 0;\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        sum[ b[i] ] = sum[ b[i] ] + a[i];\n    }\n\n    for (int i = 0; i &lt; k; i++)\n    {\n        minSum = (sum[i] &lt; minSum ? sum[i] : minSum);\n        maxSum = (sum[i] &gt; maxSum ? sum[i] : maxSum);\n    }\n\n    if (maxSum - minSum &lt; sol)\n    {\n        sol = maxSum - minSum;\n        for (int i = 0; i &lt; n; i++)\n        {\n            part[i] = b[i];\n        }\n    }\n}\n\nvoid F(int currSet, int currNum, int currMinIndex)\n{\n    if (currNum &gt;= n)\n    {\n        return;\n    }\n    if (currSet == k)\n    {\n        check();\n        //counter++;\n        return;\n    }\n\n    b[currMinIndex] = currSet;\n    for (int mask = 0; mask &lt; (1 &lt;&lt; (n - currNum - 1)); mask++)\n    {\n        counter2++;\n\n        int ind = -1;\n        int newMinInd = -1;\n        int numOfElems = 1;\n        for (int i = currMinIndex + 1; i &lt; n; i++)\n        {\n            if (b[i] == 0)\n            {\n                ind++;\n                if ((mask &amp; (1 &lt;&lt; ind)) != 0) \n                {\n                    b[i] = currSet;\n                    numOfElems++;\n                }\n                else if (newMinInd == -1) newMinInd = i;\n            }\n        }\n        F(currSet + 1, currNum + numOfElems, newMinInd);\n        for (int i = currMinIndex + 1; i &lt; n; i++)\n        {\n            if (b[i] == currSet) b[i] = 0;\n        }\n    }\n    b[currMinIndex] = 0;\n}\n\nint main() \n{\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    for (int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;a[i]);\n\n    sol = MAX_SUM;\n    for (int i = 0; i &lt;= n; i++)\n        b[i] = 0;\n\n    F(1, 0, 0);\n    printf(\"%d\\n\", sol);\n\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%d \", part[i] + 1);\n    printf(\"\\n\");\n\n    /*counter = 0LL;\n    counter2 = 0LL;\n    F(1, 0, 0);\n    printf(\"%lld\\n\", counter);\n    printf(\"%lld\\n\", counter2);*/\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/05_skrinja/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(K\\), broj poglavlja u knjizi i broj Perica, redom. U drugom redu nalazi se \\(N\\) prirodnih brojeva \\(A_i\\) \u2013 broj strana \\(i\\)-tog poglavlja.</p>"},{"location":"takprog/2014_2015/okr/05_skrinja/#izlaz","title":"Izlaz","text":"<p>U prvom redu standardnog izlaza ispisati najmanju mogu\u0107u razliku izme\u0111u broja strana Perice koji ima najvi\u0161e strana da nau\u010di i Perice koji ima najmanje strana da nau\u010di. </p> <p>U drugom redu ispisati \\(N\\) brojeva gde \\(i\\)-ti broj predstavlja Pericu koji treba da nau\u010di \\(i\\)-to poglavlje. Ukoliko postiji vi\u0161e re\u0161enja sa najmanjom razlikom, \u0161tampati bilo koje.</p>"},{"location":"takprog/2014_2015/okr/05_skrinja/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(1 \\leq N \\leq 13\\)</li> <li>\\(1 \\leq K \\leq 13\\)</li> <li>\\(1 \\leq A_i \\leq 10^8\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 10 poena va\u017ei \\(N\\leq 3\\).</li> <li>U test primerima vrednim 30 poena va\u017ei \\(N\\leq 8\\).</li> <li>U test primerima vrednim 30 poena va\u017ei \\(N\\leq 11\\).</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/okr/05_skrinja/#primer","title":"Primer:","text":""},{"location":"takprog/2014_2015/okr/05_skrinja/#ulaz_1","title":"Ulaz","text":"<pre><code>5 3\n1 3 2 5 3\n</code></pre>"},{"location":"takprog/2014_2015/okr/05_skrinja/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n1 2 2 3 1\n</code></pre>"},{"location":"takprog/2014_2015/okr/05_skrinja/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Imamo \\(5\\) poglavlja knjige i \\(3\\) Perice. Prvi Perica \u0107e u\u010diti tehnike \\(1\\) (jedna strana) i \\(5\\) (tri strane), drugi tehnike \\(2\\) (tri strane) i \\(3\\) (dve strane) dok \u0107e tre\u0107i samo tehniku \\(4\\) (pet strana). U ovakvoj podeli Perice imaju redom \\(4\\), \\(4\\) i \\(5\\) strana da nau\u010de \u0161to zna\u010di da je razlika izme\u0111u Perice koji ima najvi\u0161e da nau\u010di i Perice koji ima najmanje da nau\u010di jednaka \\(1\\). Za dati primer nije mogu\u0107e napraviti podelu tako da svi dobiju jednako da nau\u010de, pa je razlika \\(1\\) optimalna.</p>"},{"location":"takprog/2014_2015/okr/06_presto/","title":"A3 - Presto","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Ma\u010dak Cvrle je nakon dugog i iscrpljuju\u0107eg lova na prepisiva\u010de odlu\u010dio da ode u ba\u0161tu da se odmori. Ba\u0161ta je podeljena na jedini\u010dna polja i ima oblik pravougaone matrice dimenzija \\(N\\times M\\). Polje u \\(i\\)-tom redu i \\(j\\)-toj koloni se nalazi na visini \\(H_{i,j}\\). Kako je ma\u010dak uspe\u0161no odradio jako te\u017eak zadatak, odlu\u010dio je da u ovoj ba\u0161ti sebi napravi presto.</p> <p>Presto je polje u ba\u0161ti koje se nalazi na manjoj ili jednakoj visini u odnosu na sva polja u tom redu, i ve\u0107oj ili jednakoj visini u odnosu na sva polja u toj koloni. Cvrle \u017eeli od vas da mu pomognete tako \u0161to \u0107ete mu re\u0107i koliko najmanje polja u ba\u0161ti mora da promeni visinu da bi se pojavio bar jedan presto (nove visine ne moraju biti celi brojevi).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 - Dimitrije Dimi\u0107 06_presto.cpp<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/okr/06_presto/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se prirodni brojevi \\(N\\) i \\(M\\), koji predstavljaju broj redova i broj kolona ba\u0161te, redom. U svakom od narednih \\(N\\) redova ulaza nalazi se \\(M\\) celih brojeva, razdvojenih razmakom \u2013 u \\(i\\)-tom od ovih redova \\(j\\)-ti broj predstavlja \\(H_{i,j}\\).</p>"},{"location":"takprog/2014_2015/okr/06_presto/#izlaz","title":"Izlaz","text":"<p>U prvi i jedini red standardnog izlaza ispisati ceo broj \\(x\\), koji predstavlja minimalan broj izmena.</p>"},{"location":"takprog/2014_2015/okr/06_presto/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(1 \\leq N,M \\leq 300\\)</li> <li>\\(0 \\leq H_{i,j} \\leq 10^9\\)</li> </ul> <p>U primerima vrednim 50 poena va\u017ei\u0107e 1\u2264N,M\u2264100.</p>"},{"location":"takprog/2014_2015/okr/06_presto/#primer","title":"Primer:","text":""},{"location":"takprog/2014_2015/okr/06_presto/#ulaz_1","title":"Ulaz","text":"<pre><code>3 4\n1 9 3 0\n6 2 7 5\n8 4 6 3\n</code></pre>"},{"location":"takprog/2014_2015/okr/06_presto/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2014_2015/okr/06_presto/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedan na\u010din da napravimo presto je da promenimo visinu polja u drugom redu i drugoj koloni sa \\(2\\) na \\(8\\). Nakon toga, polje u istom tom redu i poslednjoj koloni postaje presto.</p>"},{"location":"takprog/2014_2015/sio/01_zadatak/","title":"1 - Zadatak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Komisija ove godine nema vremena ni za \u0161ta, pa ni za smi\u0161ljanje zanimljivih tekstova problema. Zato se u tekstu ovog zadatka ne\u0107e pominjati likovi sa sme\u0161nim imenima, izosta\u0107e prikrivena me\u0111usobna prozivanja \u010dlanova Komisije,  a ne\u0107e tu biti ni uobi\u010dajenog zafrkavanja takmi\u010dara.</p> <p>Dato je stablo sa \\(N\\) \u010dvorova ozna\u010denih brojevima od \\(1\\) do \\(N\\), tako da je svaki broj upotrebljen za ta\u010dno jedan \u010dvor. (Stablo je ono \u0161to je Komisija do sad uglavnom nazivala dr\u017eavom koja je povezana putevima tako da izme\u0111u svaka dva grada postoji jedinstven put.)</p> <p>Potrebno je napraviti matricu u kojoj je svako polje ozna\u010deno nekim brojem od \\(1\\) do \\(N\\), tako da su slede\u0107i uslovi zadovoljeni:</p> <ul> <li>Za svaki par povezanih \u010dvorova u stablu mora postojati bar jedan par susednih polja u matrici koji su ozna\u010deni sa istim brojevima kao i ta dva \u010dvora.</li> <li>Za svaki par susednih polja u matrici ozna\u010denih razli\u010ditim brojevima mora postojati par povezanih \u010dvorova u stablu koji su ozna\u010deni sa ista ta dva broja.</li> <li>Za svaka dva polja u matrici koja su ozna\u010dena istim brojem mora postojati niz susednih polja ozna\u010denih tim brojem koji po\u010dinje i zavr\u0161ava se tim poljima (sva polja sa istom oznakom u matrici moraju biti povezana). Dva polja u matrici su susedna ako dele zajedni\u010dku stranicu.</li> </ul> <p>Dva polja u matrici su susedna ako dele zajedni\u010dku stranicu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Dimi\u0107 Dimitrije Dimi\u0107 - Ivan Sto\u0161i\u0107 01_zadatak.cpp"},{"location":"takprog/2014_2015/sio/01_zadatak/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju </p> <ul> <li>\\(NapraviMatricu(N, S, T)\\)</li> </ul> <p>gde je \\(N\\) broj \u010dvorova u stablu, a \\(S\\) je niz du\u017eine \\(2(N-1)\\) u kome su redom navedeni parovi povezanih \u010dvorova u stablu (prvi i drugi element niza \\(S\\) su oznake dva povezana \u010dvora, isto to va\u017ei za tre\u0107i i \u010detvrti element niza, potom peti i \u0161esti, itd.).</p> <p>Funkciji se tako\u0111e prosle\u0111uje niz \\(T\\) kroz koji treba da vratite va\u0161e re\u0161enje.  Prvi element niza \\(T\\)  je broj \\(H\\), broj vrsta konstruisane matrice, drugi element je \\(W\\), broj kolona te matrice, i narednih \\(H*W\\) elemenata su oznake polja u toj matrici koje se navode red po red (najpre se navodi \\(W\\) polja prvog reda, potom \\(W\\) polja drugog reda, itd.). Preostali elementi niza nisu od zna\u010daja. Nizovi \\(S\\) i \\(T\\) su indeksirani od \\(0\\), \u0161to zna\u010di da je prvi element ovih nizova onaj sa indeksom \\(0\\).</p>"},{"location":"takprog/2014_2015/sio/01_zadatak/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N = 5\\), a \\(S = [1, 2, 2, 3, 2, 4, 4, 5]\\). Ovim je opisano slede\u0107e stablo.</p> <pre><code>1 - 2 - 4 - 5\n    |\n    3\n</code></pre> <p>Primeri matrica koje zadovoljavaju postavljene uslove:</p> <pre><code>5 4 2 3\n5 4 2 2\n4 4 2 1\n\n1 1 2 2\n1 2 2 4\n2 2 4 4\n3 2 4 5\n\n2 2 2 2 1 (Primetite da polja sa oznakama 3 i 4 nisu susedna)\n2 2 2 2 2\n2 2 3 2 2\n4 4 2 2 2\n5 4 2 2 2\n</code></pre> <p>Za matricu iz prvog primera odgovaraju\u0107i niz \\(T\\), koji funkcija treba da vrati je \\([3, 4, 5, 4, 2, 3, 5, 4, 2, 2, 4, 4, 2, 1]\\). Primeri matrica koje ne zadovoljavaju postavljene uslove:</p> <pre><code>5 4 2 3 (3 i 1 nisu povezani u stablu, a susedni su u matrici.)\n5 4 2 1\n\n1 1 1 1 (4 i 5 su povezani u stablu, a nisu susedni u matrici (jer u matrici ne postoji polje sa oznakom 5))\n2 2 2 2\n3 2 4 4\n\n2 1 2 2 2 (Polja sa oznakom 2 nisu povezana)\n3 2 4 2 5\n</code></pre>"},{"location":"takprog/2014_2015/sio/01_zadatak/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N \\leq 100\\)</li> <li>Nijedna dimenzija konstruisane matrice ne sme biti ve\u0107a od \\(1000\\). (Niz \\(T\\) \u0107e imati \\(2+1000*1000\\) elemenata.)</li> </ul>"},{"location":"takprog/2014_2015/sio/01_zadatak/#bodovanje","title":"Bodovanje","text":"<p>Re\u0161enje koje ne ispunjava neki od uslova boduje se sa \\(0\\) poena. Ukoliko re\u0161enje ispunjava sve uslove broj bodova za svaki test primer odre\u0111uje se na osnovu veli\u010dine konstruisane matrice i to:</p> <ul> <li>Ako je bar jedna dimenzija ve\u0107a od \\(10N\\) na tom test primeru dobijate \\(0\\) poena.</li> <li>Ina\u010de, broj bodova se ra\u010duna na osnovu formule: \\(\\min(1.0, 0.12 + 0.88 \\cdot \\frac{N}{\\max(H,W)})\\cdot X\\), gde je \\(X\\) maksimalni broj poena koje mo\u017eete osvojiti po test primeru. </li> </ul> <p>Ukupan broj poena jednak je zbiru poena za svaki test primer.</p>"},{"location":"takprog/2014_2015/sio/01_zadatak/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom zadatak.c, zadatak.cpp ili zadatak.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    void NapraviMatricu(int N, int *S, int *T);\nPascal\n    procedure NapraviMatricu(N : Integer; var S, T : array of Integer);\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include \u201czadatak.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit zadatak;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/01_zadatak/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (zadatak.c, zadatak.cpp, zadatak.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>Iz prvog redu u\u010ditavaju broj \\(N\\),</li> <li>Iz svakog od narednih \\(N-1\\) redova u\u010ditavaju po dva broja koji predstavljaju par povezanih \u010dvorova u stablu,</li> </ul> <p>a zatim pozivaju va\u0161u funkciju NapraviMatricu iz odgovaraju\u0107eg fajla (zadatak.c, zadatak.cpp, zadatak.pas) sa u\u010ditanim podacima, i na kraju konstruisanu matricu koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2014_2015/sio/02_kule/","title":"2 - Kule","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>\u010clanovi Tajne Komisije, mali Perica i mali Tuks, u pauzama izme\u0111u pripreme zadataka i spremanja ispita vole da igraju dru\u0161tvenu igru \u201dKule\u201d. Pravila igre podrazumevaju da u po\u010detku na raspolaganju imamo neki broj kockica, naslaganih jedna na drugu, u obliku kule. </p> <p>Jedan potez podrazumeva da Perica izdeli kulu na dve ili vi\u0161e manjih kula, i pore\u0111a takve kule u niz; Tuks zatim mora da odabere jednu od tih manjih kula, koja \u0107e se koristiti za naredne poteze (sve ostale kule se odbacuju). Ukoliko je Tuks odabrao \\(k\\)-tu kulu u nizu, Perica je u obavezi da mu isplati \\(k^2\\) dinara (npr. ukoliko je Tuks odabrao tre\u0107u kulu, Perica mora odmah da mu da devet dinara). Igra se zavr\u0161ava u onom momentu kada trenutna kula ima samo jednu kockicu.</p> <p>Kako je odve\u0107 poznato da \u010dlanovi Tajne Komisije nemaju vremena ni za \u0161ta (a samim tim ni za igranje igara), Perica i Tuks su odlu\u010dili da, umesto da odigraju partiju \u201dKula\u201d, poveruju jedan drugom da bi obojica igrali optimalno, i da Perica odmah isplati Tuksu iznos koji bi osvojio pod tim uslovom. Zamolili su vas za pomo\u0107 u odre\u0111ivanju ovog iznosa.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dragan Uro\u0161evi\u0107 - Petar Veli\u010dkovi\u0107 02_kule.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;string.h&gt;\n# include &lt;stdlib.h&gt;\n\n# define MAXC 200\n# define MAXN 2000\n\nusing namespace std;\n\ntypedef struct vbr {\n  int nc;\n  int nizc[MAXC];\n} tvbroj;\n\nlong long nizll[MAXN];\ntvbroj nizvb[MAXN];\nint c3[1000*MAXC];\n\nvoid llong2vbroj(long long a, tvbroj &amp;x) {\n  if (a == 0) {\n    x.nc = 1;\n    x.nizc[0] = 0;\n    return;\n  }\n  x.nc = 0;\n  while (a) {\n    x.nizc[x.nc++] = a % 10;\n    a /= 10;\n  }\n}\n\nvoid niz2vbroj(int n, int c[], tvbroj &amp;a) {\n  int i, j;\n  a.nc = n;\n  i = 0; j = n;\n  while (j &gt; 0) {\n    a.nizc[i++] = c[j--];\n  }\n}\n\nvoid dodaj(tvbroj &amp;a, tvbroj b) {\n  int i, j, p;\n  if (b.nc &lt; a.nc) {\n    p = 0;\n    for (i = 0; i &lt; b.nc; i++) {\n      p = a.nizc[i] + b.nizc[i] + p;\n      a.nizc[i] = p % 10;\n      p = p / 10;\n    }\n    while (i &lt; a.nc) {\n      p = a.nizc[i] + p;\n      a.nizc[i] = p % 10;\n      p = p / 10;\n      i++;\n    }\n    if (p) {\n      a.nizc[a.nc++] = p;\n    }\n  } else {\n    p = 0;\n    for (i = 0; i &lt; a.nc; i++) {\n      p = a.nizc[i] + b.nizc[i] + p;\n      a.nizc[i] = p % 10;\n      p = p / 10;\n    }\n    while (i &lt; b.nc) {\n      p = b.nizc[i] + p;\n      a.nizc[i] = p % 10;\n      p = p / 10;\n      i++;\n    }\n    a.nc = b.nc;\n    if (p) {\n      a.nizc[a.nc++] = p;\n    }\n  }\n}\n\nvoid oduzmi(tvbroj &amp;d, tvbroj b) {\n  int p;\n  int i;\n  int nd, nb;\n  nd = d.nc;\n  nb = b.nc;\n  p = 0;\n  for (i = 0; i &lt; nb; i++) {\n    p = d.nizc[i] - p - b.nizc[i];\n    if (p &lt; 0) {\n      d.nizc[i] = p + 10;\n      p = 1;\n    } else {\n      d.nizc[i] = p;\n      p = 0;\n    }\n  }\n  for (; i &lt; nd; i++) {\n    p = d.nizc[i] - p;\n    if (p &lt; 0) {\n      d.nizc[i] = p + 10;\n      p = 1;\n    } else {\n      d.nizc[i] = p;\n      p = 0;\n    }\n  }\n  while ((nd &gt; 1) &amp;&amp; (d.nizc[nd-1] == 0)) nd--;\n  d.nc = nd;\n}\n\nint cmpvbroj(tvbroj a, tvbroj b) {\n  int na, nb;\n  na = a.nc-1;\n  while ((na &gt;= 0) &amp;&amp; (a.nizc[na] == 0)) na--;\n  nb = b.nc-1;\n  while ((nb &gt;= 0) &amp;&amp; (b.nizc[nb] == 0)) nb--;\n  if (na &gt; nb) return 1;\n  if (na &lt; nb) return -1;\n  while ((na &gt;= 0) &amp;&amp; (a.nizc[na] == b.nizc[na])) na--;\n  if (na &lt; 0) return 0;\n  return a.nizc[na] - b.nizc[na];\n}\n\nint dopisi(tvbroj a, int nk, int c[]) {\n  int na;\n  na = a.nc;\n  while (na &gt; 0) {\n    c[++nk] = a.nizc[--na];\n  }\n  c[++nk] = -1;\n  return nk;\n}\n\nint radill(long long a) {\n  int i, j, k;\n  nizll[0] = 1;\n  nizll[1] = 1;\n  nizll[2] = 1;\n  nizll[3] = 1;\n  nizll[4] = 2;\n  for (i = 5; i &lt; MAXN; i++) {\n    nizll[i] = 0;\n    for (j = 1; j * j &lt;= i; j++)\n      nizll[i] += nizll[i-j*j];\n    if (nizll[i] &gt;= a) return i;\n  }\n  return -1;\n}\n\nint int2nizc(int b, int c[]) {\n  int i, j, k, n;\n  i = 0;\n  while (b) {\n    c[++i] = b % 10;\n    b /= 10;\n  }\n  n = i;\n  j = 1;\n  while (j &lt; i) {\n    int tc;\n    tc = c[j]; c[j] = c[i]; c[i] = tc;\n    j++; i--;\n  }\n  return n;\n}\n\nint radivb(tvbroj a, int c2[], int &amp;ns, int &amp;n3, int c3[]) {\n  int i, j, k, n2;\n  tvbroj b, c, d;\n  llong2vbroj(1, nizvb[0]);\n  llong2vbroj(1, nizvb[1]);\n  llong2vbroj(1, nizvb[2]);\n  llong2vbroj(1, nizvb[3]);\n  llong2vbroj(2, nizvb[4]);\n  for (i = 5; i &lt; MAXN; i++) {\n    llong2vbroj(0, nizvb[i]);\n    for (j = 1; j * j &lt;= i; j++)\n      dodaj(nizvb[i], nizvb[i-j*j]);\n    if (cmpvbroj(nizvb[i], a) &gt;= 0) {\n      n2 = int2nizc(i, c2);\n      llong2vbroj(0, b);\n      j = 1;\n      n3 = 0;\n      ns = 0;\n      while (cmpvbroj(b, a) &lt; 0) {\n        c = b;\n        dodaj(b, nizvb[i-j*j]);\n        if (cmpvbroj(b, a) &lt;= 0) {\n          n3 = dopisi(nizvb[i-j*j], n3, c3);\n          ns++;\n          j++;\n        } else {\n          d = a;\n          oduzmi(d, c);\n          n3 = dopisi(d, n3, c3);\n          ns++;\n          return n2;\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint Iznos(int n, int c1[], int c2[], int &amp;ns, int &amp;n3, int c3[]) {\n  tvbroj avb;\n  niz2vbroj(n, c1, avb);\n  return radivb(avb, c2, ns, n3, c3);\n}\n\nmain() {\n  int nc2, nc3, ns;\n  char c[MAXC+1];\n  int c1[MAXC+1];\n  int c2[MAXC+1];\n  long long all; \n  scanf(\"%s\", c);\n  int i, j, n;\n  i = 1; j = 0; n = strlen(c);\n  while (j &lt; n) \n    c1[i++] = c[j++] - '0';\n  nc2 = Iznos(n, c1, c2, ns, nc3, c3);\n  for (int i = 1; i &lt;= nc2; i++)\n    printf(\"%d\", c2[i]);\n  printf(\"\\n%d\\n\", ns);\n  for (i = 1; i &lt;= nc3; i++)\n    if (c3[i] != -1)\n      printf(\"%d\", c3[i]);\n    else\n      printf(\"\\n\");\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2014_2015/sio/02_kule/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju</p> <ul> <li>\\(Iznos(L,N[\u2026],Sol[\u2026],N_k,N_(C_1 ),C_1 [\u2026])\\); </li> </ul> <p>ova funkcija se poziva samo jednom na po\u010detku programa i ozna\u010dava da treba odrediti iznos koji Perica mora isplatiti Tuksu, ukoliko je po\u010detna kula imala \\(N\\) kockica (\\(N\\) je zadat kao niz cifara du\u017eine \\(L\\)). Tra\u017eeni iznos treba \u201dpopuniti\u201d u niz \\(Sol\\), tako\u0111e u vidu niza cifara. Va\u0161a funkcija mora da kao povratnu vrednost vrati du\u017einu niza \\(Sol\\), tj. broj cifara re\u0161enja. </p> <p>Va\u0161e re\u0161enje tako\u0111e treba da odredi prvi potez koji Perica povla\u010di, ukoliko rezultuje u manje od \\(1000\\) kula. U promenljivu \\(N_k\\) je potrebno smestiti broj manjih kula u prvoj optimalnoj podeli; ukoliko je ovaj broj ve\u0107i od \\(1000\\), upisati \\(-1\\). </p> <p>Ukoliko je optimalan broj manjih kula manji ili jednak \\(1000\\), niz \\(C_1\\) treba \u201dpopuniti\u201d nizovima cifara visina ovih kula (kraj jednog takvog niza cifara ozna\u010diti brojem -1). Na primer, ukoliko \u017eelite da napravite podelu na kule visina 10 i 4, onda \\(C_1=[1,0,-1,4,-1]\\). Veli\u010dinu niza \\(C_1\\) treba smestiti u promenljivu \\(N_{C_1}\\).</p> <p>Ukoliko ima vi\u0161e optimalnih prvih podela, odredite bilo koju. Nizove indeksirati od 0!</p>"},{"location":"takprog/2014_2015/sio/02_kule/#primer","title":"Primer","text":"<p>Pretpostavimo da je va\u0161 program dobio naredbu da izvr\u0161i: <code>Iznos(1,[7],Sol,N_k,N_(C_1 ),C_1 )</code>.</p> <p>U ovom slu\u010daju, re\u0161enje je \\(Sol=[8]\\), \\(N_k=2\\), \\(N_{C_1}=4\\), \\(C_1=[5,-1,2,-1]\\); povratna vrednost va\u0161e funkcije treba da bude 1.</p> <p>U jednom od mogu\u0107ih optimalnih re\u0161enja, Perica najpre deli kulu na dve kule visina 5 i 2. Ukoliko Tuks odabere drugu kulu (visine 2), dobija odmah 4 dinara, i Perica je nakon toga primoran da ovu kulu podeli na dve kule visine 1, nakon \u010dega Tuks ponovo dobija 4 dinara (8 ukupno). Ukoliko Tuks odabere prvu kulu, Perica mo\u017ee u svakom narednom potezu da deli kulu na dve kule od kojih druga ima visinu 1; u ovom slu\u010daju, Tuks \u0107e pri optimalnoj strategiji \u010detiri puta dobiti po jedan dinar, da bi na samom kraju dobio \u010detiri (ponovo 8 ukupno).</p> <p>Ne postoji po\u010detna podela kule visine 7 koja \u0107e rezultovati u manjem iznosu.</p>"},{"location":"takprog/2014_2015/sio/02_kule/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2\\leq N\\leq 10^{100}\\)</li> </ul>"},{"location":"takprog/2014_2015/sio/02_kule/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u pet podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>PODZADATAK 1 [10 POENA]: \\(N\\leq 20\\).</li> <li>PODZADATAK 2 [15 POENA]: \\(N\\leq 1000\\).</li> <li>PODZADATAK 3 [20 POENA]: \\(N\\leq 10^6\\).</li> <li>PODZADATAK 4 [20 POENA]: \\(N\\leq 10^18\\).</li> <li>PODZADATAK 5 [35 POENA]: Nema dodatnih ograni\u010denja.</li> </ul> <p>Ukoliko na svim test primerima jednog podzadatka izra\u010dunate ta\u010dan iznos koji Perica treba da isplati Tuksu, dobijate 60% poena za taj podzadatak. Ukoliko korektno odredite optimalan prvi Peri\u010din potez na svim test primerima jednog podzadatka, dobijate 40% poena za taj podzadatak.</p>"},{"location":"takprog/2014_2015/sio/02_kule/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom kule.c, kule.cpp ili kule.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    int Iznos(int L, int* N, int* Sol, int* Nk, int* NC1, int* C1);\nPascal\n    function Iznos(L : longint; var N, Sol : array of longint; var Nk, NC1 : longint; var C1 : array of longint) : longint;\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include \u201ckule.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit kule;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/02_kule/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (kule.c, kule.cpp, kule.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza string koji predstavlja niz cifara broja \\(N\\), \\(Cif[...]\\).</p> <p>Zatim pozivaju funkciju \\(Iznos(L,Cif,Sol,N_k,N_{C_1},C_1)\\) i ispisuju na standardni izlaz sadr\u017eaj niza  \\(Sol\\), kao i vrednost promenljive \\(N_k\\) i sadr\u017eaj niza \\(C_1\\). Nizovi se ispisuju bez razmaka; unutar niza \\(C_1\\) umesto \\(-1\\) se ispisuju razmaci.</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/","title":"3 - Autobusi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 1024MB <p>Tajna Komisija ni ovog puta nije imala vremena da takmi\u010dare povede u obilazak Beograda. Me\u0111utim, op\u0161te je poznato da Beograd ima kvalitetan javni gradski prevoz, i da je ovaj prevoz besplatan za sve takmi\u010dare koji na sebi imaju zna\u010dku na kojoj pi\u0161e SIO 2015. Da bi takmi\u010dar ostvario pravo na besplatan prevoz, dovoljno je da voza\u010du poka\u017ee zna\u010dku. Me\u0111utim, Komisija je zabrinuta za bezbednost takmi\u010dara, pa \u017eeli da za neke parove po\u010detne i krajnje stanice zna koliko razli\u010ditih autobuskih linija postoji, tako da je mogu\u0107e do\u0107i od te po\u010detne do te krajnje stanice.</p> <p>Svaka autobuska linija je opisana nizom stanica - mogu\u0107e je ponavljanje stanica. Svaka stanica ima svoj identifikacioni broj koji je prirodan i manji ili jednak \\(W\\). Za neku liniju i neki par stanica \\(x\\),\\(y\\) ka\u017eemo da je mogu\u0107e \\(i\\)-tom linijom do\u0107i od \\(x\\) do \\(y\\) ako i samo ako se u nizu stanica za tu liniju stanica \\(x\\) pojavljuje bar jednom pre nekog pojavljivanja stanice \\(y\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksandar Vi\u0161nji\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2014_2015/sio/03_autobusi/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Va\u0161oj funkciji prosle\u0111uje se \\(n\\), broj autobuskih linija; duzine, niz koji opisuje du\u017einu svake linije tj. broj stanica, zatim niz \\(a\\), koji je dobijen nadovezivanjem nizova stanica za sve autobuse; \\(q\\), broj upita; dva niza \\(x\\) i \\(y\\) - u \\(i\\)-tom upitu po\u010detna stanica je \\(x[i]\\), a krajnja \\(y[i]\\), i dat vam je niz \\(resenja\\) koji va\u0161a funkcija treba da popuni: u \\(resenja[i]\\) upisati odgovor na \\(i\\)-ti upit.</p> <p>Dodatno, ozna\u010dimo du\u017einu niza \\(a\\) sa \\(m\\). Svi nizovi su indeksirani od nule.</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#primer","title":"Primer","text":"<p>Neka je broj autobuskih linija \\(n=3\\), i neka su te linije opisane nizovima \\([1,2,3,4]\\),\\([2,4]\\),\\([2,3,1,4]\\). Onda je niz \\(duzine=[4,2,4]\\), i niz \\(a=[1,2,3,4,2,4,2,3,1,4]\\). Neka je broj upita \\(q=4\\) i neka su upiti \\((1,3)\\),\\((2,4)\\),\\((1,4)\\),\\((4,1)\\). Onda je \\(x=[1,2,1,4]\\) i \\(y=[3,4,4,1]\\). Va\u0161a funkcija treba niz \\(resenja\\) da popuni slede\u0107im vrednostima: \\([1,3,2,0]\\).</p> <p>Za upit \\((1,3)\\), re\u0161enje je \\(1\\) \u2013 jedina autobuska linija kod koje se stanica ozna\u010dena brojem \\(1\\) pojavljuje pre stanice ozna\u010dene brojem \\(3\\) je linija \\([1,2,3,4]\\).</p> <p>Za upit \\((2,4)\\), re\u0161enje je \\(3\\) \u2013 svakom linijom se mo\u017ee do\u0107i  od stanice \\(2\\) do stanice \\(4\\).</p> <p>Za upit \\((1,4)\\), re\u0161enje je \\(2\\) \u2013 drugom linijom je nemogu\u0107e do\u0107i od \\(1\\) do \\(4\\) a preostalim dvema jeste.</p> <p>Za upit \\((4,1)\\), re\u0161enje je \\(0\\) \u2013 nijednom linijom se ne mo\u017ee do\u0107i od \\(4\\) do \\(1\\).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq n,q\\leq 100000\\)</li> <li>\\(W&lt;100000\\)</li> <li>\\(m\\leq 100000\\)</li> <li>\\(1\\leq x[i],y[i]\\leq W\\)</li> <li>\\(x[i] \\neq y[i]\\)</li> </ul>"},{"location":"takprog/2014_2015/sio/03_autobusi/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li>PODZADATAK 1 [9 POENA]: \\(n,q,m\\leq 1000\\)</li> <li>PODZADATAK 2 [14 POENA]: \\(n\\leq 10\\)</li> <li>PODZADATAK 3 [16 POENA]: \\(W\\leq 1000\\)</li> <li>PODZADATAK 4 [26 POENA]: \\(n,q,m\\leq 50000\\)</li> <li>PODZADATAK 5 [35 POENA]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2014_2015/sio/03_autobusi/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom autobusi.c, autobusi.cpp ili autobusi.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    void resi(int n, int *duzine, int *a, int q, int *x, int *y, int *resenja);\nPascal\n    procedure resi(n : longint; var duzine, a : array of longint; q : longint; var x, y, resenja : array of longint);\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include \u201cgrader.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit autobusi;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Na raspolaganju su vam templejt fajlovi koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni pomo\u0107ni programi () koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju podatke sa standardnog ulaza, pozivaju va\u0161u funkciju \\(resi\\) i ispisuju niz re\u0161enja na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi. Format ulaza za programe je slede\u0107i:</p> <p>U prvi red upisati broj autobuskih linija \\(n\\). U drugi red upisati \\(n\\) brojeva - du\u017eine autobuskih linija. Za narednih \\(n\\) redova, u \\(i\\)-ti upisati \\(duzine[i]\\) brojeva, oznake stanica. U naredni red upisati \\(q\\) - broj upita.  Za narednih \\(q\\) redova, u \\(i\\)-ti upisati dva broja \\(x[i]\\) i \\(y[i]\\), identifikacione brojeve po\u010detne i krajnje stanice.</p> <p>Izgled ulaza za gore opisan primer je slede\u0107i:</p> <pre><code>3\n4 2 4\n1 2 3 4\n2 4\n2 3 1 4\n4\n1 3\n2 4\n1 4\n4 1\n</code></pre>"},{"location":"takprog/2014_2015/sio/03_autobusi/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Svakim upitom prolazimo jednom kroz niz \\(A\\). Napravi\u0107emo pomo\u0107ni bool niz \\(B\\) koji nam slu\u017ei da pamtimo prethodno pose\u0107ene stanice u tom prolasku. \\(A\\) se po definiciji deli na disjunktne segmente koji ozna\u010davaju po jednu autobusku liniju, stoga kada pro\u0111emo kroz jedan takav segment potrebno je opet pro\u0107i i markirati sve njegove stanice kao nepose\u0107ene, po\u0161to se svaki segment re\u0161ava zasebno. Kada nai\u0111emo na \\(Y_i\\), potrebno je samo proveriti da li je stanica \\(X_i\\) ve\u0107 pose\u0107ena. (Napomena: broj re\u0161enja se pove\u0107ava najvi\u0161e jednom po segmentu/autobuskoj liniji) Vremenska slo\u017eenost je \\(O(Q\\cdot M+N+W)\\), a memorijska \\(O(W)\\).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Pravimo dve pomo\u0107ne matrice \\(L[i][j]\\) i \\(R[i][j]\\) koje, redom, ozna\u010davaju prvo i poslednje pojavljivanje stanice \\(j\\) u liniji \\(i\\). Broj \\(-1\\) ozna\u010dava da takva stanica ne postoji. Sada za svaki upit mo\u017eemo jednostavno proveriti da li se \\(X_i\\) nalazi pre \\(Y_i\\) u svakoj od \\(N\\) autobuskih linija. Vremenska slo\u017eenost je \\(O(N\\cdot W+N\\cdot Q+M)\\), a memorijska \\(O(N\\cdot W)\\).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Izra\u010duna\u0107emo za svake dve stanice broj linija, pa \u0107emo odgovarati na upite u \\(O(1)\\). Za efikasno ra\u010dunanje \u0107emo po svakoj liniji zasebno pro\u0107i po svim parovima stanica u njoj i odrediti da li je mogu\u0107e da se jedna na\u0111e pre druge. (Ra\u010dunamo samo jednistvene stanice u liniji)</p> <p>Ovo radi u \\(O(len_i^2)\\) vremenu po liniji \\(i\\) koja ima \\(len_i\\leq W\\) stanica. Neka je \\(f(len_1,len_2,...,len_N)=\\sum_{i=1}^N len_i^2\\). Nije te\u0161ko videti da va\u017ei \\(f(...,len_i+1,...,len_j-1,...)&gt;f(...,len_i,...,len_j,..)\\) ako je \\(len_i\\geq len_j\\) i \\(i\\neq j\\). (Ne mora da va\u017ei \\(i&lt;j\\) kao u primeru gore, bitno je samo da su razli\u010diti indeksi) Iz ovoga neposredno sledi \\(f(len_1,...,len_N)\\leq f(W,...,W,0,...,0)\\). U drugoj funkciji se \\(W\\) pojavljuje ne vi\u0161e od \\(\\frac{M+W}{W}\\) puta, pa va\u017ei \\(f(W,...,W,0,...,0)\\leq (M+W)\\cdot W\\) i to je na\u0161e gornje ograni\u010denje za broj operacija.</p> <p>Vremenska slo\u017eenost je \\(O(M\\cdot W+W^2 + N+Q)\\), a memorijska \\(O(W^2)\\).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#cetvrti-podzadatak","title":"\u010cetvrti podzadatak:","text":"<p>Napravimo dva niza mapa \\(L\\) i \\(R\\) veli\u010dine \\(N\\). U njima za svaku autobusku liniju i stanicu u njoj pamtimo njeno prvo i poslednje pojavljivanje u okviru date linije. Tako\u0111e, pravimo niz skupova \\(S\\) veli\u010dine \\(W\\). U njemu za svaku stanicu odre\u0111ujemo koje sve linije prolaze kroz nju. Na upite odgovaramo na slede\u0107i na\u010din:</p> <p>Ako smo ve\u0107 odgovorili na upit \\((X_i,Y_i)\\), samo \u0107emo uzeti prethodno zapam\u0107eno re\u0161enje. (ovo je neophodno jer \u0107e ra\u010dunanje novih odgovora biti sporo, a bitno je garantovati da oni budu razli\u010diti) Za nov upit \u0107emo jednom pro\u0107i kroz manji od skupova \\(S[X_i]\\) ili \\(S[Y_i]\\), i za svaku njegovu autobusku liniju odrediti da li se \\(X_i\\) nalazi pre \\(Y_i\\).</p> <p>Ovo na prvi pogled izgleda kao da radi u \\(O(Q\\cdot N)\\) vremenu sa malom konstantom. Dokaza\u0107emo da to nije slu\u010daj. Neka niz \\(s_i\\) predstavlja koliko smo puta pro\u0161li kroz skup \\(S[i]\\). Mo\u017eemo nadalje pretpostaviti, bez umanjenja op\u0161tosti, da je dat niz skupova sortiran u nerastu\u0107em poretku po njihovim veli\u010dinama. Kako nikad ne pitamo dva ista skupa vi\u0161e od dvaput, i kako uvek pitamo manji od dva skupa, mo\u017eemo zaklju\u010diti \\(s_i \\leq2( i-1)\\) za svako \\(1\\leq i \\leq W\\). Ukupan broj operacija iznosi \\(\\sum s_i\\cdot S[i].size\\) , a maksimum se upravo posti\u017ee za \\(s_i=2(i-1)\\), \\(1\\leq i \\leq \\sqrt{Q}\\). (Otprilike, mora da va\u017ei \\(\\sum s_i=Q\\), a \\(2\\cdot \\sum_{i=1}^{\\sqrt{Q}} (i-1)\\) prevazilazi \\(Q\\)) Kada bismo mogli da menjamo veli\u010dine skupova iz niza \\(S\\) prebacivanjem jednog elementa u drugi, pove\u0107ao bi se ukupni broj operacija kada bi se pove\u0107ao i skup sa vi\u0161e prolaska. (tj. ve\u0107im brojem \\(s_i\\)) Ovim se na kraju dobija da najve\u0107i ukupan broj operacija nije ve\u0107i nego u slu\u010daju u kom va\u017ei \\(S[1].size=S[2].size=...=S[Q].size= \\sqrt{N}\\), zbog poretka veli\u010dina. Algoritam \u0107e izvr\u0161iti najvi\u0161e \\(O(Q\\sqrt{N})\\) operacija.</p> <p>Ako koristimo std::map i std::set, ukupna vremenska slo\u017eenost je  \\(O(Q\\cdot \\sqrt{N}\\cdot logN +N+M+W )\\) , a memorijska \\(O(N+M+W)\\).</p>"},{"location":"takprog/2014_2015/sio/03_autobusi/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Re\u0161enje je isto kao i  u \u010detvrtom podzadatku, samo \u0107emo umesto std::set i std::map koristiti std::unordered_set i std::unordered_map, \u010dime se vremenska slo\u017eenost pobolj\u0161ava na \\(O(Q\\cdot\\sqrt{N}+N+M+W)\\). Zadatak se tako\u0111e mo\u017ee re\u0161iti i offline ne\u0161to br\u017ee tako \u0161to \u0107emo postojanje linije koja prolazi kroz neku stanicu odrediti naknadno, ali implementacija toga je malo te\u017ea. Sve u svemu, ukupna vremenska slo\u017eenost je \\(O(Q\\cdot\\sqrt{N}+N+M+W)\\), a memorijska \\(O(N+M+W)\\).</p> 03_autobusi.cpp<pre><code>#include \"autobusi.h\"\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n#define KORISTI_HASH_VELIKI\n#define KORISTI_HASH_MALI\n#define MAXN 100005\n#define LIMIT 316\n#define MAXX 100000\n#define MAX_VELIKI 318\n\n//veliki\n\n#ifdef KORISTI_HASH_VELIKI\n\nnamespace veliki{\n    int *pl[MAX_VELIKI],*pr[MAX_VELIKI];\n    int br;\n\n    inline void napravi(int n, int sizes[], int a[]){\n        int *poc = new int[n+1],i,j;\n        poc[0] = 0;\n        for (int i=1; i&lt;=n; i++) poc[i] = sizes[i-1] + poc[i-1];\n        br=0;\n        for (i=0; i&lt;n; i++) if (sizes[i]&gt;LIMIT){\n            pl[br] = new int[MAXX];\n            pr[br] = new int[MAXX];\n            memset(pl[br],63,sizeof(int)*MAXX); //beskonacno\n            memset(pr[br],255,sizeof(int)*MAXX); //-1\n            for (j=poc[i];  j&lt;poc[i+1]; j++) pr[br][a[j]] = j;\n            for (j=poc[i+1]-1;  j&gt;=poc[i]; j--) pl[br][a[j]] = j;\n            br++;\n        }\n        delete []poc;\n    }\n\n    inline int izbroji(int a,int b){\n        int c=0;\n        for (int i=0; i&lt;br; i++){\n            if (pl[i][a] &lt; pr[i][b]) c++;\n        }\n        return c;\n    }\n}\n\n#endif\n#ifndef KORISTI_HASH_VELIKI\n\nnamespace veliki{\n    struct par{\n        int br,idx;\n        inline bool operator&lt;(const par&amp; drugi)const{\n            return br&lt;drugi.br || (br==drugi.br &amp;&amp; idx &lt; drugi.idx);\n        }\n    };\n\n    par *parovi[MAX_VELIKI];\n    int duz[MAX_VELIKI];\n    int br;\n\n    inline void napravi(int n, int sizes[], int a[]){\n        int *poc = new int[n+1],i,j;\n        poc[0] = 0;\n        for (int i=1; i&lt;=n; i++) poc[i] = sizes[i-1] + poc[i-1];\n        br=0;\n        for (i=0; i&lt;n; i++) if (sizes[i]&gt;LIMIT){\n            parovi[br] = new par[sizes[i]];\n            duz[br] = sizes[i];\n            for (j=0; j&lt;sizes[i]; j++){\n                parovi[br][j].br = a[poc[i]+j];\n                parovi[br][j].idx = j;\n            }\n            sort(parovi[br],parovi[br]+duz[br]);\n            br++;\n        }\n        delete []poc;\n    }\n\n    inline int binarna_levo(int x,int niz){\n        static int l,r,m,o;\n        l = 0;\n        r = duz[niz]-1;\n        o = -1;\n        while (l&lt;=r){\n            m = (l+r)/2;\n            if (parovi[niz][m].br &lt; x){\n                l = m+1;\n            } else\n            if (parovi[niz][m].br &gt; x){\n                r = m-1;\n            } else {\n                r = m-1;\n                o = m;\n            }\n        }\n        if (o==-1) return 999999999;\n        return parovi[niz][o].idx;\n    }\n\n    inline int binarna_desno(int x,int niz){\n        static int l,r,m,o;\n        l = 0;\n        r = duz[niz]-1;\n        o = -1;\n        while (l&lt;=r){\n            m = (l+r)/2;\n            if (parovi[niz][m].br &lt; x){\n                l = m+1;\n            } else\n            if (parovi[niz][m].br &gt; x){\n                r = m-1;\n            } else {\n                l = m+1;\n                o = m;\n            }\n        }\n        if (o==-1) return -1;\n        return parovi[niz][o].idx;\n    }\n\n    inline int izbroji(int a,int b){\n        int c=0;\n        for (int i=0; i&lt;br; i++){\n            if (binarna_levo(a,i) &lt; binarna_desno(b,i)) c++;\n        }\n        return c;\n    }\n}\n\n#endif\n\n//mali\n\n#ifdef KORISTI_HASH_MALI\n\nnamespace mali{\n    struct hash_entry{\n        int a,b,c;\n    };\n    struct par{\n        int a,b;\n        inline par(int _a=0, int _b=0):a(_a),b(_b){}\n        inline par(hash_entry e):a(e.a),b(e.b){}\n        inline bool operator&lt;(const par&amp; drugi)const{\n            return a&lt;drugi.a || (a==drugi.a &amp;&amp; b &lt; drugi.b);\n        }\n        inline bool operator==(const par&amp; drugi)const{\n            return a==drugi.a &amp;&amp; b==drugi.b;\n        }\n    };\n    const int hash_mod = 1&lt;&lt;25; // 33554432\n\n    hash_entry Tabela[hash_mod];\n\n    inline void ubaci(const par&amp; e){\n        //hash funkcije\n        int prim = (e.a*6991ll + e.b*97213ll)&amp;(hash_mod-1);\n        int sek  = (e.a*5407ll + e.b*65993ll)&amp;(hash_mod-1);\n        while (1){\n            if (!Tabela[prim].a){\n                Tabela[prim].a = e.a;\n                Tabela[prim].b = e.b;\n                Tabela[prim].c = -1;\n                return;\n            }\n            if (e==Tabela[prim]){\n                if (Tabela[prim].c&gt;0){\n                    Tabela[prim].c = -(Tabela[prim].c+1);\n                }\n                return;\n            }\n            prim = (prim+sek)&amp;(hash_mod-1);\n        }\n    }\n\n    inline void ispravi(const par&amp; e){\n        //hash funkcije\n        int prim = (e.a*6991ll + e.b*97213ll)&amp;(hash_mod-1);\n        int sek  = (e.a*5407ll + e.b*65993ll)&amp;(hash_mod-1);\n        while (1){\n            if (!Tabela[prim].a){\n                return;\n            }\n            if (e==Tabela[prim]){\n                if (Tabela[prim].c&lt;0) Tabela[prim].c*=-1;\n                return;\n            }\n            prim = (prim+sek)&amp;(hash_mod-1);\n        }\n    }\n\n    inline void napravi(int n, int sizes[], int a[]){\n        int *poc = new int[n+1],i;\n        poc[0] = 0;\n        for (i=1; i&lt;=n; i++) poc[i] = sizes[i-1] + poc[i-1];\n        static par tmp[LIMIT*(LIMIT-1)/2];\n        for (i=0; i&lt;n; i++) if (sizes[i]&lt;=LIMIT){\n            int x,y,k=0;\n            for (x=poc[i]; x&lt;poc[i+1]; x++){\n                for (y=x+1; y&lt;poc[i+1]; y++) if (a[x] != a[y]){\n                    tmp[k].a = a[x];\n                    tmp[k++].b = a[y];\n                }\n            }\n            //ubacujemo neduplikate u hash tabelu\n            for (x=0; x&lt;k; x++) ubaci(tmp[x]);\n            for (x=0; x&lt;k; x++) ispravi(tmp[x]);\n        }\n\n        delete []poc;\n    }\n\n    inline int izbroji(int a,int b){\n        par e(a,b);\n        int prim = (e.a*6991ll + e.b*97213ll)&amp;(hash_mod-1);\n        int sek  = (e.a*5407ll + e.b*65993ll)&amp;(hash_mod-1);\n        while (1){\n            if (!Tabela[prim].a){\n                return 0;\n            }\n            if (e==Tabela[prim]){\n                return Tabela[prim].c;\n            }\n            prim = (prim+sek)&amp;(hash_mod-1);\n        }\n    }\n}\n\n#endif\n#ifndef KORISTI_HASH_MALI\n\nnamespace mali{\n    struct par{\n        int a,b;\n        inline par(int _a=0, int _b=0):a(_a),b(_b){}\n        inline bool operator&lt;(const par&amp; drugi)const{\n            return a&lt;drugi.a || (a==drugi.a &amp;&amp; b &lt; drugi.b);\n        }\n        inline bool operator==(const par&amp; drugi)const{\n            return a==drugi.a &amp;&amp; b==drugi.b;\n        }\n    };\n    struct trojka{\n        int a,b,c;\n        inline trojka(){}\n        inline trojka(par e):a(e.a),b(e.b),c(1){}\n        inline bool operator&lt;(const trojka&amp; drugi)const{\n            return a&lt;drugi.a || (a==drugi.a &amp;&amp; b &lt; drugi.b);\n        }\n    };\n\n    trojka Tabela[MAXN*LIMIT/2];\n    int br;\n\n    inline void ubaci(par e){\n        Tabela[br++] = trojka(e);\n    }\n\n    inline void napravi(int n, int sizes[], int a[]){\n        int *poc = new int[n+1],i,j;\n        poc[0] = 0;\n        for (i=1; i&lt;=n; i++) poc[i] = sizes[i-1] + poc[i-1];\n        par *tmp = new par[LIMIT*(LIMIT-1)/2];\n        br=0;\n        for (i=0; i&lt;n; i++) if (sizes[i]&lt;=LIMIT){\n            int x,y,k;\n            k=0;\n            for (x=poc[i]; x&lt;poc[i+1]; x++){\n                for (y=x+1; y&lt;poc[i+1]; y++) if (a[x] != a[y]){\n                    tmp[k].a = a[x];\n                    tmp[k].b = a[y];\n                    k++;\n                }\n            }\n            //ubacujemo neduplikate u hash tabelu\n            if (k&gt;0){\n                sort(tmp,tmp+k);\n                ubaci(tmp[0]);\n                for (x=1; x&lt;k; x++) if (tmp[x-1] &lt; tmp[x]) ubaci(tmp[x]);\n            }\n        }\n\n        sort(Tabela,Tabela+br);\n\n        j=1;\n        for (i=1; i&lt;br; i++){\n            if (Tabela[i-1] &lt; Tabela[i]){\n                Tabela[j] = Tabela[i];\n                Tabela[j++].c = 1;\n            } else {\n                Tabela[j-1].c++;\n            }\n        }\n        br=j;\n\n        delete []tmp;\n        delete []poc;\n    }\n\n    int izbroji(int a,int b){\n        trojka t(par(a,b));\n        static int l,r,m,o;\n        l=0;\n        r=br-1;\n        o=-1;\n        while (l&lt;=r){\n            m = (l+r)/2;\n            if (Tabela[m] &lt; t){\n                l = m+1;\n            } else\n            if (t &lt; Tabela[m]){\n                r = m-1;\n            } else {\n                o = m;\n                break;\n            }\n        }\n        if (o==-1) return 0;\n        return Tabela[o].c;\n    }\n}\n\n#endif\n\nvoid resi(int n, int *duzine, int *a, int q, int *x, int *y, int *resenja){\n    veliki::napravi(n,duzine,a);\n    mali::napravi(n,duzine,a);\n    for (int i=0; i&lt;q; i++){\n        resenja[i] = veliki::izbroji(x[i],y[i]) + mali::izbroji(x[i],y[i]);\n    }\n}\n</code></pre>"},{"location":"takprog/2014_2015/sio/04_mudrac/","title":"4 - Mudrac","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Tajna komisija nema vremena ni za \u0161ta a samim tim ni za smi\u0161ljanje zadataka za SIO. Zbog toga su prevalili daleki put do Kazahstanskih planina (za to imaju vremena) i zatra\u017eili od \u010duvenog mudraca-programera iz pe\u0107ine Did\u017eita Programbajeva da im smisli zadatak. I on im re\u010de:</p> <p>\u201cLjudi, na po\u010detku, prvog dana, imao sam \\(A\\) kamila. Svakog narednog dana dobijam jo\u0161 onoliko kamila koliko je jednaka najve\u0107a cifra broja mojih kamila dan pre toga. Obratite pa\u017enju da ja sve to stalno posmatram po modulu \\(M\\) tj. ukoliko je \\(a_i\\) broj kamila koje imam \\(i\\)-tog dana, tada va\u017ei </p> \\[ a_{i+1}=(a_i+\\text{najve\u0107a cifra broja }a_i ) \\text{ mod } M. \\] <p>Ukoliko je pro\u0161lo \\(N\\) dana, odrediti koliko ima kilometara izme\u0111u Astane i Alma-Atija. Eto.\u201d</p> <p>\u010clanovi komisije su se malo zbunili neo\u010dekivanim krajem zadatka pa su re\u0161ili da ga malo izmene: za date prirodne brojeve \\(A\\), \\(M\\) i \\(N\\), izra\u010dunajte koliko kamila ima mudrac na kraju \\(N\\)-tog dana.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Mihail Tihomirov Aleksandar Ivanovi\u0107 <p>For now, ignore the modulo. Suppose that the current number \\(x = a\\cdot 10^p + d\\) for some non-negative integers \\(a\\), \\(p\\) and \\(0 \\leq d &lt; 10\\).</p> <p>Until \\(x\\) reaches \\(\\geq (a + 1)\\cdot 10^p\\), the sequence of changes to \\(x\\) depends only on \\(p\\), \\(d\\), and \\(k\\) \u2014 the largest digit of \\(a\\). Right after that we will have \\((a+1)\\cdot 10^p \\leq x &lt; (a+1)\\cdot 10^p+10\\), since each increase is by at most \\(9\\).</p> <p>Let \\(steps_{p,d,k}\\) and \\(delta_{p,d,k}\\) be the number of steps and total change made to \\(x\\) until \\(x\\) reaches \\(\\geq (a + 1) \\cdot 10^p\\). We can calculate \\(steps_{p,d,k}\\) and \\(delta_{p,d,k}\\) for all \\(p &gt; 0\\), \\(d\\), \\(m\\) by using \\(steps_{p\u22121,\\ldots,\\ldots}\\) and \\(delta_{p\u22121,\\ldots,\\ldots}\\) to quickly skip stages of the process.</p> <p>Note that \\(steps_{p,0,0}\\) and \\(delta_{p,0,0}\\) are undefined since no increases are ever made.</p> <p>Using \\(steps_{p,d,k}\\) and \\(delta_{p,d,k}\\) we can quickly calculate:</p> <ul> <li>the value of any \\(x\\) after \\(n\\) steps (provided \\(x\\) never exceeds \\(m\\));</li> <li>the number of steps we take starting from \\(x\\) until \\(x &gt; m\\), and the resulting value of \\(x\\).</li> </ul> <p>To do this, find the largest \\(p\\) such that \\(x \\text{ mod } 10^p &lt; 10\\), and also, if \\(p &gt; 0\\), \\(steps_{p,x \\text{ mod } 10^p,k} \\leq n\\) or \\(x+ delta_{p,x \\text{ mod } 10^p,k} \\leq m\\) (\\(k\\) being the largest digit of \\(\\lfloor x/10^p\\rfloor\\)), and use this to skip ahead in the process. Only \\(O(\\log m)\\) of such skips are required.</p> <p>Now we can solve the problem. Whenever we skip ahead, we assume that \\(x\\) and the remaining number of steps \\(n\\) decrease accordingly. Whenever \\(n = 0\\), we terminate.</p> <p>One method is to repeatedly find the first moment when either \\(x &gt; m\\) or \\(n = 0\\). After that, if \\(n &gt; 0\\), we take \\(x \\text{ mod } m\\) and go again. If at any point \\(x = 0\\), we immedaitely terminate.</p> <p>This may work very slow when \\(n\\) is much larger than \\(m\\). However, by looking at the values of \\(x\\) after taking modulo \\(m\\), we notice that the process becomes periodic after at most \\(10\\) loops.</p> <p>If the period takes \\(z\\) steps, take \\(n\\) modulo \\(z\\) to skip many periods ahead. After this, at most \\(10\\) further loops are required.</p> 04_mudrac.cpp<pre><code>#include \"mudrac.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_DIGITS = 20;\n\nlong long StepNum[10][MAX_DIGITS + 1][10];\nint NextLastDigit[10][MAX_DIGITS + 1][10];\nlong long pow10[MAX_DIGITS + 1];\nbool mark[10];\nint next[10];\nlong long cost[10];\n\nint max(int a, int b)\n{\n    return (a &gt; b ? a : b);\n}\n\nint MaxDigit(long long num)\n{\n    int ret = 0;\n    while (num &gt; 0)\n    {\n        int lastDigit = num % 10;\n        ret = max(ret, lastDigit);\n        num = num / 10;\n    }\n    return ret;\n}\n\nvoid Precalculate()\n{\n    pow10[0] = 1LL;\n    for (int i = 1; i &lt;= MAX_DIGITS; i++)\n        pow10[i] = pow10[i - 1] * 10;\n\n    // base\n    for (int maxPrefDigit = 0; maxPrefDigit &lt; 10; maxPrefDigit++)\n    {\n        for (int lastDigit = 0; lastDigit &lt; 10; lastDigit++)\n        {\n            if (maxPrefDigit == 0 &amp;&amp; lastDigit == 0) continue;\n            int c = lastDigit;\n            StepNum[maxPrefDigit][1][lastDigit] = 0;\n            while (c &lt; 10)\n            {\n                c = c + max(maxPrefDigit, c);\n                StepNum[maxPrefDigit][1][lastDigit]++;\n            }\n            NextLastDigit[maxPrefDigit][1][lastDigit] = c % 10;\n        }\n    }\n\n    for (int len = 2; len &lt;= MAX_DIGITS; len++)\n    {\n        for (int maxPrefDigit = 0; maxPrefDigit &lt; 10; maxPrefDigit++)\n        {\n            for (int lastDigit = 0; lastDigit &lt; 10; lastDigit++)\n            {\n                if (maxPrefDigit == 0 &amp;&amp; lastDigit == 0) continue;\n                StepNum[maxPrefDigit][len][lastDigit] = 0;\n                int currLastDigit = lastDigit;\n                for (int c = 0; c &lt;= 9; c++)\n                {\n                    StepNum[maxPrefDigit][len][lastDigit] += StepNum[max(maxPrefDigit, c)][len - 1][currLastDigit];\n                    currLastDigit = NextLastDigit[max(maxPrefDigit, c)][len - 1][currLastDigit];\n                }\n                NextLastDigit[maxPrefDigit][len][lastDigit] = currLastDigit;\n            }\n        }\n    }\n}\n\n// vraca broj A_{n+1} ako je A_1 = startNum, tj. broj koji se dobije kada\n// se n puta primeni povecavanje za max cifru (ne gleda module)\nlong long F(long long startNum, long long n)\n{\n    if (startNum == 0LL)\n        return 0LL;\n\n    int C = startNum % 10;\n    int B = 1;\n    long long val = startNum / 10;\n    int A = MaxDigit(val);\n    // num = val * 10^B + C, A - max cifra u val\n    while (n &gt; 0 &amp;&amp; B &gt; 0)\n    {\n        if (StepNum[A][B][C] &lt;= n)\n        {\n            n = n - StepNum[A][B][C];\n            C = NextLastDigit[A][B][C];\n            val = val + 1;\n            A = MaxDigit(val);\n            if (val % 10 == 0)\n            {\n                B++;\n                val = val / 10;\n            }\n        }\n        else\n        {\n            B--;\n            val = val * 10;\n        }\n    }\n\n    long long sol;\n    if (n &gt; 0)\n    {\n        val = val + C;\n        for (int i = 1; i &lt;= n; i++)\n        {\n            val = val + MaxDigit(val);\n        }\n        sol = val;\n    }\n    else\n    {\n        sol = val * pow10[B] + C;\n    }\n\n    return sol;\n}\n\n// racuna broj koraka (dodavanja max cifre) da bi se od broja\n// start dobio najmanji broj &gt;= goal\nlong long MinNumOfStepsToReach(long long start, long long goal)\n{\n    long long L = 1, R = goal - start;\n    while (L &lt; R)\n    {\n        long long M = (L + R) / 2;\n        if (F(start, M) &lt; goal)\n            L = M + 1;\n        else\n            R = M;\n    }\n    return L;\n}\n\nvoid RemoveModulo(long long&amp; A, long long&amp; M, long long&amp; N)\n{\n    long long x = MinNumOfStepsToReach(A, M);\n    if (N &lt; x)\n        return;\n    N = N - x;\n    A = F(A, x) - M;\n    for (int i = 0; i &lt; 10; i++) \n        mark[i] = false;\n\n    while (!mark[A])\n    {\n        mark[A] = true;\n        if (A == 0LL) return;\n        cost[A] = MinNumOfStepsToReach(A, M);\n        if (N &lt; cost[A]) return;\n        N = N - cost[A];\n        next[A] = F(A, cost[A]) - M;\n        A = next[A];\n    }\n\n    long long totalCost = cost[A];\n    int curr = next[A];\n    while (curr != A)\n    {\n        totalCost = totalCost + cost[curr];\n        curr = next[curr];\n    }\n\n    N = N % totalCost;\n    while (N &gt;= cost[A])\n    {\n        N = N - cost[A];\n        A = next[A];\n    }\n}\n\nlong long BrojKamila(long long A, long long M, long long N)\n{\n    N = N - 1;\n    Precalculate();\n    RemoveModulo(A, M, N);\n    return F(A, N);\n}\n</code></pre>"},{"location":"takprog/2014_2015/sio/04_mudrac/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>BrojKamila(A,M,N)</li> </ul> <p>gde je \\(A\\) \u2013 broj kamila prvog dana, \\(M\\) \u2013 moduo po kome se posmatraju \u010dlanovi niza i \\(N\\) \u2013 broj dana koji su pro\u0161li. Ova funkcija mora da vrati jedan ceo broj iz segmenta \\([0,M-1]\\) \u2013 broj kamila koje poseduje mudrac na kraju \\(N\\)-tog dana.</p>"},{"location":"takprog/2014_2015/sio/04_mudrac/#primer","title":"Primer","text":"<p>Neka je \\(A=123\\), \\(M=134\\) i \\(N=6\\). Ukoliko sa \\(a_i\\) ozna\u010dimo broj kamila \\(i\\)-tog dana, tada va\u017ei: \\(a_1=A=123\\), \\(a_2=(123+3) \\text{ mod } 134=126\\), \\(a_3=(126+6) \\text{ mod } 134=132\\), \\(a_4=(132+3) \\text{ mod } 134=1\\), \\(a_5=(1+1) \\text{ mod } 134=2\\), \\(a_6=(2+2) \\text{ mod }134=4\\). Prema tome, u ovom slu\u010daju va\u0161a funkcija mora da vrati broj \\(4\\).</p>"},{"location":"takprog/2014_2015/sio/04_mudrac/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq A &lt; M\\leq 10^{18}\\)</li> <li>\\(1\\leq N\\leq 10^{18}\\)</li> </ul>"},{"location":"takprog/2014_2015/sio/04_mudrac/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li>PODZADATAK 1 [5 POENA]: \\(N\\leq 10^6\\)</li> <li>PODZADATAK 2 [12 POENA]: \\(M\\leq 10^6\\)</li> <li>PODZADATAK 3 [25 POENA]: \\(A=1\\), \\(M=201520152015\\) i \\(N\\leq 10^9\\).</li> <li>PODZADATAK 4 [41 POENA]: \\(A,N\\leq 10^{17}\\), \\(M=10^{18}\\).</li> <li>PODZADATAK 5 [17 POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/sio/04_mudrac/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom mudrac.c, mudrac.cpp ili mudrac.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    long long BrojKamila(long long A, long long M, long long N);\nPascal\n    function BrojKamila(A, M, N : int64) : int64;\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include \u201cmudrac.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit mudrac;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/04_mudrac/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (mudrac.c, mudrac.cpp, mudrac.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom i jedinom redu brojeve \\(A\\), \\(M\\) i \\(N\\), redom, razdvojene razmakom</li> </ul> <p>a zatim pozivaju va\u0161u funkciju \\(BrojKamila\\) iz odgovaraju\u0107eg fajla (mudrac.c, mudrac.cpp, mudrac.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2014_2015/sio/05_gps/","title":"5 - GPS","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Tajna komisija nema vremena ni za \u0161ta a samim tim ni za planiranje putovanja od svoje tajne baze do mesta odr\u017eavanja SIO-a. Mo\u017eemo pretpostaviti da se na\u0161a dr\u017eava sastoji od \\(N\\) gradova (numerisanih brojevima od \\(1\\) do \\(N\\)) i \\(M\\) dvosmernih auto-puteva izme\u0111u nekih od njih, pri \u010demu je za svaki auto-put poznato vreme potrebno da se on pre\u0111e. Komisija se nalazi u gradu broj \\(1\\) a SIO se odr\u017eava u gradu broj \\(N\\).</p> <p>Me\u0111utim, komisija vozi poslednje \u010dudo tehnologije - Mazdu 323 sa ugra\u0111enim auto-voza\u010dem,  sistemom za navigaciju (GPS), daljinskim blokiranjem auto-puteva i sertifikatom da je bolji automobil od Nissan Ka\u0161kaija. Jedna od (mnogih) mogu\u0107nosti ovog automobila je slede\u0107a: ukoliko se trenutno nalazimo u gradu \\(X\\) i u GPS unesemo grad \\(Y\\), tada, ukoliko od grada \\(X\\) do grada \\(Y\\) postoji jedinstvena najkra\u0107a putanja (koja mo\u017ee koristiti vi\u0161e auto-puteva i prolaziti kroz vi\u0161e gradova), auto-voza\u010d \u0107e nas odvesti tom jedinstvenom najkra\u0107om putanjom do grada \\(Y\\). Na\u017ealost, mi mo\u017eemo koristiti GPS samo ako je neki od gradova \\(X\\) ili \\(Y\\) upravo \\(1\\) ili \\(N\\) (jo\u0161 uvek nije une\u0161eno dovljno podataka). Naravno, osim kori\u0161\u0107enja GPS-a/auto-voza\u010da, mogu\u0107e je voziti Mazdu na klasi\u010dan na\u010din. Tako\u0111e (videti opis mogu\u0107nosti Mazde), mogu\u0107e je blokirati najvi\u0161e jedan auto put pre po\u010detka putovanja i na taj na\u010din uticati na izra\u010dunavanja GPS-a.</p> <p>Cilj komisije je da stigne iz grada \\(1\\) do grada \\(N\\) za najkra\u0107e mogu\u0107e vreme (prvi prioritet) ali da pritom \u0161to manje vremena vozi na klasi\u010dan na\u010din, bez GPS-a (drugi prioritet). Na vama je da izra\u010dunate koliko najmanje vremena se Mazda mora voziti na klasi\u010dan na\u010din, pri \u010demu mo\u017eete odlu\u010diti da li \u0107ete u obzir uzimati mogu\u0107nost blokiranja auto-puta (videti opis funkcije i bodovanje).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 - Aleksandar Ivanovi\u0107 05_gps.cpp<pre><code>#include \"gps.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nconst int MAX_N = 200200;\nconst long long INF = 1000000000000000LL;\n\nstruct edge\n{\n    int v, w;\n    edge(int _v, int _w) { v = _v; w = _w; }\n};\n\nint n, m;\nvector&lt;edge&gt; adj[MAX_N];\nvector&lt;edge&gt; ADJ[2][MAX_N];\nbool uniquePath[2][MAX_N][2];\nlong long d[2][MAX_N];\nlong long shortest[MAX_N];\nint queue[MAX_N];\nbool mark[MAX_N];\nint topSort[2][MAX_N];\nint inDeg[MAX_N];\nint n1;\n\nint FLAG;\n\nstruct cmp {\n    bool operator () (const int&amp; a, const int&amp; b)\n    {\n        if (d[FLAG][a] == d[FLAG][b])\n            return a &lt; b;\n        return (d[FLAG][a] &lt; d[FLAG][b]);\n    }\n};\nset&lt;int, cmp&gt; heap;\n\nlong long Min(long long a, long long b)\n{\n    return (a &lt; b ? a : b);\n}\n\nvoid Dijkstra(int start, int num)\n{\n    FLAG = num;\n    for (int i = 1; i &lt;= n; i++) d[num][i] = INF;\n    d[num][start] = 0LL;\n    heap.clear();\n    heap.insert(start);\n\n    while (!heap.empty())\n    {\n        int u = *heap.begin();\n        heap.erase(heap.begin());\n        for (int i = 0; i &lt; (int)adj[u].size(); i++)\n        {\n            int v = adj[u][i].v;\n            long long w = adj[u][i].w;\n            if (d[num][v] == INF)\n            {\n                d[num][v] = d[num][u] + w;\n                heap.insert(v);\n            }\n            else if (d[num][u] + w &lt; d[num][v])\n            {\n                heap.erase(v);\n                d[num][v] = d[num][u] + w;\n                heap.insert(v);\n            }\n        }\n    }\n}\n\nvoid TopSort(int start, int num)\n{\n    for (int i = 1; i &lt;= n; i++)\n        inDeg[i] = ADJ[1 - num][i].size();\n    queue[1] = start;\n    int first = 0, last = 1;\n    int c = 0;\n\n    while (first &lt; last)\n    {\n        first++;\n        int u = queue[first];\n        c++;\n        topSort[num][c] = u;\n        cout &lt;&lt; u &lt;&lt; \" num \" &lt;&lt; num &lt;&lt;endl;\n        for (int i = 0; i &lt; (int)ADJ[num][u].size(); i++)\n        {\n            int v = ADJ[num][u][i].v;\n            inDeg[v]--;\n            if (inDeg[v] == 0)\n            {\n                last++;\n                queue[last] = v;\n            }\n        }\n    }\n}\n\nvoid FindUniquePaths(int start, int num)\n{\n    for (int i = 1; i &lt;= n; i++)\n    {\n        uniquePath[num][i][0] = false;\n        uniquePath[num][i][1] = false;\n    }\n    uniquePath[num][start][0] = true;\n    uniquePath[num][start][1] = true;\n\n    for (int i = 1; i &lt;= n1; i++)\n    {\n        int u = topSort[num][i];\n        if (u == start) continue;\n\n        if (ADJ[1 - num][u].size() == 1 &amp;&amp; uniquePath[num][ ADJ[1 - num][u][0].v ][0])\n            uniquePath[num][u][0] = true;\n\n        if (uniquePath[num][u][0]) uniquePath[num][u][1] = true;\n        if (ADJ[1 - num][u].size() == 1 &amp;&amp; uniquePath[num][ ADJ[1 - num][u][0].v ][1])\n            uniquePath[num][u][1] = true;\n        if (ADJ[1 - num][u].size() == 2 &amp;&amp; (uniquePath[num][ ADJ[1 - num][u][0].v ][0] || uniquePath[num][ ADJ[1 - num][u][1].v ][0]))\n            uniquePath[num][u][1] = true;\n    }\n}\n\n// najkraci put izmedju 2 skupa cvorova A i B:\n// x = 0, y = 0: A = {svi jednistveno dostizni iz 1}, B = {svi sa jedinstvenim putem ka B} (60% zadatka)\n// x = 1, y = 0: A = {svi jedinstevno dostizni iz 1 uz uklanjanje najvise 1 grane}, B = {svi sa jedinstvenim putem ka B}\n// x = 0, y = 1: A = {svi jednistveno dostizni iz 1}, B = {svi sa jedinstvenim putem ka B uz uklanjanje najvise jedne grane}\nlong long Solve(int x, int y)\n{\n    for (int i = 1; i &lt;= n; i++)\n    {\n        if (uniquePath[0][i][x])\n            shortest[i] = 0LL;\n        else\n            shortest[i] = INF;\n    }\n\n    for (int i = 1; i &lt;= n1; i++)\n    {\n        int u = topSort[0][i];\n        if (shortest[u] == INF)\n        {\n            for (int j = 0; j &lt; (int)ADJ[1][u].size(); j++)\n            {\n                int v = ADJ[1][u][j].v;\n                int w = ADJ[1][u][j].w;\n                shortest[u] = Min(shortest[u], shortest[v] + w);\n            }\n        }\n    }\n\n    long long ret = INF;\n    for (int i = 1; i &lt;= n; i++)\n        if (uniquePath[1][i][y]) ret = Min(ret, shortest[i]);\n\n    return ret;\n}\n\nlong long NajkracaVoznja(int N, int M, int* g1, int* g2, int* t)\n{\n    n = N;\n    m = M;\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        adj[i].clear();\n        ADJ[0][i].clear();\n        ADJ[1][i].clear();\n    }\n\n    for (int i = 1; i &lt;= M; i++)\n    {\n        adj[ g1[i] ].push_back(edge(g2[i], t[i]));\n        adj[ g2[i] ].push_back(edge(g1[i], t[i]));\n    }\n\n    // pustamo 2 dijkstre da bismo odredili dijkstra dag i grane kandidate.\n    // Dovoljna je jedna dijkstra i bfs ali ovako je lakse + bolje da se podesi vreme za ovaj algoritam\n    Dijkstra(1, 0);\n    Dijkstra(n, 1);\n\n    // Sada pravimo dijkstra DAG pri cemu se dodaju samo grane koje pripadaju nekom najkracem putu od 1 do n\n    // n1 je broj \"relevatnih cvorova\" tj onih koji su na nekom najkracem putu od 1 do n.\n    for (int i = 1; i &lt;= M; i++)\n    {\n        if (d[0][ g1[i] ] + t[i] + d[1][ g2[i] ] == d[0][n]) // g1[i] -&gt; g2[i]\n        {\n            ADJ[0][ g1[i] ].push_back(edge(g2[i], t[i]));\n            ADJ[1][ g2[i] ].push_back(edge(g1[i], t[i]));\n        }\n        else if (d[0][ g2[i] ] + t[i] + d[1][ g1[i] ] == d[0][n]) // g2[i] -&gt; g1[i]\n        {\n            ADJ[0][ g2[i] ].push_back(edge(g1[i], t[i]));\n            ADJ[1][ g1[i] ].push_back(edge(g2[i], t[i]));\n        }\n    }\n    n1 = 0;\n    for (int i = 1; i &lt;= n; i++)\n        if (d[0][i] + d[1][i] == d[0][n]) n1++;\n\n    // Odradimo topoloski sort u dijkstra dag-u (opet je dovoljan samo jedan ali simetrija)\n    // Ovo pomaze da posle umesto BFS-a/dodatne Dijkstre, imamo samo for petlju\n    TopSort(1, 0);\n    TopSort(n, 1);\n\n    // Nalazimo cvorovove do/od kojih postoje najkraci putevi sa i bez uklanjanja jedne grane\n    // Za jedinstvenost od cvora 1 nam trebaju \"suprotno\" usmerene ivice pa koristimo izraze 1-num\n    FindUniquePaths(1, 0);\n    FindUniquePaths(n, 1);\n\n    long long sol = Min(Solve(0, 1), Solve(1, 0)); // optimalno resenje\n    // long long sol = Solve(0, 0); // za 60% poena\n    return sol;\n}\n</code></pre>"},{"location":"takprog/2014_2015/sio/05_gps/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(NajkracaVoznja(N,M,g1[\u2026],g2[\u2026],t[\u2026])\\)</li> </ul> <p>gde je \\(N\\) \u2013 broj gradova (gradovi su numerisani od \\(1\\) do \\(N\\)), \\(M\\) \u2013 broj auto-puteva a \\(g1\\), \\(g2\\) i \\(t\\) nizovi du\u017eine \\(M\\) koji opisuju auto-puteve: za svako \\(1\\leq i\\leq M\\), \\(i\\)-ti auto-put povezuje gradove \\(g1[i]\\) i \\(g2[i]\\) i putovanje po njemu traje \\(t[i]\\) minuta. Auto-putevi su dvosmerni a svi nizovi su indeksirani od \\(1\\). </p> <p>Za maksimalan broj poena, va\u0161a funkcija mora da vrati jedan ceo broj \u2013 najmanje vreme koje komisija mora voziti na klasi\u010dan na\u010din ukoliko ima pravo da blokira najvi\u0161e jedan auto put. Za manji broj poena, va\u0161a funkcija mo\u017ee vratiti najmanje vreme koje komisija mora voziti na klasi\u010dan na\u010din ukoliko nema prava da blokira auto puteve; u tom slu\u010daju je potrebno vratiti rezultat sa predznakom \u201c-\u201d (minus). Ukoliko je re\u0161enje 0, ne mora se stavljati predznak.</p>"},{"location":"takprog/2014_2015/sio/05_gps/#primer","title":"Primer","text":"<p>Neka je \\(N=8\\), \\(M=11\\), \\(g1=[1,1,5,3,3,4,6,6,4,1,8]\\), \\(g2=[5,3,7,7,4,7,2,8,6,2,2]\\) i \\(t=[12, 10, 5, 8, 10, 3, 2, 7, 3, 30, 5]\\). Ovi podaci odgovaraju slede\u0107oj mapi (gradovi su prikazani kao kru\u017ei\u0107i a auto-putevi kao linije; pored svakog auto puta je dato vreme potrebno da se on pre\u0111e).</p> <p></p> <p>Najmanje vremena potrebno da se stigne iz grada 1 u grad 8 (bez obzira ko vozi) je 30 minuta. Razmotrimo slu\u010daj kada ne blokiramo nijedan auto put: tada npr. mo\u017eemo u GPS-u ukucati grad broj 7 (to je ok jer je \\(X=1\\)) i kako do njega postoji jedinstvena najkra\u0107a putanja (\\(1\\rightarrow 5\\rightarrow 7\\)) auto voza\u010d \u0107e nas odvesti tamo. Zatim mo\u017eemo da vozimo sami do grada 2 (\\(7\\rightarrow 4\\rightarrow 6\\rightarrow 2\\), ukupno 8 minuta) a zatim mo\u017eemo iz grada 2 ukucati u GPS grad 8 (dakle \\(Y=8\\) pa mo\u017eemo koristiti GPS) i auto voza\u010d nas vozi u grad 8 jedinstvenom najkra\u0107om putanjom \\(2\\rightarrow 8\\). Stigli smo do cilja za najkra\u0107e mogu\u0107e vreme a pri tom smo sami vozili 8 minuta \u2013 mo\u017ee se pokazati da ne mo\u017eemo bolje ukoliko ne blokiramo auto-puteve. Dakle, ukoliko va\u0161a funkcija za ovaj primer vrati broj -8, dobijate 60% poena (vidi bodovanje).</p> <p>Sa druge strane, ako \u017eelimo da koristimo funkciju blokiranja najvi\u0161e jednog auto-puta, tada, ukoliko npr. blokiramo auto-put izme\u0111u 5 i 7, mo\u017eemo pozvati GPS prvo za grad 2 (jedinstvena najkra\u0107a putanja \\(1\\rightarrow 3\\rightarrow 4\\rightarrow 6\\rightarrow 2\\)) a zatim iz grada 2 pozivamo GPS za grad 8. Ukupno smo sami vozili 0 minuta \u0161to je i optimalno re\u0161enje za ovaj primer (i nosi 100% poena). Primetimo npr. da ne bi bilo korektno da uklonimo auto-put izme\u0111u 4 i 6 i odmah u GPS unesemo grad 8 jer bismo tada do njega stigli za 35 minuta a moramo sti\u0107i za najkra\u0107e mogu\u0107e vreme (30 minuta).</p>"},{"location":"takprog/2014_2015/sio/05_gps/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2\\leq N\\leq 10^5\\)</li> <li>\\(1\\leq M\\leq 3\u22c510^5\\)</li> <li>Za svako \\(1\\leq i\\leq M\\) va\u017ei \\(1\\leq g1[i],g2[i]\\leq N\\), \\(g1[i]\\neq g2[i]\\) i \\(1\\leq t[i]\\leq 10^9\\)</li> <li>Izme\u0111u svaka dva grada postoji najvi\u0161e jedan auto-put.</li> <li>Uvek \u0107e postojati na\u010din da se stigne iz grada \\(1\\) u grad \\(N\\).</li> </ul>"},{"location":"takprog/2014_2015/sio/05_gps/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>U svakom podzadatku, ukoliko va\u0161 program korektno re\u0161i varijantu problema u kome nema blokiranja auto-puteva (\u0161to se zaklju\u010duje na osnovu predznaka \u201c-\u201c u povratnoj vrednosti funkcije) dobijate 60% poena od odgovaraju\u0107eg podzadatka. Ukoliko svaki test primer podzadatka va\u0161 program re\u0161ava u varijanti gde je mogu\u0107e blokirati najvi\u0161e jedan auto-put, dobijate svih 100% poena tog podzadatka.</p> <ul> <li>PODZADATAK 1 [11 POENA]: \\(N\\leq 10\\)</li> <li>PODZADATAK 2 [17 POENA]: \\(N\\leq 250\\) i \\(M\\leq 500\\).</li> <li>PODZADATAK 3 [20 POENA]: \\(N\\leq 2000\\).</li> <li>PODZADATAK 4 [21 POENA]: Za svako \\(1\\leq i \\leq M\\) va\u017ei \\(t[i]=1\\).</li> <li>PODZADATAK 5 [31 POENA]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2014_2015/sio/05_gps/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom gps.c, gps.cpp ili gps.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    long long NajkracaVoznja(int N, int M, int* g1, int* g2, int* t);\nPascal\n    function NajkracaVoznja(N, M : longint; var g1, g2, t : array of longint) : int64;\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include \u201cgps.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit gps;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/05_gps/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (gps.c, gps.cpp, gps.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(M\\), redom, razdvojene razmakom</li> <li>U slede\u0107ih \\(M\\) redova brojeve \\(g1[i]\\),\\(g2[i]\\),\\(t[i]\\), redom, razdvojene razmakom</li> </ul> <p>a zatim pozivaju va\u0161u funkciju NajkracaVoznja iz odgovaraju\u0107eg fajla (gps.c, gps.cpp, gps.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2014_2015/sio/06_odabir/","title":"6 - Odabir","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Kao i uvek \u0161to se de\u0161ava, svi \u010dlanovi komisije imaju pametnija posla od odabira zadataka. Po\u0161to je to dosadan posao, oni su na\u0161li savr\u0161enu formulu za odabir zadatak, me\u0111utim problem je \u0161to njih mrzi da napi\u0161u program koji \u0107e na osnovu predloga odabrati zadatke.</p> <p>Oni ve\u0107 imaju pripremljenih \\(N\\) predloga zadataka za koje smatraju da su dovoljno kvalitetni da budu na takmi\u010denju, me\u0111utim niko iz komisije ne\u0107e da se potrudi da od tih N predloga odabere zadatke za takmi\u010denje, te je na vama ostalo da to uradite.</p> <p>Zadaci su numerisani brojevima od \\(0\\) do \\(N-1\\) i svakom zadatku je dodeljen jedan broj \\(T_i\\) koji predstavlja te\u017einu zadatka (\u0161to je ve\u0107i broj \\(T_i\\) to je po njima te\u017ee re\u0161iti taj zadatak). </p> <p>Zadaci se biraju tako \u0161to se nasumi\u010dno odrede dva broja \\(L\\) i \\(R\\) (\\(L\\leq R\\)) koji predstavljaju interval \\([L,R]\\) odakle se zadaci moraju izabrati, tj. ne mo\u017ee se izabrati nijedan zadatak koji je numerisan brojem manjim od \\(L\\) ili ve\u0107im od \\(R\\) (posmatraju se zadaci na pozicijama \\(L,L+1,L+2,\\ldots,R\\) sa te\u017einama \\(T[L],T[L+1],T[L+2],\\ldots,T[R]\\)). Postupak za odabir zadataka je takav da se odredi broj \\(X\\) iz intervala \\([L,R]\\) (\\(L\\leq X\\leq R\\)) i na takmi\u010denju se daju svi zadaci numerisani brojevima od \\(L\\) do \\(X\\), tj. svi zadaci numerisani brojevima \\(L,L+1,L+2,\\ldots,X\\).</p> <p>\u010clanovi tajne komisije su osmislili savr\u0161en na\u010din da ocene te\u017einu takmi\u010denja na osnovu zadataka koje su odabrali. Te\u017eina takmi\u010denja se ra\u010duna tako \u0161to se od odabranih zadataka (zadaci numerisani brojevima od \\(L\\) do \\(X\\)) saberu te\u017eine najlak\u0161eg i najte\u017eeg zadatka.</p> <p>Kako je ipak ovo Srpska Informati\u010dka Olimpijada, oni ho\u0107e da takmi\u010denje bude \u0161to te\u017ee, te za dati interval \\([L,R]\\) potrebno je da prona\u0111ete najte\u017ee takmi\u010denje. Preciznije, ako sa \\(F(X)\\) ozna\u010dimo te\u017einu takmi\u010denja gde su dati zadaci sa te\u017einama \\(T[L],T[L+1],\\ldots,T[X]\\), tj.</p> \\[ F(X)=\\min(T[L],T[L+1],\\ldots,T[X])+\\max(T[L],T[L+1],\\ldots,T[X]) \\] <p>potrebno je da prona\u0111ete maksimalno \\(F(X)\\) za \\(L\\leq X\\leq R\\), tj. \\(\\max(F(L),F(L+1),\\ldots,F(R))\\).</p> <p>Tajna komisija \u0107e napraviti ta\u010dno \\(Q\\) kombinacija odabira zadataka za takmi\u010denje, te \u0107e na po\u010detku takmi\u010denja odabrati kombinaciju zadataka koju \u0107e takmi\u010dari dobiti da re\u0161avaju. </p> <p>Va\u0161 zadatak je da za svaku kombinaciju gde su vam dati brojevi \\(L\\) i \\(R\\) prona\u0111ete odgovaraju\u0107e \\(\\max(F(L),F(L+1),\\ldots,F(R))\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Demjan Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Dimitrije Dimi\u0107"},{"location":"takprog/2014_2015/sio/06_odabir/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju</p> <ul> <li>\\(Odaberi(N,T,Q,L,R,F)\\)</li> </ul> <p>gde je \\(N\\) \u2013 broj predlo\u017eenih zadataka, \\(T\\) \u2013 niz brojeva du\u017eine \\(N\\) gde \\(T[i]\\) predstavlja te\u017einu \\(i\\)-tog predlo\u017eenog zadatka, \\(Q\\)- broj kombinacija koje \u0107e se praviti za takmi\u010denje, \\(L\\) i \\(R\\) nizovi brojeva du\u017eine \\(N\\) gde su \\(L[i]\\) i \\(R[i]\\) opisani brojevi za \\(i\\)-tu kombinaciju odabira zadataka.</p> <p>\\(F\\) je prazan niz du\u017eine \\(Q\\) koji va\u0161a funkcija treba da popuni odgovaraju\u0107im brojevima, tj. na mesto \\(i\\) u nizu \\(F\\) potrebno je da se postavi te\u017eina najte\u017eeg takmi\u010denja iz intervala \\([L[i],R[i]]\\).</p> <p>Svi nizovi su numerisani od nule.</p>"},{"location":"takprog/2014_2015/sio/06_odabir/#primer","title":"Primer","text":"<p>Neka je va\u0161a funkcija pozvana sa slede\u0107im parametrima:</p> <pre><code>N=6\nT=[1000,1,1200,1300,1400,5000]\nQ=3\nL=[0,0,2]\nR=[4,5,4]\n</code></pre> <p>Prvi upit nad nizom \\(T\\) je \\([L[0],R[0]]=[0,4]\\) \u0161to odgovara delu niza \\([1000,1,1200,1300,1400]\\) te je za \\(X\\) u ovom slu\u010daju najbolje odabrati broj \\(0\\), tj. odabrao bi se samo prvi zadataka sa te\u017einom \\(1000\\) te bi te\u017eina takmi\u010denja bila \\(F=1000+1000=2000\\).</p> <p>U drugom upitu na nizom \\(T\\) je \\([L[1],R[1]]=[0,5]\\) \u0161to odgovara celom nizu \\(T\\), te u ovom slu\u010daju je potrebno odabrati ceo niz, tj. \\(X=5\\) i te\u017eina takmi\u010denja u tom slu\u010daju je \\(F=1+5000=5001\\).</p> <p>U poslednjem upitu je \\([L[2],R[2]]=[2,4]\\) se posmatra niz \\([1200,1300,1400]\\) i najbolje re\u0161enje se dobija za \\(X=4\\), a te\u017eina takmi\u010denja u tom slu\u010daju je \\(F=1400+1200=2600\\).</p> <p>Funkcija na kraju izvr\u0161avanja treba da popuni niz \\(F\\) tako da je \\(F[0]=2000\\), \\(F[1]=5001\\), \\(F[2]=2600\\).</p>"},{"location":"takprog/2014_2015/sio/06_odabir/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,Q\\leq 3*10^5\\)</li> <li>\\(1\\leq T[i]\\leq 10^9\\)</li> <li>\\(0\\leq L[i]\\leq R[i]\\leq N-1\\)</li> </ul>"},{"location":"takprog/2014_2015/sio/06_odabir/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li>PODZADATAK 1 [7 POENA]: \\(N,Q\\leq 1000\\)</li> <li>PODZADATAK 2 [20 POENA]: \\(Q\\leq 10.000\\), \\(T[i]\\leq 1000\\), \\(N\\leq 10^5\\)</li> <li>PODZADATAK 3 [13 POENA]: \\(T[i]\\leq 1000\\), \\(N,Q\\leq 10^5\\)</li> <li>PODZADATAK 4 [41 POENA]: \\(N,Q\\leq 10^5\\)</li> <li>PODZADATAK 5 [19 POENA]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2014_2015/sio/06_odabir/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom odabir.c, odabir.cpp ili odabir.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <pre><code>C/C++\n    void Odabir(int N, int *T, int Q, int *L, int *R, int *F);\nPascal\n    procedure Odabir(N: longint; var T: array of longint; Q: longint; var L, R, F : array of longint);\n</code></pre> <p>Ukoliko radite u C/C++-u, potrebno je na po\u010detku fajla staviti <code>#include odabir.h\u201d</code> a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti <code>Unit odabir;</code> (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2014_2015/sio/06_odabir/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (odabir.c, odabir.cpp, odabir.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu se u\u010ditava broj \\(N\\)</li> <li>U drugom redu se u\u010ditava \\(N\\) brojeva, tj. niz \\(T\\)</li> <li>U tre\u0107em redu se u\u010ditava broj \\(Q\\)</li> <li>U svakom od slede\u0107ih \\(Q\\) redova se nalaze dva broja koji \\(L[i]\\) i \\(R[i]\\)</li> </ul> <p>a zatim pozivaju va\u0161u funkciju Odabir iz odgovaraju\u0107eg fajla (odabir.c, odabir.cpp, odabir.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p> <p>U nastavku je dat primer u\u010ditavanja sa konzole za test primer sa papira.</p> <pre><code>6\n1000 1 1200 1300 1400 5000\n3\n0 4\n0 5\n2 4\n</code></pre> <p>Ispis na konzolu je slede\u0107i:</p> <pre><code>2000 5001 2600\n</code></pre>"},{"location":"takprog/2014_2015/sio/06_odabir/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Zadatak re\u0161avamo grubom silom: prolazimo po svakom \\(X\\) od \\(L\\) do \\(R\\) i ra\u010dunamo prefiksni minimum i maksimum. Slo\u017eenost je \\(O(N\\cdot Q)\\).</p>"},{"location":"takprog/2014_2015/sio/06_odabir/#drugi-i-treci-podzadatak","title":"Drugi i tre\u0107i podzadatak:","text":"<p>Zadatak re\u0161avamo offline, tj. prvo u\u010ditamo sve upite, sortiramo ih po \\(L\\) vrednosti, a zatim prolazimo kroz niz \\(T\\) od kraja ka po\u010detku. Dok to radimo, pamtimo niz \\(pos_i\\) koji nam govori informaciju o prvom slede\u0107em indeksu pojavljivanja \u010dlana \\(i\\) u nizu \\(T\\). Taj niz ima veli\u010dinu \\(1000\\), jer je to maksimalna vrednost \\(T_i\\) u ovom podzadatku. Sada za svaki upit znamo interesantne pozicije: Potrebno je samo po njima pro\u0107i i izra\u010dunati zbir maksimuma i minimuma. Slo\u017eenost ovog algoritma je \\(O(Q\\cdot maxT_i \\cdot logN)\\) ili \\(O(Q\\cdot maxT_i)\\) u zavisnosti od implementacije.</p>"},{"location":"takprog/2014_2015/sio/06_odabir/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sli\u010dno kao ranije, zadatak re\u0161avamo offline. Kada idemo od kraja ka po\u010detku, potrebno je odr\u017eavati i lenjo segmentno stablo nad nizom \\(T\\). Njime pamtimo maksimum na segmentu, a a\u017euriramo ga tako \u0161to dodajemo (ili oduzimamo) odre\u0111en broj na rasponu. Ono nam govori informaciju o re\u0161enju zadatka za svako \\(X\\) izme\u0111u \\(L\\) i \\(N\\). </p> <p>Preciznije, interesantnih pozicija sada ima mnogo i nije mogu\u0107e uvek pro\u0107i po njima za svaki upit. Zato pamtimo dva stack-a parova koji nam govore informacije o slede\u0107em manjem/ve\u0107em elementu u nizu \\(T\\). Kada vr\u0161imo upite raspona na na\u0161em segmentnom stablu, bri\u0161emo element iz jednog od stack-ova. To zna\u010di da ukupna slo\u017eenost ostaje \\(O(N+QlogN)\\), Po\u0161to u na\u0161e stack-ove dodajemo najvi\u0161e jedan element po prolasku kroz niz \\(T\\), a ne mo\u017eemo obrisati vi\u0161e nego \u0161to smo dodali.</p> 06_odabir.cpp<pre><code>#include \"odabir.h\"\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAX_N = 1 &lt;&lt; 19;\nconst int MAX_NUM = 1000000005;\n\nint tree[2 * MAX_N];\nint save[2 * MAX_N];\n\nint prevBigger[MAX_N];\nint prevSmaller[MAX_N];\nint nextBigger[MAX_N];\nint nextSmaller[MAX_N];\nvector&lt;int&gt; smaller[MAX_N];\nvector&lt;int&gt; bigger[MAX_N];\nint size;\nint stk[MAX_N];\n\nint f[MAX_N];\nint* L;\nint* R;\n\nbool mycmp(int a, int b) {\n    return L[a] &lt; L[b];\n}\n\nvoid update(int node, int left, int right, int nleft, int nright, int amount) {\n    if (nright &lt; left || nleft &gt; right) return;\n    if (left &gt;= nleft &amp;&amp; right &lt;= nright) {\n        tree[node] += amount;\n        save[node] += amount;\n        return;\n    }\n    int mid = (left + right) / 2;\n    tree[node * 2 + 1] += save[node];\n    tree[node * 2 + 2] += save[node];\n    save[node * 2 + 1] += save[node];\n    save[node * 2 + 2] += save[node];\n    save[node] = 0;\n    update(node * 2 + 1, left, mid, nleft, nright, amount);\n    update(node * 2 + 2, mid + 1, right, nleft, nright, amount);\n    tree[node] = max(tree[node * 2 + 1], tree[node * 2 + 2]);\n}\n\nint findMax(int node, int left, int right, int nleft, int nright) {\n    if (nright &lt; left || nleft &gt; right) return 0;\n    if (left &gt;= nleft &amp;&amp; right &lt;= nright) {\n        return tree[node];\n    }\n    int mid = (left + right) / 2;\n    tree[node * 2 + 1] += save[node];\n    tree[node * 2 + 2] += save[node];\n    save[node * 2 + 1] += save[node];\n    save[node * 2 + 2] += save[node];\n    save[node] = 0;\n    int res = 0;\n    res = max(res, findMax(node * 2 + 1, left, mid, nleft, nright));\n    res = max(res, findMax(node * 2 + 2, mid + 1, right, nleft, nright));\n    return res;\n}\n\nvoid Odaberi(int N, int *T, int Q, int *tmpL, int *tmpR, int *X) {\n    L = tmpL;\n    R = tmpR;\n\n    int minVal = T[0];\n    int maxVal = T[0];\n    for (int i = 0; i &lt; N; ++i) {\n        minVal = min(minVal, T[i]);\n        maxVal = max(maxVal, T[i]);\n        save[i + MAX_N - 1] = 0;\n        tree[i + MAX_N - 1] = minVal + maxVal;\n    }\n    for (int i = MAX_N - 2; i &gt;= 0; --i) {\n        save[i] = 0;\n        tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\n    }\n\n    for (int i = 0; i &lt; Q; ++i) f[i] = i;\n    sort(f, f + Q, mycmp);\n\n    for (int i = 0; i &lt; N; ++i) {\n        smaller[i].clear();\n        bigger[i].clear();\n    }\n    size = 0;\n    for (int i = N - 1; i &gt;= 0; --i) {\n        while (size &gt;= 1 &amp;&amp; T[stk[size - 1]] &lt; T[i]) --size;\n        stk[size++] = i;\n        nextBigger[i] = (size &gt;= 2?stk[size - 2]:N);\n    }\n    size = 0;\n    for (int i = N - 1; i &gt;= 0; --i) {\n        while (size &gt;= 1 &amp;&amp; T[stk[size - 1]] &gt; T[i]) --size;\n        stk[size++] = i;\n        nextSmaller[i] = (size &gt;= 2?stk[size - 2]:N);\n    }\n    size = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        while (size &gt;= 1 &amp;&amp; T[stk[size - 1]] &lt;= T[i]) --size;\n        stk[size++] = i;\n        prevBigger[i] = (size &gt;= 2?stk[size - 2]:-1);\n        if (prevBigger[i] &gt; -1) \n            bigger[prevBigger[i]].push_back(i);\n    }\n    size = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        while (size &gt;= 1 &amp;&amp; T[stk[size - 1]] &gt;= T[i]) --size;\n        stk[size++] = i;\n        prevSmaller[i] = (size &gt;= 2?stk[size - 2]:-1);\n        if (prevSmaller[i] &gt; -1)\n            smaller[prevSmaller[i]].push_back(i);\n    }\n\n    int last = 0;\n    for (int testId = 0; testId &lt; Q; ++testId) {\n        int left = L[f[testId]];\n        int right = R[f[testId]];\n\n        while (last &lt; left) {\n            for (int i = 1; i &lt; smaller[last].size(); ++i) {\n                int p1 = smaller[last][i - 1];\n                int p2 = smaller[last][i] - 1;\n\n                update(0, 0, MAX_N - 1, p1, p2, T[p1] - T[last]);\n            }\n            if (smaller[last].size() &gt; 0) {\n                int lastP = smaller[last][smaller[last].size() - 1];\n                update(0, 0, MAX_N - 1, lastP, nextSmaller[last] - 1, T[lastP] - T[last]);\n            }\n            for (int i = 1; i &lt; bigger[last].size(); ++i) {\n                int p1 = bigger[last][i - 1];\n                int p2 = bigger[last][i] - 1;\n\n                update(0, 0, MAX_N - 1, p1, p2, T[p1] - T[last]);\n            }\n            if (bigger[last].size() &gt; 0) {\n                int lastP = bigger[last][bigger[last].size() - 1];\n                update(0, 0, MAX_N - 1, lastP, nextBigger[last] - 1, T[lastP] - T[last]);\n            }\n\n            ++last;\n        }\n\n        X[f[testId]] = findMax(0, 0, MAX_N - 1, left, right);\n    }\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/01_maje/","title":"B1 - Maje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 400ms 64MB <p>Civilizacija maja je jedna od najpoznatijih drevnih civilizacija. Ova civilizacija je, izme\u0111u ostalog, poznata po njihovoj, za taj period, veoma naprednoj matematici. Maje su bile op\u010dinjene neopadaju\u0107im nizovima brojeva, tj. nizovima koji zadovoljavaju da je svaki element niza, sem prvog, ve\u0107i ili jednak od prethodnog u nizu. Maje su verovale da se neke bitne osobine niza mogu otkriti tako \u0161to se niz transformi\u0161e u neopadaju\u0107i niz brojeva. Me\u0111utim, po\u0161to su verovale da se redosled elemenata u nizu ne sme menjati, maje su koristile specijalnu operaciju nad elementima niza kako bi ga transformisale.</p> <p>Dozvoljena operacija uzima jedan od brojeva iz niza i redom prebacuje nekoliko cifara (mogu\u0107e njih 0) sa po\u010detka broja na njegov kraj. Npr. primenjuju\u0107i ovu operaciju na broj 12345, mogu\u0107e je dobiti jedan od brojeva (uspravnom crtom je ozna\u010dena grupa cifara koja se prebacuje na kraj broja):</p> <ul> <li>|12345 \u2192 12345</li> <li>1|2345 \u2192 23451</li> <li>12|345 \u2192 34512</li> <li>123|45 \u2192 45123</li> <li>1234|5 \u2192 51234</li> </ul> <p>Va\u0161 zadatak je da za dati niz brojeva odredite da li je mogu\u0107e da se primenjuju\u0107i opisanu operaciju na svaki element niza ta\u010dno jednom, dobije neopadaju\u0107i niz elemenata.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Demjan Grubi\u0107 Boris Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2015_2016/drz/01_maje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi prirodan broj \\(N\\) koji predstavlja du\u017einu niza. U drugom redu se nalazi \\(N\\) prirodnih brojeva koji predstavljaju niz.</p>"},{"location":"takprog/2015_2016/drz/01_maje/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza va\u0161 program treba da ispi\u0161e \u201cDA\u201d ukoliko je mogu\u0107e transformisati dati niz u neopadaju\u0107i, primenjuju\u0107i opisanu operaciju na svaki element niza ta\u010dno jednom. U suprotnom, u prvom redu standardnog izlaza va\u0161 program treba da ispi\u0161e \u201cNE\u201d.</p>"},{"location":"takprog/2015_2016/drz/01_maje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/01_maje/#ulaz","title":"Ulaz","text":"<pre><code>5\n3302 142 214 115 600\n</code></pre>"},{"location":"takprog/2015_2016/drz/01_maje/#izlaz","title":"Izlaz","text":"<pre><code>DA\n</code></pre>"},{"location":"takprog/2015_2016/drz/01_maje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/drz/01_maje/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n24 15 33\n</code></pre>"},{"location":"takprog/2015_2016/drz/01_maje/#izlaz_1","title":"Izlaz","text":"<pre><code>NE\n</code></pre>"},{"location":"takprog/2015_2016/drz/01_maje/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom test primeru, jedan od na\u010dina da se niz transformi\u0161e u neopadaju\u0107i niz brojeva je da se odrade slede\u0107e operacije nad brojevima:</p> <p>33|02 \u2192 0233, 1|42 \u2192 421, 21|4 \u2192 421, 11|5 \u2192 511, |600 \u2192 600</p> <p>Ovim operacijama se dobija niz brojeva: 233 421 421 511 600, koji je neopadaju\u0107i.  Niz dat u drugom test primeru nije mogu\u0107e transformisati opisanom operacijom u neopadaju\u0107i niz brojeva.</p>"},{"location":"takprog/2015_2016/drz/01_maje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(n \u2264 10^6\\)</li> <li>svi brojevi u datom nizu su ime\u0111u \\(0\\) i \\(10^9\\), uklju\u010duju\u0107i i ove brojeve</li> </ul>"},{"location":"takprog/2015_2016/drz/01_maje/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u 4 podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [10 poena]: svi brojevi u datom nizu su manji od 10</li> <li>Podzadatak 2 [20 poena]: \\(n = 2\\)</li> <li>Podzadatak 3 [20 poena]: svi brojevi u datom nizu su manji od 100</li> <li>Podzadatak 4 [50 poena]: nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2015_2016/drz/01_maje/#napomena","title":"Napomena","text":"<p>Primetiti da se, primenom operacije na odre\u0111eni broj, cifre 0 mogu na\u0107i na po\u010detku broja. U ovom slu\u010daju se ne posmatraju ove nule, tj. posmatra se broj bez vode\u0107ih nula. Tako\u0111e, primetiti da u ulazu brojevi ne\u0107e imati vode\u0107e nule.</p>"},{"location":"takprog/2015_2016/drz/01_maje/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Svi elementi niza su jednocifreni i samim tim se njihove vrednosti ne mogu promeniti. Potrebno je proveriti da li je dat niz ve\u0107 sortiran neopadaju\u0107e. Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\) ili \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/drz/01_maje/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Broj mogu\u0107ih vrednosti nakon transformisanja nekog broja jednak je broju njegovih cifara. (koji po uslovu zadatka ne prevazilazi \\(9\\), tj. \\(log(maxA_i)\\) ) Kako imamo samo dva broja, mo\u017eemo da generi\u0161emo sve mogu\u0107e transformacije i uporedimo ih. Vremenska slo\u017eenost:  \\(O(log^N(maxA_i))\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/drz/01_maje/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Za svaki element niza postoje dve mogu\u0107e vrednosti (ili ga transformi\u0161emo na jedini na\u010din mogu\u0107i, ili ga ne transformi\u0161emo uop\u0161te). Za prvi element je optimalno uzeti manju od te dve opcije (on ne mora biti ve\u0107i ni od \u010dega, a bi\u0107e nam lak\u0161e da ostatak niza u\u010dinimo neopadaju\u0107im). Za svaki slede\u0107i element, sli\u010dnim razmi\u0161ljanjem, uzimamo manju od dve opcije ukoliko je ona ve\u0107a ili jednaka od prethodnog elementa (mo\u017eda ve\u0107 modifikovanog). Ako nije, a ona druga opcija jeste, onda uzimamo nju. Ako za neki element nijedna od dve mogu\u0107e vrednosti nije ve\u0107a ili jednaka od prethodne, onda re\u0161enje ne postoji. U suprotnom, re\u0161enje postoji. Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\) ili \\(O(1)\\). </p>"},{"location":"takprog/2015_2016/drz/01_maje/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sli\u010dno prethodnom podzadatku, za prvi element niza uzimamo najmanju od mogu\u0107ih tranformacija. Za svaki slede\u0107i element uzimamo najmanju mogu\u0107nost koja je ve\u0107a ili jednaka od prethodnog elementa. Ukoliko takva mogu\u0107nost ne postoji, ne postoji ni re\u0161enje. Vremenska slo\u017eenost: \\(O(Nlog(maxA_i))\\), memorijska slo\u017eenost: \\(O(N)\\) ili \\(O(1)\\).</p> 01_maje.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nconst int MAX_N = 1000005;\n\nint n;\nchar a[MAX_N][10];\n\nint get_num(char str[10], int sep) {\n    int ret = 0;\n    int cnt = strlen(str);\n    for (int i = sep; i &lt; cnt; ++i)\n        ret = ret * 10 + (str[i] - '0');\n    for (int i = 0; i &lt; sep; ++i)\n        ret = ret * 10 + (str[i] - '0');\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i) {\n        scanf(\"%s\", &amp;a[i]);\n    }\n\n    bool ok = true;\n    int cnt = strlen(a[0]);\n    int lastNum = get_num(a[0], 0);\n    for (int i = 1; i &lt; cnt; ++i)\n        lastNum = min(lastNum, get_num(a[0], i));\n\n    for (int i = 1; i &lt; n; ++i) {\n        cnt = strlen(a[i]);\n        int minNum = -1;\n        for (int j = 0; j &lt; cnt; ++j) {\n            int tmp = get_num(a[i], j);\n            if (tmp &gt;= lastNum) {\n                if (minNum == -1 || minNum &gt; tmp)\n                    minNum = tmp;\n            }\n        }\n        if (minNum &lt; lastNum) {\n            ok = false;\n        }\n        lastNum = minNum;\n    }\n\n    if (ok) printf(\"DA\\n\");\n    else printf(\"NE\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/","title":"B2 - Kralj Artur","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Kralj Artur priprema svoje vojnike za odlu\u010duju\u0107u bitku protiv Saksonaca. Kako bi iskoristile svoj pun potencijal na bojnom polju, neophodno je za svaku od \\(m\\) armija odabrati po jednog komandanta. Sve armije imaju isti broj vojnika, i on iznosi n. Artur zna da svaki komandant mora da dobro poznaje vojnike kojima komanduje, pa obi\u010dno za tu ulogu bira nekog od vojnika iz same armije. Naprednim prora\u010dunima, shvatio je da ukupna mo\u0107 (tj. zbir ve\u0161tina svih komandanata) ne sme da bude prevelika, jer tada mo\u017ee do\u0107i do nesuglasica me\u0111u njima i postoji opasnost da se armije sukobe me\u0111usobno. Istog trena je napravio spisak svih mogu\u0107ih izbora m komandanata i za svaki od izbora zabele\u017eio ukupnu mo\u0107. Nakon toga je najsavremenijim algoritmom tog doba, \u201eBozo sort\u201d-om, sortirao spisak opadaju\u0107e po mo\u0107i. </p> <p>Ipak, sedam dana nije uspeo da napravi pravilan izbor. Osmog dana mu je bilo dosta, i odlu\u010dio je da pita svog mudrog \u010darobnjaka-savetnika Merlina za savet. Nakon du\u017eeg gla\u0111enja sede brade, Merlin je lupio magi\u010dan broj \\(k\\) i rekao da je vrlo o\u010digledno da je pravi izbor onaj \\(k\\)-ti sa Arturovog spiska (pri \u010demu Merlin zna da broj mogu\u0107ih izbora nije manji od \\(k\\)). Arturu ovo svakako nije bilo o\u010digledno, i odmah je oti\u0161ao da obavesti vitezove okruglog stola o tome. Prvo \u0161to su ga vitezovi pitali bilo je kolika \u0107e u tom slu\u010daju biti ukupna mo\u0107 armije. Pomozite Arturu, koji je previ\u0161e uzbu\u0111en da bi se setio ta\u010dnog broja, da im odgovori na pitanje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Marko Ili\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se brojevi \\(m\\), \\(n\\) i \\(k\\), koji predstavljaju broj armija, broj vojnika u svakoj armiji, i Merlinov magi\u010dan broj, redom. Svaka od narednih \\(m\\) linija sadr\u017ei \\(n\\) brojeva koji ozna\u010davaju ve\u0161tine vojnika. Brojevi u \\(i\\)-tom redu se odnose na vojnike iz \\(i\\)-te armije.</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati odgovor na vite\u0161ko pitanje, tj. ukupnu mo\u0107 odabrane armije.</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/02_kralj_artur/#ulaz","title":"Ulaz","text":"<pre><code>2 3 6\n2 3 1\n4 5 6\n</code></pre>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#izlaz","title":"Izlaz","text":"<pre><code>7\n</code></pre>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Artur na raspolaganju ima dve armije, i po tri vojnika u svakoj od njih. Kandidati za komandanta prve armije su vojnici sa ve\u0161tinama iz skupa {2, 3, 1}, a druge armije vojnici sa ve\u0161tinama iz skupa {4, 5, 6}. Arturov sortiran spisak svih mogu\u0107ih ukupnih mo\u0107i je: [9, 8, 8, 7, 7, 7, 6, 6, 5]. Tra\u017eeni broj je \u0161esti broj na spisku, tj. 7.</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 m \u2264 10\\).</li> <li>\\(1 \u2264 n \u2264 1000\\).</li> <li>\\(1 \u2264 k \u2264 10^18\\).</li> <li>Ve\u0161tine vojnika su nenegativni celi brojevi manji ili jednaki 1000.</li> </ul>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u 5 podzadataka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [12 poena]: \\(m = 1\\).</li> <li>Podzadatak 2 [15 poena]: \\(k \u2264 2\\).</li> <li>Podzadatak 3 [24 poena]: \\(m \u2264 4, n \u2264 30\\).</li> <li>Podzadatak 4 [28 poena]: \\(n \u2264 6\\).</li> <li>Podzadatak 5 [21 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#resenje-za-m-1","title":"Re\u0161enje za \\(m = 1\\):","text":"<p>S tim da u ovom podzadatku imamo samo jednu armiju, njene vojnike mo\u017eemo sortirati nerastu\u0107e po ve\u0161tinama i izabrati \\(k\\)-tog vojnika za komandanta. Vremenska slo\u017eenost: \\(O(nlogn\\)). Memorijska slo\u017eenost: \\(O(m \\cdot n)\\).</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#resenje-za-k-le-2","title":"Re\u0161enje za \\(k \\le 2\\):","text":"<p>Ukoliko je \\(k = 1\\) treba izabrati najboljeg vojnika iz svake armije, dok za slu\u010daj \\(k = 2\\) biramo izbor sa najve\u0107om mo\u0107i, tako da je jedan komandant drugi najbolji vojnik u svojoj armiji, a svi ostali komandanti najbolji vojnici u svojim armijama. Vremenska slo\u017eenost: \\((n \\cdot m + m)\\). Memorijska slo\u017eenost: \\((m \\cdot n)\\).</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#resenje-za-m-le-4-i-n-le-30","title":"Re\u0161enje za \\(m \\le 4\\) i \\(n \\le 30\\):","text":"<p>S tim da su \\(n\\) i \\(m\\) dosta mali, mo\u017eemo izra\u010dunati ukupnu mo\u0107 za svaki izbor komandanata, sortirati sve odabire nerastu\u0107e po ukupnoj mo\u0107i i izabrati \\(k\\)-ti najbolji. Za sortiranje mo\u017eemo koristiti counting sort, po\u0161to \u0107e ukupne mo\u0107i biti vrednosti do \\(10^4\\). Vremenska slo\u017eenost: \\(O(n^m)\\). Memorijska slo\u017eenost: \\(O(n^m)\\).</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#resenje-za-n-le-6","title":"Re\u0161enje za \\(n \\le 6\\):","text":"<p>Ovaj podzadatak se mo\u017ee re\u0161iti isto kao prethodni, ali je za simuliranje svih izbora komandanata najlak\u0161e koristiti rekurziju.</p>"},{"location":"takprog/2015_2016/drz/02_kralj_artur/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Ideja nam je da za svaku mogu\u0107u vrednost ukupne mo\u0107i komandanata izra\u010dunamo na koliko na\u010dina je mo\u017eemo posti\u0107i. Neka nam je \\(dp_{i, x}\\) taj broj izbora za ukupnu mo\u0107 \\(x\\) biraju\u0107i samo vojnike iz prvih \\(i\\) armija i neka je \\(a_{i, j}\\) mo\u0107 \\(j\\)-tog vojnika u \\(i\\)-toj armiji. Rekurentna formula je \\(dp_{i, x} = \\sum_{j = 1}^{n} dp_{i-1, x - a_{i, j}}\\), zato \u0161to kada izaberemo jednog vojnika iz \\(i\\)-te armije, ostale vojnike biramo iz prvih \\(i-1\\) armija. Tako\u0111e, u formuli posmatramo samo one \\(j\\) za koje va\u017ei da je \\(x\\) ve\u0107e ili jednako \\(a_{i, j}\\). Vremenska slo\u017eenost: \\(O(n \\cdot m^2 \\cdot maxa)\\), gde je \\(maxa\\) najve\u0107a mo\u0107 svih vojnika. Memorijska slo\u017eenost: \\(O(n \\cdot m + m^2 \\cdot maxa)\\).</p> 02_kralj_artur.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst long long lim = 1ll &lt;&lt; 60ll;\n\ninline void add(long long&amp; x, long long y){\n    x += y;\n    if (x &gt; lim) x = lim;\n}\n\nint N, M;\nlong long K;\n\nint A[11][1001];\nlong long D[11][10001];\n\nint main(){\n    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;\n    for (int i=1; i&lt;=M; i++){\n        for (int j=1; j&lt;=N; j++){\n            cin &gt;&gt; A[i][j];\n        }\n    }\n    D[0][0] = 1;\n    for (int i=1; i&lt;=M; i++){\n        for (int j=1; j&lt;=N; j++){\n            int x = A[i][j];\n            for (int k=x; k&lt;=1000*i; k++){\n                add(D[i][k], D[i-1][k-x]);\n            }\n        }\n    }\n    int w = 1000*M;\n    while (w&gt;=0){\n        if (K &lt;= D[M][w]){\n            cout &lt;&lt; w &lt;&lt; endl;\n            return 0;\n        } else {\n            K -= D[M][w];\n            w--;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/","title":"B3 - Tiho Brdo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U srednjevekovnom dobu, u malom gradi\u0107u Tihom Brdu \u017eivelo je \u010dudovi\u0161te pod nazivom Gluton, koje je volelo da terori\u0161e stanovnike ovog grada. Mnogi vitezovi su poku\u0161avali da ubiju Glutona, ali ni jedan nije uspeo da pre\u017eivi taj susret.</p> <p>Jednog dana, hrabri arhitekta Davis je odlu\u010dio da napadne Glutona. Saznao je da se Gluton zapravo sastoji iz gomile delova, koji su me\u0111usobno spojeni na taj na\u010din da svaki deo mo\u017ee kontrolisati neke druge delove. Gluton ima ta\u010dno jedan deo koji predstavlja njegov mozak, i taj deo nije kontrolisan od strane ijednog drugog dela. Tako\u0111e, Gluton mo\u017ee imati jedan ili vi\u0161e delova koji ne kontroli\u0161u ni jedan drugi deo; ovi delovi predstavljaju njegove kand\u017ee. Za svaku kand\u017eu postoji ta\u010dno jedan skup spojeva kojim je mozak (direktno ili indirektno) kontroli\u0161e. Ukoliko Davis uspe\u0161no odse\u010de mozak od kontrolisanja svih kand\u017ei, onda Gluton ostaje potpuno bezopasan.</p> <p>Davis je upotrebio svoje projektne sposobnosti i zaklju\u010dio da je svakom od Glutonovih spojeva x \u2192 y mogu\u0107e pripisati snagu w neophodnu da bi se taj spoj uni\u0161tio. Davisova \u017eelja je da ulo\u017ei minimalno snage za odsecanje mozga od kand\u017ei, pa ga zanima koje spojeve, sleva na desno, treba da prese\u010de da bi to postigao. Ukoliko postoji vi\u0161e ta\u010dnih re\u0161enja, Davis bi voleo da ulo\u017eena snaga na po\u010detku bude \u0161to je manja mogu\u0107a, tj. tra\u017ei se leksikografski najmanje re\u0161enje od svih ta\u010dnih re\u0161enja.</p> <p>Za data dva niza, a i b, veli\u010dina n i m, ka\u017eemo da je a leksikografski manji od b ukoliko ili postoji neka pozicija i tako da je su do te pozicije nizovi isti, a niz a je po i-tom \u010dlanu manji, tj.</p> \\[ (ai &lt; bi) \u2227 (\u2200j &lt; i. aj = bj ) \\] <p>ili se nizovi \\(a\\) i \\(b\\) poklapaju na svim kompatibilnim pozicijama, s tim da je niz a kra\u0107i, tj.</p> \\[ (n &lt; m) \u2227 (\u2200j \u2264 n. aj = bj ) \\] <p>Primeri: {1, 2, 3} &lt; {2, 2, 3}; {1, 2, 3, 4} &lt; {1, 2, 4, 4}; {1, 2, 3} &lt; {1, 2, 3, 4}. Zaslepljen slavom koju bi stekao i pokli\u010dima \u201cHvala hrabri Davise!\u201d od stanovnika ukoliko bi onesposobio Glutona, Davis nema dovoljno strpljenja da izra\u010duna re\u0161enje. Zamolio vas je za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Bogdan Petrovi\u0107 Andrej Iva\u0161kovi\u0107 <p>Primetimo da je Gluton stablo sa korenom u \u010dvoru \\(1\\). Operacija uni\u0161tenja spoja predstavlja uklanjanje te grane u grafu. Da bismo pobedili Glutona potrebno je ukloniti neke grane tako da koren stabla ne bude povezan ni sa jednim listom. Re\u0161enje zadatka su te\u017eine grana sa najmanjom sumom te\u017eina koje zadovoljavaju prethodni uslov. Ukoliko postoji vi\u0161e re\u0161enja, potrebno je ispisati leksikografski najmanje. Vi\u0161e o tome u analizi po podzadacima.</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(n\\), koji predstavlja broj Gluto- novih delova. Deo sa indeksom 1 uvek predstavlja mozak. Zatim slede opisi delova, od mozga do dela sa indeksom \\(n\\), redom, na slede\u0107i na\u010din: u prvom redu se nalazi ceo broj \\(m_i\\), koji predstavlja broj delova koji su pod direktnom kontrolom teku\u0107eg dela. Ukoliko va\u017ei \\(m_i\\) = 0, onda je teku\u0107i deo kand\u017ea. U suprotnom, u drugom redu se nalazi niz a od \\(m_i\\) prirodnih brojeva, koji predstavlja, sleva na desno, indekse delova pod direktnom kontrolom teku\u0107eg dela. U tre\u0107em redu se nalazi niz \\(w\\) od \\(m_i\\) prirodnih brojeva, tako da \\(j\\)-ti \u010dlan niza \\(w\\), \\(w_j\\) , ozna\u010dava snagu neophodnu za uni\u0161tenje spoja kojim teku\u0107i deo kontroli\u0161e \\(j\\)-tog \u010dlana niza \\(a\\), \\(a_j\\) .</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu standardnog izlaza potrebno je ispisati minimalnu ukupnu snagu neophodnu da bi Davis onesposobio Glutona. U narednom redu neophodno je ispisati leksikografski najmanji niz snaga koje \u0107e trebati Davisu da bi odsekao sve neophodne spojeve, sleva na desno, redom. \u010clanove niza treba odvojiti razmakom.</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#ulaz","title":"Ulaz","text":"<pre><code>7\n2\n2 5\n4 7\n2\n3 4\n2 3\n0\n0\n2\n6 7\n1 6\n0\n0\n</code></pre>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#izlaz","title":"Izlaz","text":"<pre><code>11\n4 1 6\n</code></pre>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Na slikama ispod nalazi se opis test primera; leva slika predstavlja po\u010detno stanje Glutona, a desna predstavlja optimalno re\u0161enje. Mozak je ozna\u010den crnom pozadinom, a kand\u017ee crvenom bojom. Precrtani i isprekidani spojevi predstavljaju one spojeve koje Davis treba da uni\u0161ti. Postoje dva re\u0161enja koja zahtevaju minimalnu ukupnu snagu 11; ta re\u0161enja su, sleva na desno, {4, 7} i {4, 1, 6}. Od ta dva re\u0161enja, biramo leksikografski manje.</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \u2264 n \u2264 10^5\\);</li> <li>\\(1 \u2264 w_j \u2264 10^9\\);</li> <li>Ukupan broj spojeva \u0107e uvek biti \\(n \u2212 1\\), i uvek \u0107e za svaku kand\u017eu postojati ta\u010dno jedan skup spojeva koji je povezuju sa mozgom.</li> </ul>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u \u010detiri podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [10 poena]: Svi spojevi \u0107e imati istu potrebnu snagu za uni\u0161tenje;</li> <li>Podzadatak 2 [10 poena]: Jedino mozak mo\u017ee direktno kontrolisati vi\u0161e od jednog dela Glutona;</li> <li>Podzadatak 3 [30 poena]: \\(n \u2264 1000\\);</li> <li>Podzadatak 4 [50 poena]: Nema dodatnih ograni\u010denja.</li> </ul> <p>Ukoliko na svim test primerima jednog podzadatka izra\u010dunate ta\u010dnu ukupnu snagu, dobijate 60% poena za taj podzadatak. Ukoliko korektno odredite leksikografski minimalno re\u0161enje na svim test primerima jednog podzadatka, dobijate 40% poena za taj podzadatak.</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Po\u0161to svi spojevi imaju istu potrebnu snagu za uni\u0161tenje, do re\u0161enja dolazimo brisanjem minimalnog broja grana u grafu tako da koren ne bude povezan sa listovima. To najjednostavnije posti\u017eemo brisanjem svih grana koje povezuju koren stabla sa njegovom decom. Neka je \\(d = deg(1)\\) i \\(w\\) te\u017eina grane, potrebno je ispisati \\(d\\cdot   w\\), a zatim \\(d\\) puta ispisati \\(w\\). Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Primetimo da stablo u ovom podzadatku izgleda kao \\(deg(1)\\) lanaca kojima je \u010dvor \\(1\\) jedan od krajeva. U ovakvom stablu imamo \\(deg(1)\\) listova, po jedan u svakom lancu. Da bismo prekinuli vezu izme\u0111u lista i korena potrebno je da uklonimo granu na putu od tog lista do korena, odnosno potrebno je ukloniti granu na svakom lancu. Do re\u0161enja dolazimo uklanjanjem grane sa najmanjom te\u017einom iz svakog lanca. Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Ozna\u010dimo sa \\(s_i\\) minimalnu sumu te\u017eina grana koje treba da uklonimo iz podstabla \u010dvora \\(i\\) tako da \u010dvor \\(i\\) ne bude povezan sa listovima svog podstabla, i sa \\(k_i\\) neku strukturu koja \u010duva pojedina\u010dne te\u017eine tih grana. Da bismo izra\u010dunali vrednosti  \\(s_i\\) i \\(k_i\\), koristi\u0107emo vrednosti \\(s_j\\) i \\(k_j\\), za svako \\(j\\) \u010diji je roditelj \u010dvor \\(i\\).</p> \\[ s_i=\\sum_{j}min(s_j, w_{i,j}) \\] <p>U \\(k_i\\) \u0107emo dodati  \\(w_{i,j}\\) ukoliko je \\(w_{i,j}&lt;s_j\\), u suprotnom dodajemo \\(k_j\\). Napomena: bitno je da je \\(w_{i,j}&lt;s_j\\), a ne \\(w_{i,j}\u2264s_j\\) u gornjem uslovu da bismo ispunili uslov zadatka koji nam tra\u017ei leksikografsku minimalnost. Za listove \u0107emo postaviti vrednost \\(s\\) na \\(\\infty\\), jer je nemogu\u0107e da izbri\u0161emo neke grane tako da razdvojimo taj \u010dvor od samog sebe. Re\u0161enje zadatka su \\(s_1\\) i \\(k_1\\).  Ovaj na\u010din je mogu\u0107e implementirati algoritmom pretrage u dubinu, naivnim pozivanjem funkcije pretrage u dubinu. Vremenska slo\u017eenost je \\(O(N^2)\\) , a memorijska \\(O(N)\\), jer se te\u017eina svake grane \u010duva na najvi\u0161e \\(2\\) mesta, u \\(k_i\\) i \\(k_j\\).</p>"},{"location":"takprog/2015_2016/drz/03_tiho_brdo/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Koristi\u0107emo sli\u010dno re\u0161enje kao u prethodnom podzadatku. Jedina razlika je \u0161to \u0107emo koristiti memoizaciju kao tehniku da ubrzamo pretragu u dubinu, tj. da za svaki \u010dvor \\(i\\) ra\u010dunamo vrednosti \\(s_i\\) i \\(k_i\\) jedanput. Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p> 03_tiho_brdo.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Tiho Brdo\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n#define MAX_N 1000005\n\nusing namespace std;\ntypedef long long lld;\n\nint n;\n\nstruct node\n{\n    int par; int w_par;\n    vector&lt;int&gt; adj;\n};\nnode tree[MAX_N];\n\nlld dp[MAX_N];\n\ninline void compute_dp()\n{\n    queue&lt;int&gt; bfs_q;\n    for (int i=1;i&lt;=n;i++)\n    {\n        if (tree[i].adj.empty()) bfs_q.push(i);\n    }\n\n    while (!bfs_q.empty())\n    {\n        int xt = bfs_q.front();\n        bfs_q.pop();\n\n        if (tree[xt].par == -1) continue;\n\n        dp[xt] = tree[xt].w_par;\n        if (!tree[xt].adj.empty())\n        {\n            lld s_1 = 0;\n            for (int i=0;i&lt;tree[xt].adj.size();i++)\n            {\n                s_1 += dp[tree[xt].adj[i]];\n            }\n            dp[xt] = min(dp[xt], s_1);\n        }\n\n        bfs_q.push(tree[xt].par);\n    }\n}\n\nvoid extract_seq(int x, vector&lt;int&gt; &amp;ret)\n{\n    if (tree[x].adj.size() == 0)\n    {\n        ret.push_back(tree[x].w_par);\n        return;\n    }\n\n    lld opt_2 = 0;\n    for (int i=0;i&lt;tree[x].adj.size();i++)\n    {\n        opt_2 += dp[tree[x].adj[i]];\n    }\n\n    if (tree[x].w_par &lt; opt_2)\n    {\n        ret.push_back(tree[x].w_par);\n        return;\n    }\n\n    for (int i=0;i&lt;tree[x].adj.size();i++)\n    {\n        extract_seq(tree[x].adj[i], ret);\n    }\n}\n\ninline pair&lt;lld, vector&lt;int&gt; &gt; solve()\n{\n    compute_dp();\n\n    lld ret = 0;\n    vector&lt;int&gt; seq;\n\n    for (int i=0;i&lt;tree[1].adj.size();i++)\n    {\n        ret += dp[tree[1].adj[i]];\n        extract_seq(tree[1].adj[i], seq);\n    }\n\n    return {ret, seq};\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for (int i=1;i&lt;=n;i++)\n    {\n        int len;\n        scanf(\"%d\", &amp;len);\n        tree[i].adj.resize(len);\n        for (int j=0;j&lt;len;j++)\n        {\n            scanf(\"%d\", &amp;tree[i].adj[j]);\n            tree[tree[i].adj[j]].par = i;\n        }\n        for (int j=0;j&lt;len;j++)\n        {\n            scanf(\"%d\", &amp;tree[tree[i].adj[j]].w_par);\n        }\n    }\n\n    tree[1].par = tree[1].w_par = -1;\n\n    auto ret = solve();\n    printf(\"%lld\\n\", ret.first);\n    for (int j=0;j&lt;ret.second.size();j++)\n    {\n        printf(\"%d \", ret.second[j]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/04_vatromet/","title":"A1 - Vatromet","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Stari kineski filozof, koji se u slobodno vreme bavi pravljenjem vatrometa, sada treba da napravi fitilj (da bi mogao da ih bezbedno upali). On ima kanap du\u017eine \\(N\\) metara, iz kog planira da ise\u010de deo. Kako je pravljenje fitilja posao koji zahteva veliku preciznost, on \u017eeli da se\u010de ovaj kanap tako da mora da meri samo du\u017eine koje su celi brojevi u metrima \u2013 fitilj mora po\u010deti i zavr\u0161iti se na celobrojnom rastojanju od po\u010detka kanapa. Za svaki metar kanapa, on zna ceo broj \\(A_i\\), koji predstavlja njegovu \u201cpouzdanost\u201d (metar i obuhvata deo kanapa izme\u0111u pozicija na rastojanjima \\(i\\) i \\((i + 1)\\) metara od po\u010detka kanapa). Postoji \\(Q\\) razli\u010ditih vatrometa koje bi filozof mogao da koristi. Za svaki od njih postoje uslovi koje fitilj mora da ispuni \u2013 ne sme da bude ni previ\u0161e kratak ni previ\u0161e dug, a mora i da bude dovoljno pouzdan. Za vatromet \\(i\\), ovi uslovi su definisani celim brojevima \\(L_i\\) , \\(H_i\\) , \\(T_i\\) na slede\u0107i na\u010din: * Du\u017eina fitilja mora biti ve\u0107a ili jednaka \\(L_i\\) i manja ili jednaka \\(H_i\\), * Srednja vrednost pouzdanosti fitilja mora biti barem \\(T_i\\).</p> <p>Filozof \u017eeli da odabere jedan vatromet za koji \u0107e napraviti fitilj. Zbog toga, za svaki vatromet ga interesuje na koliko na\u010dina za njega mo\u017ee da napravi fitilj od kanapa koji mu je na raspolaganju. Po\u0161to je zauzet i nema mnogo vremena, Va\u0161 zadatak je da to odredite umesto njega.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Dimitrije Erdeljan Marko Ili\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2015_2016/drz/04_vatromet/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(N\\), koji predstavlja du\u017einu kanapa. U drugom redu se nalazi \\(N\\) celih brojeva, gde je \\(i\\)-ti broj pouzdanost \\(i\\)-tog metra kanapa \\(A_i\\). U tre\u0107em redu se nalazi \\(Q\\) \u2013 broj vatrometa za koje se tra\u017ei re\u0161enje. U narednih \\(Q\\) redova se nalaze po tri cela broja: u \\(i\\)-tom se nalaze \\(L_i\\) , \\(H_i\\) i \\(T_i\\) , koji predstavljaju gore opisane uslove za vatromet \\(i\\).</p>"},{"location":"takprog/2015_2016/drz/04_vatromet/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(Q\\) celih brojeva, gde je \\(i\\)-ti od ispisanih brojeva broj na\u010dina da se ise\u010de fitilj koji ispunjava uslove za vatromet \\(i\\).</p>"},{"location":"takprog/2015_2016/drz/04_vatromet/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/04_vatromet/#ulaz","title":"Ulaz","text":"<pre><code>5\n3 2 3 1 2\n2\n1 1 2\n2 3 2\n</code></pre>"},{"location":"takprog/2015_2016/drz/04_vatromet/#izlaz","title":"Izlaz","text":"<pre><code>4\n6\n</code></pre>"},{"location":"takprog/2015_2016/drz/04_vatromet/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Za prvi vatromet, filozof mo\u017ee da ise\u010de bilo koji metar kanapa osim \u010detvrtog. Za drugi, potreban mu je deo koji je ili du\u017eine 2 (dovoljno pouzdani su delovi koji po\u010dinju na rastojanju 0, 1 i 2 od po\u010detka, sa srednjom pouzdanosti redom 2.5, 2.5 i 2) ili du\u017eine 3 (sva tri su dovoljno pouzdana).</p>"},{"location":"takprog/2015_2016/drz/04_vatromet/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 N \u2264 200\\)</li> <li>\\(1 \u2264 Q \u2264 200000\\)</li> <li>\\(1 \u2264 A_i \u2264 10^9\\)</li> <li>\\(1 \u2264 L_i \u2264 H_i \u2264 N\\)</li> <li>\\(1 \u2264 T_i \u2264 10^9\\)</li> </ul>"},{"location":"takprog/2015_2016/drz/04_vatromet/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u 3 podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [20 poena]: \\(Q \u2264 100\\)</li> <li>Podzadatak 2 [20 poena]: \\(Q \u2264 10000\\)</li> <li>Podzadatak 3 [60 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/drz/04_vatromet/#resenje-za-q-le-100","title":"Re\u0161enje za \\(Q \\le 100\\)","text":"<p>U ovom podzadatku mo\u017eemo za svaki upit pro\u0107i kroz sve mogu\u0107e fitilje (njih je \\(\\frac{N\\cdot(N-1)}{2}\\)) i za svaki proveriti da li nam odgovara. Da bismo izra\u010dunali srednju pouzdanost nekog fitilja, koristi\u0107emo prefiksne sume, kako bismo efikasno dobili zbir pouzdanosti svih metara fitilja. Vremenska slo\u017eenost: \\(O(Q \\cdot N^2)\\). Memorijska slo\u017eenost: \\(O(N)\\). </p>"},{"location":"takprog/2015_2016/drz/04_vatromet/#resenje-za-q-le-10000","title":"Re\u0161enje za \\(Q \\le 10000\\)","text":"<p>Mo\u017eemo pre nego \u0161to krenemo sa obra\u0111ivanjem upita, da za svaku mogu\u0107u du\u017einu fitilja \\(X\\), napravimo niz \\(b_X\\) u kome \u0107emo dr\u017eati srednje pouzdanosti svih fitilja du\u017eine \\(X\\). Te nizove treba sortirati neopadaju\u0107e. Sada, za svaki upit, mo\u017eemo iterirati po du\u017einama od \\(L_i\\) do \\(H_i\\) i za svaku du\u017einu \\(X\\) iz tog intervala, binarnom pretragom odrediti broj fitilja du\u017eine \\(X\\), takvih da im je srednja pouzdanost ve\u0107a ili jednaka \\(T_i\\). Vremenska slo\u017eenost: \\(O(N^2logN + QNlogN)\\). Memorijska slo\u017eenost: \\(O(N^2)\\). </p>"},{"location":"takprog/2015_2016/drz/04_vatromet/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Razlika ovog i prethodnog podzadatka je u tome \u0161to \u0107emo u nizu \\(b_X\\) dr\u017eati srednje pouzdanosti svih fitilja koji su du\u017eine manje ili jednake \\(X\\). Kada obra\u0111ujemo upit, ne moramo vi\u0161e prolaziti kroz sve mogu\u0107e du\u017eine, ve\u0107 \u0107emo samo od broja fitilja koji imaju odgovaraju\u0107u srednju pouzdanost u nizu \\(b_{H_i}\\) oduzeti broj fitilja sa odgovaraju\u0107om srednjom pouzdano\u0161\u0107u iz niza \\(b_{L_i-1}\\), jer \u0107emo time ura\u010dunati samo fitilje du\u017eine od \\(L_i\\) do \\(H_i\\). Vremenska slo\u017eenost: \\(O(N^3logN + QlogN)\\). Memorijska slo\u017eenost: \\(O(N^3)\\). </p> 04_vatromet.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nconst int N = 205;\nint a[N];\n\nstruct fraction { long long up, down; } ;\n\ninline bool operator&lt;(fraction a, fraction b)\n{\n    return a.up * b.down &lt; b.up * a.down;\n}\n\nfraction means[N][N*N]; // means[i] = sve srednje vrednosti duzine najvise i\nint n_means[N];\n\n// broj elemenata a vecih ili jednakih x\nint num_larger(int mm, fraction x)\n{\n    if(n_means[mm] == 0) return 0;\n    if(means[mm][n_means[mm] - 1] &lt; x) return 0;\n    int left = 0, right = n_means[mm] - 1;\n    while(left &lt; right)\n    {\n        int mid = (left + right) / 2;\n        if(means[mm][mid] &lt; x) left = mid + 1;\n        else right = mid;\n    }\n    return n_means[mm] - right;\n}\n\nint main()\n{\n    int n, q;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;a[i]);\n\n    for(int i = 0; i &lt; n; i++)\n    {\n        long long sum = 0;\n        for(int len = 1; i + len - 1 &lt; n; len++)\n        {\n            sum += a[i + len - 1];\n            for(int j = 0; j &lt;= len; j++)\n                means[j][n_means[j]++] = {sum,len};\n        }\n    }\n\n    for(int i = 0; i &lt;= n; i++)\n        sort(means[i], means[i] + n_means[i]);\n\n\n    scanf(\"%d\", &amp;q);\n    for(int i = 0; i &lt; q; i++)\n    {\n        int low, high, t;\n        scanf(\"%d %d %d\", &amp;low, &amp;high, &amp;t);\n\n        printf(\"%d\\n\", num_larger(low, {t, 1}) - num_larger(high + 1, {t, 1}));\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/05_magija/","title":"A2 - Magija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>U srednjem veku se mnogo pri\u010dalo o zlim ve\u0161ticama koje su koristile crnu magiju da naude ljudima. Znalo se da su one organizovane u hijerarhijsku strukturu, tj. svaka zla ve\u0161tica, osim glavne ve\u0161tice Baba Jaga, je imala ta\u010dno jednu nadre\u0111enu ve\u0161ticu kojoj je morala da govori sve svoje zle planove pre izvr\u0161avanja. Isto tako, svaka ve\u0161tica je znala koje su joj ve\u0161tice podre\u0111ene. Za razliku od toga \u0161to se mnogo znalo o zlim ve\u0161ticama, mnogo manje se znalo o ve\u0161ticama koje su koristile belu magiju da bi se borile protiv zlih ve\u0161tica i spre\u010dile ih u njihovoj nameri da naude ljudima. Najpoznatija ve\u0161tica koja je koristila belu magiju je bila magi\u010dna Sonja. Ona je bila jedina osoba koja je znala da izvede magiju koja oduzima svu mo\u0107 zloj ve\u0161tici, te je onesposobi u nameri da na\u010dini neku ozbiljnu \u0161tetu. Jedino ograni\u010denje je bilo da Sonja mo\u017ee iskoristiti ovu \u010din samo na zlim ve\u0161ticama koje nemaju nijednu podre\u0111enu ve\u0161ticu, jer u suprotnom bi sve podre\u0111ene ve\u0161tice zajedno napale Sonju.</p> <p>U jednom trenutku su se sve zle ve\u0161tice dogovorile da izvr\u0161e napade i svaka ve\u0161tica je odredila kojeg dana \u0107e iskoristiti svoju najrazorniju \u010din. Sonjin zadatak je da onesposobi sve ve\u0161tice u njihovoj nameri. Ona mora da iskoristi svoju specijalnu \u010din na svakoj ve\u0161tici pre nego \u0161to ta ve\u0161tica iskoristi svoju \u010din. Kao \u0161to je prethodno navedeno, Sonja mo\u017ee da iskoristi \u010din samo na ve\u0161ticama koje nisu nikome nadre\u0111ene. Kada onesposobi jednu ve\u0161ticu, ta ve\u0161tica se uklanja iz hijerarhijske strukture zlih ve\u0161tica (te njena nadre\u0111ena ve\u0161tica ima za jednu manje podre\u0111enu ve\u0161ticu). Svaka zla ve\u0161tica ima svoj jedinstveni redni broj, a zna se da Baba Jaga ima redni broj 1. Sonja na po\u010detku zna izgled hijerarhijske strukture zlih ve\u0161tica i za svaku ve\u0161ticu zna kog dana \u0107e iskoristiti svoju najrazorniju \u010din. Sonjina mo\u0107 je ograni\u010dena, te mo\u017ee da iskoristi svoju specijalnu \u010din samo jednom dnevno. Va\u0161 zadatak je da pomognete Sonji i preporu\u010dite raspored kojim treba da napada ve\u0161tice, tj. da joj za svaki dan ka\u017eete redni broj ve\u0161tice na koju mora da baci svoju \u010din.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nemanja \u0160kori\u0107 Demjan Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2015_2016/drz/05_magija/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi prirodan broj \\(N\\). U drugom redu standardnog ulaza se nalazi \\(N\\) brojeva gde \\(i\\)-ti broj, ti, predstavlja redni broj dana u kome \u0107e ve\u0161tica sa rednim brojem i iskoristiti svoju razornu \u010din. U narednih \\(N \u2212 1\\) redova se nalazi po dva prirodna broja \\(p\\) i \\(q\\) (\\(1 \u2264 p, q \u2264 N\\)) koji ozna\u010davaju da je ve\u0161tica sa rednim brojevim \\(p\\) nadre\u0111ena ve\u0161tici sa rednim brojem \\(q\\).</p>"},{"location":"takprog/2015_2016/drz/05_magija/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko je mogu\u0107e da Sonja onesposobi svaku ve\u0161ticu pre nego \u0161to ta ve\u0161tica upotrebi svoju \u010din, potrebno je u jednom redu ispisati \\(N\\) brojeva gde \\(i\\)-ti broj predstavlja redni broj zle ve\u0161tice koju Sonja treba da onesposobi \\(i\\)-tog dana (ukoliko postoji vi\u0161e takvih redosleda ispisati bilo koji). Ukoliko to nije mogu\u0107e, ispisati poruku \u201cPobedila je crna magija\u201d</p>"},{"location":"takprog/2015_2016/drz/05_magija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/05_magija/#ulaz","title":"Ulaz","text":"<pre><code>5\n10 7 2 6 2\n4 2\n1 4\n4 5\n1 3\n</code></pre>"},{"location":"takprog/2015_2016/drz/05_magija/#izlaz","title":"Izlaz","text":"<pre><code>5 3 2 4 1\n</code></pre>"},{"location":"takprog/2015_2016/drz/05_magija/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/drz/05_magija/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n10 7 9 2 8\n4 2\n1 4\n4 5\n1 3\n</code></pre>"},{"location":"takprog/2015_2016/drz/05_magija/#izlaz_1","title":"Izlaz","text":"<pre><code>Pobedila je crna magija\n</code></pre>"},{"location":"takprog/2015_2016/drz/05_magija/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom test primeru prvog dana se onesposobi ve\u0161tica sa rednim brojem 5, te drugog dana ve\u0161tica sa rednim brojem 3. Primetimo da smo ve\u0161ticu sa rednim brojem 3 onesposobili u poslednjem trenutku, jer da smo poku\u0161ali da je onesposobimo jedan dan kasnije ona bi ve\u0107 iskoristila \u010din. Posle ve\u0161tice sa rednim brojem 3 redom smo onesposobili ve\u0161tice sa rednim brojevima 2, 4 i 1 i nijedna od zlih ve\u0161tica nije stigla da iskoristiti svoju \u010din. Primetimo da je i redosled 3, 5, 2, 4, 1 validno re\u0161enje u ovom test primeru.</p> <p>U drugom test primeru ne mo\u017eemo sti\u0107i da onesposobimo ve\u0161ticu sa rednim brojem 4 pre nego \u0161to ona iskoristi svoju \u010din.</p>"},{"location":"takprog/2015_2016/drz/05_magija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 n \u2264 10^5\\)</li> <li>\\(1 \u2264 t_i \u2264 10^9\\)</li> </ul>"},{"location":"takprog/2015_2016/drz/05_magija/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u 4 podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [16 poena]: Svaka ve\u0161tica ima najvi\u0161e jednu direktno podre\u0111enu ve\u0161ticu.</li> <li>Podzadatak 2 [18 poena]: Ve\u0161tica \u0107e uvek iskoristiti svoju \u010din tek nakon \u0161to njene podre\u0111ene ve\u0161tice iskoriste svoje \u010dini i \\(n \u2264 1000\\)</li> <li>Podzadatak 3 [31 poena]: \\(n\\) je oblika \\(2 x \u2212 1\\) gde je \\(x\\) prirodan broj. Svaka ve\u0161tica ima ili dve ili nijednu direktno podre\u0111enu ve\u0161ticu. Uzmimo bilo koju ve\u0161ticu v i posmatrajmo niz \\(v = f_0, f_1, f_2, \u00b7 \u00b7 \u00b7 , f_k\\) gde je \\(f_i\\) nadre\u0111ena ve\u0161tica od \\(f_{i\u22121}\\) za sve \\(i \u2208 1, 2, \u00b7 \u00b7 \u00b7 , k\\). Bilo koji tako opisan niz ne\u0107e biti du\u017ei od \\(log_2(n + 1)\\). Drugim re\u010dima, bi\u0107e dato kompletno binarno balansirano stablo, tj. svi \u010dvorovi na nivoima manjim od \\(x\\) \u0107e imati ta\u010dno dva sina, a \u010dvorovi na poslednjem nivou nemaju nijednog sina.</li> <li>Podzadatak 4 [35 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/drz/05_magija/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>U ovom podzadatku data hijerarhija predstavlja vertikalni lanac \u010diji je \u010dvor \\(1\\) na vrhu. Jedina dozvoljena operacija koju mi smemo da izvr\u0161imo jeste brisanje \u010dvora sa dna. Svaki \u010dvor ima rok do kog moramo da ga obri\u0161emo. Ovaj proces je mogu\u0107e simulirati jednim prolaskom kroz lanac jer postoji samo jedna mogu\u0107a opcija za brisanje po danu. Potrebno je  proveriti za svaki \u010dvor da li smo ga obrisali pre isteka njegovog roka. Vremenska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/drz/05_magija/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Koristi\u0107emo pohlepan algoritam. Data hijerarhija je stablo i smemo da bri\u0161emo njegove listove. U svakom trenutku \u0107emo obrisati bilo koji list koji ima najskoriji rok. To mo\u017eemo u\u010diniti u \\(O(N)\\) tako \u0161to prolazimo po svim \u010dvorovima i tra\u017eimo minimalan list. Kako ima \\(N\\) brisanja, ukupna vremenska slo\u017eenost je \\(O(N^2)\\).</p>"},{"location":"takprog/2015_2016/drz/05_magija/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Istim postupkom bri\u0161emo \u010dvorove, ali potrebno je efikasnije na\u0107i minimalan list i garantovati uslov da deca imaju raniji rok od roditelja. Uslov mo\u017eemo ispuniti tako \u0161to \u0107emo za svaki \u010dvor sa rokom \\(T\\) postaviti rok \\(T-1\\) na svako njegovo dete koje trenutno ima ve\u0107i rok. Ako je mogu\u0107e obrisati roditelja na vreme, onda se moraju ispuniti i dati rokovi za njegovu decu. Ovo se efikasno implementira jednim \\(DFS\\) prolaskom kroz stablo, po\u010dev od \u010dvora \\(1\\). (korena stabla) </p> <p>Minimalni list tra\u017eimo na slede\u0107i na\u010din: u svakom \u010dvoru binarnog stabla jednostavno pamtimo indeks minimalnog koji je u njegovom podstablu. (Bi\u0107e minimum od 2 njegova deteta, ili sam taj \u010dvor ako nema decu) Kada obri\u0161emo list, potrebno je za sve njegove pretke (kojih ima \\(O(logN)\\) ) postaviti novu adekvatnu vrednost. Ukupna vremenska slo\u017eenost je \\(O(NlogN)\\) .</p>"},{"location":"takprog/2015_2016/drz/05_magija/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Opet \u0107emo garantovati uslov za rok, ali nam treba nov na\u010din za tra\u017eenje minimalnog lista. Ovaj put \u0107emo jednostavno stavljati sve listove u min heap strukturu (odnosno priority_queue u koji stavljamo parove, prvi \u010dlan para je rok \u010dvora i onaj po kome poredimo parove, a drugi \u010dlan je indeks \u010dvora). Kada bri\u0161emo \u010dvor jednostavno bri\u0161emo element na vrhu u  min heap. Ukoliko nastane novi list brisanjem \u010dvora, dodajemo ga u min heap. Vremenska slo\u017eenost je \\(O(NlogN)\\) .</p> 05_magija.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;stdio.h&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n#define MaxN 100010\n\nstruct Vestica {\n    int t;\n    int id;\n\n    Vestica() {}\n    Vestica(int _t, int _id) {\n        t = _t;\n        id = _id;\n    }\n\n    bool operator &lt; (const Vestica &amp;other) const {\n        if (t != other.t) return t &lt; other.t;\n        return id &lt; other.id;\n    }\n};\n\nint n;\nVestica a[MaxN];\nVestica b[MaxN];\nvector&lt;int&gt; edge[MaxN];\nbool deleted[MaxN];\nvector&lt;int&gt; output;\nint currTime;\n\nbool DFS(int node) {\n    if (deleted[node]) return true;\n\n    for (int i = 0; i &lt; edge[node].size(); ++i) {\n        int v = edge[node][i];\n\n        if (!DFS(v)) return false;\n    }\n\n    if (currTime &gt; a[node].t) return false;\n\n    currTime++;\n    deleted[node] = true;\n    output.push_back(node);\n\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d\",&amp;n);\n    for (int i = 0; i &lt; n; ++i) {\n        scanf(\"%d\",&amp;a[i].t);\n        a[i].id = i;\n        b[i] = a[i];\n    }\n\n    for (int i = 0; i &lt; n-1; ++i) {\n        int u, v;\n        scanf(\"%d %d\",&amp;u,&amp;v);\n\n        u--; v--;\n        edge[u].push_back(v);\n    }\n\n    sort(b, b+n);\n    memset(deleted, 0, sizeof(deleted));\n    output.clear();\n\n    currTime = 1;\n    bool ok = true;\n    for (int i = 0; i &lt; n; ++i) {\n        ok &amp;= DFS(b[i].id);\n    }\n\n    if (output.size() == n) {\n        for (int i = 0; i &lt; output.size(); ++i) {\n            printf(\"%d \",output[i]+1);\n        }\n        printf(\"\\n\");\n    }\n    else {\n        printf(\"Pobedila je crna magija\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/","title":"A3 - Podzemne vode","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U srednjevekovnom selu Enjored, nalazi se n srenjovekovnih placeva pore\u0111anih u red, jedan do drugog, numerisanih srednjevekovnim brojevima od 1 do \\(n\\). Za svaki plac je poznata snaga uticaja srednjevekovnih podzemnih voda nad njim; za \\(i\\)-ti plac ta vrednost je \\(v_i\\). Jednog dana, skupilo se \\(k\\) srednjevekovnih vazalnih gospodara i odlu\u010dili su da izgrade \\(k\\) velikih ku\u0107a pri \u010demu bi svaka ku\u0107a zauzimala ta\u010dno \\(t\\) uzastopnih placeva i, naravno, nikoje dve ku\u0107e ne mogu imati zajedni\u010dki plac.</p> <p>U dogovoru sa selom, vazalni gospodari su se obavezali da, na ime srednjevekovnog poreza, ukupno plate po 1 zlatnik za svaki od \\(n\\) placeva koji nisu deo nijedne ku\u0107e. Ispostavilo se da su vrednosti \\(n\\), \\(k\\) i \\(t\\) takve da kada \\(k\\) vazalnih gospodara podjednako podele porez, svako od njih treba da plati ne vi\u0161e od 10 zlatnika.</p> <p>Naravno, najbitnija stvar u ovoj srednjevekovnoj pri\u010di je odbrana od srednjevekovnih ve\u0161tica. U to vreme, kada bi ljudi gradili ku\u0107e, oni bi postavljali anti-ve\u0161ti\u010dne ure\u0107aje u najlevljem placu svoje ku\u0107e i otpornost ku\u0107e na ve\u0161tice bi direktno zavisila od odgovaraju\u0107e podzemne vode. Npr. ukoliko se ku\u0107a nalazi na placevima \\(i, i+ 1, . . . i+t\u22121\\), otpornost te ku\u0107e je \\(v_i\\). Vazalnigospodari su razumni ljudi koji veruju u ve\u0161tice i dogovorili su se da sagrade ku\u0107e tako da je suma otpornosti ku\u0107a na ve\u0161tice najve\u0107a mogu\u0107a. Pomozite im u tome!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Slobodan Mitrovi\u0107 Nikola Milosavljevi\u0107 Pavle Martinovi\u0107 Slobodan Mitrovi\u0107"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se tri prirodna broja \\(n\\), \\(k\\) i \\(t\\) koji predstavljaju, redom, broj placeva, broj ku\u0107a koje treba izgraditi i du\u017einu svake ku\u0107e u placevima. U narednom redu nalaze se \\(n\\) prirodnih brojeva \\(v_i\\), gde \\(i\\)-ti broj predstavlja snagu uticaja podzemne vode na \\(i\\)-ti plac.</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati najve\u0107u mogu\u0107u vrednost sume otpornosti svih ku\u0107a. Garantuje se da \u0107e re\u0161enje (tj. bar jedan raspored ku\u0107a) uvek postojati.</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#ulaz","title":"Ulaz","text":"<pre><code>8 3 2\n4 5 1 4 8 10 7 3\n</code></pre>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#izlaz","title":"Izlaz","text":"<pre><code>20\n</code></pre>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Imamo 8 placeva i potrebno je izgraditi 3 ku\u0107e od kojih svaka zauzima po 2 uzastopna placa. Ukoliko ku\u0107e izgradimo na slede\u0107i na\u010din: 4 {5 1} 4 {8 10} {7 3} , tada je ukupna otpornost ku\u0107a jednaka \\(v_2\\) + \\(v_5\\) + \\(v_7\\) = 20. Mo\u017ee se pokazati da ne postoji raspored ku\u0107a koji daje otpornost ve\u0107u od 20.</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(n \u2264 800 000\\)</li> <li>\\(1 \u2264 t, k \u2264 3 000\\)</li> <li>\\(1 \u2264 v_i \u2264 10^9\\)</li> <li>Za brojeve \\(n\\), \\(k\\) i \\(t\\) va\u017ee sva dodatna ogran\u010denja iz teksta zadataka.</li> </ul>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje.","text":"<p>Test primeri su podeljeni u 4 podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja:</p> <ul> <li>Podzadatak 1 [12 poena]: \\(n \u2264 20, k, t \u2264 5\\)</li> <li>Podzadatak 2 [15 poena]: Posle izgradnje, osta\u0107e ta\u010dno jedan slobodan plac</li> <li>Podzadatak 3 [30 poena]: \\(n \u2264 30 000\\)</li> <li>Podzadatak 4 [43 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#napomena","title":"Napomena","text":"<p>Obratiti pa\u017enju da je za ispis re\u0161enja neophodan 64-bitni tip podataka.</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#nleq-20","title":"\u0420\u0435\u0448\u0435\u045a\u0435 \u043a\u0430\u0434\u0430 \\(N\\leq 20\\)","text":"<p>\u0423 \u043e\u0432\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0458\u0443 \u045b\u0435\u043c\u043e \u0434\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c\u043e \u0441\u0432\u0438\u0445 \\(2^N\\) \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0446\u0438\u0458\u0430 \u043a\u043e\u0458\u0435 \u043f\u043b\u0430\u0446\u0435\u0432\u0435 \u045b\u0435\u043c\u043e \u0438\u0437\u0430\u0431\u0440\u0430\u0442\u0438 \u043a\u0430\u043e \u043d\u0430\u0458\u043b\u0435\u0432\u0459\u0435. \u0417\u0430\u0442\u0438\u043c \u0443 \u043b\u0438\u043d\u0435\u0430\u0440\u043d\u043e\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0443 \u0441\u0435 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0434\u043d\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u0430\u0432\u0430 \u0434\u0430 \u043b\u0438 \u043f\u043e\u0441\u0442\u043e\u0458\u0435 \u0434\u0432\u0430 \u043a\u043e\u0458\u0430 \u0441\u0443 \u043d\u0430 \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438 \u043c\u0430\u045a\u043e\u0458 \u043e\u0434 \\(t\\) \u0438 \u0434\u0430 \u043b\u0438 \u0438\u0445 \u0458\u0435 \u0442\u0430\u0447\u043d\u043e \\(k\\). \u0421\u0442\u043e\u0433\u0430 \u043d\u0430\u043b\u0430\u0442\u0438\u043c\u043e \u0440\u0435\u0448\u0435\u045a\u0435 \u0443 \\(O(2^N)\\)</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#o","title":"\u0420\u0435\u0448\u0435\u045a\u0435 \u043a\u0430\u0434\u0430 o\u0441\u0442\u0430\u043d\u0435 \u0441\u0430\u043c\u043e \u0458\u0435\u0434\u0430\u043d \u043f\u043b\u0430\u0446","text":"<p>\u0410\u043a\u043e \u0444\u0438\u043a\u0441\u0438\u0440\u0430\u043c\u043e \\(x\\) \u043a\u043e\u0458\u0438 \u045b\u0435 \u043d\u0430\u043c \u0442\u043e \u043f\u043b\u0430\u0446 \u043e\u0441\u0442\u0430\u0442\u0438 \u043d\u0435\u043f\u043e\u043f\u0443\u045a\u0435\u043d, \u043b\u043e\u043a\u0430\u0446\u0438\u0458\u0435 \u0441\u0432\u0438\u0445 \u043a\u0443\u045b\u0430 \u045b\u0435 \u0431\u0438\u0442\u0438 \u0458\u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043e \u043e\u0434\u0440\u0435\u0452\u0435\u043d\u0435, \u0438 \u0442\u043e \u045b\u0435 \u0438\u043c \u0441\u0435 \u043d\u0430\u0458\u043b\u0435\u0432\u0459\u0438 \u043f\u043b\u0430\u0446\u0435\u0432\u0438 \u043d\u0430\u043b\u0430\u0437\u0438\u0442\u0438 \u043d\u0430 \u0441\u0432\u0430\u043a\u0438\u0445 \\(t\\) \u043b\u0435\u0432\u043e \u043e\u0434 \\(x-t\\), \u0438 \u043d\u0430 \u0441\u0432\u0430\u043a\u0438\u0445 \\(t\\) \u0434\u0435\u0441\u043d\u043e \u043e\u0434 \\(x+1\\).  \u041f\u0430\u043c\u045b\u0435\u045a\u0435\u043c \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u043d\u0438\u0445 \u0438 \u0441\u0443\u0444\u0438\u043a\u0441\u043d\u0438\u0445 \u0441\u0443\u043c\u0430 \u043d\u0430 \u0441\u0432\u0430\u043a\u0438\u0445 \\(t\\) (\u0440\u0435\u043a\u0443\u0440\u0435\u043d\u0442\u043d\u0430 \u0432\u0435\u0437\u0430 \\(pref[x]=a[x]+pref[x-t]\\)) \u043c\u043e\u0436\u0435\u043c\u043e \u0437\u0430 \u0441\u0432\u0430\u043a\u0438 \u043f\u043b\u0430\u0446 \u043a\u043e\u0458\u0438 \u0438\u0437\u0431\u0430\u0446\u0438\u043c\u043e \u043e\u0434\u043c\u0430\u0445 \u0434\u0430 \u0438\u0437\u0440\u0430\u0447\u0443\u043d\u0430\u043c\u043e \u0440\u0435\u0448\u0435\u045a\u0435, \u0443\u043a\u0443\u043f\u043d\u043e \u0443 \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#nleq-30000","title":"\u0420\u0435\u0448\u0435\u045a\u0435 \u043a\u0430\u0434\u0430 \\(N\\leq 30000\\)","text":"<p>\u0423 \u043e\u0432\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0458\u0443 \u0440\u0430\u0434\u0438\u043c\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u043a\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0438\u0440\u0430\u045a\u0435 \u0441\u0430 \u0441\u0442\u0430\u045a\u0435\u043c \\(dp[i][j]\\), \u043a\u043e\u0458\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u0459\u0430 \u0440\u0435\u0448\u0435\u045a\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u0430\u043a\u043e \u043f\u043e\u0441\u043c\u0430\u0442\u0440\u0430\u043c\u043e \u0441\u0430\u043c\u043e \u043f\u0440\u0432\u0438\u0445 \\(j\\) \u043f\u043b\u0430\u0446\u0435\u0432\u0430, \u0438 \u0434\u043e \u0441\u0430\u0434\u0430 \u0441\u043c\u043e \u0434\u043e\u0434\u0435\u043b\u0438\u043b\u0438 \u043a\u0443\u045b\u0435 \u043f\u0440\u0432\u0438\u0445 \\(i\\) \u0441\u0442\u0430\u043d\u043e\u0432\u043d\u0438\u043a\u0430. \u041e\u0432\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u043a\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0438\u0440\u0430\u045a\u0435 \u0438\u043c\u0430 \u0458\u0430\u043a\u043e \u0458\u0435\u0434\u043d\u043e\u0441\u0442\u0430\u0432\u043d\u0443 \u0440\u0435\u043a\u0443\u0440\u0435\u043d\u0442\u043d\u0443 \u0432\u0435\u0437\u0443: \u043f\u043e\u0441\u043b\u0435\u0434\u045a\u0438 \u043f\u043b\u0430\u0446 \u043c\u043e\u0436\u0435 \u0434\u0430 \u043d\u0435 \u0431\u0443\u0434\u0435 \u0434\u0435\u043e \u043a\u0443\u045b\u0435, \u0443 \u043a\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0458\u0443 \u0458\u0435 \u043e\u0434\u0433\u043e\u0432\u043e\u0440 \\(dp[i][j-1]\\), \u0438\u043b\u0438 \u0434\u0430 \u0431\u0443\u0434\u0435 \u0434\u0435\u043e \u043a\u0443\u045b\u0435 \u0443 \u043a\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0458\u0443 \u0458\u0435 \u043e\u0434\u0433\u043e\u0432\u043e\u0440 \\(dp[i-1][j-t]+a[i-t+1]\\). \u0421\u0442\u043e\u0433\u0430 \u043d\u0430\u043b\u0430\u0437\u0438\u043c\u043e \\(O(1)\\) \u0442\u0440\u0430\u043d\u0437\u0438\u0446\u0438\u0458\u0443 \u0437\u0430\u0434\u0430\u0442\u0443 \u0444\u043e\u0440\u043c\u0443\u043b\u043e\u043c \\(dp[i][j]=max(dp[i][j-1],dp[i-1][j-t]+a[i-t+1])\\), \u0430 \u043a\u0430\u043a\u043e \u043e\u043d\u043e \u0438\u043c\u0430 \\(O(n^2)\\) \u0441\u0442\u0430\u045a\u0430, \u043d\u0430\u043b\u0430\u0437\u0438\u043c\u043e \u0440\u0435\u0448\u0435\u045a\u0435 \u0443 \u0442\u043e\u0458 \u0441\u043b\u043e\u0436\u0435\u043d\u043e\u0441\u0442\u0438. \u041a\u0430\u043a\u043e \u043d\u0435\u043c\u0430 \u043c\u0435\u043c\u043e\u0440\u0438\u0458\u0435 \u0437\u0430\u043f\u0430\u043c\u0442\u0438\u0442\u0438 \u0441\u0432\u0430 \u0441\u0442\u0430\u045a\u0430, \u0430\u043b\u0438 \u0441\u0432\u0430\u043a\u043e \u0441\u0442\u0430\u045a\u0435 \u0437\u0430\u0432\u0438\u0441\u0438 \u0441\u0430\u043c\u043e \u043e\u0434 \u0442\u0440\u0435\u043d\u0443\u0442\u043d\u043e\u0433 \u0438 \u043f\u0440\u0435\u0442\u0445\u043e\u0434\u043d\u043e\u0433 \u0441\u043b\u043e\u0458\u0430 (\u0430\u043a\u043e \u043d\u0430\u043c \u0458\u0435 \"\u0441\u043b\u043e\u0458\" \u043a\u043e\u043b\u0438\u043a\u043e \u0438\u043c\u0430 \u0441\u0442\u0430\u043d\u043e\u0432\u043d\u0438\u043a\u0430 \u0434\u043e \u0441\u0430\u0434), \u043c\u043e\u0436\u0435\u043c\u043e \u043f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u0438 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0434\u043d\u0443 \u0444\u043e\u0440\u0443 \u043f\u0430\u043c\u045b\u0435\u045a\u0430 \u0441\u0430\u043c\u043e \u043f\u043e\u0441\u043b\u0435\u0434\u045a\u0430 \u0434\u0432\u0430 \u043d\u0438\u0432\u043e\u0430 \u0443 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u043a\u043e\u043c.</p>"},{"location":"takprog/2015_2016/drz/06_podzemne_vode/#_1","title":"\u0413\u043b\u0430\u0432\u043d\u043e \u0440\u0435\u0448\u0435\u045a\u0435","text":"<p>\u0413\u043b\u0430\u0432\u043d\u043e \u0440\u0435\u0448\u0435\u045a\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u0459\u0430 \u043c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0458\u0443 \u043f\u0440\u0435\u0442\u0445\u043e\u0434\u043d\u043e\u0433 \u043f\u0440\u0438\u0441\u0442\u0443\u043f\u0430 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u043a\u0438\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0438\u0440\u0430\u045a\u0435\u043c. \u041d\u0430\u0438\u043c\u0435 \u043f\u0440\u0438\u043c\u0435\u0442\u0438\u043c\u043e \u0434\u0430 \u043d\u0435\u043c\u0430 \u043c\u043d\u043e\u0433\u043e \u0441\u043c\u0438\u0441\u043b\u0430 \u0434\u0430 \\(i\\)-\u0442\u0438 \u0441\u0442\u0430\u043d\u043e\u0432\u043d\u0438\u043a \u0438\u043c\u0430 \u043a\u0443\u045b\u0443 \u043f\u0440\u0435 \u043f\u043e\u0437\u0438\u0446\u0438\u0458\u0435 \\((i-1)t\\) \u0438 \u043f\u043e\u0441\u043b\u0435 \\(n-t(k-i)+1\\), \u0458\u0435\u0440 \u0443 \u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0458\u0443 \u043d\u0435\u043c\u0430 \u043c\u0435\u0441\u0442\u0430 \u0434\u0430 \u0441\u0442\u0430\u043d\u0443 \u043a\u0443\u045b\u0435 \u043f\u0440\u0435, \u043e\u0434\u043d\u043e\u0441\u043d\u043e \u043f\u043e\u0441\u043b\u0435, \u045a\u0435\u0433\u043e\u0432\u0435 \u043a\u0443\u045b\u0435. \u0422\u0430\u043a\u043e \u0434\u0430 \u0458\u0435\u0434\u0438\u043d\u043e \u0438\u043c\u0430 \u0441\u043c\u0438\u0441\u043b\u0430 \u0440\u0430\u0447\u0443\u043d\u0430\u0442\u0438 \\(n-kt\\) \u043e\u0434 \u0441\u0432\u0438\u0445 \u043f\u043e\u0437\u0438\u0446\u0438\u0458\u0430 \u0437\u0430 \u043d\u0435\u043a\u0443 \u0444\u0438\u043a\u0441\u043d\u0443 \u0432\u0440\u0435\u0434\u043d\u043e\u0441\u0442 \u043e\u0434 \\(i\\) \u0443 \u043f\u0440\u0435\u0442\u0445\u043e\u0434\u043d\u043e\u043c \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u043a\u043e\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0438\u0440\u0430\u045a\u0443, \u043f\u0430 \u043d\u0430\u043c \u0431\u0440\u043e\u0458 \u0441\u0442\u0430\u045a\u0430 \u043f\u043e\u0441\u0442\u0430\u0458\u0435 \\(k(n-kt)\\). \u041d\u0430\u0458\u0437\u0430\u0434, \u043a\u0430\u043a\u043e \u0438\u043c\u0430 \u0442\u0430\u0447\u043d\u043e \\(n-kt\\) \u043d\u0435\u0437\u0430\u0443\u0437\u0435\u0442\u0438\u0445 \u043f\u043b\u0430\u0446\u0435\u0432\u0430, \u043d\u0430\u043b\u0430\u0437\u0438\u043c\u043e \u0434\u0430 \u0458\u0435 \u0443\u0441\u043b\u043e\u0432 \u0437\u0430 \u043f\u043e\u0440\u0435\u0437 \u0435\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u0430\u043d \u0441\u0430 \u0442\u0438\u043c\u0435 \u0434\u0430 \u0458\u0435 \\(\\frac{n-kt}{k}\\le10\\), \u043f\u0430 \u043d\u0430\u043c \u0434\u043e\u0437\u0432\u043e\u0459\u0430\u0432\u0430 \u0434\u0430 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0438\u043c\u043e \u0431\u0440\u043e\u0458 \u0441\u0442\u0430\u045a\u0430 \u0441\u0430 \\(10k^2\\), \u0438 \u043d\u0430\u043b\u0430\u0437\u0438\u043c\u043e \u0440\u0435\u0448\u0435\u045a\u0435 \u0443 \\(O(10k^2)\\).</p> 06_podzemne_vode.cpp<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include&lt;memory.h&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 800010;\nconst int MAX_K = 3010;\nconst int MAX_T = 3010;\n\nint n, k, t;\nint v[MAX_N];\nlong long d[2][MAX_N];\n\nlong long solve(int n, int k, int t, int v[])\n{\n    memset(d, 0, sizeof(d));\n    for (int i = 1; i &lt;= n; i++)\n    {\n        d[0][i] = max(d[0][i - 1], (long long)v[i]);\n    }\n\n    int currRow = 0;\n    for (int i = 2; i &lt;= k; i++)\n    {\n        currRow = 1 - currRow;\n        int L = 1 + (i - 1) * t;\n        int R = n - (k - i) * t;\n        d[currRow][L] = d[1 - currRow][L - t] + v[L];\n        for (int j = L + 1; j &lt;= R; j++)\n        {\n            d[currRow][j] = max(d[currRow][j - 1], d[1 - currRow][j - t] + v[j]);\n        }\n    }\n\n    return d[currRow][n];\n}\n\nint main()\n{\n\n    scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;t);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%d\", &amp;v[i]);\n    }\n    n = n - (t - 1);\n\n    printf(\"%lld\\n\", solve(n, k, t, v));\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/01_vatra/","title":"1 - Vatra","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Pre oko dvadeset hiljada godina, praistorijski ljudi su dosta vremena provodili u pe\u0107inama. Tokom no\u0107i, da ih \u017eivotinje ne bi napale, zapalili bi vatru. Jedno ve\u010de, pre spavanja, primetili su da im vatra ne\u0107e izdr\u017eati do ujutru, te su na\u0161li tri predmeta koja su hteli da ubace u vatru i time produ\u017ee vreme trajanja vatre. Me\u0111utim, ubacivanje nekih od tih predmeta bi moglo da dovede do skra\u0107ivanja vremena trajanja vatre, te nije isplativo ubaciti te predmete. Za svaki od tri predmeta vama je dato za koliko bi se promenilo vreme trajanja vatre (ovaj broj mo\u017ee da bude i negativan) ukoliko bi se taj predmet ubacio u vatru. Va\u0161 zadatak je da odredite maksimalno vreme za koje je mogu\u0107e produ\u017eiti trajanje vatre.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Boris Grubi\u0107 Milica Mi\u0107i\u0107 Lazar Milenkovi\u0107"},{"location":"takprog/2015_2016/kv1/01_vatra/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza se nalaze tri cela broja \\(x_1\\), \\(x_2\\) i \\(x_3\\), gde \\(x_i\\) predstavlja vreme za koje bi se promenilo trajanje vatre ukoliko bi se i-ti predmet ubacio u vatru.</p>"},{"location":"takprog/2015_2016/kv1/01_vatra/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi red standardnog izlaza ispisati jedan ceo broj koji predstavlja maksimalno vreme za koje je mogu\u0107e produ\u017eiti vreme trajanja vatre.</p>"},{"location":"takprog/2015_2016/kv1/01_vatra/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/01_vatra/#ulaz","title":"Ulaz","text":"<pre><code>5 -3 7\n</code></pre>"},{"location":"takprog/2015_2016/kv1/01_vatra/#izlaz","title":"Izlaz","text":"<pre><code>12\n</code></pre>"},{"location":"takprog/2015_2016/kv1/01_vatra/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/kv1/01_vatra/#ulaz_1","title":"Ulaz","text":"<pre><code>-4 -4 5\n</code></pre>"},{"location":"takprog/2015_2016/kv1/01_vatra/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2015_2016/kv1/01_vatra/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(-1000 \\leq x_1,x_2,x_3\\leq 1000\\).</li> <li>Bar jedan od brojeva u ulazu \u0107e uvek biti nenegativan.</li> </ul>"},{"location":"takprog/2015_2016/kv1/01_vatra/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena va\u017ei \\(x_1\\), \\(x_2\\), \\(x_3\\) \\(\\geq 0\\).</li> <li>U test primerima vrednim 70 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/kv1/01_vatra/#resenje-za-x_1-x_2-x_3-geq-0","title":"Re\u0161enje za \\(x_1, x_2, x_3 \\geq 0\\) :","text":"<p>Kada bi se bilo koji od predmeta ubacio u vatru du\u017eina njenog gorenja bi se pove\u0107ala. Vatra bi onda najdu\u017ee gorela ako bi se svaki od tih predmeta ubacio i zato je potrebno samo ispisati zbir sve tri date vrednosti.</p>"},{"location":"takprog/2015_2016/kv1/01_vatra/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>\u017delimo da odaberemo samo predmete koji imaju nenegativnu vrednost produ\u017eavanja trajanja vatre i njihove vrednosti sabiramo kao krajnje re\u0161enje. Ako bi se uzeo i neki od predmeta sa negativnim brojem kona\u010dno vreme gorenja bi se samo smanjilo.</p> 01_vatra.cpp<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int x1, x2, x3;\n    cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3;\n    cout &lt;&lt; max(0, x1) + max(0, x2) + max(0, x3) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/02_uooaah/","title":"2 - Uooaah","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Pre oko dvadeset hiljada godina, kada nisu bili u pe\u0107inama, praistorijski ljudi (pe\u0107inci) su voleli da provode vreme na sve\u017eem vazduhu i izvode fizi\u010dke eksperimente. Jedan od omiljenijih im je bio slede\u0107i: pe\u0107inci Pera, Mika i Laza bi se postavili na razli\u010ditim pozicijama na jednom pravcu (mo\u017eemo ih zamisliti kao ta\u010dke na realnoj pravoj) i svako od njih bi poneo svoj digitalni ru\u010dni pe\u0161\u010dani sat.</p> <p>U trenutku 0 svako od njih uzvikne \"Aaaa!!\"(standardni pozdrav pe\u0107inaca) - ovaj pozdrav se \u0161iri u svim smerovima brzinom od 1 m/s (gustina vazduha je tada bila druga\u010dija pa je brzina zvuka bila manja). U trenutku kada pe\u0107inac prvi put \u010duje pozdrav (od nekog od preostale dvojice) on se razdere standardnim pe\u0107inskim otpozdravom - \"Uooaah?!\"koji se \u0161iri na isti na\u010din i istom brzinom. Na kraju, u trenutku kada svaki pe\u0107inac prvi put \u010duje otpozdrav \"Uooaah?!\"on zapamti to vreme na svom digitalnom pe\u0161\u010danom satu i eksperiment je zavr\u0161en.</p> <p>Na kraju eksperimenta, Pera, Mika i Laza se vrate u pe\u0107inu i saop\u0161te svoja zabele\u017eena vremena pe\u0107inskom vra\u010du Kljovku koji koriste\u0107i ove podatke, \u0161estar, znanje fizike i osve\u0107ene kljove mamuta poku\u0161ava da impresionira pe\u0107inske ljude tako \u0161to odre\u0111uje po\u010detne polo\u017eaje na\u0161a tri pe\u0107inca (tj. tri pozicije na realnoj pravoj). Pomozite Kljovku da se ne obruka! Obratiti pa\u017enju da se ponead mo\u017ee desiti da re\u0161enje ne postoji (tj. da Perini, Mikini i/ili Lazini podaci nisu dobri zbog nepreciznosti praistorijskih digitalnih pe\u0161\u010danih satova). Dodatno, te tri pozicije moraju biti razli\u010diti realni brojevi koji po apsolutnoj vrednosti nisu ve\u0107i od 109 (Kljovko ne zna mnogo velike brojeve).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Nikola Milosavljevi\u0107 Aleksandar Vi\u0161nji\u0107 Andrej Iva\u0161kovi\u0107"},{"location":"takprog/2015_2016/kv1/02_uooaah/#opis-ulaza","title":"Opis ulaza","text":"<p>Svaki test primer \u0107e se sastojati od 3 razli\u010dita eksperimenta tj. standardni ulaz se sastoji od 3 reda i u svakom redu (koji predstavlja jedan eksperiment) se nalaze po tri realna broja \\(t_1, t_2\\) i \\(t_3\\), zadata se precizno\u0161\u0107u od jedne decimale, koji predstavljaju vremena kada su Pera, Mika i Laza, redom, \u010duli otpozdrav \"Uooaah?!\".</p>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od 3 eksperimenta treba uraditi slede\u0107e: ukoliko postoji re\u0161enje (tj. po\u010detne pozicije koje zadovoljavaju sve uslove) u jednom redu treba ispisati \"UGA\"(bez navodnika, zna\u010di \"DA\"na pe\u0107inskom) a u narednom redu tri realna broja \\(x_1\\), \\(x_2\\) i \\(x_3\\) sa precizno\u0161\u0107u na dve decimale koja, redom, predstavljaju po\u010detne pozicije Pere, Mike i Laze i koja zadovoljavaju pomenuta dodatna ograni\u010denja. Sa druge strane, ukoliko ne postoji re\u0161enje u jednom redu samo ispisati \"UHUH\"(bez navodnika, zna\u010di \"Na\u017ealost, eksperiment nije uspeo\"na pe\u0107inskom). Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/02_uooaah/#ulaz","title":"Ulaz","text":"<pre><code>7.0 8.0 7.0\n2.0 4.0 6.0\n1.5 1.5 1.5\n</code></pre>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#izlaz","title":"Izlaz","text":"<pre><code>UGA\n2.00 10.00 5.50\nUHUH\nUGA\n-0.75 0.00 0.75\n</code></pre>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvom eksperimentu jedno mogu\u0107e re\u0161enje je da se Pera nalazi na poziciji 2, Mika na poziciji 10 i Laza na poziciji 5.5. Tada Pera prvi put \u010duje pozdrav od Laze posle 3.5 sekun di i tada otpozdravlja; sli\u010dno, Mika otpozdravlja posle 4.5 sekundi (kada \u010duje pozdrav od Laze) a Laza otpozdravlja posle 3.5 sekundi kada \u010duje pozdrav od Pere. Pera prvi put \u010duje otpozdrav \"Uooaah?!\"od Laze i to posle 7 sekundi, Mika prvi put \u010duje otpozdrav posle 8 sekundi (od Laze) i Laza prvi put posle 7 sekundi od Pere. Za drugi eksperiment ne postoji re\u0161enje a lako se mo\u017ee proveriti da su pozicije u tre\u0107em eksperimentu zaista jedno od re\u0161enja.</p>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq t_1, t_2, t_3 \\leq 10^9\\).</li> <li>\\(-10^9 \\leq x_1, x_2, x_3 \\leq 10^9\\) i sve ove vrednosti moraju biti me\u0111usobno razli\u010dite (ukoliko re\u0161enje postoji, postoja\u0107e i ono koje zadovoljava ove dodatne uslove)</li> </ul>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima vrednim 40 poena va\u017ei: ukoliko re\u0161enje postoji, postoja\u0107e i re\u0161enje kod koga su tra\u017eene pozicije celi brojevi koje po apsolutnoj vrednosti nisu ve\u0107e od 100.</li> <li>U test primerima vrednim 60 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#napomena-2","title":"Napomena 2","text":"<p>Ukoliko takmi\u010dar za svaki eksperiment u test primeru ispravno odredi da li postoji ili ne postoji re\u0161enje ali same pozicije nisu dobre, dobija 30% poena za dati test primer. Obratiti pa\u017enju da je \u010dak i u tom slu\u010daju posle svakog ispisa \"UGA\"potrebno ispisati tri realna broja koja zadovoljavaju dodatna ograni\u010denja (npr. \"1.00 2.00 3.00\").</p>"},{"location":"takprog/2015_2016/kv1/02_uooaah/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Neka bez umanjenja op\u0161tosti va\u017ei \\(x_1\\leq x_2\\leq x_3\\) (mo\u017eemo pe\u0107ince permutovati tako). Posmatrajmo slu\u010daj kada va\u017ei \\(x_2-x_1 \\leq x_3-x_2\\) (drugi slu\u010daj se analogno re\u0161ava). Pe\u0107inci \\(1\\) i \\(2\\) \u010duju \"Aaaa!!\" u istom trenutku \\(x_2-x_1\\), a nakon toga \u010duju i \"Uooaah?!\" u istom trenutku \\(2(x_2-x_1)\\) (drugi pe\u0107inac \u0107e pre to \u010duti od onog koji je bli\u017ei njemu, a to je prvi pe\u0107inac). Tre\u0107i pe\u0107inac \u010duje \"Uooaah?!\" tek u vremenu \\(x_3-x_1\\). Za data (pravilno permutovana) vremena, pozicije se mogu konstruisati kao \\(x_1=0\\), \\(x_2=\\frac{t_1}{2}\\) i \\(x_3=t_3\\), pa se potom odgovaraju\u0107im permutovanjem dobija re\u0161enje zadatka. Primetimo da takve pozicije postoje ako i samo ako je \\(t_1=t_2\\leq t_3\\) (u nekom poretku).</p> <p>Dakle, re\u0161enje postoji samo kada su neka dva vremena jednaka, a tre\u0107e ne manje od ostala dva. Na osnovu tih vremena se potom izra\u010duna formula za poziciju svakog pe\u0107inca. Dovoljno je pokriti \\(4\\) slu\u010daja, s tim da je poslednji nemogu\u0107:</p> <ol> <li>\\(t_1=t_2\\leq t_3\\), formula je \\((0,\\frac{t_1}{2},t_3)\\)</li> <li>\\(t_2=t_3\\leq t_1\\), formula je \\((t_1,0,\\frac{t_2}{2})\\)</li> <li>\\(t_3=t_1\\leq t_2\\), formula je \\((\\frac{t_3}{2},t_2,0)\\)</li> <li>ostalo</li> </ol> 02_uooaah.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\ndouble t1, t2, t3;\n\nbool eq(double x, double y)\n{\n    return ((x - y &lt; 0.000001) &amp;&amp; (x - y &gt; -0.000001));\n}\n\nint main()\n{\n    for (int tests = 0; tests &lt; 3; tests++)\n    {\n        scanf(\"%lf%lf%lf\", &amp;t1, &amp;t2, &amp;t3);\n\n        if (eq(t1, t2) &amp;&amp; (eq(t2, t3) || t2 &lt; t3)) // t1 = t2 &lt;= t3\n        {\n            printf(\"UGA\\n\");\n            printf(\"%.2lf %.2lf %.2lf\\n\", 0.0, t1/2, t3);\n        }\n        else if (eq(t1, t3) &amp;&amp; (eq(t1, t2) || t1 &lt; t2)) // t1 = t3 &lt;= t2\n        {\n            printf(\"UGA\\n\");\n            printf(\"%.2lf %.2lf %.2lf\\n\", 0.0, t2, t3/2);\n        }\n        else if (eq(t2, t3) &amp;&amp; (eq(t3, t1) || t3 &lt; t1)) // t2 = t3 &lt;= t1\n        {\n            printf(\"UGA\\n\");\n            printf(\"%.2lf %.2lf %.2lf\\n\", t1, 0.0, t2/2);\n        }\n        else printf(\"UHUH\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/03_simboli/","title":"3 - Simboli","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 64MB <p>U praistorijskom dobu, iako nisu postojala jasno definisana pisma, jezici i ud\u017ebenici, ljudi su i dalje nalazili na\u010dina da pripi\u0161u prirodne pojave nekim simbolima\u2014tako stvaraju\u0107i prete\u010de dana\u0161njih jezika. </p> <p>Poznato je da su u jednoj staroj civilizaciji na prostorima gde je vladala Tajna Komisija ljudi komunicirali koriste\u0107i 26 simbola (koje \u0107emo, radi lak\u0161e postavke, zapisivati koriste\u0107i velika slova engleske abecede). Tako\u0111e je ustanovljeno da se ti simboli mogu podeliti u \u201csuprotne parove\u201d. Ponovo, radi pojednostavljenja, smatra\u0107emo da su slova koja su sa suprotnih strana engleske abecede me\u0111usobno suprotna. (\\(A\\) i \\(Z\\), \\(B\\) i \\(Y\\), \\(C\\) i \\(X\\), itd.)</p> <p>Hiljadama godina kasnije, naslednici stare Tajne Komisije su iskopali jedan niz od n simbola, zajedno sa opisom pravila igre koja se igrala u to doba. Prvi igra\u010d bira jedan simbol, nakon \u010dega drugi igra\u010d menja \\(k\\) uzastopnih simbola iz niza u njima suprotne simbole. Na kraju, prvi igra\u010d dobija poen za svako pojavljivanje simbola koji je odabrao u nizu, dok drugi igra\u010d dobija poen za svako pojavljivanje njemu suprotnog simbola.</p> <p>Mali Perica i njegov kolega mali Nikolaj odlu\u010dili su da odigraju jednu partiju ove igre. Pericu zanima koliku najve\u0107u prednost mo\u017ee ostvariti kao prvi igra\u010d, ukoliko Nikolaj bude igrao optimalno. Kao i ranije, zamolio vas je za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Dragan Uro\u0161evi\u0107 <p>Zadatak Simboli predstavlja problem srednje te\u017eine na ovogodi\u0161njim Kvalifikacijama. Na njemu je bilo relativno jednostavno osvojiti zna\u010dajnu koli\u010dinu bodova, dok je za pune bodove bilo potrebno primeniti vrstu ideje koja nije momentalno intuitivna, ali se \u010desto \"provla\u010di'' u takmi\u010darskim zadacima, i zato iskusniji takmi\u010dari uglavnom nisu imali problema sa ovim zadatkom. Autor je originalno smislio ovaj zadatak 2013. godine, inspirisan zadacima \"Menjanje stringa'' i \"Menjanje stringa v2'' koji su se pojavili na tada\u0161njim Kvalifikacijama, i predstavljaju sli\u010dne primere prednosti pametnih optimizacija nad direktnom simulacijom.</p> <p>Re\u0161enje koje se odmah name\u0107e, s obzirom na mali broj simbola (26), je da se prona\u0111e re\u0161enje za svaki mogu\u0107i Peri\u010din odabir simbola, uzimaju\u0107i maksimalno od tih re\u0161enja kao kona\u010dno re\u0161enje. Samim tim, na\u0161e re\u0161enje se onda svodi na re\u0161avanje potproblema u kome je unapred poznato koji simbol je odabrao Perica.</p> <p>Direktna simulacija procesa u tekstu zadatka (tj. direktno obrtanje svakog mogu\u0107eg stringa du\u017eine \\(k\\)) mo\u017ee doneti bilo koji broj bodova u intervalu od 20 do 60, u zavisnosti od nivoa \"optimizovanosti'' re\u0161enja; evo nekoliko takvih re\u0161enja: </p> <ul> <li>Re\u0161enje koje za svaki podstring du\u017eine \\(k\\) obr\u0107e sve simbole u njemu, a zatim broji pojavljivanja simola dodatnim prolazom kroz ceo niz; ovo re\u0161enje ima ukupnu slo\u017eenost \\(O(n^2 \\cdot k)\\).</li> <li>Modifikovano prethodno re\u0161enje u kome nemamo dodatni prolaz kroz ceo niz na kraju; iskori\u0161\u0107avamo \u010dinjenicu da, ukoliko prethodno zapamtimo koliko ima kog simbola u celom nizu, treba direktno a\u017eurirati ove sume samo nad intervalom koji trenutno obr\u0107emo da bismo prebrojali sva pojavljivanja simbola. Ovo re\u0161enje ima ukupnu slo\u017eenost \\(O(n\\cdot k)\\).</li> <li>Mo\u017eemo dodatno optimizovati prethodno re\u0161enje ukoliko iskoristimo \u010dinjenicu da \u0107e koli\u010dine svakog simbola uvek biti iste za isto obrtanje (tj. ranije smo 26 puta obrtali string na istom mestu---i svaki put dobijali iste koli\u010dine simbola). Ukoliko prvo odradimo obrtanje na nekoj poziciji pa tek onda izra\u010dunamo relevantne koli\u010dine za svaki simbol na toj poziciji, i dalje imamo algoritam slo\u017eenosti \\(O(n\\cdot k)\\), ali \u0107e ovaj algoritam sveukupno izvr\u0161iti znatno manje operacija obrtanja!</li> </ul> <p>Za preostalih 40 poena neophodno je isko\u010diti iz okvira direktne simulacije zadatka, i smisliti optimalnije re\u0161enje. Jedna od mogu\u0107ih ideja je da, ukoliko za svaki simbol pamtimo kumulativnu sumu njegovih pojavljivanja kroz ceo niz, tj. za svaki simbol \\(s\\) i poziciju \\(1 \\leq x \\leq n\\), pamtimo vrednost \\(K_x^s\\), tako da va\u017ei: \\(K_x^s = \\sum_{i=1}^x {\\mathbb{I}(S_i = s)}\\) gde je \\(S_i\\) \\(i\\)-ti simbol u po\u010detnom stringu, a \\(\\mathbb{I}(S_i = s)\\) je definisan kao . Za svaki simbol \\(s\\), ove vrednosti se mogu izra\u010dunati u jednom prolazu kroz niz; za svaki indeks, uzimamo prethodnu vrednost, i dodajemo 1 ukoliko je trenutni simbol jednak simbolu \\(s\\), tj. \\(K_{x+1}^s = K_{x}^s + \\mathbb{I}(S_{x+1} = s)\\).</p> <p>Kada imamo ove vrednosti, mogu\u0107e je efikasnije izra\u010dunati efekat jednog obrtanja bez da se zapravo direktno obrnu vrednosti stringa. Naime, ukupan broj pojavljivanja simbola \\(s\\) izme\u0111u pozicija \\(a\\) i \\(b\\) je:</p> \\[ \\sum_{i=a}^{b} {\\mathbb{I}(S_i = s)} = \\sum_{i=1}^{b} {\\mathbb{I}(S_i = s)} - \\sum_{i=1}^{a-1} {\\mathbb{I}(S_i = s)} = K_b^s - K_{a-1}^s \\] <p>Tako\u0111e, ukupan broj pojavljivanja simbola \\(s\\) je dat kao:</p> \\[ \\sum_{i=1}^{n} {\\mathbb{I}(S_i = s)} = K_n^s \\] <p>Ozna\u010dimo sada obrnuti simbol simbolu \\(s\\) sa \\(\\bar{s}\\). Prednost za obrtanje na \\(i\\)-toj poziciji se onda mo\u017ee izra\u010dunati kao:</p> \\[ (K_n^s - (K_{i+k-1}^s - K_{i-1}^s) + (K_{i+k-1}^{\\bar{s}} - K_{i-1}^{\\bar{s}})) - (K_n^{\\bar{s}} - (K_{i+k-1}^{\\bar{s}} - K_{i-1}^{\\bar{s}}) + (K_{i+k-1}^{s} - K_{i-1}^{s})) \\] \\[ = K_n^s - 2(K_{i+k-1}^s - K_{i-1}^s) + 2(K_{i+k-1}^{\\bar{s}} - K_{i-1}^{\\bar{s}}) - K_n^{\\bar{s}} \\] <p>Po\u0161to smo ve\u0107 izra\u010dunali sve ove vrednosti, za fiksirano obrtanje i Peri\u010din simbol mo\u017eemo odrediti re\u0161enje u konstantnom vremenu. Ovo nam sveukupno daje algoritam optimalne vremenske slo\u017eenosti \\(O(n)\\).</p> <p>Me\u0111utim, naivno \u010duvanje svih vrednosti \\(K_n^s\\) dovodi do probijanja memorijskog ograni\u010denja; ukoliko takmi\u010dari koriste stati\u010dki alocirane nizove, onda \u0107e mo\u0107i ovo odmah da vide i koriguju. Ukoliko korekcija bude kori\u0161\u0107enje manje \u0161irokog tipa (npr. short/integer umesto int/longint) ovo \u0107e dovesti do prekora\u010denja opsega na ve\u0107im primerima i do neta\u010dnog re\u0161enja; ovakva re\u0161enja onda donose oko 80 bodova.</p> <p>Za optimalno re\u0161enje, mo\u017eemo primetiti da, kada razmatramo jedan simbol \\(s\\), zanimaju nas samo vrednosti \\(K_{\\cdot}^s\\) i \\(K_{\\cdot}^{\\bar{s}}\\), tj. samo dva simbola. Ukoliko u svakom momentu \u010duvamo ove vrednosti samo za ove simbole, smanjujemo dodatnu memorijsku slo\u017eenost algoritma sa \\(O(26n)\\) na \\(O(2n)\\), \u0161to je dovoljno za osvajanje 100 poena.</p> <p>Napomenimo na kraju da je mogu\u0107e dodatno modifikovati optimalno re\u0161enje, tako da je neophodno samo konstantno mnogo (tj. \\(O(1)\\)) dodatne memorije. Da li mo\u017eete smisliti ovo re\u0161enje?</p> 03_simboli.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Simboli\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n\n#define MAX_N 1000001\n\nusing namespace std;\n\nint n, k;\nchar sym[MAX_N];\n\nint s[2][MAX_N];\n\nint sol = -MAX_N;\n\nint total(int left)\n{\n    int right = left + k - 1;\n\n    int cnt1 = s[0][n - 1] - (s[0][right] - (left &gt; 0 ? s[0][left - 1] : 0)) + (s[1][right] - (left &gt; 0 ? s[1][left - 1] : 0));\n    int cnt2 = s[1][n - 1] - (s[1][right] - (left &gt; 0 ? s[1][left - 1] : 0)) + (s[0][right] - (left &gt; 0 ? s[0][left - 1] : 0));\n\n    return cnt1 - cnt2;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    scanf(\"%s\", sym);\n\n\n    for (int ch=0;ch&lt;26;ch++)\n    {\n        int opp = 25 - ch;\n\n        if (sym[0] - 'A' == ch) s[0][0] = 1;\n        else s[0][0] = 0;\n\n        if (sym[0] - 'A' == opp) s[1][0] = 1;\n        else s[1][0] = 0;\n\n        for (int i=1;i&lt;n;i++)\n        {\n            s[0][i] = s[0][i - 1];\n            s[1][i] = s[1][i - 1];\n            if (sym[i] - 'A' == ch) s[0][i]++;\n            if (sym[i] - 'A' == opp) s[1][i]++;\n        }\n        if (k == 0)\n        {\n            sol = max(sol, s[0][n - 1] - s[1][n - 1]);\n        }\n        else\n        {\n            int curr_sol = MAX_N;\n            for (int l=0;l&lt;n-k+1;l++)\n            {\n                curr_sol = min(curr_sol, total(l));\n            }\n            sol = max(sol, curr_sol);\n        }\n    }\n\n    printf(\"%d\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/03_simboli/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja, \\(n\\) i \\(k\\), koji predstavljaju du\u017einu niza simbola i broj uzastopnih simbola koje Nikolaj treba pretvoriti u suprotne, redom.</p> <p>U drugom redu nalazi se niz od \\(n\\) velikih slova engleske abecede, koji predstavlja po\u010detno stanje niza simbola.</p>"},{"location":"takprog/2015_2016/kv1/03_simboli/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati jedan ceo broj koji ozna\u010dava maksimalnu prednost koju Perica mo\u017ee ostvariti.</p>"},{"location":"takprog/2015_2016/kv1/03_simboli/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/03_simboli/#ulaz","title":"Ulaz","text":"<pre><code>7 2\nAAABBAA\n</code></pre>"},{"location":"takprog/2015_2016/kv1/03_simboli/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2015_2016/kv1/03_simboli/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Perica \u0107e ste\u0107i najve\u0107u prednost ukoliko na po\u010detku odabere simbol \\(A\\). Nikolaj tada mo\u017ee da promeni dva uzastopna simbola \\(A\\) u simbole \\(Z\\), \u010dime u nizu na kraju postoje tri simbola \\(A\\) i dva simbola \\(Z\\), \u0161to predstavlja prednost od jednog poena za Pericu.</p>"},{"location":"takprog/2015_2016/kv1/03_simboli/#ogranicenja","title":"Ograni\u010denja.","text":"<ul> <li>\\(1 \u2264 n \u2264 10^6\\).</li> <li>\\(0 \u2264 k \u2264 n\\).</li> </ul>"},{"location":"takprog/2015_2016/kv1/03_simboli/#napomena","title":"Napomena.","text":"<p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(n \u2264 50\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(n \u2264 1000\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(n \u2264 10^4\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(n \u2264 10^5\\).</li> <li>U test primerima vrednim 20 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/kv1/04_zadaci/","title":"4 - Zadaci","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 32MB <p>Poznato je da je jedno od prvih ve\u0107ih takmi\u010denja koje je organizovano na prostoru Balkanskog poluostrva bila jedna informati\u010dka olimpijada pre oko dvadeset hiljada godina (kada su jedini dozvoljeni programski jezici bili Fortran i COBOL). Ono \u0161to je manje poznato jeste \u010dinjenica da je tada sama organizacija takmi\u010denja bila druga\u010dija. Arheolozi su otkrili da je Tajna Komisija imala predlo\u017eenih N zadataka i procenila te\u017einu svakog od njih nekim nenegativnim celim brojem ne ve\u0107im od \\(10^9\\) (ve\u0107i brojevi su odgovarali te\u017eim zadacima). Tajna Komisija je nakon procesa predlaganja zadataka odr\u017eala sastanak na kom se raspravljalo o organizaciji takmi\u010denja i bio je napravljen odabir zadataka koji su se posle pojavili na olimpijadi, pri \u010demu su se zadaci na takmi\u010denju rasporedili u onom redosledu u kom su bili na spisku predloga. Me\u0111utim, nije poznato koji zadaci su bili odabrani, kao ni koliko je bilo zadataka (jasno, bio je odabran bar jedan zadatak). \\(Q\\) arheologa, u saradnji sa sada\u0161njom Tajnom Komisijom, zapo\u010delo je istra\u017eivanje koje bi otkrilo ne\u0161to vi\u0161e o prirodi prve informati\u010dke olimpijade. Nijedan arheolog nije uspeo da otkrije broj zadataka, ali su svi postavili teorije o tome koja je bila procenjena te\u017eina najte\u017eeg zadatka. Pre nego \u0161to se napravi plan daljeg istra\u017eivanja, neophodno je svim arheolozima odgovoriti koliko postoji potencijalnih lista zadataka na olimpijadi (uzimaju\u0107i u obzir teoriju o te\u017eini najte\u017eeg zadatka). Pomozite Tajnoj Komisiji i arheolozima da odgovore na ovo pitanje od istorijskog zna\u010daja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Andrej Iva\u0161kovi\u0107 Marko Ili\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2015_2016/kv1/04_zadaci/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi prirodan broj \\(N\\), koji predstavlja ukupan broj zadataka sa spiska predlo\u017eenih zadataka. U drugom redu se nalazi \\(N\\) nenegativnih celih brojeva, gde \\(k\\)-ti broj predstavlja procenjenu te\u017einu \\(k\\)-tog zadatka. U tre\u0107em redu se nalazi prirodan broj \\(Q,\\) broj arheologa. U narednih \\(Q\\) redova standardnog ulaza se nalazi po jedan nenegativan ceo broj \\(x\\) koji predstavlja teoriju odgovaraju\u0107eg arheologa, odnosno upit \"Koliko je takmi\u010denja moglo da se organizuje ako je te\u017eina najte\u017eeg zadatka bila ta\u010dno \\(x\\)?\"</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(Q\\) redova standardnog izlaza ispisati po jedan ceo broj, gde se u \\(k\\)-tom redu nalazi odgovor na upit \\(k\\)-tog arheologa. Re\u0161enja ispisivati po modulu \\(10^9 + 7\\).</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/04_zadaci/#ulaz","title":"Ulaz","text":"<pre><code>5\n8 1 3 9 3\n2\n8\n3\n</code></pre>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#izlaz","title":"Izlaz","text":"<pre><code>8\n6\n</code></pre>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U slu\u010daju teorije da je najte\u017ei zadatak imao te\u017einu 8, znamo da je prvi zadatak sa spiska predlo\u017eenih bio na takmi\u010denju. Mogu\u0107a takmi\u010denja su: samo prvi zadatak; prvi i drugi zadatak; prvi i tre\u0107i; prvi i peti; prvi, drgi i tre\u0107i; prvi, drugi i peti; prvi, tre\u0107i i peti; prvi, drugi, tre\u0107i i peti. U slu\u010daju druge teorije, postojalo je \u0161est mogu\u0107ih takmi\u010denja: drugi i tre\u0107i zadatak; drugi i peti zadatak; drugi, tre\u0107i i peti; tre\u0107i i peti; samo tre\u0107i; samo peti.</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#ogranicenja","title":"Ograni\u010denja.","text":"<ul> <li>\\(1 \u2264 N \u2264 10^5\\).</li> <li>\\(1 \u2264 Q \u2264 10^5\\).</li> <li>Te\u017eine zadataka su nenegativni celi brojevi koji nisu ve\u0107i od \\(10^9\\).</li> <li>Svi arheolozi su predlo\u017eili te\u017eine koji su nenegativni celi brojevi koji nisu ve\u0107i od \\(10^9\\).</li> </ul>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#napomena","title":"Napomena.","text":"<p>Re\u0161enje ovog zadatka \u0107e biti testirano na test primerima koji mogu da se podele u nekoliko skupova koji nisu disjunktni (odnosno, postoje preklapanja):</p> <ul> <li>U test primerima ukupno vrednim 20 poena \u0107e biti zadovoljena ograni\u010denja \\(N \\leq 15, Q \\leq 1000\\).</li> <li>U test primerima ukupno vrednim 45 poena je poznato da \u0107e te\u017eine zadataka bili nenegativni celi brojevi koji nisu ve\u0107i od \\(10^6\\).</li> <li>U test primerima ukupno vrednim 50 poena \u0107e va\u017eiti ograni\u010denja \\(N \\leq 5000, Q \\leq 5000\\).</li> <li>U test primerima koji ukupno vrede 30 poena ne postoje dodatna ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#resenje-i-analiza","title":"Re\u0161enje i analiza","text":"<p>Ovom problemu je mogu\u0107e pristupiti na dosta na\u010dina, koji se poprili\u010dno razlikuju po efikasnosti (samim tim i broju poena predvi\u0111enom za taj pristup). Ono \u0161to je uvek koristan prvi korak jeste sastavljanje apstraktne postavke problema. U ovom slu\u010daju, ova postavka bi bila: za dati niz \\(A\\) od \\(N\\) nenegativnih celih brojeva, odgovoriti na \\(Q\\) upita predstavljenih jednim nenegativnim prirodnim brojem \\(x\\) sa zna\u010denjem \"koliko postoji podnizova (ne nu\u017eno uzastopnih elemenata) niza \\(A\\) \u010diji je maksimum \\(k\\)?\"</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#pretraga-svih-mogucnosti","title":"Pretraga svih mogu\u0107nosti","text":"<p>Najjednostavnije re\u0161enje (ovde \"najjednostavnije\" zna\u010di \"najlak\u0161e je smisliti ga\") je primena grube sile. Ovo zna\u010di da se razmatraju svi podnizovi \\(A\\) i za svaki podniz se odredi da li je maksimum zaista jednak \\(k\\). Broj re\u0161enja predstavlja vrednost jednog broja\u010da koji je na po\u010detku postavljen na 0 i koji se inkrementira svaki put kada se na\u0111e podniz sa datim svojstvom. Na\u010dina za generisanje svih mogu\u0107ih podnizova \\(A\\) ima nekoliko, ali su takmi\u010dari najverovatnije najbolje upoznati sa rekurzivnim bektrekingom. U ovom konkretnom slu\u010daju, pi\u0161e se rekurzivna procedura \u010dije je osnovno zna\u010denje \"razmatranje\" nekog \u010dlana niza, nakon \u010dega se rekurzivno poziva \"razmatranje\" za slede\u0107i \u010dlan niza dva puta: prvi put, kada aktuelni element nije u podnizu; drugi put, kada aktuelni element jeste u podnizu. Kada vi\u0161e ne postoje \u010dlanovi niza za razmatranje, dolazi trenutak \"ispitivanja maksimuma\". Ovakvo re\u0161enje nije komplikovano: \u0161tavi\u0161e, o\u010dekuje se da su svi takmi\u010dari koji su ranije videli bektreking re\u0161enja zadataka u mogu\u0107nosti da ovo uspe\u0161no implementiraju. Me\u0111utim, ono je veoma neefikasno: vremenska slo\u017eenost ovog re\u0161enja je \u010dak \\(O(2^N)\\) za jedan upit (odnosno, ukupno \\(O(Q2^N)\\), \u0161to se mo\u017ee zaklju\u010diti iz \u010dinjenice da postoji  \\(2^N\\) podnizova nekog niza du\u017eine \\(N\\) (standardan rezultat kombinatorike). Postoje neke varijante ovog re\u0161enja koje u op\u0161tem slu\u010daju neznatno pobolj\u0161avaju slo\u017eenost, ali se ne o\u010dekuje da \u0107e takmi\u010darima doneti mnogo vi\u0161e od 20 poena, koliko je predvi\u0111eno za ovakav pristup.</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#primena-kombinatorike","title":"Primena kombinatorike","text":"<p>U prethodnom re\u0161enju je u pomenuto da jedan niz od \\(N\\) elemenata ima \\(2^N\\) podnizova. Ispostavlja se da ova \u010dinjenica itekako poma\u017ee pri daljem razvoju re\u0161enja. Pridr\u017eavamo se istih oznaka kao i pre, tako da razmatramo situaciju kada upit ima argument \\(k\\). Podnizovi koji \u0107e se ra\u010dunati u re\u0161enju sigurno ne\u0107e sadr\u017eati elemente niza \\(A\\) koji su ve\u0107i od \\(k\\), ali svi ostali elementi \u0107e sigurno biti u nekom podnizu. Ako \\(A\\) sadr\u017ei \\(p\\) elemenata koji su jednaki \\(k\\) i \\(q\\) elemenata koji su manji od \\(k\\) (gde \\(p, q &gt; 0\\)), tada se u nekom od odabranih podnizova javlja bar jedan od elemenata jednakih k i mo\u017eda neki od elemenata manjih od \\(k\\). Broj podnizova formiranih od pomenutih q elemenata je zato \\(2^q\\) , dok je broj nepraznih podnizova formiranih od p elemenata jednak \\((2^p \u2212 1)\\) (neophodno je \"odbiti\" prazan podniz). Stoga je odgovor na jedan upit jednak \\((2^{p} \u2212 1) \u00b7 2^q\\).</p> <p>Ukoliko takmi\u010dari ispravno implementiraju ovo re\u0161enje (uz posebnu pa\u017enju na ispisivanje rezultata \"po modulu\"), \u010dija je vremenska slo\u017eenost \\(O (QN)\\), predvi\u0111en broj poena je 50. Me\u0111utim, ono se u osnovi ne razlikuje mnogo od re\u0161enja koje donosi 100 poena, kao \u0161to \u0107emo kasnije videti.</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#vrednosti-preprocesiranje-stepena-dvojke","title":"Vrednosti, preprocesiranje stepena dvojke","text":"<p>U jednom od \"podzadataka\" postoji ograni\u010denje za vrednosti elemenata u \\(A\\): nijedan element nije ve\u0107i od \\(10^6\\). Ovo omogu\u0107ava primenu ideje sli\u010dne ovoj u prethodno navedenom \"podzadatku\", ali zahteva i jedan \"trik\" ukoliko \u017eelimo da postignemo dobru slo\u017eenost. Primetimo da odre\u0111ivanje koliko postoji elemenata niza A koji su jednaki x zahteva \\(O (N)\\) operacija u svakom upitu. Osnovna ideja je da se na svaki upit odgovori u konstantnom vremenu tako \u0161to \u0107e se najpre vr\u0161iti preprocesiranje, odnosno bi\u0107e pripremljeni delovi kona\u010dnog odgovora odmah po u\u010ditavanju niza. Ovo zahteva da formiramo dva pomo\u0107na niza, C i D, \u010dije su du\u017eine 106 (uz pa\u017enju oko granica), pri \u010demu im je zna\u010denje slede\u0107e:</p> <ul> <li>\\(C [i]\\): broj pojavljivanja vrednosti \\(i\\) u nizu \\(A\\);</li> <li>\\(D [i]\\): broj elemenata u nizu \\(A\\) koji su manji od \\(i\\).</li> </ul> <p>Ovi nizovi mogu jednostavno da se izra\u010dunaju na po\u010detku programa. Zato je odgovor na upit \\(k\\) jednak \\((2^{C[k]} \u2212 1)2^{D[k]}\\).</p> <p>Me\u0111utim, neophodan nam je jo\u0161 jedan \"trik\" da bismo dobili efikasno re\u0161enje: preprocesiranje svih stepena dvojke. Ta\u010dnije, na po\u010detku mo\u017eemo da napravimo niz \\(S\\) takav da je \\(S [i] = 2i\\) (uz pa\u017enju oko modula). Time smo uspeli da smanjimo broj operacija na \\(O (N + Q)\\) ukupno. Za ovo re\u0161enje je predvi\u0111eno 45 poena. Uz malo pa\u017enje oko rada sa slu\u010dajevima, ukoliko se ovo re\u0161enje ukombinuje sa prethodnim, mogu\u0107e je ostvarili 70 poena na zadatku.</p>"},{"location":"takprog/2015_2016/kv1/04_zadaci/#konacno-resenje","title":"Kona\u010dno re\u0161enje","text":"<p>Sada predstavljamo re\u0161enje u slo\u017eenosti \\(O ((N + Q) log N)\\), za koje su predvi\u0111eni svi poeni. Mogu\u0107e je dobiti 100 poena na ovom zadatku primenom nekog re\u0161enja koje ovde nije opisano, ali iste/sli\u010dne slo\u017eenosti. Koristan dodatni zadatak za takmi\u010dare je da otkriju \u0161to je mogu\u0107e vi\u0161e ovakvih algoritama, budu\u0107i da neke od tih ideja mogu da poslu\u017ee u daleko te\u017eim i komplikovanijim zadacima!</p> <p>Za potrebe ovog re\u0161enja \u0107emo koristiti neke ideje iz re\u0161enja prethodnih \"podzadataka\": postojanje niza \\(S\\) koji sadr\u017ei stepene dvojke, formulu za broj podnizova. Me\u0111utim, za dolazak do re\u0161enja je neophodno uo\u010diti jedno klju\u010dno svojstvo: redosled elemenata koji nam je zadat u \\(A\\) nije bitan. Ovo ne\u0107e biti formalno dokazano, ali bi neki \"intuitivni\" argument bio taj da se zadaci razli\u010dite te\u017eine i dalje razlikuju po tome na kom su mestu u \\(A\\), tako da su svi redosledi ekvivalentni. Po\u0161to je redosled nebitan, mo\u017eemo da sortiramo niz \\(A\\) u rastu\u0107em (u drugoj terminologiji: neopadaju\u0107em) poretku. Ovo je korisno jer su tada svi zadaci koji su iste te\u017eine uzastopni, a ovo nam omogu\u0107ava da iskoristimo algoritam binarne pretrage. Algoritam binarne pretrage mo\u017ee da se napi\u0161e u nekoliko varijanti. U uobi\u010dajenom obliku, rezultat binarne pretrage je samo \\(true\\) ili \\(false\\) i ovaj povratni rezultat ima zna\u010denje \"ova vrednost se nalazi u ovom sortiranom nizu\". Me\u0111utim, mo\u017eemo da insistiramo na tome da nas binarna pretraga na neki na\u010din informi\u0161e o polo\u017eaju elementa ukoliko on postoji u nizu. Postavlja se pitanje: \u0161ta se radi ukoliko se elementi niza ponavljaju? U tom slu\u010daju, mo\u017eemo da posmatramo dve korisne funkcije:</p> <ul> <li>\\(binpretl (v)\\): odre\u0111uje indeks prvog elementa u nizu \\(A\\) koji nije ve\u0107i od \\(v\\);</li> <li>\\(binpretd (v)\\): odre\u0111uje indeks poslednjeg elementa u nizu \\(A\\) koji nije manji od \\(v\\).</li> </ul> <p>Ove dve varijante binarne pretrage imaju sli\u010dne implementacije, neophodno je adekvatno izmeniti korak u kom se \"pomeraju granice\".</p> <p>Na osnovu ovoga mo\u017eemo da zaklju\u010dimo da je broj pojavljivanja \\(k\\) u sortiranom nizu \\(A\\) jednak \\(binpretd (k) \u2212 binpretl(k) + 1\\), a da je \\(binpretl(k)\\) broj elemenata koji su stogo manji od \\(k\\) (pod pretpostavkom da je niz indeksiran od 0, \\(binpretl(k)\u22121\\) ukoliko je indeksiran od 1). Nakon ovoga mo\u017eemo da primenimo formulu koja je ranije bila navedena da bismo do\u0161li do rezultata.</p> <p>Slo\u017eenost ovog pristupa zavisi od slo\u017eenosti algoritma sortiranja. Postoje algoritmi sortiranja koji zahtevaju \\(O (N log N)\\) operacija, poput Quick sort, Merge sort (uz pa\u017enju da je izbor pivota u Quick sort kriti\u010dan i da mo\u017ee da dovede do kvadratne slo\u017eenosti u lo\u0161im slu\u010dajevima). Slo\u017eenost binarne pretrage je \\(O (log N)\\), te je ukupna vremenska slo\u017eenost \\(O ((N + Q) log N)\\), uz svega \\(O (N)\\) pomo\u0107nog prostora.</p> 04_zadaci.cpp<pre><code>/*\n    ZADATAK:       zadaci (Kvalifikacije, 4)\n    AUTOR ZADATKA: Andrej Ivaskovic\n    AUTOR KODA:    Andrej Ivaskovic\n\n    Za ovo resenje je predvidjeno 100 poena. Zasniva se na kombinatornoj logici\n    i binarnoj pretrazi. Konkretno, svi podnizovi ciji je maksimum neko k imaju\n    odredjen nenulti broj pojavljivanja k i sastoje se od nekog broja\n    (potencijalno nula) elemenata polaznog niza koji su manji od k. Broj nacina\n    na koji ovo moze da se postigne je (2^p - 1) * 2^q, gde je p broj\n    pojavljivanja vrednosti p u A, a q broj elemenata niza A koji su manji od\n    k.\n\n    Stepeni dvojke mogu da se preprocesiraju, a odredjivanje p i q se odredjuje\n    pri svakom upitu na efikasan nacin. Ako se A najpre sortira u (ne strogo)\n    rastucem poretku, tada je moguce odrediti prvo i poslednje pojavljivanje k\n    u sortiranom nizu A binarnom pretragom (uz dve njene standardne varijante),\n    na osnovu cega mogu da se odrede vrednosti p i q.\n\n    Slozenost ovog pristupa je O((Q + N) log N).\n*/\n\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n#define MAX_DUZ 200005\n#define MOD 1000000007\n\nint N, Q;\nint A[MAX_DUZ];\nint k;\nlong long broj_res;\nlong long stepen[MAX_DUZ];\nint p, q;\nint prvo_poj, posl_poj;\n\n// Preprocesiranje stepena dvojke\nvoid generisi_stepene(void)\n{\n    stepen[0] = 1L;\n    for (int i = 1; i &lt;= N; i++) {\n        stepen[i] = (stepen[i - 1] * 2) % MOD;\n    }\n}\n\n// Odredjuje indeks prvog pojavljivanja elementa koji je &gt;= v u A\nint bin_pret_l(int v)\n{\n    int l = 0, d = N - 1, s;\n    while (l &lt; d) {\n        s = (l + d) / 2;\n        if (v == A[s]) {\n            d = s;\n        } else if (v &gt; A[s]) {\n            l = s + 1;\n        } else if (v &lt; A[s]) {\n            d = s - 1;\n        }\n    }\n    return l;\n}\n\n// Odredjuje indeks poslednjeg pojavljivanja elementa koji je &lt;= v u A\nint bin_pret_d(int v)\n{\n    int l = 0, d = N - 1, s;\n    while (l &lt; d) {\n        s = (l + d + 1) / 2;\n        if (v == A[s]) {\n            l = s;\n        } else if (v &gt; A[s]) {\n            l = s + 1;\n        } else if (v &lt; A[s]) {\n            d = s - 1;\n        }\n    }\n    return l;\n}\n\nint main(void)\n{\n    // Ulaz\n    scanf(\"%d\", &amp;N);\n    generisi_stepene();              // neophodno zbog efikasnosti\n    for (int i = 0; i &lt; N; i++) {\n        scanf(\"%d\", &amp;A[i]);\n    }\n    sort(A, A + N);                 // omogucava binarnu pretragu\n    // Upiti\n    scanf(\"%d\", &amp;Q);\n    for (int i = 0; i &lt; Q; i++) {\n        scanf(\"%d\", &amp;k);\n        // Prvo i poslednje pojavljivanje k u nizu\n        prvo_poj = bin_pret_l(k);\n        posl_poj = bin_pret_d(k);\n        if (A[prvo_poj] == k) {          // postoji neko pojavljivanje k\n            p = posl_poj - prvo_poj + 1;\n            q = prvo_poj;\n            broj_res = ((stepen[p] - 1) * stepen[q]) % MOD;\n        } else {                        // ne postoji pojavljivanje k\n            broj_res = 0L;\n        }\n        printf(\"%lld\\n\", broj_res);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/05_ograde/","title":"5 - Ograde","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Pre oko dvadeset hiljada godina, praistorijski ljudi (pe\u0107inci) su usavr\u0161ili ve\u0161tinu izrade drvenih ograda kako bi zadr\u017eali dobre stvari blizu sebe i lo\u0161e stvari daleko od sebe. Pe\u0107inac Dimitrije je stru\u010dnjak u izradi konveksnih ograda (pe\u0107incima nikada nije bilo jasno \u0161ta ovo zna\u010di) i svima je poznato da on pravi najbolje ograde u plemenu. Najve\u0107i neprijatelj pe\u0107ina\u010dkih ograda su d\u017einovski praistorijski crvi. D\u017einovski praistorijski crvi imaju naviku da s vremena na vreme iza\u0111u na povr\u0161inu zemlje i krenu ka severu ili ka jugu ru\u0161e\u0107i sve pred sobom pre nego \u0161to se vrate pod zemlju. Dimitrije je upravo dobio poruku od Pe\u0107inca Nju\u0161kala da su prethodne no\u0107i d\u017einovski praistorijski crvi opet izronili na povr\u0161inu i potencijalno uni\u0161tili jednu od Dimitrijevih ograda. Zajedno sa ovom porukom dobio je i sve putanje d\u017einovskih praistorijskih crva prethodne no\u0107i. Dimitrija sada interesuje koliko stabala sekvoje on mora da pose\u010de u stra\u0161noj \u0161umi, ako se zna da je za svaki uni\u0161teni segment ograde potrebno po jedno stablo sekvoje. On vas moli da mu vi ka\u017eete minimalan broj ovih stabala kako bi on proveo \u0161to manje vremena u stra\u0161noj \u0161umi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Demjan Grubi\u0107 Lazar Milenkovi\u0107 Aleksandar Vi\u0161nji\u0107 Demjan Grubi\u0107"},{"location":"takprog/2015_2016/kv1/05_ograde/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei prirodan broj \\(N\\) - broj segmenata od kojih je Dimitrijeva ograda izgra\u0111ena. Narednih \\(N\\) linija sadr\u017ee po 2 cela broja \\(x_i\\) i \\(y_i\\) koji ozna\u010davaju krajeve svih segmenata ograde (dati su redom u smeru kazaljke na satu i uvek formiraju konveksni mnogougao), tj \\(i\\)-ti segment po\u010dinje na poziciji \\((x_i,y_i)\\) i zavr\u0161ava se na poziciji (xi+1,yi+1) pri \u010demu \\(N\\)-ti segment po\u010dinje na poziciji \\((x_N ,y_N)\\) i zavr\u0161ava se na poziciji \\((x_1,y_1)\\). Naredna linija sadr\u017ei broj \\(M\\) - broj putanja d\u017einovskih praistorijskih crva. Narednih \\(M\\) linija sadr\u017ee po 3 cela broja \\(a_i , p_i\\) i \\(k_i\\) koji opisuju kretanje jednog od d\u017einovskih praistorijskih crva tj. da se crv kretao izme\u0111u ta\u010daka \\((a_i,p_i)\\) i \\((a_i,k_i)\\). Segment ograde se smatra uni\u0161tenim ako se u bar jednoj ta\u010dki se\u010de sa putanjamad\u017einovskih praistorijskih crva, dakle ako crvi pro\u0111u kroz zajedni\u010dku ta\u010dku dva segmenta, oba segmenta se smatraju uni\u0161tenima. Tako\u0111e, ako crvi iza\u0111u na povr\u0161inu ta\u010dno na mestu gde je ograda, ili se vrate nazad u zemlju u ta\u010dki koja pripada segmentu ograde, taj segment se tako\u0111e smatra sru\u0161enim. Krajevi segmenata ograde zadovoljavaju uslov da nikoja tri nisu kolinearna.</p>"},{"location":"takprog/2015_2016/kv1/05_ograde/#opis-izlaza","title":"Opis izlaza","text":"<p>Prva i jedina linija izlaza treba da sadr\u017ei ta\u010dno jedan ceo broj - broj stabala koji Dimitrije mora da pose\u010de u stra\u0161noj \u0161umi.</p>"},{"location":"takprog/2015_2016/kv1/05_ograde/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/05_ograde/#ulaz","title":"Ulaz","text":"<pre><code>-11 0\n-8 2\n-3 4\n6 3\n8 2\n11 0\n-1 -4\n3\n3 2 -3\n-5 -4 8\n0 8 1\n</code></pre>"},{"location":"takprog/2015_2016/kv1/05_ograde/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2015_2016/kv1/05_ograde/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom primeru su uni\u0161tena 4 segmenta: segment sa krajnjim ta\u010dkama u (-3, 4) i (-8, 2), segment sa krajnjim ta\u010dkama u (-11, 0) i (-1, -4), segment sa krajnjim ta\u010dkama (-1, -4) i (11,0), kao i segment sa krajnjim ta\u010dkama (6, 3) i (-3, 4).</p>"},{"location":"takprog/2015_2016/kv1/05_ograde/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \u2264 N \u2264 10^5\\)</li> <li>\\(1 \u2264 M \u2264 10^5\\)</li> <li>\\(\u221210^7 \u2264 x_i, y_i, a_i, p_i, k_i \u2264 10^7\\)</li> </ul>"},{"location":"takprog/2015_2016/kv1/05_ograde/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u 3 grupe:</p> <ul> <li>u 20% test primera ograda \u0107e biti u obliku jednakokrakog pravouglog trougla \u010dija je hipotenuza paralelna x osi ili u obliku kvadrata \u010dije su stranice zarotirane za 45\u25e6 u odnosu na koordinatne ose</li> <li>u 40% test primera va\u017ei\u0107e da je \\(N \u00b7 M \u2264 10^6\\)</li> <li>ostali primeri nemaju ograni\u010denja</li> </ul>"},{"location":"takprog/2015_2016/kv1/05_ograde/#prvi-i-drugi-podzadatak","title":"Prvi i drugi podzadatak:","text":"<p>Za svakog crva i ogradu proveravamo da li je taj crv uni\u0161tio tu ogradu, odnosno da li se njihove du\u017ei seku. To je mogu\u0107e uraditi preko me\u0161ovitog proizvoda vektora, odnosno orijentacije trougla. Du\u017ei \\(AB\\) i \\(CD\\) se seku akko trouglovi \\(ABC\\) i \\(ABD\\) imaju suprotnu orijentaciju. Slo\u017eenost je \\(O(N\\cdot M)\\).</p>"},{"location":"takprog/2015_2016/kv1/05_ograde/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sortiramo sve crve po \\(x\\) koordinati i segmente ograde podelimo u dva sortirana niza (isto po \\(x\\) koordinati levog kraja) - \"gornji omota\u010d\" i \"donji omota\u010d\". Zadatak re\u0161avamo prvo za jedan, pa onda za drugi omota\u010d. To radimo tehnikom two pointers. Za svaki segment ograde odredimo koji crvi zadovoljavaju to da se njihova \\(x\\) koordinata nalazi izme\u0111u \\(x\\) koordinata krajeva segmenta. Nakon toga, imamo skup crva koji mogu se\u0107i dati segment. Ostalo je to jo\u0161 samo proveriti. Slo\u017eenost je \\(O(NlogN)\\) zbog sortiranja i zato \u0161to po svakom crvu prolazimo najvi\u0161e \\(4N\\) puta.</p> 05_ograde.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MAXQ = 100000;\n\nint sign(long long x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    return x &lt; 0 ? -1 : 1;\n}\n\nbool intersects(pair&lt;int, pair&lt;int, int&gt;&gt; segment, long long x1, long long y1, long long x2, long long y2)\n{\n    if (x1 &lt; x2 &amp;&amp; (segment.first &lt; x1 || segment.first &gt; x2))\n    {\n        return false;\n    }\n    if (x2 &lt; x1 &amp;&amp; (segment.first &lt; x2 || segment.first &gt; x1))\n    {\n        return false;\n    }\n    int sign1 = sign((y2 - y1) * (segment.first - x1) - (segment.second.first - y1) * (x2 - x1));\n    int sign2 = sign((y2 - y1) * (segment.first - x1) - (segment.second.second - y1) * (x2 - x1));\n    return sign1 != sign2;\n}\n\nint main(int argc, char *argv[])\n{\n    string inFileName = argv[1];\n    string outFileName = inFileName.substr(0, inFileName.length() - 3) + \".out\";\n    fstream ifs, ofs;\n    ifs.open(inFileName, fstream::in);\n    ofs.open(outFileName, fstream::out);\n    int n;\n    ifs &gt;&gt; n;\n    int x[MAXN], y[MAXN];\n    pair&lt;int, pair&lt;int, int&gt;&gt; segments[MAXQ];\n    int st = 0, ed = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        ifs &gt;&gt; x[i] &gt;&gt; y[i];\n        if (x[i] &lt; x[st])\n        {\n            st = i;\n        }\n        if (x[i] &gt; x[ed])\n        {\n            ed = i;\n        }\n    }\n    int q;\n    ifs &gt;&gt; q;\n    for (int i = 0; i &lt; q; i++)\n    {\n        ifs &gt;&gt; segments[i].first &gt;&gt; segments[i].second.first &gt;&gt; segments[i].second.second;\n    }\n    sort(segments, segments + q);\n    int ret = 0;\n    for (int i = st, idx = 0, save = 0; i != ed; i = (i + 1) % n)\n    {\n        int j = (i + 1) % n;\n        int valid = save;\n        save = 0;\n        while (segments[idx].first &lt;= x[j])\n        {\n            if (idx &lt; q &amp;&amp; intersects(segments[idx], x[i], y[i], x[j], y[j]))\n            {\n                if (segments[idx].first == x[j])\n                {\n                    save = 1;\n                }\n                valid = 1;\n            }\n            idx++;\n        }\n        ret += valid;\n    }\n    for (int i = ed, idx = q - 1, save = 0; i != st; i = (i + 1) % n)\n    {\n        int j = (i + 1) % n;\n        int valid = save;\n        save = 0;\n        while (idx &gt;= 0 &amp;&amp; segments[idx].first &gt;= x[j])\n        {\n            if (intersects(segments[idx], x[i], y[i], x[j], y[j]))\n            {\n                if (segments[idx].first == x[j])\n                {\n                    save = 1;\n                }\n                valid = 1;\n            }\n            idx--;\n        }\n        ret += valid;\n    }\n    ofs &lt;&lt; ret &lt;&lt; endl;\n    //cerr &lt;&lt; inFileName &lt;&lt; \" \" &lt;&lt; 1.0 * ret / n &lt;&lt; endl;\n    ifs.close();\n    ofs.close();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/06_cmyk/","title":"6 - CMYK","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 512MB <p>U vremenima neolitske Tajne Komisije, ljudi nisu mogli previ\u0161e dobro da opi\u0161u koncept boje. Me\u0111utim, ono \u0161to se znalo je da je bela boja bila obo\u017eavana. Tako\u0111e, boje su bile me\u0161ane tako \u0161to se izvori te dve boje (uglavnom biljke) smrve toljagom i pome\u0161aju\u2014po\u0161to razli\u010diti izvori imaju razli\u010dita hemijska svojstva, ovo nije uvek garantovalo iste rezultate (npr. proizvod me\u0161anja crvene i \u017eute boje nije uvek narand\u017east).</p> <p>Kao i u slu\u010daju igre simbola, \u010dlanovi savremene Tajne Komisije su uspeli da do\u0111u do nekoliko nizova biljaka raznih boja iz tog perioda. Pretpostavka je da su tada\u0161nji ljudi mogli samo da spajaju po dve susedne boje u nizu u jednu. Unajmljena je pomo\u0107 malog Davisa, poznatog (al)hemi\u010dara, da se ustanovi koje su sve kombinacije boja mogle da se dobiju me\u0161anjem. Ispostavilo se, izme\u0111u ostalog, da je redosled boja bitan (npr. me\u0161anje plave i crvene ne mora biti isto kao me\u0161anje crvene i plave), da je mogu\u0107e da me\u0161anje dve boje nema jedinstven rezultat, kao i da je mogu\u0107e da neke dve boje ne mo\u017eemo pome\u0161ati. Malog Pericu sada zanima da li je mogu\u0107e dobiti samo nizove belih boja, prate\u0107i pravila koja je Davis generisao.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107 Petar Veli\u010dkovi\u0107 <p>Re\u0161enje mo\u017eete na\u0107i na slede\u0107em linku: </p> 06_cmyk.cpp<pre><code>// RandomUsername (Nikola Jovanovic)\n// Quals 2016\n// CMYK cyk tiles\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// symbols: 'A'..'Z'\nconst int MAX_STRING_LEN = 105, MAX_SYMBOLS = 30, MAX_GRAMMAR_SZ = 105, MAX_RULE_LEN = 10;\n\nstruct productionRule\n{\n    int L, R1, R2;\n};\n\n// vars\nint testCases, stringLen, grammarSz, symbolNo;\nchar str[MAX_STRING_LEN];\nbool DP[MAX_STRING_LEN][MAX_STRING_LEN][MAX_SYMBOLS]; // DP[length][index][symbol]\nproductionRule grammar[MAX_STRING_LEN];\n\n// input vars\nchar temp[MAX_RULE_LEN];\nchar L, R1, R2;\n\n// parts of the string that can be formed from a single 'W'\nvector&lt; pair&lt;int, int&gt; &gt; blocks;\n// parts of the string that can be tiled using 'W' chars\nbool tiled[MAX_STRING_LEN];\n\n// sort by the endpoints\nbool compair(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)\n{\n    return (a.second == b.second) ? (a.first &lt; b.first) : (a.second &lt; b.second);\n}\n\nvoid solveCYK()\n{\n    // init\n    for(int l = 1; l &lt;= stringLen; l++)\n    {\n        for(int i = 1; i &lt;= stringLen; i++)\n        {\n            for(int symb = 0; symb &lt;= symbolNo; symb++)\n            {\n                if(l == 1)\n                {\n                    DP[l][i][symb] = (symb == (str[i] - 'A'));\n                }\n                else\n                {\n                    DP[l][i][symb] = false;\n                }\n            }\n            if(DP[l][i]['W' - 'A'])\n            {\n                blocks.push_back({i, i});\n            }\n        }\n    }\n\n    // actual DP\n    for(int l = 2; l &lt;= stringLen; l++)\n    {\n        for(int i = 1; i &lt;= stringLen - l + 1; i++)\n        {\n            for(int k = 1; k &lt;= l - 1; k++)\n            {\n                for(int idx = 1; idx &lt;= grammarSz; idx++)\n                {\n                    // s[i..i+l-1] (L) -&gt; s[i..i+k-1] (R1) + s[i+k..stringLen] (R2)\n                    DP[l][i][ grammar[idx].L ] |= DP[k][i][ grammar[idx].R1 ] &amp; DP[l-k][i+k][ grammar[idx].R2 ];\n                }\n            }\n            if(DP[l][i]['W' - 'A'])\n            {\n                blocks.push_back({i, i + l - 1});\n            }\n        }\n    }\n}\n\nvoid SolveTiling()\n{\n    tiled[0] = true;\n    for(int i = 1; i &lt;= stringLen; i++)\n    {\n        tiled[i] = false;\n    }\n    sort(blocks.begin(), blocks.end());\n    for(int i = 0; i &lt; blocks.size(); i++)\n    {\n        tiled[ blocks[i].second ] |= tiled[ blocks[i].first - 1 ];\n    }\n}\n\nint main()\n{\n    double start = clock();\n    // input\n    symbolNo = 25;\n    scanf(\"%d\", &amp;grammarSz);\n    for(int i = 1; i &lt;= grammarSz; i++)\n    {\n        scanf(\"\\n%c%c -&gt; %c\", &amp;R1, &amp;R2, &amp;L);\n        grammar[i] = { (L - 'A'), (R1 - 'A'), (R2 - 'A') };\n    }\n    scanf(\"%d\", &amp;testCases);\n    for(int tc = 1; tc &lt;= testCases; tc++)\n    {\n        blocks.clear();\n        scanf(\"%d\", &amp;stringLen);\n        scanf(\"%s\", str+1);\n        // CYK\n        solveCYK();\n        // we have to tile the string using blocks\n        SolveTiling();\n        printf(\"%s\\n\", tiled[stringLen] ? \"YES\" : \"NO\" );\n    }\n    double stop = clock();\n    fprintf(stderr, \"Time: %.2f\\n\", (stop - start) / CLOCKS_PER_SEC);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj m, koji predstavlja broj pravila me\u0161anja boja koje je mali Davis prona\u0161ao. U svakom od narednih m redova nalazi se po jedno pravilo, dato u formatu \\(XY\\) -&gt; \\(Z\\) (gde su \\(X, Y\\) i \\(Z\\) velika slova engleske abecede), \u0161to zna\u010di da, ukoliko su nam boje \\(X\\) i \\(Y\\) susedne u nizu, mo\u017eemo ih pome\u0161ati i dobiti boju \\(Z\\) na tom mestu. U narednom redu standardnog ulaza nalazi se prirodan broj \\(t\\), koji predstavlja broj na\u0111enih nizova boja, nakon \u010dega je svaki niz zadat u dva reda; prvi red sadr\u017ei prirodan broj \\(n\\), du\u017einu niza, a drugi red sadr\u017ei niz od \\(n\\) velikih slova engleske abecede, koji predstavlja sam niz boja.</p>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(t\\) nizova, ispisati u zasebnom redu standardnog izlaza ili \u201cYES\u201d ili \u201cNO\u201d (bez navodnika), u zavisnosti od toga da li je mogu\u0107e do\u0107i od po\u010detnog niza do niza u kome su sveboje bele (W).</p>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/kv1/06_cmyk/#ulaz","title":"Ulaz","text":"<pre><code>2\nRG -&gt; B\nBB -&gt; W\n2\n9\nRGBRGBRGB\n4\nRGBB\n</code></pre>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#izlaz","title":"Izlaz","text":"<pre><code>YES\nNO\n</code></pre>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom nizu mo\u017eemo odraditi slede\u0107e transformacije: RGBRGBRGB -&gt; BBRGBRGB -&gt; BBBBRGB -&gt; BBBBBB -&gt; WBBBB -&gt; WWBB -&gt; WWW, \u010dime dobijamo niz samo bele boje. U drugom nizu mogu\u0107e je do\u0107i do niza WB ili BW, posle \u010dega nije mogu\u0107e vr\u0161iti dalje transformacije.</p>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 m \u2264 100\\)</li> <li>\\(1 \u2264 n \u2264 100\\)</li> <li>\\(1 \u2264 t \u2264 10\\)</li> <li>Svi nizovi \u0107e sadr\u017eati samo velika slova engleske abecede.</li> </ul>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(m \u2264 15, n \u2264 10\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(m \u2264 15\\).</li> <li>U test primerima vrednim 25 poena va\u017ei\u0107e \\(m \u2264 75, n \u2264 75\\).</li> <li>U test primerima vrednim 35 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/kv1/06_cmyk/#napomena-2","title":"Napomena 2","text":"<p>Mogu\u0107e je da pravila me\u0161anja za neke dve boje nisu jedinstvena, npr. mogu\u0107e je prisustvo XY -&gt; Z i XY -&gt; W u istom skupu pravila.</p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/","title":"B1 - Davis zona","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U starim vremenima, mongolski vladar Petar Kan je vladao Tajnom Komisijom sa \u010dvrstom pesnicom. Predani uzurpator Davis je po svaku cenu re\u0161en da ga zbaci sa trona. Op\u0161te je poznato da Davis dobija nadljudske mo\u0107i kada u\u0111e u njegovu zonu\u2014zato je Petar re\u0161en da po svaku cenu spre\u010di Davisa da u\u0111e u zonu.</p> <p>Davisova zona se nalazi unutar tajne prostorije (koja je potpuno okru\u017eena zidovima) oblika pravougaonika stranica \\(a\\) i \\(b\\). Prostorija je podeljena na \\(a \u00b7 b\\) kvadratnih polja dimenzija 1 \u00d7 1. Polja su numerisana od (1, 1) (gornje-levo) do (a, b) (donje-desno). Zona je pravougaonik dimenzija c i d, sa gornjim levim poljem \\((x, y)\\) (ovaj pravougaonik je potpuno sadr\u017ean u prostoriji). </p> <p>Davis kre\u0107e sa polja \\((dx, dy)\\), i u svakom koraku \u0107e se pomeriti za \\(\u2206x\\) polja nadole, odnosno \\(\u2206y\\) polja udesno. Ukoliko bi Davis tim pomeranjem udario u zid, odbi\u0107e se pod istim uglom pod kojim je udario u njega. Ako Davis udari u zid vi\u0161e od k puta bez da u\u0111e u zonu, odusta\u0107e ovoga puta.</p> <p>Petra sada zanima da li \u0107e Davis ikada biti u zoni, i ako ho\u0107e, zanima ga polje na kome \u0107e biti kada prvi put bude u zoni, da bi znao da na njega postavi stra\u017eare.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Dragan Uro\u0161evi\u0107 Mladen Puzi\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2015_2016/okr/01_davis_zona/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja a i b, koji predstavljaju broj redova i kolona prostorije, redom. U drugom redu nalaze se dva prirodna broja \\(c\\) i \\(d\\), koji predstavljaju broj redova i kolona Davisove zone, redom. U tre\u0107em redu nalaze se dva prirodna broja \\(x\\) i \\(y\\), koji predstavljaju red i kolonu gornjeg levog polja zone, redom. U \u010detvrtom redu nalaze se dva prirodna broja \\(dx\\) i \\(dy\\), koji predstavljaju red i kolonu polja sa koga Davis kre\u0107e. U petom redu nalaze se tri cela broja \\(\u2206x\\), \\(\u2206y\\) i \\(k\\), koji predstavljaju broj polja nadole i udesno za koliko \u0107e se Davis pomeriti u svakom koraku, kao i ograni\u010denje za broj udara u zid.</p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati dva prirodna broja hx i hy, koji predstavljaju red i kolonu polja na kome \u0107e Davis biti prvi put kada se na\u0111e u zoni, redom. Ukoliko Davis ne uspe da u\u0111e u zonu, potrebno je ispisati \u201cNE\u201d (bez navodnika).</p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/01_davis_zona/#ulaz","title":"Ulaz","text":"<pre><code>5 4\n1 2\n2 3\n5 2\n-1 -1 1\n</code></pre>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#izlaz","title":"Izlaz","text":"<pre><code>2 3\n</code></pre>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Na slikama ispod nalazi se opis test primera; na svakoj slici Davisova pozicija ozna\u010dena je slovom D, polja zone su zatamnjena, a strelica ozna\u010dava polje na koje \u0107e Davis oti\u0107i u slede\u0107em koraku. Davis najpre udara u zid u polju (4, 1); dva koraka nakon toga uspe\u0161no ulazi u zonu, i to u polju (2, 3). Pritom nije udario u zid vi\u0161e od jednom, tako da je ovo kona\u010dno re\u0161enje koje treba ispisati.</p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 a, b, c, d \u2264 1000\\);</li> <li>\\(1 \u2264 c, x, dx \u2264 a\\);</li> <li>\\(1 \u2264 d, y, dy \u2264 b\\);</li> <li>\\(0 \u2264 k \u2264 1000\\);</li> <li>\\(\u2206x, \u2206y \u2208 \\{\u22121, 0, 1\\}\\);</li> <li>Davisova zona \u0107e uvek biti obuhva\u0107ena prostorijom.</li> </ul>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#napomena","title":"Napomena","text":"<ul> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(\u2206x = 0\\) ili \\(\u2206y = 0\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(k = 0\\).</li> <li>U test primerima vrednim 60 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#resenje-za-delta-x-0-ili-delta-y-0","title":"Re\u0161enje za \\(\\Delta x = 0\\) ili  \\(\\Delta y = 0\\):","text":"<p>Uslov zna\u010di da se kre\u0107emo isklju\u010divo ili gore-dole ili levo-desno, i samim tim nije potrebno razmatrati komplikovanije sudare sa zidom. Izme\u0111u svaka dva sudara sa zidom pro\u0107i \u0107e najvi\u0161e \\(max(a, b)\\) sekundi, pa \u0107e ukupan broj koraka biti najvi\u0161e oko \\(max(a, b) \\cdot k\\), \u0161to je dovoljno malo da mo\u017eemo simulirati kretanje. To radimo tako \u0161to proverimo da li smo trenutno u Davis zoni, pa se pomerimo (ovaj redosled je bitan za slu\u010daj da smo ve\u0107 u po\u010detku u Davis zoni). Ukoliko udarimo u zid, samo promenimo smer kretanja u suprotni. Stajemo kada smo u Davis zoni, ili kada potro\u0161imo sva odbijanja od zida. Vremenska slo\u017eenost: \\(O((a+b)\\cdot k)\\), memorijska slo\u017eenost: \\(O(1)\\). </p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#resenje-za-k-0","title":"Re\u0161enje za \\(k = 0\\):","text":"<p>U ovom slu\u010daju, nikad ne moramo simulirati odbijanje od zidove, ve\u0107 samo kretanje dok ne nai\u0111emo na zid ili Davis zonu. Po\u0161to je najve\u0107i broj koraka pre udarca u zid \\(max(a, b)\\), vremenska slo\u017eenost je \\(O(a+b)\\), a memorijska slo\u017eenost \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/okr/01_davis_zona/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Jo\u0161 uvek mo\u017eemo da simuliramo proces (jo\u0161 uvek izme\u0111u svaka dva udarca u zid ima najvi\u0161e \\(max(a, b)\\) koraka), samo je potrebno i simulirati komplikovanija odbijanja od zid, konkretno, dijagonalna odbijanja. Na primer, ako udaramo u vertikalan zid, onda \u0107emo promeniti \\(\\Delta y\\), u suprotnom \\(\\Delta x\\). Ukoliko udaramo u \u0107o\u0161ak, onda menjamo obe vrednosti. Simuliramo dok ne potro\u0161imo sva odbijanja ili ne budemo u Davis zoni. Vremenska slo\u017eenost: \\(O((a+b)\\cdot k)\\), memorijska slo\u017eenost: \\(O(1)\\). </p> 01_davis_zona.cpp<pre><code># include &lt;stdio.h&gt;\n\nmain() {\n  int a, b, c, d;\n  int cx, cy, dx, dy;\n  int to, mo;\n  int x1, y1, x2, y2;\n  scanf(\"%d%d\", &amp;a, &amp;b); \n  scanf(\"%d%d\", &amp;c, &amp;d); \n  scanf(\"%d%d\", &amp;x1, &amp;y1); \n  scanf(\"%d%d\", &amp;cx, &amp;cy); \n  scanf(\"%d%d%d\", &amp;dx, &amp;dy, &amp;mo); \n  x2 = x1 + c - 1;\n  y2 = y1 + d - 1;\n  if ((dx == 0) &amp;&amp; (dy == 0)) {\n    if ((cx &gt;= x1) &amp;&amp; (cx &lt;= x2) &amp;&amp; (cy &gt;= y1) &amp;&amp; (cy &lt;= y2)) \n      printf(\"%d %d\\n\", cx, cy);\n    else\n      printf(\"NE\\n\");\n    return 0;\n  }\n  to = 0;\n  while (to &lt;= mo) {\n    if ((cx &gt;= x1) &amp;&amp; (cx &lt;= x2) &amp;&amp; (cy &gt;= y1) &amp;&amp; (cy &lt;= y2)) {\n      printf(\"%d %d\\n\", cx, cy);\n      return 0;\n    }\n    if ((cx+dx &lt; 1) || (cx+dx &gt; a)) {\n      dx = -dx;\n      if ((cy+dy &lt; 1) || (cy+dy &gt; b)) dy = -dy;\n      to++;\n    } else {\n      if ((cy+dy &lt; 1) || (cy+dy &gt; b)) {\n        dy = -dy;   \n        to++;\n      }\n    }\n    if (to &gt; mo) break;\n    cx += dx; cy += dy;  \n  }\n  printf(\"NE\\n\");\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/","title":"B2 - (Novi) Vavilon","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Neposredno pre 626. godine p.n.e. na podru\u010dju Mesopotamije je izbio veliki gra\u0111anski sukob. Pobunjeni gra\u0111anin Napobalasar je \u017eeleo da zbaci sa vlasti tada\u0161nje vladare Asirce i da osnuje Haldejsko carstvo, odnosno Novi Vavilon. Interesantna \u010dinjenica je da je svaki od gra\u0111ana tada\u0161nje Mesopotamije imao jedinstveni mati\u010dni broj gra\u0111ana koji je ceo broj iz intervala \\([1, m]\\). Napobalasar je tako\u0111e bio visoki sve\u0161tenik vudu religije Avalon koja mnogo veruje u okrugle stolove i verovao je da posti\u0107i pobedu ako i samo ako uspe da gra\u0111ane rasporedi na stolu u obliku osmice koji je sastavljen od dva kru\u017ena stola kapaciteta n, tako da on sedi na mestu koje spaja te stolove i da va\u017ei da je najmanji zajedni\u010dki sadr\u017ealac jedinstvenih mati\u010dnih brojeva gra\u0111anana jednom stolu jednak  najve\u0107em zajedni\u010dkom deliocu jedinstvenih mati\u010dnih brojeva gra\u0111ana na drugom stolu i da je ta vrednost upravo jednaka vrednosti njegovog jedinstvenog mati\u010dnog broja gra\u0111ana. Napobalasar trenutno nema vremena da izra\u010duna na koliko na\u010dina mo\u017ee rasporediti gra\u0111ane na ovakvom stolu, pa vas moli za pomo\u0107 kako bi sagradio Novi Vavilon. Po\u0161to ovaj broj mo\u017ee biti veoma velik, va\u0161 zadatak je da ispi\u0161ete ostatak pri deljenju ovog broja brojem \\(10^9 + 7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Jovanovi\u0107 Dimitrije Erdeljan Marko Ili\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj i jedinoj liniji standardnog ulaza se nalaze tri cela broja \\(n, m\\) i \\(id\\) koja redom predstavljaju kapacitet svakog od kru\u017enih stolova, broj ljudi koji \u017eive u Mesopotamiji i Napobalasarov jedinstveni mati\u010dni broj gra\u0111ana.</p>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvoj i jedinoj liniji standardnog izlaza treba ispisati ostatak pri deljenju broja xna\u010dina na koji Napobalasar mo\u017ee izabrati gra\u0111ane po opisanom verovanju, brojem \\(10^9 + 7\\).</p>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#ulaz","title":"Ulaz","text":"<pre><code>4 48 12\n</code></pre>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#izlaz","title":"Izlaz","text":"<pre><code>720\n</code></pre>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#ulaz_1","title":"Ulaz","text":"<pre><code>4 38 12\n</code></pre>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Na slici iznad su ilustrovani dati primer, gde crveno mesto predstavlja Napobalasara. U prvom test primeru, Napobalasar mo\u017ee za jednim stolom da rasporedi ljude sa jedinstevnim mati\u010dnim brojevima gra\u0111ana 1, 2, 3, 4, 6 tako da njihov najmanji zajedni\u010dki sadr\u017ealac iznosi 12 i on to mo\u017ee uraditi na 5 \u00b7 4 \u00b7 3 = 60 na\u010dina, a za drugim stolom mo\u017ee da rasporedi ljude sa mati\u010dnim brojevima 24, 36, 48 tako da je njihov najve\u0107i zajedni\u010dni delilac jednak 12 i on to mo\u017ee uraditi na 3 \u00b7 2 \u00b7 1=6 na\u010dina. Kona\u010dan rezultat je (60 \u00b7 6) \u00b7 2 po\u0161to prvu grupu ljudi mo\u017ee staviti ili na levi ili na desni sto.</p> <p>U drugom test primeru, Napobalasar nikako ne mo\u017ee za drugim stolom da rasporedi 3 gra\u0111ana tako da njihov najve\u0107i zajedni\u010dki delilac iznosi 12, pa je broj na\u010dina 0.</p>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 10^6\\)</li> <li>\\(1 \\leq m \\leq 10^9\\)</li> <li>\\(1 \\leq id \\leq m\\)</li> </ul>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#napomena","title":"Napomena","text":"<p>Svaki od gra\u0111ana ima jedinstven mati\u010dni broj. Nijedan sto ne sme imati prazno mesto. Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(n = 2\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(m \\leq 10^3\\).</li> <li>U test primerima vrednim 60 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#resenje-za-n-2","title":"Re\u0161enje za \\(N = 2\\):","text":"<p>U ovom podzadataku treba izabrati jednog gra\u0111anina \u010diji je mati\u010dni broj delilac broja \\(id\\) i jednog \u010diji je mati\u010dni broj umno\u017eak broja \\(id\\). Ako \\(id\\) ima \\(x\\) delilaca i \\(y\\) umno\u017eaka ne ve\u0107ih od \\(m\\), onda je ukupan broj odgovaraju\u0107ih rasporeda gra\u0111ana jednak \\(2 \\cdot (x-1) \\cdot (y-1)\\) (minus jedan u zagradama zato \u0161to ne mo\u017eemo da biramo Napobalasara, puta dva, jer mi odre\u0111ujemo ko ide na koji sto). Vrednost \\(x\\) \u0107emo dobiti tako \u0161to \u0107emo iterirati po celobrojnim vrednostima \\(a\\) od \\(1\\) do \\(\\sqrt id\\) i za svako \\(a\\) koje deli \\(id\\) pove\u0107ati broja\u010d za 2, jednom za sam broj \\(a\\), a drugi put za njegov par \\(id / a\\), do kog ne\u0107emo do\u0107i u ovoj petlji jer je ve\u0107i od \\(\\sqrt id\\). Na kraju, ukoliko je \\(id\\) potpun kvadrat broja\u010d treba smanjiti za jedan jer smo ga za \\(a = \\sqrt id\\) dvaput pove\u0107ali za istu vrednost. Vrednost \\(y\\) je jednaka \\(\\lfloor {m/id} \\rfloor\\), gde \\(\\lfloor x \\rfloor\\) predstavlja najmanji ceo broj ne ve\u0107i od \\(x\\). Vremenska slo\u017eenost: \\(O(\\sqrt {id})\\). Memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#resenje-za-1-le-m-le-103","title":"Re\u0161enje za \\(1 \\le m \\le 10^3\\):","text":"<p>Za razliku od prethodnog podzadatka, u ovom vrednosti \\(x\\) i \\(y\\) mo\u017eemo dobiti iteriranjem po brojevima od 1 do \\(m\\) i pove\u0107avanjem \\(x\\) ukoliko je posmatrani broj delilac broja \\(id\\), a \\(y\\) ukoliko je umno\u017eak broja \\(id\\). Re\u0161enje je:  $$ 2 \\cdot (x-1) \\cdot (x-2) \\cdot \\ldots \\cdot (x-N+1) \\cdot (y-1) \\cdot (y-2) \\cdot \\ldots \\cdot (y-N+1).$$  Vremenska slo\u017eenost: \\(O(M + N)\\). Memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/okr/02_novi_vavilon/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Za svih \\(100\\) poena treba iskoristiti ideje iz prethodna dva podzadatka. Vrednosti \\(x\\) i \\(y\\) \u0107emo na\u0107i kao u prvom podzadatku, a potom primeniti formulu iz drugog podzadatka. Vremenska slo\u017eenost: \\(O(\\sqrt {id} + N)\\). Memorijska slo\u017eenost: \\(O(1)\\).</p> 02_novi_vavilon.cpp<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nint main()\n{\n    long long n, m, id;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; id;\n\n    int high = m / id - 1;\n    int low = 0;\n    for(int i = 1; i * i &lt;= id; i++)\n        if(id % i == 0)\n        {\n            low++;\n            if(i*i != id &amp;&amp; id/i &lt; id) low++;\n        }\n\n    if(high + 1 &lt; n || low + 1 &lt; n)\n    {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n        return 0;\n    }\n\n    long long res = 2;\n    for(int i = 0; i &lt; n - 1; i++)\n    {\n        res *= high - i;\n        res %= MOD;\n        res *= low - i;\n        res %= MOD;\n    }\n\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/okr/03_abakus/","title":"B3 - Abakus","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Stari Vavilonci su koristili jednu varijantu naprave Abakus za komplikovana matemati\u010dka izra\u010dunavanja. Abakus se sastoji od \\(n\\) kuglica numerisanih brojevima od 1 do \\(n\\). Svaka od kuglica se mo\u017ee nalaziti na jednoj od 10 pozicija (numerisanih brojevima od 0 do 9), a te pozicije govore o vrednosti koju ima odgovaraju\u0107a kuglica (to su vrednosti od 0 do 9). Kuglice su podeljene u \\(m\\) disjunktnih grupa, numerisanih brojevima od 1 do \\(m\\) (pojedine grupe mogu biti prazne). Korisnik ima na raspolaganju dve vrste operacija:</p> <ul> <li>Postavi \\(BrG\\) \\(Poz\\), ovom komandom postavljaju se sve kuglice iz grupe \\(BrG\\) u poziciju \\(Poz\\) (tj. postavlja vrednost svih kuglica iz te grupe na Poz). Ova operacija ima cenu \\(C1\\).</li> <li>Promeni \\(BrK\\) \\(Poz\\), ovom komandom se preme\u0161ta samo kuglicu sa rednim brojem \\(BrK\\) na poziciju \\(Poz\\) (tj. menja se njena vrednost na \\(Poz\\)). Za ovu operaciju korisnik pla\u0107a cenu jednaku \"kru\u017enom rastojanju\" izme\u0111u dosada\u0161nje pozicije te kuglice i nove pozicije. \"Kru\u017eno rastojanje\" je najkra\u0107e rastojanje izme\u0111u pozicija, ako bi one bile pore\u0111ane na krugu u skladu sa numeracijom. Npr. kru\u017eno rastojanje izme\u0111u 0 i 7 je 3, izme\u0111u 1 i 9 je 2, a ime\u0111u 7 i 3 je 4.</li> </ul> <p>Dobili ste opis Abakusa (broj kuglica, cenu operacije Postavi (C1) i podelu kuglica po grupama), po\u010detno stanje kuglica (tj. poziciju u kojoj se nalazi svaka od kuglica na po\u010detku) i krajnje stanje kuglica (tj. pozicije na kojima treba na kraju da se nalaze). Potrebno je da odredite minimalnu cenu da se od zadatog po\u010detnog stanja kuglica (tj. po\u010detnih pozicija kuglica) do\u0111e do krajnjeg stanja kuglica.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Jovanovi\u0107 Dragan Uro\u0161evi\u0107 Marko Ili\u0107 Demjan Grubi\u0107"},{"location":"takprog/2015_2016/okr/03_abakus/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi broj kuglica (\\(n\\)) i cena operacije Postavi (\\(C1\\)). U drugom redu se nalazi \\(n\\) prirodnih brojeva, a \\(i\\)-ti od njih predstavlja redni broj grupe u kojoj se nalazi \\(i\\)-ta kuglica. U tre\u0107em redu se nalazi \\(n\\) brojeva, a \\(i\\)-ti od tih brojeva predstavlja po\u010detnu poziciju (tj. po\u010detnu vrednost) \\(i\\)-te kuglice. U \u010detvrtom redu se nalazi \\(n\\) brojeva, a \\(i\\)-ti od tih brojeva predstavlja krajnju poziciju \\(i\\)-te kuglice.</p>"},{"location":"takprog/2015_2016/okr/03_abakus/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati samo jedan broj - minimalnu zbirnu cenu operacija koje treba izvesti da bi se kuglice dovele na krajnje pozicije.</p>"},{"location":"takprog/2015_2016/okr/03_abakus/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/03_abakus/#ulaz","title":"Ulaz","text":"<pre><code>8 3\n6 5 6 5 5 6 1 2\n5 1 5 2 3 5 8 0\n0 1 0 2 3 8 4 8\n</code></pre>"},{"location":"takprog/2015_2016/okr/03_abakus/#izlaz","title":"Izlaz","text":"<pre><code>10\n</code></pre>"},{"location":"takprog/2015_2016/okr/03_abakus/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Kuglice iz grupe 5 ne moramo uop\u0161te preme\u0161tati. Kuglice iz grupe 6 prebacujemo komandom Postavi 6 0 u poziciju 0, a zatim komandom Promeni 6 8 i pla\u0107amo cenu 5 (3+2). Kuglicu iz grupe 1 prebacujemo komandom Postavi 1 4 i pla\u0107amo cenu 3 (ako bi koristili komandu Promeni 7 4 platili bi 4). Kuglicu iz grupe 2 prebacujemo komandom Promeni 8 8 i pla\u0107amo cenu 2 (komandom Postavi 2 8 platili bi 3).</p>"},{"location":"takprog/2015_2016/okr/03_abakus/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 10^6\\).</li> <li>\\(1 \\leq m \\leq 1000\\).</li> <li>\\(1 \\leq C1 \\leq 10^6\\).</li> </ul>"},{"location":"takprog/2015_2016/okr/03_abakus/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u tri disjunktne grupe</p> <ul> <li>u test primerima koji vrede 30 poena va\u017ei\u0107e da se sve kuglice nalaze u jednoj grupi (tj. \\(m\\) = 1).</li> <li>u test primerima koji vrede 30 poena svaku od grupa \u010dini blok uzastopnih kuglica (tj. blok kuglica \u010dije su oznake uzastopni prirodni brojevi).</li> <li>u test primerima koji vrede 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/03_abakus/#resenje-za-m-1","title":"Re\u0161enje za \\(m = 1\\):","text":"<p>Ono \u0161to treba primetiti jeste da operaciju kojom prebacujemo sve kuglice jedne grupe na odre\u0111enu poziciju ima smisla raditi samo na po\u010detku i to maksimalno jednom, jer bilo koja operacija koja se odradi pre takve operacije ne bi imala uticaj na krajnji rezultat. Dakle, mo\u017eemo da uop\u0161te ne koristimo tu operaciju, ili da sve kuglice prebacimo u neku od deset grupa, pa onda one koje ne treba da budu tu, prebacimo u odgovaraju\u0107e grupe pomo\u0107u druge operacije. Kao re\u0161enje treba izabrati najjeftiniju opciju. Vremenska slo\u017eenost: \\(O(N \\cdot maxC)\\), gde je \\(maxC\\) broj cifara, memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/okr/03_abakus/#resenje-kada-svaku-od-grupa-cini-blok-uzastopnih-kuglica","title":"Re\u0161enje kada svaku od grupa \u010dini blok uzastopnih kuglica:","text":"<p>S tim da kuglice iz razli\u010ditih grupa ne mo\u017eemo pomerati u istoj operaciji, treba svaku grupu posebno re\u0161iti, pa \u0107e kona\u010dno re\u0161enje biti suma re\u0161enja za svaku od grupa. U ovom podzadatku mo\u017eemo jednostavno izdvojiti grupe s tim da su to uzastopne kuglice i nakon toga za svaku grupu primeniti ideju iz prvog podzadatka. Vremenska  slo\u017eenost: \\(O(N \\cdot maxC)\\), memorijska slo\u017eenost: \\(O(N)\\).  </p>"},{"location":"takprog/2015_2016/okr/03_abakus/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Razlika u odnosu na prethodni podzadatak je u tome \u0161to ovde prvo treba odvojiti kuglice po grupama. Mo\u017eemo da za svaku grupu izgradimo niz kuglica koje se nalaze u njoj i nakon toga treba primeniti ideju iz prethodnog podzadatka. Vremenska slo\u017eenost: \\(O(N \\cdot maxC)\\), memorijska slo\u017eenost: \\(O(N)\\)</p> 03_abakus.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;stdlib.h&gt;\n\n# define MAXN 1000000\n# define MAXM 1000\n\nint c1;\nint n, m;\nint g[MAXN];\nint a[MAXN], b[MAXN];\nint brp[MAXM][10][10];\nint brf[MAXM][10];\nint ukc, minc, trenc;\nint c2[10][10];\n\nvoid citaj() {\n    int i;\n    scanf(\"%d%d\", &amp;n, &amp;c1);\n    for (i = 0; i &lt; n; i++) \n      scanf(\"%d\", &amp;g[i]);\n    for (i = 0; i &lt; n; i++) \n      scanf(\"%d\", &amp;a[i]);\n    for (i = 0; i &lt; n; i++) \n      scanf(\"%d\", &amp;b[i]);   \n}\n\nvoid odredic2() {\n    int i, j;\n    for (i = 0; i &lt; 10; i++) \n      for (j = 0; j &lt; 10; j++) {\n        c2[i][j] = abs(i - j);\n        if (10 - c2[i][j] &lt; c2[i][j])\n           c2[i][j] = 10 - c2[i][j];\n      }\n}\n\nvoid prebroj() {\n    int i;\n    int mt;\n    for (i = 0; i &lt; n; i++) {\n        mt = g[i];\n        if (mt &gt; m) m = mt;\n        brp[mt][a[i]][b[i]]++;\n        brf[mt][b[i]]++;\n    }\n}\n\nvoid resi() {\n    int mt;\n    int i, j;\n    for (mt = 0; mt &lt;= m; mt++) {\n        trenc = 0;\n        for (i = 0; i &lt; 10; i++)\n          for (j = 0; j &lt; 10; j++)\n            trenc += brp[mt][i][j] * c2[i][j];\n        minc = trenc;\n        for (i = 0; i &lt; 10; i++) {\n            trenc = c1;\n            for (j = 0; j &lt; 10; j++)\n              trenc += brf[mt][j] * c2[i][j];\n            if (trenc &lt; minc)\n              minc = trenc;\n        }\n        ukc += minc;\n    }\n}\n\nvoid pisi() {\n    printf(\"%d\\n\", ukc);\n}\n\nmain() {\n    citaj();\n    odredic2();\n    prebroj();\n    resi();\n    pisi();\n}\n</code></pre>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/","title":"A1 - Tajna prostorija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Egip\u0107ani su veoma poznati po njihovim piramidama koje i dan danas predstavljaju pravu enigmu za istori\u010dare. Me\u0111utim, istori\u010dari veruju da su na pragu velikog otkri\u0107a, ali im je potrebna va\u0161a pomo\u0107. Naime, prou\u010davaju\u0107i unutra\u0161njost jedne od piramida, oni su nai\u0161li na zid na kome su u jednom redu ispisani razni brojevi. Dobro poznata teorija o jednoj od najpoznatijih kraljica Egipta, svemo\u0107noj Tamari, glasi da je Tamara bila op\u010dinjena nizovima brojeva gde svi brojevi u nizu imaju bar jednu istu cifru. Istori\u010dari veruju da je niz brojeva napisan na zidu koji su na\u0161li ba\u0161 delo kraljice Tamare i da predstavlja zagonetku \u010dije re\u0161enje vodi do Tajne prostorije gde se nalazi skriveno svo kralji\u010dino blago. </p> <p>Istori\u010dari su ube\u0111eni da je re\u0161enje zagonetke najdu\u017ei podniz uzastopnih elemenata datog niza brojeva za koji va\u017ei da postoji bar jedna cifra koja se nalazi u svim brojevima tog podniza. Po\u0161to oni nisu uspeli da na\u0111u ovaj podniz, oni su vas zamolili za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Boris Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Ivanovi\u0107"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi ceo broj \\(N\\) koji predstavlja du\u017einu niza brojeva napisanog na zidu. U drugom redu se nalazi \\(N\\) celih brojeva koji predstavljaju brojeve niza.</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati jedan ceo broj koji predstavlja du\u017einu najdu\u017eeg podniza uzastopnih brojeva datog niza za koji va\u017ei da postoji bar jedna cifra koja se nalazi u svim brojevima tog podniza.</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#ulaz","title":"Ulaz","text":"<pre><code>5\n123 222 334 443 538\n</code></pre>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n13 456 3\n</code></pre>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom test primeru podniz [334, 443, 538] je du\u017eine 3 i svi njegovi elementi sadr- \u017ee cifru 3. Ne postoji podniz du\u017eine 4 \u010diji brojevi imaju bar jednu istu cifru.</p> <p>U drugom test primeru nikoja dva susedna broja nemaju zajedni\u010dku cifru, pa je re\u0161enje za taj test primer 1.</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 N \u2264 10^6\\).</li> <li>Svi brojevi u datom nizu brojeva su izme\u0111u \\(1\\) i \\(10^9\\).</li> </ul>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei \\(1 \u2264 N \u2264 100\\).</li> <li>U test primerima vrednim 30 poena va\u017ei \\(1 \u2264 N \u2264 1000\\).</li> <li>U test primerima vrednim 20 poena va\u017ei da su svi brojevi u datom nizu jednocifreni.</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Razli\u010ditih uzastopnih podnizova ima \\(\\frac{N\\cdot(N-1)}{2}\\). Mo\u017eemo zasebno za svaki od njih i svaku cifru izra\u010dunati da li se ta cifra pojavljuje u svakom njegovom \u010dlanu. Vremenska slo\u017eenost: \\(O(maxC\\cdot N^3)\\), gde je \\(maxC\\) broj razli\u010ditih cifara, u ovom slu\u010daju \\(10\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Sli\u010dno kao u prethodnom podzadatku proverava\u0107emo istu stvar za svaki podniz, ali efikasnije. Umesto da iznova ra\u010dunamo odgovor za podniz \\(A_i...A_j\\), koristi\u0107emo prethodni odgovor za \\(A_i...A_{j-1}\\). Preciznije, ako znamo da se cifra \\(c\\) pojavljuje u podnizu \\(A_i...A_{j-1}\\), potrebno je proveriti samo jo\u0161 element \\(A_j\\). Lako se proverava da li \\(A_j\\) sadr\u017ei cifru \\(c\\) (mo\u017eemo unapred odrediti skup cifara za svaki \u010dlan niza \\(A\\), ili pro\u0107i u tom trenutku kroz sve cifre, \u0161to je sporija opcija) i na osnovu prethodnog odgovora imamo i slede\u0107i. Dakle, fiksiramo cifru \\(c\\) i levu granicu intervala \\(l\\), pa se kre\u0107emo na desno dokle god se cifra \\(c\\) jo\u0161 uvek nalazi u elementima. Vremenska slo\u017eenost: \\(O(maxC\\cdot N^2)\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Potrebno je na\u0107i najdu\u017ei podniz jednakih elemenata. To radimo slede\u0107im algoritmom:  Podesimo broja\u010d na \\(1\\). Idemo redom od po\u010detka do kraja niza. Ako je trenutni element jednak prethodnom, pove\u0107avamo broja\u010d za \\(1\\). U suprotnom ga resetujemo na \\(1\\). Re\u0161enje zadatka je maksimalna vrednost broja\u010da u bilo kom trenutku.  Vremenska slo\u017eenost: \\(O(N)\\), memorijska slo\u017eenost: \\(O(N)\\) ili \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/okr/04_tajna_prostorija/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Postavi\u0107emo isto pitanje kao u drugom podzadatku: \"Da li je cifra \\(c\\) prisutna u svakom elementu podniza \\(A_i...A_j\\)?\", ali \u0107emo koristiti sli\u010dan algoritam kao iz tre\u0107eg podzadatka i to paralelno nad \\(10\\) razli\u010ditih nizova nula i jedinica. Te nizove ne pravimo fizi\u010dki, ve\u0107 ih zami\u0161ljamo na slede\u0107i na\u010din: \\(i\\)-ti \u010dlan u \\(c\\)-tom nizu ozna\u010dava da li element \\(A_i\\) sadr\u017ei cifru \\(c\\). Podniz jedinica \\([i,j]\\) u nekom takvom nizu ozna\u010dava da \\(A_iA_{i+1}...A_j\\) imaju zajedni\u010dku cifru.  Efikasna implementacija dovodi do vremencke slo\u017eenosti \\(O(maxC\\cdot N)\\), memorijske \\(O(maxC)\\).</p> 04_tajna_prostorija.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint n;\nint a[1000005];\nint has[1000005][10];\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i) {\n        scanf(\"%d\", &amp;a[i]);\n        int x = a[i];\n        while (x &gt; 0) {\n            has[i][x % 10] = true;\n            x /= 10;\n        }\n    }\n\n    int res = 1;\n    for (int dig = 0; dig &lt; 10; ++dig) {\n        int cur = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            if (has[i][dig]) ++cur;\n            else {\n                res = max(res, cur);\n                cur = 0;\n            }\n        }\n        res = max(res, cur);\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/okr/05_faraon/","title":"A2 - Faraon","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>Prema istori\u010darima, u staroj egipatskoj dr\u017eavi, faraoni su morali da doka\u017eu predstavnicima plemena da su dovoljno sna\u017eni da vode dr\u017eavu tako \u0161to su pred njima morali da se bore sa bikom i da mu i\u0161\u010dupaju rep. Me\u0111utim, manje poznato je da su faraoni morali da doka\u017eu i da su dovoljno pametni re\u0161avaju\u0107i drevni matemati\u010dki zadatak.</p> <p>U drevnom matemati\u010dkom zadatku su postavljena dva broja \\(p\\) i \\(q\\). Faraon je morao da odgovori u koliko najmanje specijalnih matemati\u010dkih operacija mo\u017ee od broja p da se dobije broj q. Specijalne matemati\u010dke operacije su slede\u0107e:</p> <ul> <li>Broj \\(t\\) mo\u017ee da se pomno\u017ei bilo kojim prostim brojem \\(r\\), kako bi se dobio broj \\(t \u00b7 r\\)</li> <li>Broj \\(t\\) mo\u017ee da se podeli bilo kojim prostim brojem \\(r\\) koji deli \\(t\\), kako bi se dobio broj \\(t/r\\).</li> </ul> <p>Naravno, faraon je znao da su prosti brojevi oni prirodni brojevi ve\u0107i od 1 koji su deljivi samo sa 1 i samim sobom. Kako bi mu ote\u017eali posao, predstavnik svakog plemena mu zadaje nove brojeve \\(p\\) i \\(q\\), i faraon mora ta\u010dno da odgovori na svaki zadati par brojeva. Istori\u010dari su prona\u0161li stari zapis na kojem su zapisani postavljeni brojevi faraonu i znaju\u0107i da je faraon dokazao da je pametan (odgovorio je ta\u010dno na sva pitanja) va\u0161 zadatak je da prona\u0111ete faraonove odgovore za svaki par postavljenih brojeva \\(p\\) i \\(q\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Demjan Grubi\u0107 Demjan Grubi\u0107 Mladen Puzi\u0107 Dimitrije Erdeljan <p>Ozna\u010dimo sa \\(d\\) najve\u0107i zajedni\u010dki delilac brojeva \\(p\\) i \\(q\\). Prvo \u0107emo broj \\(p\\) podeliti sa \\(p/d\\), tako da dobijemo broj \\(d\\), pa ga pomno\u017eiti sa \\(q/d\\), tako da dobijemo \\(q\\). To, naravno, radimo jednim po jednim prostim brojem. Tako dobijamo \\(q\\) od \\(p\\), a optimalno je, jer nema potrebe da dalje delimo \\(p\\) nakon \u0161to ga spustimo do \\(d\\).</p> <p>Ostaje nam samo da efikasno faktori\u0161emo brojeve \\(p/d\\) i \\(q/d\\) i tako izbrojimo broj koraka koji su nam potrebni (\u0161to je zbir eksponenata u kanonskoj faktorizaciji tih brojeva).</p>"},{"location":"takprog/2015_2016/okr/05_faraon/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza \u0107e se nalaziti ceo broj \\(N\\) koji ozna\u010dava broj plemena (broj postavljenih pitanja). U narednih \\(N\\) redova \u0107e se nalaziti po dva cela broja \\(p\\) i \\(q\\).</p>"},{"location":"takprog/2015_2016/okr/05_faraon/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz potrebno je ispisati \\(N\\) redova gde se u \\(k\\)-tom redu nalazi odgo- vor faraona na \\(k\\)-to pitanje iz ulaza.</p>"},{"location":"takprog/2015_2016/okr/05_faraon/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/05_faraon/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 1\n16 2\n2 3\n3 9\n6 10\n</code></pre>"},{"location":"takprog/2015_2016/okr/05_faraon/#izlaz","title":"Izlaz","text":"<pre><code>0\n3\n2\n1\n2\n</code></pre>"},{"location":"takprog/2015_2016/okr/05_faraon/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \u2264 N \u2264 10^6\\)</li> <li>\\(1 \u2264 p, q \u2264 10^6\\)</li> </ul>"},{"location":"takprog/2015_2016/okr/05_faraon/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei \\(N \u2264 10^4\\).</li> <li>U test primerima vrednim 40 poena va\u017ei \\(p, q \u2264 10^5\\).</li> <li>U test primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/05_faraon/#resenje-za-n-leq-104","title":"Re\u0161enje za \\(N \\leq 10^4\\)","text":"<p>Po\u0161to je \\(N\\) malo, mo\u017eemo manje efikasno faktorisati brojeve. Konkretno, mo\u017eemo to uraditi u slo\u017eenosti \\(O(\\sqrt x)\\), za broj \\(x\\) koji faktori\u0161emo. To mo\u017eemo uraditi tako \u0161to \u0107emo pro\u0107i redom kroz sve brojeve od \\(2\\) do \\(\\lfloor \\sqrt x \\rfloor\\) i deliti broj \\(x\\) njima dokle god je mogu\u0107e. Ovako \u0107emo ga uvek deliti prostim faktorima, jer kad do\u0111emo do slo\u017eenog broja, nijedan njihov prosti \u010dinilac vi\u0161e ne\u0107e deliti \\(x\\). Ukoliko nam ostane broj koji je ve\u0107i od \\(1\\) i taj broj je prost faktor broja \\(x\\) (ovo je ta\u010dno jer broj \\(x\\) mo\u017ee imati najvi\u0161e jedan prost faktor koji je ve\u0107i od \\(\\lfloor \\sqrt x \\rfloor\\)). Ukupno \u0107e prostih faktora biti najvi\u0161e \\(\\lceil \\log_2{x} \\rceil\\), pa deljenje njima ne uti\u010de na slo\u017eenost.</p> <p>Vremenska slo\u017eenost je \\(O(N\\cdot (\\sqrt p + \\sqrt q)\\)), a memorijska \\(O(1)\\).</p>"},{"location":"takprog/2015_2016/okr/05_faraon/#resenje-za-p-q-leq-105","title":"Re\u0161enje za \\(p, q \\leq 10^5\\)","text":"<p>Koristi\u0107emo istu faktorizaciju kao u prethodnom re\u0161enju, samo \u0161to \u0107emo, pre nego \u0161to odgovorimo na bilo koje pitanje, izra\u010dunati broj prostih faktora svih brojeva od \\(1\\) do \\(M\\) (u ovom slu\u010daju \\(M = 10^5\\)). Nakon toga koristimo te informacije kako bismo u \\(O(1)\\) odgovorili na svako pitanje.</p> <p>Vremenska slo\u017eenost je \\(O(N\\log M + M \\sqrt {M})\\), a memorijska \\(O(M)\\).</p>"},{"location":"takprog/2015_2016/okr/05_faraon/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Potrebno je da faktorizaciju uradimo efikasnije. Koristimo modifikovano Eratostenovo sito, po\u0161to su nam brojevi do \\(10^6\\), da pre svih pitanja izra\u010dunamo slede\u0107e:  - za svaki broj \\(x\\) od \\(1\\) do \\(M\\), koji je najmanji prost broj koji deli \\(x\\)?</p> <p>Kada nai\u0111emo na prost broj, za sve njegove mno\u017eioce proveri\u0107emo da li oni ve\u0107 imaju manjeg prostog delioca. Ukoliko ne, onda je u pitanju na\u0161 trenutni prost broj. Kada imamo ovu informaciju, zbir eksponenata u kanonskoj faktorizaciji \\(x\\) je samo broj koraka koji nam je potreban da dovedemo \\(x\\) do \\(1\\), uvek ga dele\u0107i sa njegovim najmanjim prostim deliocem. Tih koraka \u0107e biti najvi\u0161e \\(\\lceil \\log_2{x} \\rceil\\).</p> <p>Vremenska slo\u017eenost je \\(O(maxPQ \\log maxPQ + N log)\\)</p> 05_faraon.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nusing namespace std;\n\nconst int MaxNumber = 1000000;\n\nint T, p, q;\n\nint sqrtMaxNumber;\nint smallestDivisor[MaxNumber+5];\nint dp[MaxNumber+5];\n\nint gcd(int a, int b)\n{\n    while (b) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nint main()\n{\n    memset(smallestDivisor, -1, sizeof(smallestDivisor));\n    sqrtMaxNumber = int(sqrt(MaxNumber)) + 1;\n\n    smallestDivisor[1] = -1;\n    for (int number = 2; number &lt;= sqrtMaxNumber; ++number) {\n        if (smallestDivisor[number] != -1) continue;\n\n        smallestDivisor[number] = number;\n        for (int curr = number * number; curr &lt;= MaxNumber; curr += number) {\n            if (smallestDivisor[curr] == -1) smallestDivisor[curr] = number;\n        }\n    }\n    for (int i = sqrtMaxNumber; i &lt;= MaxNumber; ++i) {\n        if (smallestDivisor[i] == -1) smallestDivisor[i] = i;\n    }\n\n    dp[1] = 0;\n    for (int number = 2; number &lt;= MaxNumber; ++number) {\n        int previousNumber = number / smallestDivisor[number];\n        dp[number] = dp[previousNumber] + 1;\n    }\n\n    scanf(\"%d\",&amp;T);\n    for (;T--;) {\n        scanf(\"%d%d\",&amp;p,&amp;q);\n        int result = dp[p] + dp[q] - 2 * dp[gcd(p,q)];\n        printf(\"%d\\n\",result);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/okr/06_zid/","title":"A3 - Zid","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Nalazimo se u godini 80. pre nove ere. Cela Galija je pod vla\u0161\u0107u Rimljana... Osim \\(N\\) sela, koja se jo\u0161 uvek uspe\u0161no odupiru. Posle puno poku\u0161aja, Rimljani su odustali od osvajanja svih sela. Odlu\u010dili su da \u0107e napraviti veliki zid, koji \u0107e odvojiti neka sela od njihove teritorije, a zatim osvojiti preostala.</p> <p>Za svako selo je poznata njegova pozicija \\((X_i, Y_i)\\) (u kilometrima) i cena opremanja vojske (u zlatnicima) dovoljne da ga osvoji \\(W_i\\). Rimska vojna taktika je toliko dobra da pri ovome ne o\u010dekuju gubitke \u2013 za osvajanje vi\u0161e sela cena opremanja vojske jednaka je najve\u0107oj ceni za pojedina\u010dna sela.</p> <p>Na primer, ukoliko van zida ostanu tri sela, sa \\(W_i\\) = 50, 20, 30, neophodna vojska \u0107e ko\u0161tati 50 zlatnika. Zid mora biti pravougaonog oblika, sa stranicama paralelnim koordinatnim osama i centrom u \\((0, 0)\\) (niko nije rekao za\u0161to, ali sigurno postoji dobar razlog). Jedan kilometar zida ko\u0161ta \\(C\\) zlatnika. Mogu\u0107e je napraviti zid koji je po jednoj ili obe dimenzije veoma kratak i ogra\u0111uje samo sela na odgovaraju\u0107oj osi \u2013 u tom slu\u010daju, smatra se da je du\u017eina \u201ckratke\u201d stranice zida 0 (npr. da bi se ogradila sela na \\((0, 1)\\) i \\((0, 1)\\), dovoljan je zid sa stranicama du\u017eine 2 i \u201czanemarljivo malo\u201d, sa ukupnom du\u017einom 4). Va\u0161e zadu\u017eenje je da odredite najmanju cenu za koju je mogu\u0107e ostvariti ovaj plan (sagraditi zid i osvojiti sva sela van zida).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Jovanovi\u0107 Ivan Sto\u0161i\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Milosavljevi\u0107"},{"location":"takprog/2015_2016/okr/06_zid/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza \u0107e se nalaziti dva cela broja \\(N\\) i \\(C\\), koji ozna\u010davaju redom broj sela i cenu kilometra zida.</p> <p>U narednih \\(N\\) redova \u0107e se nalaziti po tri cela broja \\(X_i\\), \\(Y_i\\), \\(W_i\\), koji ozna\u010davaju redom koordinate i cenu osvajanja sela (u redu \\(i\\) + 1 \u0107e se nalaziti podaci za \\(i\\)-to selo).</p>"},{"location":"takprog/2015_2016/okr/06_zid/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati jedan broj \u2013 minimalan broj zlatnika koje je neophodno potro\u0161iti da bi se plan ostvario.</p>"},{"location":"takprog/2015_2016/okr/06_zid/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2015_2016/okr/06_zid/#ulaz","title":"Ulaz","text":"<pre><code>4 2\n2 -1 12\n3 2 60\n-5 -5 6\n562\n</code></pre>"},{"location":"takprog/2015_2016/okr/06_zid/#izlaz","title":"Izlaz","text":"<pre><code>46\n</code></pre>"},{"location":"takprog/2015_2016/okr/06_zid/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2015_2016/okr/06_zid/#ulaz_1","title":"Ulaz","text":"<pre><code>2 10\n005\n111\n</code></pre>"},{"location":"takprog/2015_2016/okr/06_zid/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2015_2016/okr/06_zid/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^6\\)</li> <li>\\(1 \\leq C \\leq 200\\)</li> <li>\\(106 \\leq X_i, Y_i \\leq 10^6\\)</li> <li>\\(0 \\leq W_i \\leq 10^6\\)</li> </ul>"},{"location":"takprog/2015_2016/okr/06_zid/#napomena","title":"Napomena","text":"<p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei \\(N \\leq  100, 100 \\leq  X_i, Y_i \\leq  100\\).</li> <li>U test primerima vrednim 20 poena va\u017ei \\(N \\leq  10^3\\) i sva sela su na \\(x\\)-osi \\((Y_i = 0)\\).</li> <li>U test primerima vrednim 30 poena va\u017ei \\(N \\leq  10^3\\).</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2015_2016/okr/06_zid/#obzervacija","title":"Obzervacija:","text":"<p>Ako jedno teme pravougaonog zida ima koordinate \\((x,y)\\), onda ostala imaju \\((x,-y)\\), \\((-x,y)\\) i \\((-x,-y)\\). Zbog simetrije, zadatak mo\u017eemo re\u0161avati samo u prvom kvadrantu: uze\u0107emo apsolutnu vrednost koordinata svih sela, a zid \u0107e pokrivati sva sela u pravougaoniku sa temenima \\((0,0)\\), \\((x,0)\\), \\((0,y)\\) i \\((x,y)\\) i njegova cena \u0107e biti \\(4C\\cdot (x+y)\\). Selo \\(i\\) pripada zidu akko \\(X_i\\leq x\\) i \\(Y_i\\leq y\\).</p>"},{"location":"takprog/2015_2016/okr/06_zid/#podzadatak-1","title":"Podzadatak 1:","text":"<p>U ovom podzadatku mo\u017eemo izgraditi svaki mogu\u0107i zid jer ih ima dovoljno malo i proveriti za svako selo da li je u njemu, i na osnovu toga da izra\u010dunamo cenu izgradnje zida i osvajanja svih ostalih. Ako je \\(M=max(max|X_i|,max|Y_i|)\\), zidova koje proveravamo ima najvi\u0161e \\((M+1)^2\\), a ukupna slo\u017eenost je \\(O(M^2\\cdot N)\\).</p>"},{"location":"takprog/2015_2016/okr/06_zid/#podzadatak-2","title":"Podzadatak 2:","text":"<p>\\(X\\) koordinate sela se mogu pore\u0111ati u sortiran niz i potrebno je izgraditi \"prefiks\" \u010dija cena linearno zavisi od njegove du\u017eine i na tu cenu dodati sufiksni maksimum (najskuplje selo za osvojiti van tog prefiksa)  koji smo ranije izra\u010dunali za svako selo. Primetimo da je u ovom slu\u010daju optimalno graditi zid sa krajem u selu. Slo\u017eenost je \\(O(NlogN)\\) ili \\(O(N+M)\\) zbog sortiranja.</p>"},{"location":"takprog/2015_2016/okr/06_zid/#podzadatak-3","title":"Podzadatak 3:","text":"<p>Selo sa koordinatama \\((X_i,Y_i)\\) mo\u017eemo razlo\u017eiti na dva sela sa \\((X_i,0)\\) i \\((0,Y_i)\\). Nije te\u0161ko videti da se oba \"razlo\u017eena\" sela moraju osvojiti kako se njegova cena ne bi ura\u010dunala u maksimum, samim tim je ovo ekvivalentan zadatak. Sada imamo dva  soritrana niza (\"horizontalna\" i \"vertikalna\" sela). Gradimo zid koji ima koordinate me\u0111u ovim razlo\u017eenim selima, njih ima \\(O(N^2)\\) i u cenu osvajanja ra\u010dunamo sufiksne maksimume ova dva niza za efikasno re\u0161enje.</p>"},{"location":"takprog/2015_2016/okr/06_zid/#podzadatak-4","title":"Podzadatak 4","text":"<p>Pretpostavimo da pla\u0107amo \\(Z\\) zlatnika za osvajanje sela van zida. Preostaje nam samo da ogradimo sela sa ve\u0107om cenom. To mo\u017eemo raditi jednim opadaju\u0107im prolaskom po svim vrednostima \\(Z\\) tako \u0161to nakon izgradnje zida za odre\u0111enu vrednost i nakon ra\u010dunanja cene dodamo sva sela sa tom istom cenom u zid (kako bismo garantovali da vi\u0161e ne pla\u0107amo za njih); ako je ono van, onda jednostavno promenimo dimenzije zida najmanje \u0161to mo\u017eemo tako da ono bude unutar (drugim re\u010dima, postavljamo \\(x=max(x,X_i)\\) i \\(y=max(y,Y_i)\\)). Koriste\u0107i counting sort dobijamo slo\u017eenost \\(O(N+max(W_i))\\).</p> 06_zid.cpp<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct Selo {\n    int x, y, w;\n};\n\nvector&lt;Selo&gt; sela[1000002];\nint C; // cena kilometra zida\n\nvoid ucitaj(){\n    int N;\n    cin &gt;&gt; N &gt;&gt; C;\n    while (N--){\n        Selo novo;\n        cin &gt;&gt; novo.x &gt;&gt; novo.y &gt;&gt; novo.w;\n        sela[novo.w].push_back(novo);\n    }\n}\n\nint aps(int x){\n    return x &gt; 0 ? x : -x;\n}\n\nint resi(){\n    int xmax = 0, ymax = 0, obim = 0, resenje = 1e9;\n\n    for (int d=1000000; d&gt;=0; d--){\n        for (unsigned i=0; i&lt;sela[d+1].size(); i++){\n            xmax = max(xmax, aps(sela[d+1][i].x));\n            ymax = max(ymax, aps(sela[d+1][i].y));\n            obim = 4*(xmax+ymax);\n        }\n        resenje = min(resenje, C*obim + d);\n    }\n    return resenje;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    ucitaj();\n    cout &lt;&lt; resi() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/","title":"1 - Ma\u0111arski krug","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 32MB <p>Erno Rubik je poznati ma\u0111arski izumitelj i arhitekta, najpoznatiji po tzv. Rubikovoj kocki. Me\u0111utim, malo je poznato da je on tako\u0111e izumeo krug, koji \u0107emo zvati \u201cma\u0111arski krug\u201d. To je logi\u010dka zagonetka u kojoj treba odrediti udaljenost izme\u0111u dve najbli\u017ee i dve najdalje ta\u010dke na kru\u017enici i to uraditi u \u0161to manjem broju pogleda na krug.</p> <p>Igra\u010d ove zagonetke u jednom pogledu na krug mo\u017ee da sazna rastojanje izme\u0111u neke dve ta\u010dke na krugu - rastojanje se defini\u0161e kao du\u017eina najkra\u0107eg puta od jedne do druge ta\u010dke, pri \u010demu je dozvoljeno samo kretanje po obimu kruga. Sve ta\u010dke se, naravno, nalaze na obimu i nikoje dve ta\u010dke nisu na istoj poziciji.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 i Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Mladen Puzi\u0107 -"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju \\(Resi(N, L, H)\\) gde je \\(N\\) broj ta\u010daka u zagonetki, \\(L\\) adresa promenljive u koju treba upisati tra\u017eeno minimalno rastojanje i \\(H\\) adresa promenljive u koju treba upisati tra\u017eeno maksimalno rastojanje. Na raspolaganju vam je i funkcija \\(Rastojanje(u, v)\\) koja vra\u0107a rastojanje izme\u0111u ta\u010daka sa indeksima \\(u\\) i \\(v\\). Ta\u010dke su indeksirane brojevima od 0 do \\(N \u2212 1\\).</p>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#primer","title":"Primer","text":"<p>Neka je \\(N = 4\\). Neka je rastojanje od ta\u010dke 2 do ta\u010daka 0, 1 jednako 2 a rastojanje od ta\u010dke 3 do ta\u010daka 0, 1 jednako 10. Mo\u017ee se zaklju\u010diti da su ta\u010dke 2 i 3 na razli\u010ditim stranama u odnosu na pravu koja spaja 0 i 1, kao i da je tetiva 2 \u2212 3 pre\u010dnik kruga. Najve\u0107a udaljenost je onda jednaka polovini obima, odnosno 12 a najmanja je 2.</p>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \u2264 N \u2264 100,000\\)</li> <li>Obim kruga je najvi\u0161e \\(10^9\\)</li> </ul>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u dva podzadatka, u kojima va\u017ee slede\u0107a dodatna ograni\u010denja</p> <ul> <li>PODZADATAK 1 [30 POENA]: \\(N \u2264 1000\\)</li> <li>PODZADATAK 2 [70 POENA]: Nema dodatnih ograni\u010denja U zavisnosti od broja poziva funkciji Rastojanje (ozna\u010dimo ovaj broj sa \\(K\\)), za svaki podzadatak dobija se slede\u0107i procenat poena:</li> <li>[100 %]: Ako je u svakom test primeru \\(K \u2264 2N\\)</li> <li>[60 %]: Ako je u svakom test primeru \\(K \u2264 4N\\)</li> <li>[30 %]: Ako je u svakom test primeru \\(K \u2264 30N\\)</li> <li>[10 %]: Ukoliko nijedno od prethodnih ograni\u010denja nije ispo\u0161tovano</li> </ul>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom krug.c, krug.cpp ili krug.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke. Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika: C/C++ void \\(Resi\\)(int \\(N\\), int \\(L\\), int \\(H\\)) Pascal procedure \\(Resi\\)(\\(N\\) : longint; var \\(L, H\\) : longint);</p> <p>Funkcija Rastojanje bi\u0107e slede\u0107eg oblika: C/C++ int \\(Rastojanje\\)(int \\(u\\), int \\(v\\)) Pascal function \\(Rastojanje\\)(\\(u, v\\) : longint) : longint</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajla staviti #include \u201ckrug.h\u201d a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti Unit krug; (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam template fajlovi (krug.c, krug.cpp, krug.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza broj \\(N\\), zatim pozivaju va\u0161u funkciju \\(Resi\\). Svaki put kada se pozove funkcija \\(Rastojanje\\) na standardni izlaz ispi\u0161u se parametri \\(u, v\\) poziva te funkcije, a nakon toga na standardni ulaz treba uneti tra\u017eeno rastojanje. Po izlasku iz funkcije \\(Resi\\) ispisuju se vrednosti \\(L, H\\).</p>"},{"location":"takprog/2015_2016/sio/01_madjarski_krug/#resenje","title":"Re\u0161enje","text":"<p>Koriste\u0107i \\(N-1\\) poziv funkciji na\u0111imo rastojanje od ta\u010dke \\(0\\) do svih ostalih ta\u010daka. Ta\u010dka koja je najbli\u017ea ta\u010dki \\(0\\) mora joj biti susedna, bez umanjenja op\u0161tosti, re\u0107i \u0107emo da je to ta\u010dka \\(1\\). Koriste\u0107i jo\u0161 \\(N-2\\) poziva funkciji na\u0111imo rastojanje svih ta\u010daka (sem \\(0\\) i \\(1\\)) od ta\u010dke \\(1\\). </p> <p>Sada krug mo\u017eemo podeliti u dve grupe: na one ta\u010dke koje su bli\u017ee ta\u010dki \\(0\\) i one koje su bli\u017ee ta\u010dki \\(1\\). Te ta\u010dke sada mo\u017eemo sortirati po rastojanju od svoje odgovaraju\u0107e ta\u010dke, i samim tim, na\u0107i redosled ta\u010daka na krugu. Tako\u0111e, znamo rastojanje svake dve susedne ta\u010dke, sem za jedan par: ta\u010dku iz prve grupe koja je najdalja od ta\u010dke \\(1\\) (nazovimo ovu ta\u010dku \\(A\\) za dalje potrebe) i ta\u010dku iz druge grupe koja je najdalja od ta\u010dke \\(1\\) (nazovimo ovu ta\u010dku \\(B\\) za dalje potrebe). Za taj par \u0107emo iskoristiti jo\u0161 jedan poziv funkciji, tako da smo ukupno iskoristili \\(2N-2\\) poziva. </p> <p>Najmanje rastojanje \u0107e sigurno biti jedno od rastojanja susednih ta\u010daka, tako da to ve\u0107 mo\u017eemo da izra\u010dunamo. Za najve\u0107e rastojanje nam je potrebno jo\u0161 obzervacija. Potrebno je da na\u0111emo obim kruga. </p> <p>Ukoliko se ta\u010dke ne nalaze sve na istom polukrugu, obim je jednak \\(Rastojanje(0, 1)\\)+\\(Rastojanje(0, A)\\)+\\(Rastojanje(1, A)\\)+\\(Rastojanje(A, B)\\) (za ovo ne moramo pozivati funkciju, sva ova rastojanja ve\u0107 imamo). Ukoliko se nalaze, mo\u017eemo pretpostaviti da je \\(Rastojanje(A, B)\\) poluobim, \u010dime ne kvarimo nijedno rastojanje (ovo nije neophodno, ostatak re\u0161enja mo\u017eemo posmatrati kroz dva slu\u010daja, ali je ovako lak\u0161e za implementaciju).  </p> <p>Sada kada imamo obim, mo\u017eemo da na\u0111emo rastojanje izme\u0111u bilo koje dve ta\u010dke bez da pozivamo na\u0161u funkciju. Za svaku ta\u010dku iz prve grupe mo\u017eemo binarnom ili ternarnom pretragom na\u0107i najdalju ta\u010dku u slo\u017eenosti \\(O(logN)\\),  i za kraj uzmemo najdalji par. </p> 01_madjarski_krug.cpp<pre><code>#include \"krug.h\"\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint d0[100005], dx[100005], p[200005];\n\nvoid Resi(int N, int* L, int* H){\n    for (int i=1; i&lt;N; i++) d0[i] = Rastojanje(0, i);\n    int m=1;\n    for (int i=1; i&lt;N; i++) if (d0[i] &lt; d0[m]) m = i;\n    for (int i=1; i&lt;N; i++) if (i!=m) dx[i] = Rastojanje(m, i);\n    p[0] = 0;\n    p[m] = d0[m];\n    int lm = 0, rm = m;\n    for (int i=1; i&lt;N; i++) if (i!=m){\n        if (d0[i] &lt; dx[i]){\n            p[i] = -d0[i];\n            if (p[i] &lt; p[lm]) lm = i;\n        } else {\n            p[i] = dx[i] + d0[m];\n            if (p[i] &gt; p[rm]) rm = i;\n        }\n    }\n\n    int obim = p[rm] - p[lm] + Rastojanje(lm, rm);\n    sort(p, p+N);\n    for (int i=0; i&lt;N; i++) p[i+N] = p[i] + obim;\n    *L = obim;\n    *H = 0;\n    for (int i=0; i&lt;N; i++) if (p[i+1] - p[i] &lt; *L) *L = p[i+1] - p[i];\n    int j = 0;\n    for (int i=0; i&lt;N; i++){\n        while (p[j+1] - p[i] &lt;= obim/2) j++;\n        if (p[j] - p[i] &gt; *H) *H = p[j] - p[i];\n    }\n}\n</code></pre>"},{"location":"takprog/2015_2016/sio/02_igra/","title":"2 - Igra","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 600ms 256MB <p>Malo ko zna da su Nikola Tesla i Albert Ajn\u0161tajn bili jako dobri prijatelji. Svake nedelje je jedan od njih postavljao zagonetke drugome. Ovoga puta je do\u0161ao red na Alberta da postavi zagonetku. On je zadao zagonetku u obliku igre.</p> <p>Da bi se igrala igra potrebna je tabla na kojoj se nalazi \\(N\\) polja koja su numerisana brojevima od 1 do \\(N\\) . Ta polja su povezana uz pomo\u0107 \\(M\\) puteva, gde svaki put povezuje neka dva polja. Tabla je takva da je mogu\u0107e krenuti iz bilo kog \u010dvora i koriste\u0107i date puteve do\u0107i do bilo kog drugog \u010dvora. Na po\u010detku igre, svaka od \\(K\\) figurica (ozna\u010dene brojevima od 1 do \\(K\\)) se postavi na njeno po\u010detno polje i tako\u0111e se za svaku od tih figurica obele\u017ei i krajnje polje, tj. polje gde ta figurica mora da se na\u0111e na kraju igre.</p> <p>U jednom potezu, Tesla mora da pomeri svaku figuricu sa polja gde se ta figurica nalazi na neko susedno polje. Dva polja su susedna ukoliko me\u0111u datih \\(M\\) puteva, postoji put koji spaja ta dva polja. Na jednom polju u isto vreme mo\u017ee da se nalazi vi\u0161e figurica. Poenta igre je da se sve figurice u isto vreme na\u0111u na njihovim krajnjim pozicijama. Primetimo da ukoliko je neka figurica pre kraja na svojoj krajnjoj poziciji, ona u slede\u0107em potezu mora da se pomeri sa te pozicije.</p> <p>Dobro je poznato da su njih dvojica ra\u010dunali dane druga\u010dije nego \u0161to smo navikli, njihovih nedelju dana je trajalo \\(D\\) dana, umesto nama dobro poznatih 7.</p> <p>Prvi dan u njihovoj nedelji, Albert je poslao postavku igre Tesli, tj. tablu i obele\u017eena po\u010detna i krajnja polja za svaku figuricu. Postavio mu je uslov da svaki dan mora da odigra ta\u010dno jedan potez i tra\u017eio je od njega da mu ka\u017ee za svaki dan u njihovoj nedelji koji je najmanji broj poteza (dana) koje Tesla mora da odigra kako bi sve figurice bile na svojim krajnjim pozicijama ba\u0161 na taj dan u nedelji.</p> <p>Dobili ste postavku igre i znate da je Tesla uspe\u0161no dao odgovor za svaki dan u njihovoj nedelji. Va\u0161 zadatak je da otkrijete koje je odgovore Tesla poslao Ajn\u0161tajnu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Demjan Grubi\u0107 Demjan Grubi\u0107 Aleksandar Vi\u0161nji\u0107 Boris Grubi\u0107"},{"location":"takprog/2015_2016/sio/02_igra/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju</p> \\[ Igra(N,M,K,D,U[...],V[...],S[...],F[...],R[...]) \\] <p>gde je:</p> <ul> <li>\\(N\\) \u2013 broj polja na tabli</li> <li>\\(M\\) \u2013 broj puteva izme\u0111u polja</li> <li>\\(K\\) \u2013 broj figurica na tabli</li> <li>\\(D\\) \u2013 broj dana u Albertovoj i Nikolinoj nedelji</li> <li>\\(U\\) i \\(V\\) \u2013 nizovi du\u017eine \\(M\\), gde znamo da su polja ozna\u010dena brojevima \\(U_i\\) i \\(V_i\\) povezana putem na tabli</li> <li>\\(S\\) i \\(F\\) \u2013 nizovi du\u017eine \\(K\\), gde \\(i\\)-ti elementi niza ozna\u010davaju redni broj po\u010detnog i krajnjeg polja za \\(i\\)-tu figuricu, redom.</li> </ul> <p>Funkciji se tako\u0111e prosle\u0111uje i parametar \\(R\\) koji predstavlja niz du\u017eine \\(D\\), kroz koji treba da vratite va\u0161e re\u0161enje. Po zavr\u0161etku funkcije, i-ti element niza \\(R\\) treba da ima vrednost minimalnog broja dana (poteza) tako da sve figurice budu na svojim krajnjim pozicijama na dan i u nedelji. Ukoliko za neki dan u nedelji nije mogu\u0107e da se sve figurice na\u0111u na istom mestu, re\u0161enje za taj dan treba da bude -1.</p> <p>Svi nizovi su indeksirani od 0, \u0161to zna\u010di da je prvi element nizova onaj sa indeksom 0. Voditi ra\u010duna da po\u0161to su svi nizovi indeksirani od 0, \\(R_0\\) treba da predstavlja re\u0161enje za dan 1, \\(R_1\\) za dan 2, itd...</p>"},{"location":"takprog/2015_2016/sio/02_igra/#primer","title":"Primer:","text":"<p>Neka postoji \\(N=6\\) polja, povezana uz pomo\u0107 \\(M=7\\) puteva koji su opisani uz pomo\u0107 nizova \\(U=\\{1,1,2,3,4,4,5\\}\\) i \\(V=\\{2,3,4,4,5,6,6\\}\\). Neka postoji \\(K=2\\) figurice gde su po\u010detne i krajnje pozicije date uz pomo\u0107 nizova \\(S=\\{1,4\\}\\) i \\(F=\\{2,5\\}\\), i neka nedelja traje \\(D=3\\) dana. Na slici ispod mo\u017eete videti prikaz takve table.</p> <p></p> <p>Prva figurica po\u010dinje na polju 1 i treba da zavr\u0161i na polju 2, dok druga figurica po\u010dinje na polju 4 i treba da zavr\u0161i na polju 5.</p> <p>Nedelja ima 3 dana i za svaki od tih dana treba da ispi\u0161emo najmanji broj poteza da bi obe figurice bile na krajnjim pozicijima ba\u0161 na taj dan u nedelji.</p> <ul> <li>Dan 1 - najmanji broj poteza je 3. Jedno mogu\u0107e re\u0161enje je da prva figurica pravi \u0161etnju: polje 1 (dan 1) polje 3 (dan 2) polje 4 (dan 3) polje 2 (dan 1), dok druga pravi \u0161etnju: polje 4 (dan 1) polje 6 (dan 2) polje 4 (dan 3) polje 5 (dan 1). </li> <li>Dan 2 - najmanji broj poteza je 1. Jedno mogu\u0107e re\u0161enje je da prva figurica pravi \u0161etnju: polje 1 (dan 1) polje 2 (dan 2), dok druga pravi \u0161etnju: polje 4 (dan 1) polje 5 (dan 2). </li> <li>Dan 3 - najmanji broj poteza je 5. Jedno mogu\u0107e re\u0161enje je da prva figurica pravi \u0161etnju: polje 1 (dan 1) polje 3 (dan 2) polje 4 (dan 3) polje 3 (dan 1) polje 4 (dan 2) polje 2 (dan 3), a druga \u0161etnju: polje 4 (dan 1) polje 6 (dan 2) polje 4 (dan 3) polje 6 (dan 1) polje 4 (dan 2) polje 5 (dan 3).</li> </ul>"},{"location":"takprog/2015_2016/sio/02_igra/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\u2264N\u22641000\\)</li> <li>\\(1\u2264M\\leq 100.000\\)</li> <li>\\(1\u2264K\u2264100\\)</li> <li>\\(1\u2264D\u22641000\\)</li> <li>\\(1\u2264U_i,V_i \\leq N\\), za svako \\(0\u2264i \\leq M\\)</li> <li>\\(1\u2264S_i,F_i \\leq N\\), za svako \\(0\u2264i \\leq K\\)</li> </ul>"},{"location":"takprog/2015_2016/sio/02_igra/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li>PODZADATAK 1 [10 POENA]: Izme\u0111u svaka dva polja na tabli postoja\u0107e ta\u010dno jedan put (dato je stablo) i va\u017ei \\(K=1\\).</li> <li>PODZADATAK 2 [15 POENA]: Izme\u0111u svaka dva polja na tabli postoja\u0107e ta\u010dno jedan put (dato je stablo).</li> <li>PODZADATAK 3 [25 POENA]: \\(D\u226410,K\u226410\\) i \\(D\\) je paran broj.</li> <li>PODZADATAK 4 [10 POENA]: \\(D\u226410,K\u226410\\)</li> <li>PODZADATAK 5 [40 POENA]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2015_2016/sio/02_igra/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom igra.c, igra.cpp ili igra.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <p>C/C++ void Igra(int N, int M, int K, int D, int U, int V, int S, int F, int* R);</p> <p>Pascal procedure Igra(N, M, K, D : longint; var U, V, S, F, R : array of longint);</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajla staviti #include \u201cigra.h\u201d a ukoliko radite u Pascal-u, potrebno je na po\u010detku fajla staviti Unit igra; (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/02_igra/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (igra.c, igra.cpp, igra.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ol> <li>U prvom redu brojeve \\(N,M,K\\)  i \\(D\\).    </li> <li>U slede\u0107ih \\(M\\) redova brojeve \\(U_i\\) i \\(V_i\\), redom, razdvojene razmakom</li> <li>U narednih \\(K\\) redova brojeve \\(S_i\\) i \\(F_i\\), redom, razdvojene razmakom</li> </ol> <p>a zatim pozivaju va\u0161u funkciju Igra iz odgovaraju\u0107eg fajla (igra.c, igra.cpp, igra.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2015_2016/sio/02_igra/#podzadatak-1","title":"Podzadatak 1","text":"<p>Stablo ima svojstvo bipartitivnosti: svaki \u010dvor se mo\u017ee obojiti u crno ili belo tako da susedni \u010dvorovi uvek imaju razli\u010ditu boju. Jedan potez po uslovu zadatka uvek menja boju na kojoj se figurica nalazi. Mo\u017eemo napraviti slede\u0107u trdnju: ako je \\(W\\) najkra\u0107i put izme\u0111u neka dva \u010dvora \\(U\\) i \\(V\\), onda su mogu\u0107e du\u017eine svih ostalih puteva (koji mogu biti samo-presecaju\u0107i) \\(W+2,W+4,W+6,...\\) Putevi kra\u0107i od \\(W\\) ne postoje, a putevi \u010dija je du\u017eina druga\u010dije parnosti od \\(W\\) tako\u0111e ne postoje zbog bipartitivnosti. Svi ostali postoje jer je uvek mogu\u0107e iza\u0107i iz \u010dvora i vratiti se u njega za \\(2\\) poteza.</p> <p>Najkra\u0107i putevi iz svakog \u010dvora mogu se na\u0107i efikasno i jednostavno bilo kojim algoritmom za pretra\u017eivanje celog stabla u slo\u017eenosti \\(O(N)\\). Ostalo je samo cikli\u010dno proveriti koji dani su mogu\u0107i i odrediti odgovaraju\u0107e parnosti. Vremenska slo\u017eenost je \\(O((N+M+D)\\cdot K)\\), a memorijska  \\(O(N^2+K)\\) ili \\(O(N+M+K)\\).</p>"},{"location":"takprog/2015_2016/sio/02_igra/#podzadatak-2","title":"Podzadatak 2","text":"<p>Koristi\u0107emo isto re\u0161enje kao u prethodnom podzadatku, samo je potrebno jo\u0161 i proveriti da li du\u017eine najkra\u0107ih puteva imaju istu parnost. Ako je dat uslov ispunjen, onda je mogu\u0107e da se sve figurice na\u0111u na svojim krajnjim pozicijama nakon \\(max(W_i)\\) poteza, gde je \\(W_i\\) du\u017eina najkra\u0107eg puta od \\(U_i\\) do \\(V_i\\).</p>"},{"location":"takprog/2015_2016/sio/02_igra/#podzadaci-34-i-5","title":"Podzadaci 3,4 i 5","text":"<p>Graf vi\u0161e ne mora da bude bipartitivan, ali mo\u017eemo napraviti novi koji \u0107e biti: svaki \u010dvor u njemu numeri\u0161emo isto kao i u prethodnom, ali \u010duvamo crnu i belu verziju. Grane su iste, ali povezujemo isklju\u010divo susedne \u010dvorove sa suprotnim bojama verzija. Novi graf \u0107e biti duplo ve\u0107i po broju \u010dvorova i grana i bipartitivan. Mo\u017eemo pretpostaviti da sve figurice kre\u0107u iz belog \u010dvora i treba da stignu u odgovaraju\u0107i \u010dvor proizvoljne boje. Bitno je da svaka figurica zavr\u0161i u \u010dvoru iste boje (tj. da im du\u017eine puteva imaju istu parnost). Ostalo je na\u0107i najkra\u0107i put od bele verzije \\(U_i\\) do obe verzije \\(V_i\\). (Ili odrediti da put ne postoji) Opet \u0107emo ra\u010dunati \\(max(W_i)\\) i parnost kao u prethodnim podzadacima, ali ovog puta to moramo uraditi odvojeno za samo za crne i samo za bele krajeve figurica. </p> <p>Efikasna implementacija koristi pretragu po \u0161irini da na\u0111e najkra\u0107i put od svakog po\u010detnog polja figurica do svakog drugog \u010dvora. Vremenska slo\u017eenost je \\(O((N+M+D)\\cdot K)\\), a memorijska \\(O(N+M+K)\\). Manje efikasne implementacije ili izostavljanje ra\u010dunanja odre\u0111enih parnosti mogu re\u0161iti i prethodne podzadatke. </p> 02_igra.cpp<pre><code>#include \"igra.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;stdio.h&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n#define MaxK 110\n#define MaxN 1010\n#define MaxM 100010\n#define INF 1000000000\n\nint n, m, k, d;\nvector&lt;int&gt; edge[2*MaxN];\n\nint even[MaxK];\nint odd[MaxK];\nint dist[2*MaxN];\n\nint OddNode( int id )\n{\n    return id;\n}\n\nint EvenNode( int id )\n{\n    return n + id;\n}\n\nvoid BFS( int start, int end, int &amp;even, int &amp;odd )\n{\n    memset(dist, -1, sizeof(dist));\n    queue&lt;int&gt; q;\n    while (!q.empty()) q.pop();\n\n    dist[ EvenNode( start ) ] = 0;\n    q.push( EvenNode( start ) );\n\n    while (!q.empty()) {\n        int currNode = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; edge[ currNode ].size(); ++i) {\n            int adjNode = edge[ currNode ][i];\n            if ( dist[ adjNode ] != -1 ) continue;\n\n            dist[ adjNode ] = dist[ currNode ] + 1;\n            q.push( adjNode );\n        }\n    }\n\n    even = dist[ EvenNode( end ) ];\n    odd = dist[ OddNode( end ) ];\n}\n\nint Calculate( int currDay, int wantedDay, int D )\n{\n    if ( currDay == -1 ) return INF;\n\n    int ret = currDay;\n    currDay %= D;\n\n    if ( wantedDay &lt; currDay ) {\n        wantedDay += D;\n    }\n\n    if ( (wantedDay - currDay) % 2 == 0 ) {\n        return ret + (wantedDay - currDay);\n    }\n\n    wantedDay += D;\n    if ( (wantedDay - currDay) % 2 == 0 ) {\n        return ret + (wantedDay - currDay);\n    }\n\n    return INF;\n}\n\nvoid Igra(int N, int M, int K, int D, int* U, int* V, int* S, int* F, int* R){\n    n = N;\n    m = M;\n    k = K;\n    d = D;\n\n    for (int i = 0; i &lt; m; ++i) {\n        int u = U[i];\n        int v = V[i];\n        --u; --v;\n\n        edge[ OddNode(u) ].push_back( EvenNode(v) );\n        edge[ EvenNode(u) ].push_back( OddNode(v) );\n\n        edge[ OddNode(v) ].push_back( EvenNode(u) );\n        edge[ EvenNode(v) ].push_back( OddNode(u) );\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        int start = S[i], end = F[i];\n        --start; --end;\n\n        BFS( start, end, even[ i ], odd[ i ] );\n\n        // printf(\"%d =&gt; %d %d\\n\", i+1, even[i], odd[i]);\n    }\n\n    for (int day = 0; day &lt; d; ++day) {\n        int maximumEven = -1;\n        int maximumOdd = -1;\n\n        for (int i = 0; i &lt; k; ++i) {\n            int evenNumberOfMoves = Calculate( even[i], day, d );\n            int oddNumberOfMoves = Calculate( odd[i], day, d );\n\n            maximumEven = max( maximumEven, evenNumberOfMoves );\n            maximumOdd = max( maximumOdd, oddNumberOfMoves );\n        }\n\n        int ret = min( maximumEven, maximumOdd );\n        if ( ret == INF ) R[day] = -1;\n        else R[day] = ret;\n    }\n}\n</code></pre>"},{"location":"takprog/2015_2016/sio/03_migovi/","title":"3 - Migovi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>U prvoj polovini 20. veka, umesto velikog nau\u010dnog napretka, dominatni su bili vojni sukobi. Poznato je da su velika imena nauke, poput Alana Tjuringa i D\u017eona fon Nojmana, dali veliki doprinos za br\u017ei zavr\u0161etak ovih sukoba. Na\u017ealost, ljudi lako zaboravljaju istoriju, pa i dan-danas \u010desto nije bitno da li neko ima britak um i visoko obrazovanje ve\u0107 da li ima veliku vojsku i moderne Migove 323...</p> <p>Jedan od najpoznatijih generala dana\u0161njice, Dimi Gavi, najvi\u0161e od svega voli da gleda paradu svojih N najmodernijih Migova 323 na nebu i zami\u0161lja da je Maverik iz Top Gan-a. Me\u0111utim, Dimi Gavi ne voli sve\u017e vazduh pa ih on ne gleda na nebu ve\u0107 na monitoru svog radara na kome se migovi vide kao ta\u010dkice. Svaki od migova se kre\u0107e u jednom od 4 smera (gledano na ekranu, ti smerovi su: gore, desno, dole i levo) i svi se kre\u0107u istom brzinom od 1 kilometra u sekundi. Dimi Gavi ka\u017ee da je rastojanje izme\u0111u dva miga, koja se nalaze na pozicijama \\((x_1,y_1)\\) i \\((x_2,y_2)\\) u koordinatnom sistemu ekrana, jednako \\(x_1-x_2+|y_1-y_2|\\) i svi to po\u0161tuju.</p> <p>Dimi Gavi posmatra svaka dva miga i u trenutku kada oni budu na najmanjem mogu\u0107em me\u0111usobnom rastojanju (to mo\u017ee biti u po\u010detnom trenutku ili u nekom kasnijem trenutku) on uzvikne \u201cDanger Zone!\u201d i zabele\u017ei to rastojanje. Zatim sva ta rastojanja sabere. Zatim ode ku\u0107i. Na vama je da, znaju\u0107i po\u010detne pozicije i smerove kretanja svih migova, odredite koji je rezultat dobio Dimi Gavi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Boris Grubi\u0107 <p>Formulacija zadatka je prili\u010dno jednostavna a jasno je i da se radi sa standardnim Menhetn-rastojanjem<sup>1</sup> izme\u0111u ta\u010daka koje poseduje nekoliko korisnih osobina koje \u0107emo i eksploatisati. Koristi\u0107emo termine \\(U\\)-mig, \\(R\\)-mig, \\(D\\)-mig i \\(L\\)-mig za migove \u010diji su smerovi kretanja, redom, gore, desno, dole i levo. Tako\u0111e, za par migova \u0107emo re\u0107i da \u010dine \\(ort\\)--par (ortogonalni par) ukoliko su im smerovi kretanja normalni jedan na drugi, a ina\u010de oni \u010dine \\(par\\)--par (paralelni par); intuitivno je jasno da \u0107e nam ve\u0107i problem praviti \\(ort\\)--parovi. Da bismo do\u0161li do optimalnog alogritma najlak\u0161e (i najprirodnije) je re\u0161avati podzadatke redom.</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <p>ZbirRastojanja(\\(N\\), \\(x\\), \\(y\\),\\(s[\u2026]\\))</p> <p>gde je \\(N\\) \u2013 broj migova a \\(x\\), \\(y\\) i \\(s\\) nizovi koji opisuju migove: \\(i\\)-ti mig se nalazi na poziciji \\((x_i, y_i)\\) i, ukoliko je \\(s_i=0\\), on se kre\u0107e nagore, ukoliko je \\(s_i=1\\), on se kre\u0107e udesno, ukoliko je si=2, on se kre\u0107e nadole i ukoliko je si=3 on se kre\u0107e ulevo. Svi nizovi su indeksirani od 0. Ova funkcija mora da vrati jedan ceo broj \u2013 zbir najmanjih mogu\u0107ih rastojanja izme\u0111u svaka dva miga .</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#primer","title":"Primer:","text":"<p>Neka \\(N=3\\), \\(x=[0, 3, 5]\\), \\(y=[3, 0, 4]\\) i \\(s=[0, 1, 2]\\). Ovi podaci ozna\u010davaju da imamo 3 miga: prvi je na poziciji 0,3 i ide nagore, drugi je na poziciji (3,0) i ide udesno i tre\u0107i je na poziciji (5,4) i ide nadole. Najmanje me\u0111usobno rastojanje izme\u0111u prvog i drugog miga se dosti\u017ee u nultom trenutku i iznosi 0-3+3-0=6. Najmanje rastojanje izme\u0111u prvog i tre\u0107eg miga je 5 i dosti\u017ee se posle pola sekunde (ako pretpostavimo da su jedini\u010dna rastojanja \u2013 kilometri). Najmanje rastojanje izme\u0111u drugog i tre\u0107eg miga je 2 (dosti\u017ee se u vi\u0161e trenutaka, npr. u tre\u0107oj sekundi). Prema tome, u ovom slu\u010daju va\u0161a funkcija mora da vrati broj 6+5+2=13.</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li> <p>\\(2\u2264N\u2264200.000\\)</p> </li> <li> <p>Za svako \\(i=[0,N-1]\\) va\u017ei \\(-5\u22c510^7\u2264x_i, y_i\u22645\u22c510^7\\) i \\(s_i \\in \\{0, 1, 2, 3\\}\\)</p> </li> <li> <p>Sve koordinate su celi brojevi</p> </li> <li> <p>Nikoja dva miga nemaju iste po\u010detne koordinate</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/03_migovi/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li> <p>PODZADATAK 1 [9 POENA]: \\(N\u22641.000\\).</p> </li> <li> <p>PODZADATAK 2 [18 POENA]: Svi migovi se kre\u0107u nagore tj. \\(s_i=0\\) za svako \\(i\\).</p> </li> <li> <p>PODZADATAK 3 [24 POENA]: Svaki mig se kre\u0107e ili levo ili desno tj. \\(s_i\u2208\\{1,3\\}\\) za svako \\(i\\).</p> </li> <li> <p>PODZADATAK 4 [49 POENA]: Nema dodatnih ograni\u010denja.</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/03_migovi/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom migovi.c, migovi.cpp ili migovi.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <p>C/C++</p> <p>long long ZbirRastojanja(int N, int x, int y, int* s);</p> <p>Pascal</p> <p>function ZbirRastojanja(N : longint; var x, y, s : array of longint) : int64;</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajla staviti #include \u201cmigovi.h\u201d a ukoliko radite u Pascal -u, potrebno je na po\u010detku fajla staviti Unit migovi; (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (migovi.c, migovi.cpp, migovi.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li> <p>U prvom redu broj \\(N\\)</p> </li> <li> <p>U slede\u0107ih \\(N\\) redova brojeve \\(x_i, y_i, s[i]\\), redom, razdvojene razmakom</p> </li> </ul> <p>a zatim pozivaju va\u0161u funkciju ZbirRastojanja iz odgovaraju\u0107eg fajla (migovi.c, migovi.cpp, migovi.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#podzadatak-1","title":"Podzadatak \\(1\\)","text":"<p>Na osnovu ograni\u010denja, jasno je da je ovde dovoljan trivijalan alogoritam koji odre\u0111uje minimalna rastojanja izme\u0111u svaka dva miga (posebno) u slo\u017eenosti \\(O(N^2)\\). Ipak, sama implementacija zahteva analizu nekoliko slu\u010dajeva a jedan od pametnijih na\u010dina je slede\u0107i: neka su \\(i(x_i, y_i)\\) i \\(j(x_j, y_j)\\) dva miga; nije te\u0161ko uo\u010diti da je minimalno rastojanje izme\u0111u \\(i\\) i \\(j\\) upravo njihovo menhetn-rastojanje  \\(|x_i -x_j| + |y_i - y_j|\\) osim u slu\u010daju kada oni \u010dine \\(par\\)--par i kre\u0107u se jedan ka drugom ili \\(ort\\)--par i oba idu ka prese\u010dnoj ta\u010dki (tada su tra\u017eena rastojanja manja). Za poslednja dva slu\u010daja treba oduzeti odgovaraju\u0107i \"vi\u0161ak\" a tu tehniku \u0107emo koristiti i u narednim podzadacima.</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#podzadatak-2","title":"Podzadatak \\(2\\)","text":"<p>Kako svi migovi idu nagore jednakim brzinama, njihova me\u0111usobna rastojanja ostaju ista pa mo\u017eemo zamisliti da se ne kre\u0107u. Problem se svodi na (poznat) problem odre\u0111ivanja sume svih menhetn-rastojanja (po parovima) datih \\(N\\) ta\u010daka. Kako je menhetn rastojanje nezavisno po koordinatama, tj. \\(\\sum_{1 \\leq i &lt; j \\leq n} (|x_i - x_j| + |y_i - y_j|) = \\sum_{1 \\leq i &lt; j \\leq n} |x_i - x_j| + \\sum_{1 \\leq i &lt; j \\leq n} |y_i - y_j|\\), problem se svodi na izra\u010dunavanje izraza \\(F(a) = \\sum_{1 \\leq i &lt; j \\leq n} |a_i - a_j|\\) za dati niz \\(a\\). Suma ne zavisi od pozicija elemenata u nizu ve\u0107 samo od njihovih vrednosti pa sortiranjem niza \\(a\\) (\\(a_1 \\leq a_2 \\leq \\ldots \\leq a_N\\)) \"gubimo\" apsolutne vrednosti i nakon malo transformacija dobijamo \\(F(a) =  \\sum_{1 \\leq i &lt; j \\leq n} (a_j - a_i) = \\sum_{j = 1}^N (j\\cdot a_j - p_{j-1})\\) gde je \\(p\\) niz prefiksnih suma tj. \\(p_i = a_1 + a_2 + \\ldots + a_i\\).</p> <p>Izraz za \\(F(a)\\) smo posle sortiranja mogli transformisati i na drugi na\u010din: za svako \\(k\\), vrednost \\(a_k\\) se u sumi \\(\\sum_{1 \\leq i &lt; j \\leq n} (a_j - a_i)\\) javlja ta\u010dno \\(k-1\\) puta sa predznakom \"\\(+\\)\" i ta\u010dno \\(N - k\\) puta sa predznakom \"\\(-\\)\" (toliko ima manjih/ve\u0107ih vrednosti od \\(a_k\\)) pa dobijamo da je \\(F(a) = \\sum_{k=1}^N (k - 1 - (N - k)) \\cdot a_k = \\sum_{k=1}^N (2k - N - 1)\\cdot a_k\\). U oba slu\u010daja je jasno da se suma mo\u017ee izra\u010dunati u slo\u017eenosti \\(O(N)\\) pa se ra\u010dunanje izraza \\(F(x) + F(y)\\) mo\u017ee odraditi u slo\u017eenosti \\(O(N \\log N)\\) (zbog sortiranja) \u0161to je dovoljno za ovaj podzadatak.</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#podzadatak-3","title":"Podzadatak \\(3\\)","text":"<p>U ovom podzadatku svaki par migova \u010dini \\(par\\)--par pri \u010demu se \\(y\\) koordinate migova ne menjaju. Primetimo da je minimalno rastojanje izme\u0111u migova \\(i\\) i \\(j\\) jednako \\(|y_i - y_j|\\) ukoliko idu \"jedan drugom u susret\" (jer \u0107e u nekom trenutku biti \\(|x_i - x_j| = 0\\)), odnosno \\(|x_i - x_j| + |y_i - y_j|\\) u ostalim slu\u010dajevima (tada se vrednost \\(|x_i - x_j|\\) ne\u0107e smanjivati).  Dakle, i dalje mo\u017eemo posmatrati odvojeno \\(x\\) i \\(y\\) koordinate a jedan od najlak\u0161ih na\u010dina za re\u0161avanje ovog podzadatka je izra\u010dunati tra\u017eena rastojanja pod pretpostavkom da se migovi ne pomeraju (u slo\u017eenosti \\(O(N \\log N)\\) kao u prethodnom zadatku) a zatim od dobijenog rezultata oduzeti \"vi\u0161ak\", tj. oduzeti po \\(|x_i - x_j|\\) za svaka dva miga \\(i\\) i \\(j\\) koji idu jedan drugom u susret.</p> <p>Ukoliko neopadaju\u0107e sortiramo \\(x\\) koordinate migova, problem se svodi na efikasno ra\u010dunanje sume svih \\(|x_j - x_i|\\) za svako \\(i &lt; j\\) gde je mig \\(i\\) \\(R\\)-mig a mig \\(j\\) \\(L\\)-mig. O\u010dekivano, ovo se mo\u017ee uraditi u slo\u017eenosti \\(O(N)\\): dovoljno je kretati se s leva na desno i u svakom trenutku pamtiti vrednosti \\(sumR\\) i \\(numR\\) koji, redom, predstavljaju sumu \\(x\\)--koordinata i broj svih prethodnih \\(R\\)-migova. Ukoliko je \\(i\\)-ti mig \\(R\\)-mig, odradimo \\(update\\) trenutnih vrednosti a u suprotnom na\u0161oj tra\u017eenoj sumi treba dodati vrednost \\(numR \\cdot x_i - sumR\\) (trenutni mig \u0107e \"poni\u0161titi\" rastojanja za svih \\(numR\\) \\(R\\)-migova sa njegove leve strane). Dakle, ukupna slo\u017eenost za ovaj podzadatak je \\(O(N\\log N)\\).</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#podzadatak-4","title":"Podzadatak \\(4\\)","text":"<p>Ovde nastaje pravi problem jer je zbog \\(ort\\)--parova nemogu\u0107e posmatrati nezavisno \\(x\\) i \\(y\\) koordinate. Zaista, ukoliko migovi \\(i\\) i \\(j\\) \u010dine \\(ort\\)--par i oba idu ka prese\u010dnoj ta\u010dki (nazovimo ovakve parove lo\u0161i), tada \u0107e oni (prvi put) dosti\u0107i minimalno rastojanje kada mig koji je bli\u017ei ta\u010dki preseka do\u0111e u istu -- tada je rastojanje \\(||x_i - x_j| - |y_i - y_j||\\) i ne mo\u017ee se lepo \"razlo\u017eiti\" na koordinate. </p> <p> Slika \\(1\\):  \\(a)\\) minimalno rastojanje kod lo\u0161eg para; \\(b)\\) Podela gornjeg-desnog kvadratna za \\(R\\)-miga \\((x_i, y_i)\\) na dva beskona\u010dna trougla: \"gornji trougao\" (oblast \\(I\\)) ograni\u010den pravama \\(x = x_i\\) i \\(y = x + (y_i - x_i)\\) i \"donji trougao\" (oblast \\(II\\)) ograni\u010den pravama \\(y = y_i\\) i \\(y = x + (y_i - x_i)\\). </p> <p>Prethodni izraz mo\u017eemo transformisati u \\(|x_i - x_j| + |y_i - y_j| - 2 \\cdot \\min\\{|x_i - x_j|, |y_i - y_j|\\}\\) sa motivacijom da primenimo metod \"oduzimanja vi\u0161ka\": ukoliko saberemo sva po\u010detna me\u0111usobna rastojanja (podzadataka \\(2\\)) a zatim oduzmemo vi\u0161ak za \\(par\\)--parove (Podzadatak \\(3\\), posebno za grupu \\(L/R\\)-migova i grupu \\(U/D\\)-migova) ostaje samo da za svaki lo\u0161 par migova \\(i\\) i \\(j\\) oduzmemo vrednost \\(2 \\cdot \\min\\{|x_i - x_j|, |y_i - y_j|\\}\\). Lo\u0161e parove mo\u017eemo, zavisno od smerova migova, podeliti u \\(4\\) disjunktne grupe (\\(RD\\), \\(DL\\), \\(LU\\) i \\(UR\\)) koje se (o\u010dekivano) re\u0161avaju na simetri\u010dan na\u010din. Zbog toga opisujemo re\u0161enje samo za \\(RD\\) grupu, tj. problem se svodi na efikasno ra\u010dunanje sume \\(\\(2\\sum_{\\substack{i \\in R, \\enspace j \\in D \\\\ (i,j) \\text{ je lo\u0161 par}}} \\min\\{|x_i - x_j|, |y_i - y_j|\\}.\\)\\) Koriste\u0107i \u010dinjenicu da su za dati \\(R\\)-mig \\(i\\) svi migovi koji \u010dine lo\u0161 par sa njim upravo \\(D\\)-migovi koji su \"gore-desno\" od njega (tj. \\(D\\)-migovi \\(j\\) za koje va\u017ei \\(x_i \\leq x_j\\) i \\(y_i \\leq y_j\\)) problem se (posle izbacivanja faktora \\(2\\)) dodatno svodi na ra\u010dunanje izraza \\(\\(\\sum_{i \\in R} \\sum_{\\substack{j \\in D, \\\\ x_i \\leq x_j, \\; y_i \\leq x_j}} \\min\\{x_j - x_i, y_j - y_i\\}\\)\\) Za izbacivanje nezgodnog minimuma, uvedimo slede\u0107e oznake na osnovu Slike \\(1\\): za dati \\(R\\)-mig \\(i\\) neka su \\(T_x(i)\\) i \\(T_y(i)\\), redom, skupovi svih \\(D\\)-migova koji se nalaze \"gornjem trouglu\" (oblast \\(I\\)), odnosno \"donjem trouglu\" (oblast \\(II\\)) miga \\(i\\).  Nije te\u0161ko videti da ako \\(j \\in T_x(i)\\) tada \\(x_j - x_i \\leq y_j - y_i\\) i da iz \\(j \\in T_y(i)\\) sledi \\(y_j - y_i \\leq x_j - x_i\\). Sada prethodnu sumu mo\u017eemo napisati kao \\(\\(\\sum_{i \\in R}\\sum_{j \\in T_x(i)} (x_j - x_i) + \\sum_{i \\in R}\\sum_{j \\in T_y(i)} (y_j - y_i).\\)\\) Zbog simetrije, koncentrisa\u0107emo se na levu sumu prethodnog izraza. Za po\u010detak, mo\u017eemo se obezbediti da unutra\u0161nja suma \u0161to manje zavisi od \\(i\\): neka je \\(n_i = |T_x(i)|\\) (broj \\(D\\)-migova u trouglu) i \\(s_i = \\sum_{j \\in T_x(i)} x_j\\) (suma \\(x\\) koodinata \\(D\\)-migova iz trougla). Kona\u010dno, prethodna desna suma se svodi na \\(\\(\\sum_{i \\in R} (s_i - n_i \\cdot x_i).\\)\\) U ovom trenutku (a iskusni takmi\u010dar to mo\u017ee shvatiti mnogo ranije) problem mo\u017eemo kona\u010dno svesti na efikasno odgovaranje na upite slede\u0107eg tipa: za datu ta\u010dku \\((x_i, y_i)\\), odrediti broj ta\u010daka (kao i zbir njihovih \\(x\\) koordinata) koje le\u017ee u \"donjem trouglu\" odre\u0111enom ta\u010dkom \\((x_i, y_i)\\). Standardni poku\u0161aj je sortirati \\(R\\) i \\(D\\)-migove zajedno po nekom parametru a zatim ih redom obilaziti (\\(sweep\\)) i prilikom nailaska na \\(D\\)-miga vr\u0161iti ubacivanje u neku strukturu a prilikom nailaska na \\(R\\)-miga vr\u0161iti upit nad tom strukturom. Najprirodniji pristup -- \\(sweep\\) po jednoj koordinati a odre\u0111ivanje pozicija u strukturi po drugoj, ovde ne prolazi jer trouglovi nisu samo odre\u0111eni pravama paralelnim \\(x\\) i \\(y\\)-osama ve\u0107 i pravama paralenim pravoj \\(y = x\\). I upravo je klju\u010dni deo zadatka raditi \\(sweep\\) po pravama paralelnih pravoj \\(y = x\\) u smeru \"gore-levo\" \\(\\rightarrow\\) \"dole-desno\". </p> <p>Preciznije, prvo sortiramo migove neopadaju\u0107e po vrednosti \\(x_i - y_i\\); u tom redosledu \u0107emo ih obilaziti. Dodatno za svakog miga \\(i\\) izra\u010dunamo \\(pos_i\\) -- pozicija u nizu na kojoj bi se mig na\u0161ao ukoliko bismo ih sve sortirali po \\(x\\) koordinatama. Prilikom obilaska u gore pomenutom redosledu, mi nailazimo na migove i, zavisno od tipa miga, radimo slede\u0107e (vidi Sliku \\(2\\)):</p> <ul> <li>\\(D\\)-mig \\(j\\): ubacujemo mig \\(j\\) u pomo\u0107ni niz \\(A\\) na poziciji \\(pos_j\\).</li> <li>\\(R\\)-mig \\(i\\): ra\u010dunamo broj migova i sumu \\(x\\) koordinata svih migova koji se nalaze u segmentu \\([pos_i, N]\\) u nizu \\(A\\). \u010cinjenica da je neki mig \\(j\\) ve\u0107 u nizu \\(A\\) i da je \\(pos_j &gt; pos_i\\) je ekvivalentna sa \\(x_j - y_j \\leq x_i - y_i\\) i \\(x_j \\geq x_i\\) \u0161to je uslov da \\(j\\) pripada \"gornjem trouglu\", tj. \\(j \\in T_x(i)\\).</li> </ul> <p>Zbog prirode upita, jasno je da umesto niza \\(A\\) mo\u017eemo koristiti Segmentno stablo<sup>2</sup> ili Kumulativnu tabelu<sup>3</sup> i posti\u0107i slo\u017eenost \\(O(\\log N)\\) za svaki od pomenuta dva upita/doga\u0111aja, pa gore pomenutu sumu \\(\\sum_{i \\in R} (s_i - n_i \\cdot x_i)\\) mo\u017eemo izra\u010dunati u slo\u017eenosti \\(O(N \\log N)\\).  Analogno ra\u010dunamo sumu i za \"donje trouglove\" -- tada radimo obrnuti obilazak (\"dole-desno\" \\(\\rightarrow\\) \"gore-levo\") a niz \\(pos\\) se odnosi na \\(y\\) koordinate. Sve ovo radimo \\(4\\) puta (za svaku grupu lo\u0161ih parova) pa je ukupna slo\u017eenost algoritma \\(O(N \\log N)\\).</p>"},{"location":"takprog/2015_2016/sio/03_migovi/#detalji-implementacije_1","title":"Detalji implementacije","text":"<p>Iz opisa optimalnog re\u0161enja vidi se da je potrebno odraditi \\(8\\) sli\u010dnih \\(sweep\\)-ova vr\u0161e\u0107i odgovaraju\u0107e upite (po dva obilaska za svaku od \\(4\\) grupe). Ovde nikako ne treba raditi sa \\(8\\) razli\u010ditih oblasti od interesa (\"trouglova\") i \\(8\\) puta du\u017eim kodom, ve\u0107 svaku grupu lo\u0161ih parova svesti na \\(RD\\) grupu rotacijom ravni za \\(90^\\circ\\) i pozivom iste funkcije. Dodatno, dva pomenuta \\(sweep\\)-a u okviru iste grupe je mogu\u0107e implementirati pozivom iste funkcije ukoliko se strukturi kao parametar prenosi i informacija da li se radi o \\(x\\) ili \\(y\\) osi. Tako\u0111e, potrebno je preciznije u kodu definisati \"gornji i donji trougao\", tj. odrediti kome od njih pripadaju migovi na dijagonali da se ne bi ra\u010dunali dva puta. Napomenimo i to da smo \\(sweep\\) mogli raditi po nekoj od osa a niz \\(pos\\) indeksirati na osnovu razlika \\(x_i - y_i\\).</p> 03_migovi.cpp<pre><code>#include \"migovi.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 200020;\nconst int TREE_SIZE = (1 &lt;&lt; 19);\nconst int X_AXIS = 0;\nconst int Y_AXIS = 1;\nconst int DIR_UP = 0;\nconst int DIR_RIGHT = 1;\nconst int DIR_DOWN = 2;\nconst int DIR_LEFT = 3;\n\nstruct Mig\n{\n    long long x, y;\n    int s;\n    int posx, posy;\n    Mig(int x, int y, int s) : x(x), y(y), s(s) {}\n    Mig() {}\n};\n\nMig migs[MAX_N];\nlong long pos[MAX_N];\nlong long dir[MAX_N];\nlong long sol;\n\nbool cmpX(const Mig&amp; m1, const Mig&amp; m2)\n{\n    if (m1.x != m2.x) return (m1.x &lt; m2.x);\n    return (m1.y &lt; m2.y);\n}\n\nbool cmpY(const Mig&amp; m1, const Mig&amp; m2)\n{\n    if (m1.y != m2.y) return (m1.y &lt; m2.y);\n    return (m1.x &lt; m2.x);\n}\n\nbool cmpDiffXY(const Mig&amp; m1, const Mig&amp; m2)\n{\n    if (m1.x - m1.y != m2.x - m2.y) return (m1.x - m1.y &lt; m2.x - m2.y);\n    return (m1.x &lt; m2.x);\n}\n\nstruct SegmentTree\n{\n    int axis;\n    int count[TREE_SIZE];\n    long long sum[TREE_SIZE];\n\n    void init(int axis)\n    {\n        this-&gt;axis = axis;\n        memset(count, 0, sizeof(count));\n        memset(sum, 0, sizeof(sum));\n    }\n\n    // add value val at position pos\n    void add(int pos, long long val)\n    {\n        pos = pos + (TREE_SIZE &gt;&gt; 1) - 1;\n        while (pos &gt; 0)\n        {\n            count[pos] = count[pos] + 1;\n            sum[pos] = sum[pos] + val;\n            pos = (pos &gt;&gt; 1);\n        }\n    }\n\n    // calculate sum[l..r] - count[l..r] * val\n    long long calculate(int node, int node_L, int node_R, int l, int r, long long val)\n    {\n        if (node_R &lt; l || node_L &gt; r)\n            return 0;\n        if (l &lt;= node_L &amp;&amp; node_R &lt;= r)\n            return (sum[node] - val * count[node]);\n\n        int node_M = (node_L + node_R) &gt;&gt; 1;\n        return calculate((node &lt;&lt; 1), node_L, node_M, l, r, val) + calculate((node &lt;&lt; 1) + 1, node_M + 1, node_R, l, r, val);\n    }\n\n    void addMig(Mig&amp; mig)\n    {\n        if (axis == X_AXIS)\n            add(mig.posx, mig.x);\n        else\n            add(mig.posy, mig.y);\n    }\n\n    long long extraSum(Mig&amp; mig)\n    {\n        if (axis == X_AXIS)\n            return calculate(1, 1, (TREE_SIZE &gt;&gt; 1), mig.posx, (TREE_SIZE &gt;&gt; 1), mig.x);\n        else\n            return calculate(1, 1, (TREE_SIZE &gt;&gt; 1), mig.posy, (TREE_SIZE &gt;&gt; 1), mig.y);\n    }\n\n\n};\n\nSegmentTree xTree, yTree;\n\nlong long SolveByCoordinate(int N, Mig* migs, int axis, int forwardDir, int backDir)\n{\n    long long res = 0LL;\n\n    if (axis == X_AXIS)\n        sort(migs, migs + N, cmpX);\n    else\n        sort(migs, migs + N, cmpY);\n\n    for (int i = 0; i &lt; N; i++)\n    {\n        dir[i] = migs[i].s;\n        pos[i] = (axis == X_AXIS ? migs[i].x : migs[i].y);\n    }\n\n    // suma svih |pos[i] - pos[j]|\n    long long totalSum = 0LL;\n    for (int i = 0; i &lt; N; i++)\n    {\n        res = res + (pos[i] * i - totalSum);\n        totalSum = totalSum + pos[i];\n    }\n\n    // oduzeti rastojanja izmedju onih migova koji idu jedan ka drugom\n    long long forwardSum = 0LL;\n    long long forwardNum = 0LL;\n    for (int i = 0; i &lt; N; i++)\n    {\n        if (dir[i] == backDir)\n        {\n            res = res - (pos[i] * forwardNum - forwardSum);\n        }\n        else if (dir[i] == forwardDir)\n        {\n            forwardNum = forwardNum + 1;\n            forwardSum = forwardSum + pos[i];\n        }\n    }\n\n    return res;\n}\n\n// Rotiramo ravan za 90 stepeni ulevo\nvoid RotateLeft(int N, Mig* migs)\n{\n    for (int i = 0; i &lt; N; i++)\n    {\n        migs[i].s = (migs[i].s + 3) % 4;\n        long long x = migs[i].x;\n        long long y = migs[i].y;\n        migs[i].x = -y;\n        migs[i].y = x;\n    }\n}\n\n// Kompenzacija koju treba oduzeti za migove koji idu\n// udesno i na dole jedan ka drugom\nlong long SolveRightDown(int N, Mig* migs)\n{\n    long long ret = 0LL;\n\n    sort(migs, migs + N, cmpX);\n    for (int i = 0; i &lt; N; i++)\n        migs[i].posx = i + 1;\n\n    sort(migs, migs + N, cmpY);\n    for (int i = 0; i &lt; N; i++)\n        migs[i].posy = i + 1;\n\n    sort(migs, migs + N, cmpDiffXY);\n\n    xTree.init(X_AXIS);\n    for (int i = 0; i &lt; N; i++)\n    {\n        if (migs[i].s == DIR_RIGHT)\n        {\n            ret = ret + xTree.extraSum(migs[i]);\n        }\n        if (migs[i].s == DIR_DOWN)\n        {\n            xTree.addMig(migs[i]);\n        }\n    }\n\n    yTree.init(Y_AXIS);\n    for (int i = N - 1; i &gt;= 0; i--)\n    {\n        if (migs[i].s == DIR_RIGHT)\n        {\n            ret = ret + yTree.extraSum(migs[i]);\n        }\n        if (migs[i].s == DIR_DOWN)\n        {\n            yTree.addMig(migs[i]);\n        }\n    }\n\n    return ret * 2;\n}\n\n\nlong long ZbirRastojanja(int N, int * x, int * y, int * s)\n{\n    for (int i = 0; i &lt; N; i++)\n        migs[i] = Mig(x[i], y[i], s[i]);\n\n    sol = 0;\n    // suma svih pocetnih rastojanja - kompenzacija za one koji idu jedni ka drugima\n    sol = sol + SolveByCoordinate(N, migs, X_AXIS, DIR_RIGHT, DIR_LEFT);\n    sol = sol + SolveByCoordinate(N, migs, Y_AXIS, DIR_UP, DIR_DOWN);\n\n    // sada je potrebno za svaka dva miga koji idu normalno jedan ka drugom\n    // oduzeti 2 * Min(distX, distY), gde su distX i distY pocenta rastojanja po x i y osi\n    sol = sol - SolveRightDown(N, migs);\n    RotateLeft(N, migs);\n    sol = sol - SolveRightDown(N, migs);\n    RotateLeft(N, migs);\n    sol = sol - SolveRightDown(N, migs);\n    RotateLeft(N, migs);\n    sol = sol - SolveRightDown(N, migs);\n\n    return sol;\n}\n</code></pre>"},{"location":"takprog/2015_2016/sio/04_zipv/","title":"4 - ZiPV","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Jo\u0161 u 1984. godini (kada Internet kakvim ga danas znamo nije ni postojao), Gramp (F.T. Grampp) i Moris (R.H. Morris) su dali \u010duveni citat: \u201cLako je imati bezbedan ra\u010dunarski sistem. Samo treba prese\u0107i sve veze sa drugim ra\u010dunarima, dozvoliti samo direktne \u017ei\u010dane terminale izme\u0111u ra\u010dunara, staviti ma\u0161ine u zabravljenu sobu, i postaviti \u010duvara ispred vrata.''</p> <p>Vo\u0111eni tim citatom, \u010delnici Ujedinjenih Komisijskih Dr\u017eava su do 2061. godine u\u010dinili da sve veze koje povezuju spoljni svet sa njihovim ma\u0161inama ne mogu da \u0161alju vi\u0161e od trideset 64-bitnih celih brojeva odjednom, uz ogla\u0161avanje op\u0161te uzbune ukoliko se po\u0161alje vi\u0161e takvih paketa. Me\u0111utim, i pored toga su \u010duveni hakeri Perica i Davis uspeli da koordiniranim napadom zaposednu dve dr\u017eavne ma\u0161ine.</p> <p>Perica je uspeo da, na ma\u0161ini koju je zaposeo, dobije pristup nekim slikama (veli\u010dine 100 x 100, samo u nijansama sive - vrednost svakog piksela je ceo broj izme\u0111u 0 i 255) koje bi mogle da kriju skrivene \u0161ifre za lansiranje nuklearnih raketa u sebi. \u017deleo bi da po\u0161alje slike Davisu, me\u0111utim zbog ograni\u010denja prenosnih kanala, mo\u017ee poslati samo trideset 64-bitnih celih brojeva-tako da su mogu\u0107i gubici pri slanju. Zamolio vas je za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 - Andrej Iva\u0161kovi\u0107 i Dimitrije Erdeljan 04_zipv.cpp"},{"location":"takprog/2015_2016/sio/04_zipv/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate dve funkcije:</p> <p>Encode(In[...][...], Code[...]),</p> <p>koja pretvara ulaznu sliku (predstavljenu kao 100 x 100 matricu 8-bitnih celih brojeva) u niz od trideset 64-bitnih celih brojeva;</p> <p>Decode(Code[...], Out[...][...]),</p> <p>koja na osnovu izra\u010dunatog niza treba da, \u0161to preciznije, rekonstrui\u0161e originalnu sliku.</p> <p>Jedini na\u010din na koji ove dve funkcije mogu razmeniti informacije je niz  Code!</p> <p>Pri popunjavanju, niz  Code  i matricu  Out  indeksirajte od 0!</p>"},{"location":"takprog/2015_2016/sio/04_zipv/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li> <p>Sve slike \u0107e biti predstavljene kao 100 x 100 matrice 8-bitnih vrednosti ([0, 255]);</p> </li> <li> <p>Du\u017eina koda je ograni\u010dena na trideset 64-bitnih celih brojeva.</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/04_zipv/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<p>Test primeri su podeljeni u 4 podzadatka od po 25 poena, koji predstavljaju razli\u010dite vrste slika. Za svaku sliku, ukupna gre\u0161ka se ra\u010duna kao suma kvadratnih odstupanja ulazne od izlazne slike na svakoj poziciji:</p> \\[err=\\sum\\limits_{i=0}^{99}\\sum\\limits_{j=0}^{99}(In[i][j]-Out[i][j])^2\\] <p>Za svaku sliku definisane su konstante \\(A\\) i \\(B\\) tako da:</p> <ul> <li> <p>Ukoliko va\u017ei \\(err\u2264A\\), osvajate 25 poena za tu sliku;</p> </li> <li> <p>Ukoliko va\u017ei \\(err\u2265B\\), osvajate 0 poena za tu sliku;</p> </li> <li> <p>Ina\u010de, osvajate \\(25\u00d7(\\frac{B - err}{B-A})\\) poena za tu sliku.</p> </li> </ul> <p>Broj osvojenih poena na jednom podzadatku je minimalan broj poena osvojenih na svim slikama unutar tog podzadatka.</p>"},{"location":"takprog/2015_2016/sio/04_zipv/#trening-podaci","title":"Trening podaci","text":"<p>Unutar svakog podzadatka, generisano je osam slika na sli\u010dan na\u010din. Od tog broja, tri slike su nasumi\u010dno odabrane i direktno su vam dostupne u arhivi prilo\u017eenoj uz zadatak. Preostalih pet slika \u0107e biti kori\u0161\u0107ene za testiranje unutar svakog podzadatka. Slike su date u dva formata: u Bitmap formatu (sa ekstenzijom .bmp), kao i tekstualni fajl (sa ekstenzijom .in) koji u sebi sadr\u017ei odgovaraju\u0107u 100 x 100 matricu vrednosti piksela. Na slici ispod se nalazi, za svaki podzadatak, po jedan primer od tri koja su vam data u arhivi.</p>"},{"location":"takprog/2015_2016/sio/04_zipv/#_1","title":"4 - ZiPV","text":""},{"location":"takprog/2015_2016/sio/04_zipv/#_2","title":"4 - ZiPV","text":""},{"location":"takprog/2015_2016/sio/04_zipv/#_3","title":"4 - ZiPV","text":""},{"location":"takprog/2015_2016/sio/04_zipv/#_4","title":"4 - ZiPV","text":""},{"location":"takprog/2015_2016/sio/04_zipv/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno dva fajla, pod nazivima [zipv_encode.c; zipv_decode.c], [zipv_encode.cpp; zipv_decode.cpp] ili [zipv_encode.pas; zipv_decode.pas], koji implementiraju dve gorepomenute funkcije. Osim tra\u017eenih funkcija, va\u0161i fajlovi mogu sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke. Me\u0111utim, imajte na umu da \u0107e funkcije Encode i Decode da se pozivaju u odvojenim programima, tako da ne\u0107ete mo\u0107i da sa\u010duvate ikakvu globalnu promenljivu koja nije konstantna izme\u0111u poziva ove dve funkcije!</p> <p>Zavisno od programskog jezika koji koristite, va\u0161e funkcije/procedure moraju biti slede\u0107eg oblika:</p> <p>C/C++</p> <p>void Encode(unsigned char *data_in, long long code);</p> <p>void Decode(long long code, unsigned char *data_out)</p> <p>Pascal</p> <p>type matrix = array[0..99] of array[0..99] of byte;</p> <p>procedure Encode(var data_in : matrix; var code : array of int64)</p> <p>procedure Decode(var code : array of int64; var data_out : matrix)</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajlova staviti #include \"zipv_encode.h\", odnosno #include \"zipv_decode.h\", a ukoliko radite u Pascal -u, potrebno je na po\u010detku fajla staviti Unit zipv_encode;, odnosno Unit zipv_decode;  (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/04_zipv/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate'' fajlovi (zipv_encode.c, zipv_decode.c, zipv_encode.cpp, zipv_decode.cpp, zipv_encode.pas, zipv_decode.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (manager.c, manager.cpp, manager.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza matricu od 100 x 100 8-bitnih celih brojeva (izme\u0111u 0 i 255). Zatim pozivaju funkciju Encode nad tom matricom, a nakon toga pozivaju funkciju Decode nad dobijenim nizom, i kona\u010dno ispisuju na standardni izlaz dobijenu matricu.</p>"},{"location":"takprog/2015_2016/sio/05_meteori/","title":"5 - Meteori","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 256MB <p>U eri brzih i dramati\u010dnih de\u0161avanja u vasioni se desila eksplozija ogromnih razmera. Ona je izazvala pomeranje ogromnog broja meteora. Nau\u010dnici poku\u0161avaju da izmodeliraju de\u0161avanja u vasioni. Polo\u017eaje meteora predstavljaju njihovim koordinatama u ravni. Iako je za o\u010dekivati da se meteori kre\u0107u u ogromnom broju razli\u010ditih pravaca, svaki od njih se kre\u0107e u jednom od \u010detiri pravca: na gore, na dole, udesno ili ulevo. Svi se kre\u0107u konstantnom brzinom od jednog metra po sekundi.</p> <p>Za obja\u0161njavanje doga\u0111anja, nau\u010dnici su zaklju\u010dili da im treba konveksni omota\u010d za skup ta\u010daka koje odgovaraju pozicijama meteora po isteku \\(10^{1000}\\) sekundi od eksplozije. Za to im treba va\u0161a pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dragan Uro\u0161evi\u0107 Uro\u0161 Kostadinovi\u0107 Ivan Sto\u0161i\u0107 <p>Zadatak re\u0161avamo koriste\u0107i neki od poznatih algoritama za konvkesni omota\u010d poput \"Graham scan\" i \"Monotone chain\". Problem se javlja kada \u017eelimo da izra\u010dunamo vektorski proizvod zato \u0161to su koordinate reda veli\u010dine \\(10^{1000}\\).</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je implementirati funkciju</p> \\[KonveksniOmotac(N, x[\u2026],y[\u2026],d[\u2026])\\] <p>gde je \\(N\\) - broj meteora, a \\(x\\), \\(y\\) i \\(d\\) nizovi koji opisuju meteore: \\(i\\)-ti meteor se nalazi na poziciji \\((x_i, y_i)\\) i, ukoliko je \\(d[i]=0\\), on se kre\u0107e na gore, ukoliko je \\(d[i]=1\\), on se kre\u0107e udesno, ukoliko je \\(d[i]=2\\), on se kre\u0107e na dole, a ukoliko je \\(d[i]=3\\) on se kre\u0107e ulevo. Svi nizovi su indeksirani od 0. Ova funkcija mora da vrati jedan ceo broj \u2013 broj temena na konveksnom omota\u010du skupa ta\u010daka koje predstavljaju pozicije meteora u toj dalekoj budu\u0107nosti. One ta\u010dke iz tog skupa, koje nisu temena konveksnog omota\u010da, ve\u0107 se nalaze na stranicama poligona se ne ra\u010dunaju.</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#primer","title":"Primer:","text":"<p>Neka \\(N=6\\), \\(x=[1, 12, 7, 3, 5, 4]\\), \\(y=[1, 2, 10, 4, 7, 8]\\) i \\(d=[0, 2,1,2,3,0]\\). Ovi podaci ozna\u010davaju da imamo 6 meteora: prvi je na poziciji 1,1 i ide na gore, drugi je na poziciji (12,2) i ide na dole, tre\u0107i je na poziciji (7,10) i ide udesno, \u010detvrti na poziciji (3,4) ide na dole, peti na poziciji (5,7) ide ulevo i \u0161esti na pozicji (4,8) ide na gore. Oba meteora koja idu na dole \u0107e biti na konveksnom omota\u010du. Meteor koji kre\u0107e sa pozicije (1,1) \u0107e biti unutar omota\u010da. Meteori koji idu udesno i ulevo (po jedan) \u0107e biti na konveksnom omota\u010du. Tako je odgovor 5.</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li> <p>\\(4\u2264N\u2264100.000\\)</p> </li> <li> <p>Za svako \\(i=[0,N-1]\\) va\u017ei \\(-10^9\u2264x_i, y_i \\leq 10^9\\) i \\(d[i] \\in \\{0, 1, 2, 3\\}\\)</p> </li> <li> <p>Sve koordinate su celi brojevi</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/05_meteori/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li> <p>PODZADATAK 1 [9 POENA]: \\(N\u22641.000\\).</p> </li> <li> <p>PODZADATAK 2 [24 POENA]: Svi meteori se kre\u0107u na gore ili na dole (ali bar po jedan u svakom od ta dva smera) tj. \\(d[i]=0\\) ili \\(d[i]=2\\) za svako [i].</p> </li> <li> <p>PODZADATAK 3 [18 POENA]: Koordinate meteora su brojevi izme\u0111u -5000 i 5000.</p> </li> <li> <p>PODZADATAK 4 [49 POENA]: Nema dodatnih ograni\u010denja.</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/05_meteori/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom meteori.c, meteori.cpp ili meteori.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <p>C/C++</p> <p>int KonveksniOmotac(int N, int x, int y, int* d);</p> <p>Pascal</p> <p>function KonveksniOmotac(N : longint; var x, y, s : array of longint) : longint;</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajla staviti #include \u201cmeteori.h\u201d a ukoliko radite u Pascal -u, potrebno je na po\u010detku fajla staviti Unit meteori; (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (meteori.c, meteori.cpp, meteori.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li> <p>U prvom redu broj \\(N\\)</p> </li> <li> <p>U slede\u0107ih \\(N\\) redova brojeve \\(x_i\\), \\(y_i\\), \\(d[i]\\), redom, razdvojene razmakom</p> </li> </ul> <p>a zatim pozivaju va\u0161u funkciju KonveksniOmotac iz odgovaraju\u0107eg fajla (meteori.c, meteori.cpp, meteori.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Mo\u017eemo implementirati mno\u017eenje, sabiranje i oduzimanje velikih brojeva koriste\u0107i niske. Primetimo tako\u0111e da je dovoljno posmatrati poziciju \\(10^{200}\\) sekundi nakon eksplozije te \u0107e mno\u017eenje niskih biti dovoljno brzo.</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>U daljem tekstu \\(\\aleph\\) predstavlja \\(10^{1000}\\). Ozna\u010dimo sa \\(U\\) skup svih meteora koji idu nagore i sa \\(D\\) skup svih meteora koji idu nadole. Ako \u017eelimo da odredimo da li ta\u010dka \\(C\\) ima desni ili levi zaokret u odnosu na (orijentisanu) du\u017e \\(AB\\) posle \\(\\aleph\\) sekundi razmotri\u0107emo slede\u0107e slu\u010dajeve: </p> <ol> <li> <p>\\(A,B,C\\in U\\): U ovom slu\u010daju mo\u017eemo izra\u010duanti orjentaciju pre eksplozije. </p> </li> <li> <p>\\(A,B\\in U\\) i \\(C\\in D\\): Ako \\(A_x=B_x\\) onda se prava \\(AB\\) ne\u0107e translirati i zbog toga mo\u017eemo da uporedimo \\(C_x\\) sa \\(A_x\\) i \\(A_y\\) sa \\(B_y\\). U suprotnom po\u0161to \u0107e se prava \\(AB\\) translirati za \\(\\aleph\\) nagore, ta\u010dka \\(C\\) \u0107e biti ispod prave \\(AB\\) posle eksplozije pa \u0107e zbog toga biti desni zaokret ako \\(B_x&gt;A_x\\), a ina\u010de levi.</p> </li> <li> <p>\\(A,C\\in U\\) i \\(B\\in D\\): Koeficijent prave \\(AB\\) \u0107e biti reda \\(10^{991}\\) i \\(A\\) i \\(C\\) se ne\u0107e pomeriti relativno (ostaju \"blizu\" jedna drugoj za razliku od ta\u010dke \\(B\\)), \\(|A_x-C_x| \\leq 2\\cdot 10^9\\), \\(|A_y-C_y| \\leq 2\\cdot 10^9\\) te \u0107e zaokret \\(C\\) u odnusu na \\(AB\\) biti isti kao i zaokret \\(C\\) u odnosu na \\(AD\\) gde je \\(D=(A_x,B_y)\\).</p> </li> </ol> <p>Svaki od ostalih 5 slu\u010dajeva je analogan nekom od prethodnih. Vremenska slo\u017eenost je \\(O(N \\log N)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Dovoljno je na svaku kordinatu dodati odnosno oduzeti \\(10^9\\) umesto \\(10^{1000}\\) i na\u0107i konveksni omota\u010d za te ta\u010dke. Ovo se mo\u017ee dokazati predstavljanjem brojeva kao parova sli\u010dno kao u glavnom re\u0161enju. Kada ra\u010dunamo vektorski proizvod nikada ne\u0107emo  mno\u017eiti neki broj vi\u0161e od jednom. Zbog toga \u0107e nam drugi broj u ure\u0111enom paru biti maksimalno reda \\(O(M^2)\\), gde je \\(|M| \\leq 5000\\), \u0161to \u0107e biti manje od \\(10^9\\), pa \u0107e tad i \\(c\\)-u odre\u0111ivati znak. Vremenska slo\u017eenost je \\(O(N \\log N)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2015_2016/sio/05_meteori/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Svaki broj \\(A\\) \u0107emo predstaviti kao ure\u0111enu trojku \\((a,b,c)\\) tako da \\(A = a\\cdot \\aleph ^2 + b \\cdot \\aleph + c\\) i \\(|a|,|b|,|c| &lt; \\aleph\\). Defini\u0161imo sabiranje, oduzimanje i mno\u017eenje dva para na slede\u0107i na\u010din:  \\(\\((a,b,c) + (d,e,f) = (a + d, b+e, c+f)\\)\\)</p> \\[(a,b,c) - (d,e,f) = (a-d, b-e, c-f)\\] \\[(a,b,c)\\cdot (d,e,f) = (a\\cdot f + d\\cdot c + b \\cdot e, b\\cdot f + e\\cdot c, c \\cdot f)\\] <p>U kodu \\(b\\) \u010dlan u ure\u0111enoj trojki \\((a,b,c)\\) nikad ne\u0107e pre\u0107i po apsolutnoj vrednosti \\(\\aleph\\) jer je ono preveliko, kao ni \\(a\\) . U mno\u017eenju dve trojke smo zanemarili vrednosti reda ve\u0107eg od \\(\\aleph ^2\\) jer kada ra\u010dunamo vektorski proizvod nijednu trojku ne\u0107emo mno\u017eiti vi\u0161e od jedamput, a svaka na po\u010detku ima \\(c = 0\\).  Svaku ta\u010dku posle \\(\\aleph\\) vremena \u0107emo predstaviti kao ure\u0111en par ure\u0111enih trojki \\(((a,b,c),(d,e,f))\\) gde su \\(c\\) i \\(f\\) koordinate ta\u010dke na po\u010detku, \\(b\\) i \\(e\\) odre\u0111eni u odnosu na pravac i smer kretanja meteora, a \\(a = c = 0\\). Mo\u017eemo vektorski proizvod dva vektora da ra\u010dunamo koriste\u0107i prethodno definisane operacije. </p> <p>Kada dobijemo \\((a,b,c)\\) kao rezultat potrebno je da proverimo znak broja \\(A = a\\cdot \\aleph^2 + b\\cdot \\aleph +c\\). Ako \\(A\\neq 0\\) onda znak odre\u0111uje \u010dlan u ure\u0111enoj trojci s najve\u0107om te\u017einom.</p> <p>Vremenska slo\u017eenost je \\(O(N \\log N)\\), a memorijska \\(O(N)\\).</p> 05_meteori.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;stdlib.h&gt;\n\n# define MAXN 100100\n\ntypedef struct {\n  int x, y;\n} tacka;\n\nint nc, na;\nint nau, nbu, ncu;\nint nad, nbd, ncd;\nint nal, nbl, ncl;\nint nar, nbr, ncr;\ntacka ct[MAXN];\ntacka atu[MAXN], btu[MAXN], ctu[MAXN];\ntacka atd[MAXN], btd[MAXN], ctd[MAXN];\ntacka atl[MAXN], btl[MAXN], ctl[MAXN];\ntacka atr[MAXN], btr[MAXN], ctr[MAXN];\n\nlong long vecpr(tacka t1, tacka t2, tacka t3) {\n  long long x12, x13, y12, y13;\n  x12 = t2.x - t1.x;\n  y12 = t2.y - t1.y;\n  x13 = t3.x - t1.x;\n  y13 = t3.y - t1.y;\n  return x12 * y13 - x13 * y12;\n}\n\ndouble tang(tacka t1, tacka t2) {\n  if (t1.x == t2.x) {\n    if (t2.y &gt; t1.y) \n      return 1000;\n    else\n      return -1000;\n  } \n  return (double)(t2.y - t1.y) / (t2.x - t1.x);\n}\n\ndouble tangje1(tacka t1, tacka t2) {\n    return (t2.x - t1.x) == (t2.y - t1.y);\n}\n\ndouble tangjem1(tacka t1, tacka t2) {\n    return (t2.x - t1.x) == (t1.y - t2.y);\n}\n\n\ndouble ctang(tacka t1, tacka t2) {\n  if (t1.y == t2.y) {\n    if (t2.x &gt; t1.x) \n      return 1000;\n    else\n      return -1000;\n  } \n  return (double)(t2.x - t1.x) / (t2.y - t1.y);\n}\n\nint cmptackaxu(const void *p1, const void *p2) {\n  const tacka *pt1, *pt2;\n  pt1 = (const tacka *)p1;\n  pt2 = (const tacka *)p2;\n  if (pt1-&gt;x != pt2-&gt;x)\n    return pt1-&gt;x - pt2-&gt;x;\n  else\n    return pt1-&gt;y - pt2-&gt;y;\n}\n\nint cmptackaxd(const void *p1, const void *p2) {\n  const tacka *pt1, *pt2;\n  pt1 = (const tacka *)p1;\n  pt2 = (const tacka *)p2;\n  if (pt1-&gt;x != pt2-&gt;x)\n    return pt1-&gt;x - pt2-&gt;x;\n  else\n    return pt2-&gt;y - pt1-&gt;y;\n}\n\nint cmptackayl(const void *p1, const void *p2) {\n  const tacka *pt1, *pt2;\n  pt1 = (const tacka *)p1;\n  pt2 = (const tacka *)p2;\n  if (pt1-&gt;y != pt2-&gt;y)\n    return pt1-&gt;y - pt2-&gt;y;\n  else\n    return pt2-&gt;x - pt1-&gt;x;\n}\n\nint cmptackayr(const void *p1, const void *p2) {\n  const tacka *pt1, *pt2;\n  pt1 = (const tacka *)p1;\n  pt2 = (const tacka *)p2;\n  if (pt1-&gt;y != pt2-&gt;y)\n    return pt1-&gt;y - pt2-&gt;y;\n  else\n    return pt1-&gt;x - pt2-&gt;x;\n}\n\nint chup(int n, tacka *at, tacka *bt) {\n  tacka pt;\n  int i, m, j1, j2;\n  if (n == 0) return 0;\n  if (n == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  qsort(at, n, sizeof(tacka), cmptackaxu);\n  j1 = j2 = n - 1;\n  while ((j1 &gt;= 0) &amp;&amp; (at[j1].x == at[j2].x)) j1--;\n  j1++;\n  while (j1 &lt; j2) {\n    pt = at[j1]; at[j1] = at[j2]; at[j2] = pt;\n    j1++; j2--;\n  }  \n  bt[0] = at[0]; bt[1] = at[1];\n  m = 2;\n  for (i = 2; i &lt; n; i++) {\n    while ((m &gt;= 2) &amp;&amp; \n           (vecpr(bt[m-2], bt[m-1], at[i]) &gt;= 0)) m--;\n    bt[m++] = at[i];\n  }\n  return m;\n}\n\nint chdown(int n, tacka *at, tacka *bt) {\n  tacka pt;\n  int i, j1, j2, m;\n  if (n == 0) return 0;\n  if (n == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  qsort(at, n, sizeof(tacka), cmptackaxd);\n  j1 = j2 = n - 1;\n  while ((j1 &gt;= 0) &amp;&amp; (at[j1].x == at[j2].x)) j1--;\n  j1++;\n  while (j1 &lt; j2) {\n    pt = at[j1]; at[j1] = at[j2]; at[j2] = pt;\n    j1++; j2--;\n  }  \n  bt[0] = at[0]; bt[1] = at[1];\n  m = 2;\n  for (i = 2; i &lt; n; i++) {\n    while ((m &gt;= 2) &amp;&amp; \n           (vecpr(bt[m-2], bt[m-1], at[i]) &lt;= 0)) m--;\n    bt[m++] = at[i];\n  }\n  return m;\n}\n\nint chleft(int n, tacka *at, tacka *bt) {\n  tacka pt;\n  int i, j1, j2, m;\n  if (n == 0) return 0;\n  if (n == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  qsort(at, n, sizeof(tacka), cmptackayl);\n  j1 = j2 = n - 1;\n  while ((j1 &gt;= 0) &amp;&amp; (at[j1].y == at[j2].y)) j1--;\n  j1++;\n  while (j1 &lt; j2) {\n    pt = at[j1]; at[j1] = at[j2]; at[j2] = pt;\n    j1++; j2--;\n  }  \n  bt[0] = at[0]; bt[1] = at[1];\n  m = 2;\n  for (i = 2; i &lt; n; i++) {\n    while ((m &gt;= 2) &amp;&amp; \n           (vecpr(bt[m-2], bt[m-1], at[i]) &gt;= 0)) m--;\n    bt[m++] = at[i];\n  }\n  return m;\n}\n\nint chright(int n, tacka *at, tacka *bt) {\n  tacka pt;\n  int i, j1, j2, m;\n  if (n == 0) return 0;\n  if (n == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  qsort(at, n, sizeof(tacka), cmptackayr);\n  j1 = j2 = n - 1;\n  while ((j1 &gt;= 0) &amp;&amp; (at[j1].y == at[j2].y)) j1--;\n  j1++;\n  while (j1 &lt; j2) {\n    pt = at[j1]; at[j1] = at[j2]; at[j2] = pt;\n    j1++; j2--;\n  }  \n  bt[0] = at[0]; bt[1] = at[1];\n  m = 2;\n  for (i = 2; i &lt; n; i++) {\n    while ((m &gt;= 2) &amp;&amp; \n           (vecpr(bt[m-2], bt[m-1], at[i]) &lt;= 0)) m--;\n    bt[m++] = at[i];\n  }\n  return m;\n}\n\nint filterup(int nt, tacka *at, tacka *bt) {\n  int i, mt;\n  if (nt == 0)\n    return 0;\n  if (nt == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  i = 0;\n  while ((i+1 &lt; nt) &amp;&amp; (tang(at[i], at[i+1]) &gt; 1)) i++;\n  bt[0] = at[i];\n  mt = 1;\n  for (i++; i &lt; nt; i++) {\n    if (tang(bt[mt-1], at[i]) &lt; -1) break;\n    bt[mt] = at[i];\n    mt++;\n  }  \n  return mt;\n}\n\n\nint filterdown(int nt, tacka *at, tacka *bt) {\n  int i, mt;\n  if (nt == 0)\n    return 0;\n  if (nt == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  i = 0;\n  while ((i+1 &lt; nt) &amp;&amp; (tang(at[i], at[i+1]) &lt; -1)) i++;\n  bt[0] = at[i];\n  mt = 1;\n  for (i++; i &lt; nt; i++) {\n    if (tang(bt[mt-1], at[i]) &gt; 1) break;\n    bt[mt] = at[i];\n    mt++;\n  }  \n  return mt;\n}\n\nint filterright(int nt, tacka *at, tacka *bt) {\n  int i, mt;\n  if (nt == 0)\n    return 0;\n  if (nt == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  i = 0;\n  while ((i+1 &lt; nt) &amp;&amp; (ctang(at[i], at[i+1]) &gt; 1)) i++;\n  bt[0] = at[i];\n  mt = 1;\n  for (i++; i &lt; nt; i++) {\n    if (ctang(bt[mt-1], at[i]) &lt; -1) break;\n    bt[mt] = at[i];\n    mt++;\n  }  \n  return mt;\n}\n\n\nint filterleft(int nt, tacka *at, tacka *bt) {\n  int i, mt;\n  if (nt == 0)\n    return 0;\n  if (nt == 1) {\n    bt[0] = at[0];\n    return 1;\n  }\n  i = 0;\n  while ((i+1 &lt; nt) &amp;&amp; (ctang(at[i], at[i+1]) &lt; -1)) i++;\n  bt[0] = at[i];\n  mt = 1;\n  for (i++; i &lt; nt; i++) {\n    if (ctang(bt[mt-1], at[i]) &gt; 1) break;\n    bt[mt] = at[i];\n    mt++;\n  }  \n  return mt;\n}\n\n\nint KonveksniOmotac(int n, int x[], int y[], int d[]) {\n  int i;\n  nau = nad = nal = nar = 0;\n  for (i = 0; i &lt; n; i++) \n    switch (d[i]) {\n      case 0:\n        atu[nau].x = x[i];\n        atu[nau].y = y[i];\n        nau++;\n        break;\n      case 2:\n        atd[nad].x = x[i];\n        atd[nad].y = y[i];\n        nad++;\n        break;\n      case 1:\n        atr[nar].x = x[i];\n        atr[nar].y = y[i];\n        nar++;\n        break;\n      case 3:\n        atl[nal].x = x[i];\n        atl[nal].y = y[i];\n        nal++;\n        break;\n    }\n  nbu = chup(nau, atu, btu);\n  nbd = chdown(nad, atd, btd);\n  nbr = chright(nar, atr, btr);\n  nbl = chleft(nal, atl, btl);\n/***\n  printf(\"%d %d %d %d\\n\", nau, nad, nal, nar);\n  printf(\"%d %d %d %d\\n\", nbu, nbd, nbl, nbr);\n  for (i = 0; i &lt; nbu; i++) \n    printf(\"U %d %d %lf\\n\", btu[i].x, btu[i].y, tang(btu[i], btu[i+1]));\n  for (i = 0; i &lt; nbd; i++) \n    printf(\"D %d %d %lf\\n\", btd[i].x, btd[i].y, tang(btd[i], btd[i+1]));\n  for (i = 0; i &lt; nbl; i++) \n    printf(\"L %d %d %lf\\n\", btl[i].x, btl[i].y, ctang(btl[i], btl[i+1]));\n  for (i = 0; i &lt; nbr; i++) \n    printf(\"R %d %d %lf\\n\", btr[i].x, btr[i].y, tang(btr[i], btr[i+1]));\n***/\n  if (nar + nal == 0) {\n    int nd = 0;\n    int n1u, n2u, n1d, n2d;\n    n1u = 0; n2u = nbu - 1;\n    n1d = 0; n2d = nbd - 1;\n    if (btu[n1u].x &lt; btd[n1d].x) {\n      if ((n1d &lt; n2d) &amp;&amp; (btd[n1d].x == btd[n1d+1].x)) n1d++; \n    } else {\n      if (btu[n1u].x &gt; btd[n1d].x) {\n        if ((n1u &lt; n2u) &amp;&amp; (btu[n1u].x == btu[n1u+1].x)) n1u++; \n      } else {\n        if ((n1u &lt; n2u) &amp;&amp; (btu[n1u].x == btu[n1u+1].x)) n1u++; \n        if ((n1d &lt; n2d) &amp;&amp; (btd[n1d].x == btd[n1d+1].x)) n1d++; \n      }\n    }\n    if (btu[n2u].x &lt; btd[n2d].x) {\n      if ((n1u &lt; n2u) &amp;&amp; (btu[n2u].x == btu[n2u-1].x)) n2u--; \n    } else {\n      if (btu[n2u].x &gt; btd[n2d].x) {\n        if ((n1d &lt; n2d) &amp;&amp; (btd[n2d].x == btd[n2d-1].x)) n2d--; \n      } else {\n        if ((n1u &lt; n2u) &amp;&amp; (btu[n2u].x == btu[n2u-1].x)) n2u--; \n        if ((n1d &lt; n2d) &amp;&amp; (btd[n2d].x == btd[n2d-1].x)) n2d--; \n      }\n    }\n    return n2u - n1u + n2d - n1d + 2;\n  }\n  nc = 0;\n  nc += ncu = filterup(nbu, btu, ctu);\n  nc += ncd = filterdown(nbd, btd, ctd);\n  nc += ncr = filterright(nbr, btr, ctr);\n  nc += ncl = filterleft(nbl, btl, ctl);\n\n/***\n  printf(\"%d %d %d %d\\n\", ncu, ncd, ncl, ncr);\n  for (i = 0; i &lt; ncu; i++) \n    printf(\"U %d %d\\n\", ctu[i].x, ctu[i].y);\n  for (i = 0; i &lt; ncd; i++) \n    printf(\"D %d %d\\n\", ctd[i].x, ctd[i].y);\n  for (i = 0; i &lt; ncl; i++) \n    printf(\"L %d %d\\n\", ctl[i].x, ctl[i].y);\n  for (i = 0; i &lt; ncr; i++) \n    printf(\"R %d %d\\n\", ctr[i].x, ctr[i].y);\n***/\n\n  int n1u, n2u, n1d, n2d, n1r, n2r, n1l, n2l;\n  n1u = n1d = n1r = n1l = 0;\n  n2u = ncu - 1;\n  n2d = ncd - 1;\n  n2r = ncr - 1;\n  n2l = ncl - 1;\n  if ((n2u &gt; n1u) &amp;&amp; tangjem1(ctu[n2u-1], ctu[n2u])) {\n    if (ctu[n2u].x + ctu[n2u].y &lt;= ctr[n2r].x + ctr[n2r].y) {\n        n2u--; nc--;\n    }\n  }\n  if ((n2r &gt; n1r) &amp;&amp; tangjem1(ctr[n2r-1], ctr[n2r])) {\n    if (ctr[n2r].x + ctr[n2r].y &lt;= ctu[n2u].x + ctu[n2u].y) {\n        n2r--; nc--;\n    }\n  }\n  if ((n1u &lt; n2u) &amp;&amp; tangje1(ctu[n1u], ctu[n1u+1])) {\n    if (ctu[n1u].y - ctu[n1u].x &lt;= ctl[n2l].y - ctl[n2l].x) {\n        n1u++; nc--;\n    }\n  }\n  if ((n1l &lt; n2l) &amp;&amp; tangje1(ctl[n2l-1], ctl[n2l])) {\n    if (ctu[n1u].y - ctu[n1u].x &gt;= ctl[n2l].y - ctl[n2l].x) {\n        n2l--; nc--;\n    }\n  }\n  if ((n1l &lt; n2l) &amp;&amp; tangjem1(ctl[n1l], ctl[n1l+1])) {\n    if (ctd[n1d].x + ctd[n1d].y &lt;= ctl[n1l].x + ctl[n1l].y) {\n        n1l++; nc--;\n    }\n  }\n  if ((n1d &lt; n2d) &amp;&amp; tangjem1(ctd[n1d], ctd[n1d+1])) {\n    if (ctd[n1d].x + ctd[n1d].y &gt;= ctl[n1l].x + ctl[n1l].y) {\n        n1d++; nc--;\n    }\n  }\n  if ((n1d &lt; n2d) &amp;&amp; tangje1(ctd[n2d-1], ctd[n2d])) {\n    if (ctr[n1r].y - ctr[n1r].x &lt;= ctd[n2d].y - ctd[n2d].x) {\n        n2d--; nc--;\n    }\n  }\n  if ((n1r &lt; n2r) &amp;&amp; tangje1(ctr[n1r], ctr[n1r+1])) {\n    if (ctr[n1r].y - ctr[n1r].x &gt;= ctd[n2d].y - ctd[n2d].x) {\n        n1r++; nc--;\n    }\n  }\n  return nc;\n}      \n\n\nint chff(int n, int x[], int y[], int d[]) {\n  int nd;\n  int i, dd;\n  dd = 1000000000;\n  nau = nad = nal = nar = 0;\n  for (i = 0; i &lt; n; i++) \n    switch (d[i]) {\n      case 0:\n        atu[nau].x = x[i];\n        atu[nau].y = y[i] + dd;\n        nau++;\n        break;\n      case 2:\n        atu[nau].x = x[i];\n        atu[nau].y = y[i] - dd;\n        nau++;\n        break;\n      case 1:\n        atu[nau].x = x[i] + dd;\n        atu[nau].y = y[i];\n        nau++;\n        break;\n      case 3:\n        atu[nau].x = x[i] - dd;\n        atu[nau].y = y[i];\n        nau++;\n        break;\n    }\n  nbu = chup(nau, atu, btu);\n  nbd = chdown(nau, atu, btd);\n/***\n  printf(\"%d %d %d %d\\n\", nau, nad, nal, nar);\n  printf(\"%d %d %d %d\\n\", nbu, nbd, nbl, nbr);\n  for (i = 0; i &lt; nbu; i++) \n    printf(\"U %d %d\\n\", btu[i].x, btu[i].y);\n  for (i = 0; i &lt; nbd; i++) \n    printf(\"D %d %d\\n\", btd[i].x, btd[i].y);\n***/\n  nd = 2;\n  if (btu[0].x == btu[1].x) nd++;\n  if (nbu &gt; 2)\n    if (btu[nbu-1].x == btu[nbu-2].x) nd++;\n  nc = nbu + nbd - nd;\n  return nc;\n}      \n\n\nint n;\nint x[MAXN], y[MAXN], d[MAXN];\n\nmain() {\n  int i;\n  scanf(\"%d\", &amp;n);\n  for (i = 0; i &lt; n; i++) \n    scanf(\"%d%d%d\", &amp;x[i], &amp;y[i], &amp;d[i]);\n  printf(\"%d\\n\", KonveksniOmotac(n, x, y, d));\n//  printf(\"%d\\n\", chff(n, x, y, d));\n}\n</code></pre>"},{"location":"takprog/2015_2016/sio/06_svemir/","title":"6 - Svemir","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Sredinom 23. veka ljudi sa planete Zemlje su kona\u010dno razvili tehnike me\u0111uplanetarnog putovanja i krenuli sa osvajanjem svemira! Ve\u0107 za dve godine su osvojili \\(N\\) planeta, numerisali ih brojevima od 1 do \\(N\\) i napravili svemirske tunele izme\u0111u nekih od njih! Svi tuneli su dvosmerni i sistem tunela je napravljen tako da za svake dve planete postoji jedinstven na\u010din da se od jedne do\u0111e do druge koriste\u0107i ove tunele i neke usputne planete. Mo\u017ee se zaklju\u010diti da tih tunela ima ta\u010dno \\(N-1\\) i da zajedno sa planetama obrazuju strukturu koju ljudi na Zemlji nazivaju stablom. Ti tuneli su zapravo neka vrsta crnih rupa i to nema puno smisla ali ono \u0161to je bitno je \u010dinjenica da se ovaj zadatak de\u0161ava u svemiru!</p> <p>Osim \u0161to su u svemiru, ove planete imaju i neka druga svojstva \u2013 za svaku planetu je poznata vrednost \\(C_i\\) koja predstavlja kvalitet svemirskih sarmi na ovim planetama; neke od ovih vrednosti mogu biti i negativne \u0161to je logi\u010dno u svemiru. Poznati krijum\u010dar svemirskih sarmi Jurij Margarin je skovao svemirski plan \u2013 izabra\u0107e dve (ne nu\u017eno razli\u010dite) planete \\(A\\) i \\(B\\) i trejdova\u0107e sarme na svim planetama (uklju\u010duju\u0107i i ove dve) koje se nalaze na (setimo se) jednistvenom putu izme\u0111u \\(A\\) i \\(B\\). Juriju je naravno cilj da zbir kvaliteta trejdovanih sarmi bude najve\u0107i mogu\u0107.</p> <p>Jedini problem u celoj ovoj svemirskoj pri\u010di je \u0161to Margarina (i sve nas) vidi Svemirska policija, svetlost univerzuma. Preciznije, postoji ta\u010dno \\(K\\) svemirskih patrola \u2013 za svaku je poznata po\u010detna i krajnja planeta \\(P_i\\) i \\(Q_i\\) (\\(P_i \\neq Q_i\\)) njihovog patroliranja i ta patrola obilazi sve planete na jedinstvenom putu izme\u0111u planeta \\(P_i\\) i Qi (uklju\u010duju\u0107i i njih). Sa vedrije strane, Jurij Margarin ima dovoljno sarmi u svemirskom \u0161teku da podmiti najvi\u0161e jednu svemirsku patrolu. Prema tome, Jurij mora izabrati put sa najve\u0107im zbirom kvaliteta sarmi ali takav da se na tom putu on mo\u017ee susresti sa najvi\u0161e jednom patrolom (mo\u017eda vi\u0161e puta). Pomozite mu!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dimitrije Dimi\u0107 Nemanja Majski Nikola Milosavljevi\u0107 06_svemir.cpp"},{"location":"takprog/2015_2016/sio/06_svemir/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> \\[SvemirskiPut(N, K, t,pat, c[\u2026])\\] <p>gde je \\(N\\) \u2013 broj planeta, $K \u2013 broj svemirskih patrola, t niz du\u017eine 2(N-1) koji opisuju tunele, pat niz du\u017eine 2K koji opisuje patrole i c je niz kvaliteta du\u017eine N. U nizu t su, redom, navedeni parovi planeta izme\u0111u kojih postojoje tuneli (postoji tunel izme\u0111u planeta \\(t[0]\\) i \\(t[1]\\), izme\u0111u planeta \\(t[2]\\) i \\(t[3]\\) i u op\u0161tem slu\u010daju izme\u0111u planeta \\(t[2i]\\) i \\(t[2i+1]\\) za svako \\(i=[0,N-2]\\)). Na potpuno isti na\u010din niz pat opisuje parove planeta izme\u0111u kojih postoji svemirska patrola. Na kraju, za svako \\(i=[0,N-1]\\) kvalitet sarmi na planeti \\(i+1\\) je \\(c[i]\\). Svi nizovi su indeksirani od 0. Ova funkcija mora da vrati jedan ceo broj \u2013 najve\u0107i mogu\u0107i zbir kvaliteta sarmi na Margarinovom put koji zadovoljava gore pomenute uslove.</p>"},{"location":"takprog/2015_2016/sio/06_svemir/#primer","title":"Primer:","text":"<p>Neka je N=9, K=3, t=[1, 3, 3, 9, 2, 4, 7, 8, 9, 8, 9, 6, 8, 5, 2, 9], pat=[4, 2, 3, 8, 7, 5] i c=[-3, 15, 20, 10, 20, 10, 20, 20, -2]. Ovi podaci opisuju sistem planeta i tunela kao na slici: plavi krugovi predstavljaju planete pri \u010demu su njihovi redni brojevi unutar krugova a brojevi pored njih predstavljaju kvalitet njihvih sarmi; plave linije predstaljaju tunele; ostale linije predstavljaju patrole \u2013 imamo 3 patrole, prva patroli\u0161e izme\u0111u planeta 2 i 4 (obilazi obe), druga izme\u0111u planeta 3 i 8 (obilazi planete 3, 9 i 8) i tre\u0107a izme\u0111u planeta 7 i 5 (obilazi planete 5, 8 i 7). Jurij \u0107e najbolje trejdovati sarme ako izabere planete 3 i 6 \u2013 tada podmi\u0107uje samo drugu patrolu a ukupan kvalitet sarmi na putu od 3 do 6 jednak 20 + (-2) + 10 = 28; bolje od toga ne mo\u017ee i to je broj koji va\u0161a funkcija treba da vrati. Primetimo da Jurij npr. ne mo\u017ee izabrati put izme\u0111u planeta 3 i 4 ili izme\u0111u 3 i 8 jer bi se onda mogao susresti sa dve razli\u010dite patrole.</p> <p></p>"},{"location":"takprog/2015_2016/sio/06_svemir/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li> <p>\\(2\u2264N\u2264200.000\\)</p> </li> <li> <p>\\(1\u2264K\u2264200.000\\)</p> </li> <li> <p>Za svako \\(0\u2264i&lt;2N-1\\) va\u017ei \\(1\u2264t[i]\u2264N\\)</p> </li> <li> <p>Za svako \\(0\u2264i&lt;2K\\) va\u017ei \\(1\u2264 pat[i]\u2264N\\)</p> </li> <li> <p>Za svako \\(0\u2264i&lt;K\\) va\u017ei \\(pat[2i]\u2260pat[2i+1]\\)</p> </li> <li> <p>Za svako \\(0\u2264i&lt;N\\) va\u017ei \\(-10^9 \\leq c[i] \\leq 10^9\\)</p> </li> <li> <p>Ulazni podaci \u0107e biti takvi da \u0107e izme\u0111u svake dve planete postojati jedinstven put</p> </li> <li> <p>Ulazni podaci \u0107e biti takvi da \u0107e re\u0161enje uvek postojati</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/06_svemir/#podzadaci-i-bodovanje","title":"Podzadaci i bodovanje","text":"<ul> <li> <p>PODZADATAK 1 [15 POENA]: \\(N,K\u22641.000\\)</p> </li> <li> <p>PODZADATAK 2 [15 POENA]: Planete su povezane na slede\u0107i na\u010din: \\(1-2-3-\u22ef-n\\)</p> </li> <li> <p>PODZADATAK 3 [20 POENA]: Sve sarme u svemiru su nekvalitetne tj. \\(c[i]&lt;0\\) za svako \\(i\\)</p> </li> <li> <p>PODZADATAK 4 [20 POENA]: K\u2264100</p> </li> <li> <p>PODZADATAK 5 [30 POENA]: Nema dodatnih ograni\u010denja</p> </li> </ul>"},{"location":"takprog/2015_2016/sio/06_svemir/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl, pod nazivom svemir.c, svemir.cpp ili svemir.pas, koji implementira gore pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Zavisno od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> <p>C/C++</p> <p>long long SvemirskiPut(int N, int K, int t, int pat, int* c);</p> <p>Pascal</p> <p>function SvemirskiPut(N, K : longint; var t, pat, c : array of longint) : int64;</p> <p>Ukoliko radite u C/C++ -u, potrebno je na po\u010detku fajla staviti #include \u201csvemir.h\u201d a ukoliko radite u Pascal -u, potrebno je na po\u010detku fajla staviti Unit svemir; (ovo je ve\u0107 dodato u fajlovima koji su vam obezbe\u0111eni).</p>"},{"location":"takprog/2015_2016/sio/06_svemir/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \u201ctemplate\u201d fajlovi (svemir.c, svemir.cpp, svemir.pas) koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi (grader.c, grader.cpp, grader.pas) koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li> <p>U prvom redu brojeve \\(N\\) i \\(K\\), redom</p> </li> <li> <p>U narednom redu \\(2(N-1)\\) brojeva \\(t[i]\\), razdvojenih razmakom</p> </li> <li> <p>U narednom redu \\(2K\\) brojeva \\(pat[i]\\), razdvojenih razmakom</p> </li> <li> <p>U narednom redu \\(N\\) brojeva \\(c[i]\\), razdvojenih razmakom</p> </li> </ul> <p>a zatim pozivaju va\u0161u funkciju SvemirskiPut iz odgovaraju\u0107eg fajla (svemir.c, svemir.cpp, svemir.pas) sa u\u010ditanim parametrima i na kraju vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2016_2017/drz/01_bond/","title":"B1 - Bond","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Po\u0161to je dobio dozvolu za ubijanje, dobro poznati agent Bond, D\u017eejms Bond, se uputio u, nama susednu, Crnu Goru kako bi spasio svet. On je saznao da se ozlogla\u0161eni Le \u0160ifr uputio u kazino kako bi u\u010destvovao u turniru sa velikim ulogom u igri Rojal. Kako bi osujetili planove Le \u0160ifra i naterali ga da se preda, MI6 planira da ubaci Bonda u turnir, veruju\u0107i da ba\u0161 on mo\u017ee da pobedi. Kao \u0161to to obi\u010dno biva, do finala su stigli ba\u0161 Bond i Le \u0160ifr. </p> <p>Rojal je veoma jednostavna igra. Na po\u010detku igre se odredi broj \\(k\\). Potom prvi igra\u010d baca \u0161estostranu kockicu (svaka strana kockice ima urezan broj od 1 do 6) \\(k\\) puta i zabele\u017ee se brojevi na kojima kockica stane prilikom svakog bacanja. Ozna\u010dimo dobijene brojeve sa \\(A = [a_1, a_2, ..., a_k]\\). Zatim drugi igra\u010d baca istu kockicu \\(k\\) puta i zabele\u017ei brojeve koje dobije. Ozna\u010dimo dobijene brojeve sa \\(B = [b_1, b_2, ..., b_k]\\). Posle bacanja kockica sledi upore\u0111ivanje nizova \\(A\\) i \\(B\\) i to se radi na slede\u0107i na\u010din:</p> <ul> <li>Najpre se brojevi u nizu \\(A\\) sortiraju u neopadaju\u0107i poredak i tako se dobije novi niz \\(A' = [a'_1, a'_2, ..., a'_k]\\).</li> <li>Sli\u010dno se brojevi u nizu \\(B\\) sortiraju u neopadaju\u0107i poredak kako bi se dobio novi niz \\(B' = [b'_1, b'_2, ..., b'_k]\\).</li> <li>Na kraju se brojevi u nizovima upore\u0111uju jedan po jedan, tj. broj \\(a'_i\\) se upore\u0111uje sa \\(b'_i\\) (gde \\(1 &lt;= i &lt;= k\\)). Sa \\(R_1\\) ozna\u010dimo broj puta gde je \\(a'_i &gt; b'_i\\), a sa \\(R_2\\) broj puta gde je \\(a'_i &lt; b'_i\\). Broj poena koje prvi igra\u010d osvoji je ba\u0161 \\(R_1\\), a \\(R_2\\) predstavlja broj poena drugog igra\u010da.</li> </ul> <p>Npr. pretpostavimo da je \\(k = 5\\) i da prvi igra\u010d prilikom bacanja kockice dobija brojeve \\(A = [6, 4, 1, 4, 3]\\), a drugi igra\u010d dobija brojeve \\(B = [1, 5, 3, 2, 5]\\). Po sortiranju ovih nizova dobijamo nizove \\(A' = [1, 3, 4, 4, 6]\\) i \\(B' = [1, 2, 3, 5, 5]\\). Upore\u0111ivanjem brojeva ova dva niza imamo: \\(1 = 1\\), \\(3 &gt; 2\\), \\(4 &gt; 3\\), \\(4 &lt; 5\\) i \\(6 &gt; 5\\), tj. \\(R_1 = 3\\) i \\(R_2 = 1\\).</p> <p>Bond je saznao da \u0107e u finalu da se koristi specijalna kockica za koju mo\u017ee da predvidi na kojim brojevima \u0107e da stane za prvih \\(2 \\cdot N\\) bacanja, tj. u prvih \\(2 \\cdot N\\) bacanja, kockica \u0107e da padne na brojeve \\(X = [x_1, x_2, ..., x_{2 \\cdot N}]\\) redom. Zna se da \u0107e Bond da bude prvi igra\u010d i jo\u0161 ima pravo da odabere broj \\(k\\) koji predstavlja broj bacanja kockice svakog igra\u010da u igri. Me\u0111utim, mora da va\u017ei da ukupan broj bacanja kockice ne sme biti ve\u0107i od \\(2 \\cdot N\\), tj. \\(1 &lt;= k &lt;= N\\).</p> <p>Va\u0161 zadatak je da pomognete Bondu da odabere njemu najpovoljnije \\(k\\), tj. takvo \\(k\\) gde \u0107e osvojiti najvi\u0161e poena.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Spasi\u0107 Boris Grubi\u0107 Aleksa Dani\u0107 Dimitrije Erdeljan"},{"location":"takprog/2016_2017/drz/01_bond/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalazi prirodan broj \\(N\\) koji ozna\u010dava maksimalan broj bacanja kockice. U slede\u0107em redu se nalazi \\(2 \\cdot N\\) celih brojeva \\(x_1, x_2, ..., x_{2 \\cdot N}\\) koji predstavljaju vrednosti na koje \u0107e kockica da padne u prvih \\(2 \\cdot N\\) bacanja, redom (u prvom bacanju kockica \u0107e da padne na broj \\(x_1\\), u drugom na \\(x_2\\), itd.).</p>"},{"location":"takprog/2016_2017/drz/01_bond/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standarni izlaz je potrebno ispisati jedan ceo broj, \\(R_1\\), koji predstavlja maksimalan broj poena koje Bond mo\u017ee da osvoji.</p>"},{"location":"takprog/2016_2017/drz/01_bond/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/01_bond/#ulaz","title":"Ulaz","text":"<pre><code>4\n2 4 6 1 5 3 5 2\n</code></pre>"},{"location":"takprog/2016_2017/drz/01_bond/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/drz/01_bond/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/drz/01_bond/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n1 1 2 2\n</code></pre>"},{"location":"takprog/2016_2017/drz/01_bond/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2016_2017/drz/01_bond/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U ovom test primeru, mogu\u0107e vrednosti za \\(k\\) su 1, 2, 3 i 4.</p> <ul> <li>Ukoliko je \\(k = 1\\), onda imamo \\(A = [x_1] = [2], B = [x_2] = [4]\\), tj. \\(A' = [2], B' = [4]\\) i ovde imamo da je \\(R_1 = 0\\).</li> <li>Ukoliko je \\(k = 2\\), onda imamo \\(A = [x_1, x_2] = [2, 4], B = [x_3, x_4] = [6, 1]\\), tj. \\(A' = [2, 4], B' = [1, 6]\\) i ovde imamo da je \\(R_1 = 1\\).</li> <li>Ukoliko je \\(k = 3\\), onda imamo \\(A = [x_1, x_2, x_3] = [2, 4, 6], B = [x_4, x_5, x_6] = [1, 5, 3]\\), tj. \\(A' = [2, 4, 6], B' = [1, 3, 5]\\) i ovde imamo da je \\(R_1 = 3\\).</li> <li>Ukoliko je \\(k = 4\\), onda imamo \\(A = [x_1, x_2, x_3, x_4] = [2, 4, 6, 1], B = [x_5, x_6, x_7, x_8] = [5, 3, 5, 2]\\), tj. \\(A' = [1, 2, 4, 6], B' = [2, 3, 5, 5]\\) i ovde imamo da je \\(R_1 = 1\\).</li> </ul> <p>Dakle, najve\u0107i broj poena koje Bond mo\u017ee da osvoji je 3.</p> <p>U drugom test primeru, koje god \\(k\\) Bond da odabere, ima\u0107e 0 poena.</p>"},{"location":"takprog/2016_2017/drz/01_bond/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq x_1, x_2, ..., x_{2 \\cdot N} \\leq 6\\)</li> </ul> <p>Postoje 3 podzadatka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [21 poen]: \\(1 \\leq N \\leq 100\\).</li> <li>Podzadatak 2 [31 poen]: \\(1 \\leq N \\leq 5000\\).</li> <li>Podzadatak 3 [48 poen]: \\(1 \\leq N \\leq 1000000\\)</li> </ul>"},{"location":"takprog/2016_2017/drz/01_bond/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Za re\u0161enje ovog podzadatka dovoljno je simulirati igru za svako \\(k\\). Neka je \\(A=[a_1,a_2,...,a_k]\\), \\(B=[a_{k+1},a_{k+2},...,a_{2k}]\\). Ova dva niza mo\u017eemo sortirati nekim od algoritama za sortiranje koji rade u vremenskoj slo\u017eenosti \\(O(N^2)\\). Jednostavno na\u0111emo broj indeksa \\(i\\) za koje va\u017ei \\(A_i&gt;B_i\\), i pamtimo za koje \\(k\\) je on najve\u0107i. Vremenska slo\u017eenost ovog algoritma je \\(O(N^3)\\).</p>"},{"location":"takprog/2016_2017/drz/01_bond/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Koristimo istu ideju kao u prvom podzadatku. Efikasnijim algoritmom za sortiranje mo\u017eemo ostvariti vremensku slo\u017eenost \\(O(N^2logN)\\) ili \\(O(N^2)\\), u zavisnosti od implementacije.</p>"},{"location":"takprog/2016_2017/drz/01_bond/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Primetimo da je broj razli\u010ditih elemenata u nizu veoma mali, samo \\(6\\). Kao i u prethodnim podzadacima, fiksiramo broj bacanja kockice \\(k\\). Umesto da pe\u0161ke ra\u010dunamo broj poena koje bi Bond osvojio, odr\u017eavamo dva niza du\u017eine \\(6\\): \\(cntA\\) i \\(cntB\\), gde je \\(cntA_i\\) broj pojavljivanja broja \\(i\\) u nizu \\(A\\), a \\(cntB_i\\) broj pojavljivanja broja \\(i\\) u nizu \\(B\\) (koristimo oznake iz prvog podzadatka). Ova dva niza su nam dovoljna da u vremenskoj slo\u017eenosti \\(O(1)\\) na\u0111emo tra\u017eeni broj poena. Vremenska slo\u017eenost je \\(O(N)\\).</p> 01_bond.cpp<pre><code>// O(N) - sve subtaskove\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint n;\nint x[2000000];\n\nint cnt1[7];\nint cnt2[7];\n\nint calcRes() {\n    int ret = 0;\n    int sum1 = 0;\n    int sum2 = 0;\n    int last = 0;\n    for (int i = 1; i &lt;= 6; ++i) {\n        sum1 += cnt1[i];\n        sum2 += cnt2[i];\n        if (sum1 &lt; sum2) {\n            ret += sum2 - max(sum1, last);\n            last = sum2;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; 2 * n; ++i) {\n        scanf(\"%d\", &amp;x[i]);\n    }\n\n    memset(cnt1, 0, sizeof(cnt1));\n    memset(cnt2, 0, sizeof(cnt2));\n\n    int res = 0;\n    for (int k = 0; k &lt; n; ++k) {\n        cnt1[x[k]]++;\n        cnt2[x[k]]--;\n        cnt2[x[2 * k]]++;\n        cnt2[x[2 * k + 1]]++;\n        res = max(res, calcRes());\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/drz/02_hari/","title":"B2 - Hari","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 400ms 64MB <p>Hogvorts, \u0161kola magije i \u010darobnja\u0161tva, priprema se za uskr\u0161nji raspust kada svi u\u010denici idu ku\u0107i na zaslu\u017eeni odmor. Kako je magija zabranjena u svetu obi\u010dnih ljudi, \u010darobnjaci ne nose svoje \u010darobne \u0161tapove, ve\u0107 ih ostavljaju Hagridu na \u010duvanje. \u010carobni \u0161tapovi se \u010duvaju u posebnim magi\u010dnim kutijama. Hagrid je vrlo senilan, pa je zaboravio gde je ostavio magi\u010dne kutije, te mora da napravi nove.</p> <p>Da se \u0161tapovi ne bi pome\u0161ali, pa da nakon raspusta \u010darobnjaci ne mogu da na\u0111u svoj \u0161tap, postoji posebna procedura. Najpre svi \u010darobnjaci, njih \\(N\\), ostave svoje \u0161tapove na duga\u010dkom stolu, a onda ih Hagrid redom pakuje u kutije. Hagrid mora da ih pakuje redom, tj svaka kutija treba sadr\u017eati samo uzastopne \u0161tapove.</p> <p>Mora se voditi ra\u010duna i o stabilnosti kutija. U svakoj kutiji mora biti isti broj \u0161tapova. Tako\u0111e, \u0161tapovi imaju starost, izra\u017eenu u godinama. Ukoliko se u jednoj kutiji na\u0111e vi\u0161e od \\(K\\) \u010darobnih \u0161tapova iste starosti, mo\u017ee do\u0107i do velike magi\u010dne eksplozije.</p> <p>Hagrida zanima na koliko na\u010dina mo\u017ee da upakuje \u0161tapove u kutije, a da ispo\u0161tuje sva pravila.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Dejkovi\u0107 Ivan Dejkovi\u0107 Uro\u0161 Vuki\u0107evi\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2016_2017/drz/02_hari/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja, \\(N\\) - broj \u010darobnjaka i \\(K\\) - najve\u0107i dozvoljeni broj \u0161tapova iste starosti koji se mogu na\u0107i u jednoj kutiji. U slede\u0107em redu nalazi se N celih brojeva, \\(A_1, A_2, ..., A_N\\) koji predstavljaju starosti \u0161tapova.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz potrebno je ispisati jedan broj, koji predstavlja broj na\u010dina na koji Hagrid mo\u017ee podeliti \u0161tapove u kutije.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/02_hari/#ulaz","title":"Ulaz","text":"<pre><code>6 1\n1 5 3 3 7 4 \n</code></pre>"},{"location":"takprog/2016_2017/drz/02_hari/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2016_2017/drz/02_hari/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/drz/02_hari/#ulaz_1","title":"Ulaz","text":"<pre><code>12 2\n1 2 3 4 2 3 4 2 1 2 3 4\n</code></pre>"},{"location":"takprog/2016_2017/drz/02_hari/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2016_2017/drz/02_hari/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru K je 1, \u0161to zna\u010di da svi \u0161tapovi u jednoj kutiji moraju imati razli\u010ditu starost. Mogu\u0107e je staviti svaki \u0161tap u posebnu kutiju, ili prva tri u jednu kutiju, a slede\u0107a tri u drugu. Ako se stavljaju po dva, druga kutija \u0107e sadr\u017eati \u0161tapove starosti 3 i 3, \u0161to nije stabilno. U drugom primeru validne su podele na po 1, 2, 3, 4 i 6 \u0161tapova po kutiji.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq K \\leq 200000\\)</li> <li>\\(1 \\leq A_i \\leq 10^9\\)</li> </ul> <p>Postoje 4 podzadatka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [16 poena]: \\(1 \\leq N \\leq 100\\).</li> <li>Podzadatak 2 [24 poena]: \\(1 \\leq N \\leq 20000\\).</li> <li>Podzadatak 3 [29 poena]: \\(1 \\leq N \\leq 200000\\) i \\(1 \\leq A_i \\leq 10^6\\).</li> <li>Podzadatak 4 [31 poena]: \\(1 \\leq N \\leq 200000\\).</li> </ul>"},{"location":"takprog/2016_2017/drz/02_hari/#napomena","title":"Napomena","text":"<p>Dozvoljeno je staviti i sve \u0161tapove u jednu kutiju, ukoliko su ispunjni sva pravila.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Kako su ograni\u010denja mala, zadatak se mo\u017ee re\u0161iti direktnom implementacijom teksta zadatka, odnosno grubom silom.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>U ovom podzadatku prolaze sporije implementacije glavnog re\u0161enja, koje ina\u010de ne bi pro\u0161le. Na primer, kori\u0161\u0107enje struktura std::set ili std::map je neefikasno, ali donosi odre\u0111en broj poena.</p>"},{"location":"takprog/2016_2017/drz/02_hari/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>Po\u0161to kutije moraju sadr\u017eati isti broj \u0161tapova, kandidati za broj \u0161tapova u svakoj od kutija su samo delioci broja \\(N\\). Delioce broja \\(N\\) mo\u017eemo na\u0107i u \\(O(\\sqrt{N})\\) . Tako\u0111e, za \\(N\\le200000\\) najve\u0107i broj delilaca bi\u0107e \\(160\\) . Ova \u010dinjenica se mo\u017ee potvrditi lokalno generisanim kodom.</p> <p>Sada mo\u017eemo napraviti niz vektora \\(pos\\); \\(pos_{x}\\) predstavlja sve pozicije broja \\(x\\) u nizu, pore\u0111ane od manje ka ve\u0107oj. Nakon toga za fiksirani delilac \\(d\\) mo\u017eemo proveriti da li je ta veli\u010dina kutije validna. To radimo tako \u0161to za svaki \u0161tap \\(x\\) proverimo da li se on u svakoj kutiji pojavio ne vi\u0161e od \\(K\\) puta. Za bilo koju poziciju \\(i\\), najlevlji \u0161tap koji \u0107e sadr\u017eati kutija koja sadr\u017ei i \\(i\\)-ti \u0161tap bi\u0107e najve\u0107i sadr\u017ealac \\(d\\) koji je manji ili jednak od \\(i\\). Zbog ove \u010dinjenice mo\u017eemo samo jednom pro\u0107i kroz sve pozicije \u0161tapa \\(x\\) i proveriti da li se on u svakoj kutiji pojavio ne vi\u0161e od \\(K\\) puta. </p> <p>Vremenska slo\u017eenost je \\(O(T \\cdot (maxA_i+N))\\), a memorijska slo\u017eenost je \\(O(maxA_i+N)\\).  \\(T\\) predstavlja broj delilaca broja \\(N\\), koji iznosi najvi\u0161e \\(160\\).</p>"},{"location":"takprog/2016_2017/drz/02_hari/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Po\u0161to nam je za bilo koja dva \u0161tapa va\u017eno samo da li su isti, niz mo\u017eemo kompresovati(u slo\u017eenosti \\(O(N\\log N)\\)) tako da sve vrednosti budu manje od ili jednake \\(N\\). Nakon \u0161to smo to uradili, re\u0161enje se svodi na re\u0161enje iz prethodnog podzadatka. </p> <p>Vremenska slo\u017eenost je \\(O(N\\log N + T\\cdot N)\\), a memorijska slo\u017eenost je \\(O(N)\\).</p> 02_hari.cpp<pre><code>//carobni stapovi\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstruct Stap {\n    int tip;\n    int pozicija;\n\n    bool operator &lt; (const Stap &amp;s) const {\n        if (tip != s.tip) {\n            return tip &lt; s.tip;\n        }\n        return pozicija &lt; s.pozicija;\n    }\n};\n\nint n, k, br_delilaca, delilac[12345], k_ti[200000];\nStap stap[200000];\n\nvoid nadji_delioce(int n) {\n    br_delilaca = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        if (n % i == 0) {\n            delilac[br_delilaca++] = i;\n        }\n    }\n}\n\nbool proveri_grupu(int pocetak, int kraj) {\n    for (int i = pocetak; i &lt; kraj; i++) {\n        if (k_ti[i] == -1) {\n            continue;\n        }\n        if (k_ti[i] &lt; kraj) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    for (int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;stap[i].tip);\n        stap[i].pozicija = i;\n    }\n\n    nadji_delioce(n);\n\n    sort(stap, stap + n);\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i + k &gt;= n || stap[i].tip != stap[i + k].tip) {\n            k_ti[stap[i].pozicija] = -1;\n        }\n        else {\n            k_ti[stap[i].pozicija] = stap[i + k].pozicija;\n        }\n    }\n\n    int br_nacina = 0;\n\n    for (int d = 0; d &lt; br_delilaca; d++) {\n        int br_grupa = n / delilac[d];\n        bool balans = true;\n\n        for (int g = 0; g &lt; br_grupa; g++) {\n            int pocetak = g * delilac[d];\n            int kraj = (g+1) * delilac[d];\n            if (!proveri_grupu(pocetak, kraj)) {\n                balans = false;\n                break;\n            }\n        }\n\n        if (balans) {\n            br_nacina++;\n        }\n    }\n\n    printf(\"%d\\n\", br_nacina);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/drz/03_kladionica/","title":"B3 - Kladionica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 700ms 256MB <p>Pametni koder Aki je sino\u0107 gledao film \u201dOcean's eleven\u201d (Igraj svoju igru). Kako mu je film bio dosadan, negde na polovini se uspavao i po\u010deo da sanja o tome kako mo\u017ee prevariti kladionicu kao akteri filma. Sanjao je da ima pristup bazi podataka kladionice i da mo\u017ee namestiti rezultat bilo koje utakmice.</p> <p>Odlu\u010dio je da se kladi na fudbalske me\u010deve. Postoji \\(N\\) razli\u010ditih fudbalskih liga, a u svakoj ligi po \\(M\\) utakmica za koje je mogu\u0107e ulo\u017eiti opkladu. Za svaku utakmicu koju je odabrao je poznata kvota - prirodan broj koji predstavlja koeficijent dobitka koji nosi ta utakmica ukoliko je rezultat pogo\u0111en.</p> <p>Aki \u0107e iz svake lige izabrati bar jednu utakmicu (mogu\u0107e i vi\u0161e), i tako sastaviti tiket. Za svaku ligu je poznat broj utakmica koje je mogu\u0107e izabrati iz te lige na istom tiketu - npr. postoji slu\u010daj gde  je za neku ligu mogu\u0107e izabrati ta\u010dno 2 ili 4 utakmice, ali nije mogu\u0107e izabrati 3.</p> <p>Dobitak tiketa se odre\u0111uje tako \u0161to se pomno\u017ee kvote svih odabranih utakmica, a zatim se dobijeni proizvod pomno\u017ei sa bonusom koji zavisi od broja odigranih utakmica. Bonusi za svaki mogu\u0107i broj odigranih utakmica su dati od strane kladionice.</p> <p>Kako Aki u svom snu mo\u017ee namestiti rezultate svih utakmica, i \u017eeli da zaradi \u0161to vi\u0161e para, on \u0107e sastaviti sve mogu\u0107e tikete. Dva tiketa se razlikuju ukoliko bar jedna utakmica postoji na jednom tiketu, a ne postoji na drugom. Na kraju, Aki \u0107e zaraditi onoliko para koliko je zbir dobitaka sa svih tiketa.</p> <p>Izra\u010dunajte i ispi\u0161ite koliko \u0107e para Aki zaraditi u svom snu (ra\u010dunaju\u0107i po modulu \\(10^9 + 7 = 1000000007\\)).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Du\u0161an Zdravkovi\u0107 <p>Pravolinijsko re\u0161enje se dobija tako \u0161to se utakmice numeri\u0161u, npr. brojevima od \\(0\\) do \\(N\\cdot M - 1\\) (ako su lige numerisane brojevima od 1 do \\(N\\), a utakmice u okviru svake lige brojevima od 1 do \\(M\\), onda \u0107e utakmica  \\(j\\) iz lige broj \\(i\\) biti numerisana brojem \\((i-1)\\cdot M + (j-1)\\)) i nakon toga svaki tiket posmatra kao podskup skupa \\(\\{0, 1, 2, ..., N\\cdot M - 1\\}\\). Primetimo da ne mora svaki podskup skupa  \\(\\{0, 1, 2, ..., N\\cdot M - 1\\}\\) predstavljati ispravan tiket: mo\u017ee se desiti da je iz nekih liga izabran nedozvoljen broj utakmica. No bez obzira na to, podskupovi se mogu reprezentovati pomo\u0107u celih brojeva izme\u0111u 0 i \\(2^{N\\cdot M}-1\\). Svaki broj iz tog opsega se mo\u017ee zapisati u binarnom brojnom sistemu sa najvi\u0161e \\(N\\cdot M\\) cifara (bitova). Ako zapis ima manje od \\(N\\cdot M\\) cifara dopuni se nulama (sa leve strane). Cifra nula na mestu odre\u0111ene te\u017eine ozna\u010dava da utakmica \u010dija se oznaka poklapa sa te\u017einom nije izabrana u podskup (na tiket), a cifra 1, da je odgovaraju\u0107a utakmica izabrana u podskup (na tiket). Prema tome, potrebno je od broja formirati tiket, proveriti da li je tiket ispravan (validan), ako jeste, odrediti dobitak i dodati na zbir dobitaka. Slo\u017eenost ovog re\u0161enja je \\(\\Theta(N\\cdot M \\cdot 2^{N\\cdot M})\\). Ovo predstavlja re\u0161enje podzadatka 1.</p> <p>Podzadatak 3 se tako\u0111e mo\u017ee re\u0161iti na poseban na\u010din. Pretpostavimo radi pojednostavljenja da imamo samo dve lige. Iz svake lige je mogu\u0107e uzeti po jednu utakmicu, a dobitak se ra\u010duna kao proizvod kvota za izabrane utakmice i bonusa za tiket sa dve utakmice. Za svaki tiket \u0107e bonus biti isti (jer svaki tiket ima ta\u010dno dve utakmice), pa se zbog toga mogu prvo izra\u010dunati samo proizvodi kvota za tikete, sabrati i na kraju pomno\u017eiti sa bonusom. Kao \u0161to smo rekli, ispravne tikete \u010dine sve kombinacije sastavljene od po jedne utakmice iz obe lige. Zbog distributivnosti mno\u017eenja u odnosu na sabiranje, zbir proizvoda kvota za sve mogu\u0107e tikete \u0107e biti jednak proizvodu zbira kvota za prvu ligu i zbira kvota za drugu ligu. Ovo se mo\u017ee poop\u0161titi i na slu\u010daj kada postoji vi\u0161e od dve lige, pa se zbir svih dobitaka mo\u017ee odrediti tako \u0161to se pomno\u017ee zbirovi kvota za sve lige i to na kraju pomno\u017ei sa bonusom (uvek isti broj - broj odigranih utakmica je jednak broju liga). Slo\u017eenost ovog re\u0161enja je \\(\\Theta(N\\cdot M)\\).</p> <p>Opi\u0161imo re\u0161enje koje \"pokriva\" sve podzadatke. Pretpostavimo opet da imamo samo dve lige. Ako je dozvoljeno iz prve lige uzeti \\(k_1\\) utakmica, a iz druge lige \\(k_2\\) utakmica, onda se bilo koji podskup od \\(k_1\\) utakmica iz prve lige mo\u017ee kombinovati sa bilo kojim podskupom od \\(k_2\\) utakmica iz druge lige, a dobitak \u0107e se ra\u010dunati kao proizvod kvota izabranih utakmica i bonusa za \\(k_1+k_2\\) odigranih utakmica. Kako je bonus uvek isti, mo\u017ee se opet ra\u010dunati samo zbir proizvoda kvota, pa na kraju dobijeni zbir pomno\u017eiti sa bonusom. Zbog distributivnosti, zbir proizvoda se mo\u017ee dobiti tako \u0161to se saberu svi proizvodi od po \\(k_1\\) kvota za prvu ligu, odnosno svi proizvodi od po \\(k_2\\) kvota za drugu ligu i na kraju ta dva zbira pomno\u017ee. Ako bi bilo vi\u0161e od dve lige, onda bi se opet zbirove proizvoda (sa istim brojem odigranih utakmica) za pojedine lige mno\u017eili i nakon toga mno\u017eili  sa odgovaraju\u0107im bonusom . Prema tome,  potrebno je za po\u010detak za svaku ligu \\(i\\) i svaku vrednost \\(j\\in\\{1, 2, ..., M\\}\\) odrediti zbir svih proizvoda kvota za ta\u010dno \\(j\\) utakmica odigranih u ligi \\(i\\) (ozna\u010dimo te zbirove sa \\(pr_{ij}\\)).</p> <p>Izraze  \\(pr_{ij}\\) \u0107emo izra\u010dunati koriste\u0107i dinami\u010dko programiranje. Neka je \\(pr_{i,j}^{(k)}\\) zbir svih proizvoda kvota od ta\u010dno \\(j\\) utakmica iz lige \\(i\\), pri \u010demu  svi podskupovi sadr\u017ee samo utakmice sa rednim brojevima izme\u0111u 1 i \\(k\\) (naravno ne nu\u017eno sve). Tada \u0107e \\(pr_{i,j}^{(M)}\\) biti zbir svih mogu\u0107ih proizvoda kvota od po \\(j\\) utakmica u ligi broj \\(i\\). Lako se mo\u017ee zaklju\u010diti da je</p> \\[ pr_{i,j}^{(0)}=\\begin{cases} 1, &amp;\\text{ako je }j=0\\\\ 0, &amp;\\text{ako je }j &gt; 0 \\end{cases}. \\] <p>\u0160to se ti\u010de zbira svih proizvoda kvota za ta\u010dno \\(j\\) utakmica gde je svih \\(j\\) utakmica iz skupa \\(\\{1, 2, ..., k, k+1\\}\\), primetimo da postoje dve mogu\u0107nosti:</p> <ul> <li>Svih \\(j\\) izabranih utakmica su iz skupa \\(\\{1, 2, ..., k\\}\\), tj. nije izabrana utakmica \\(k+1\\),</li> <li>Jedna od izabranih utakmica je ba\u0161 \\(k+1\\). Onda je preostalih \\(j-1\\) utakmica iz skupa \\(\\{1, 2, ..., k\\}\\). Pri tome se svaki tiket sa \\(j-1\\) utakmicom mo\u017ee pro\u0161iriti do tiketa sa \\(j\\) utakmica dodavanjem utakmice \\(k+1\\). Zbog distributivnosti mno\u017eenja u odnosu na sabiranje, zbir svih proizvoda sa \\(j\\) izabranih utakmica, gde je poslednja ba\u0161 utakmica \\(k+1\\) bi\u0107e jednak proizvodu kvote za tu utakmicu \\(k+1\\) i zbira proizvoda svih tiketa sa \\(j-1\\) utakmicom (gde su sve te utakmice iz skupa \\(\\{1, 2, ..., k\\}\\) .</li> </ul> <p>Na osnovu ovog razmatranja mo\u017ee se izvesti formula za izra\u010dunavanje zbirova: </p> <p>$$ pr_{i,j}^{(k+1)}=\\begin{cases} pr_{i,j}^{(k)} + pr_{i,j-1}^{(k)} \\cdot q_{i,k+1}, &amp;\\text{ako je }j\\leq k+1\\ 0, &amp;\\text{ako je }j &gt; k+1 \\end{cases}. $$ U gornjem izrazu \\(q_{i,k+1}\\) predstavlja kvotu za utakmicu \\(k+1\\) u ligi \\(i\\).</p> <p>Kada imamo zbirove proizvoda sa fiskiranim brojem utakmica za svaku ligu, onda sli\u010dnim postupkom odre\u0111ujemo zbirove proizvoda kvota na tiketu koji sadr\u017ei utakmice iz raznih liga. Ozna\u010dimo sa \\(gpr_{k,j}\\) zbir proizvoda svih tiketa koji imaju ta\u010dno \\(j\\) utakmica iz prvih \\(k\\) liga. Tada \u0107e va\u017eiti da je</p> \\[ gpr_{1,j}^{(1)} = pr_{1,j}. \\] <p>Lako se zaklju\u010duje da ako iz prvih \\(k+1\\) liga treba izbrati ta\u010dno \\(j\\) utakmica, to mo\u017eemo uraditi tako \u0161to iz lige broj \\(k+1\\) izaberemo bilo koji dozvoljeni broj utakmica (ne ve\u0107i od \\(j\\)) a ostatak dopunimo iz prvih \\(k\\) liga. Mi ve\u0107 imamo izra\u010dunate zbirove proizvoda kvota za sve mogu\u0107e brojeve utakmica na tiketu. Ako uvedemo oznake </p> \\[ c_{i,j} = \\begin{cases} 1,&amp;\\text{ mo\u017ee izabrati ta\u010dno  $j$ utakmica iz lige $i$}\\\\ 0,&amp;\\text{ ne mo\u017ee se izabrati ta\u010dno  $j$ utakmica iz lige $i$} \\end{cases}, \\] <p>onda se $gpr_{k+1,j} $ mo\u017ee ra\u010dunati na slede\u0107i na\u010din</p> \\[ g_{k+1,j} = \\sum_{j'=1}^{\\min(M,j)} c_{k+1,j'}\\cdot pr_{k+1,j'}\\cdot gpr_{k,j-j'} \\] <p>Nakon odre\u0111ivanja svih pomenutih zbirova proizvoda potrebno je samo odgovaraju\u0107e zbirove pomno\u017eiti sa bonusima i sabrati:</p> \\[ \\sum_{j}^{N\\cdot M} F_j \\cdot gpr_{N,j} \\] <p>Ovde je sa \\(F_j\\) ozna\u010den bonus za tiket sa \\(j\\) utakmica.</p> <p>Napomenimo da se sve operacije izvode po modulu \\(10^9+7\\), tj. svaki put posle izvedene operacije (sabiranje ili mno\u017eenje) se odre\u0111uje ostatak pri deljenju sa \\(10^9+7\\).</p> <p>Na kraju, par re\u010di o slo\u017eenosti postupka. Slo\u017eenost ra\u010dunanja matrice \\(pr\\) je \\(O(N\\cdot M^2)\\), a slo\u017eenost ra\u010dunanja matrice \\(gpr\\) je \\(O(N^2\\cdot M^2)\\).</p> 03_kladionica.cpp<pre><code># include &lt;stdio.h&gt;\n\n# define MAXNM 110\n# define MAXK 10100\n# define MOD 1000000007\n\nint n, m;\n\nint t[MAXNM][MAXNM];\nint c[MAXNM][MAXNM];\nint cz[MAXNM][MAXNM];\n\nint F[MAXK];\n\nlong long rez;\n\nlong long prs[MAXNM][MAXNM];\nlong long prt[MAXNM][MAXK];\n\ncitaj() {\n  int i, j, k;\n  scanf(\"%d%d\", &amp;n, &amp;m);\n  for (i = 1; i &lt;= n; i++)\n    for (j = 1; j &lt;= m; j++)\n      scanf(\"%d\", &amp;t[i][j]);\n  for (i = 1; i &lt;= n; i++) {\n    k = 0;\n    for (j = 1; j &lt;= m; j++) {\n        scanf(\"%d\", &amp;c[i][j]);\n        if (c[i][j] == 1) {\n            k++;\n            cz[i][k] = j;   \n        }\n    }\n    k++;\n    cz[i][k] = -1;\n }\n  for (i = 1; i &lt;= n * m; i++)\n    scanf(\"%d\", &amp;F[i]); \n}\n\n\nvoid racunajprs() {\n    int i, j, k;\n    for (i = 1; i &lt;= n; i++) {\n        prs[i][0] = 1;\n        for (j = 1; j &lt;= m; j++) \n            prs[i][j] = 0;\n        for (j = 1; j &lt;= m; j++) {\n            for (k = j; k &gt;= 1; k--) {\n                prs[i][k] = (prs[i][k] + prs[i][k-1] * t[i][j]) % MOD;\n            }\n        }\n    }\n}\n\nvoid racunajprt() {\n    int i, j, j1, k;\n    for (j1 = 1; cz[1][j1] != -1; j1++) {\n        j = cz[1][j1];\n        prt[1][j] = prs[1][j];\n    }\n    for (i = 2; i &lt;= n; i++) {\n        for (j1 = 1; cz[i][j1] != -1; j1++) {\n            j = cz[i][j1];\n            for (k = (i - 1) * m; k &gt;= 0; k--) {\n                prt[i][k+j] = (prt[i][k+j] + prt[i-1][k] * prs[i][j]) % MOD;\n            }\n        }\n    }\n    rez = 0;\n    for (k = 1; k &lt;= m * n; k++) {\n        rez = (rez + prt[n][k] * F[k]) % MOD;\n    }\n}\n\npisi() {\n    printf(\"%lld\\n\", rez);\n}\n\nmain() {\n    citaj();\n    racunajprs();\n    racunajprt();\n    pisi();\n    return 0;   \n}\n</code></pre>"},{"location":"takprog/2016_2017/drz/03_kladionica/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu se nalaze dva prirodna broja: \\(N\\) - broj liga, i \\(M\\) - broj utakmica u svakoj ligi. U narednih \\(N\\) redova se nalazi po \\(M\\) prirodnih brojeva koji predstavljaju kvote za svaku utakmicu.</p> <p>U slede\u0107ih \\(N\\) redova se nalazi po \\(M\\) brojeva koji predstavljaju matricu \\(C\\). Elementi te matrice mogu imati vrednost nula ili jedan. Ako je \\(j\\)-ti broj u \\(i\\)-tom od tih redova jednak jedan (\\(C[i][j]=1\\)), onda to zna\u010di da se iz \\(i\\)-te lige mo\u017ee izabrati \\(j\\) utakmica, a ako je jednak nuli, onda se iz \\(i\\)-te lige ne mo\u017ee izabrati \\(j\\) utakmica.</p> <p>U poslednjem redu ulaza ima ukupno \\(N \\times M\\) prirodnih brojeva gde \\(i\\)-ti broj u nizu predstalja bonus za ukupno odigranih \\(i\\) utakmica.</p>"},{"location":"takprog/2016_2017/drz/03_kladionica/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu izlaza ispisati koliko \u0107e para Aki zaraditi, ra\u010dunaju\u0107i po modulu \\(10^9 + 7 = 1000000007\\).</p>"},{"location":"takprog/2016_2017/drz/03_kladionica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/03_kladionica/#ulaz","title":"Ulaz","text":"<pre><code>2 3\n2 3 4\n5 6 7\n1 0 1\n0 1 1\n10 20 30 40 50 60\n</code></pre>"},{"location":"takprog/2016_2017/drz/03_kladionica/#izlaz","title":"Izlaz","text":"<pre><code>535290\n</code></pre>"},{"location":"takprog/2016_2017/drz/03_kladionica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Postoje dve lige sa po tri utakmice. Kvote utakmica u prvoj ligi su \\(2\\), \\(3\\) i \\(4\\), dok u drugoj ligi postoje utakmice sa kvotama \\(5\\), \\(6\\) i \\(7\\). Iz prve lige je mogu\u0107e izabrati ta\u010dno jednu ili ta\u010dno tri utakmice, dok nije mogu\u0107e izabrati dve utakmice iz prve lige. Iz druge lige je mogu\u0107e izabrati dve ili tri utakmice. Neki od mogu\u0107ih tiketa su:</p> <ul> <li>Iz prve lige biramo prvu utakmicu (kvota \\(2\\)), iz druge lige biramo prvu i drugu utakmicu (kvote \\(5\\) i \\(6\\)). Ukupna kvota je \\(2 \\cdot 5 \\cdot 6 = 60\\). Po\u0161to smo izabrali 3 utakmice, kvota se mno\u017ei sa bonusom za 3 utakmice (\\(30\\)), i tako dobijamo ukupan dobitak za ovaj tiket: \\(60 \\cdot 30 = 2400\\)</li> <li>Iz prve lige biramo sve tri utakmice (kvote \\(2\\), \\(3\\) i \\(4\\)), iz druge lige biramo prvu i tre\u0107u utakmicu (kvote \\(5\\) i \\(7\\)). Ukupna kvota je \\(2 \\cdot 3 \\cdot 4 \\cdot 5 \\cdot 7 = 840\\). Kako smo izabrali ukupno 5 utakmica, kvota se mno\u017ei sa bonusom \u0455a 5 utakmica (\\(50\\)) i tako dobijamo ukupan dobitak: \\(840 \\cdot 50 = 42000\\)</li> </ul> <p>Kombinovanjem svih mogu\u0107ih tiketa, a onda sabiranjem njihovih dobitaka, dobijamo ukupnu zaradu od \\(535290\\).</p>"},{"location":"takprog/2016_2017/drz/03_kladionica/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>Kvote tiketa i bonusi su prirodni brojevi izme\u0111u 1 i 1000</li> </ul> <p>Postoje \\(5\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [7 poena]: \\(N \\cdot M \\leq 20\\).</li> <li>Podzadatak 2 [25 poena]: \\(N=1\\), i \\(M \\leq 100\\).</li> <li>Podzadatak 3 [12 poena]: \\(N,M \\leq 100\\) i iz svake lige se mo\u017ee igrati ta\u010dno jedna utakmica (\\(C[i][1]=1\\), \\(C[i][j]=0\\) ako je \\(j&gt;1\\)).</li> <li>Podzadatak 4 [25 poena]: \\(N,M \\leq 100\\) i svi bonsi su ta\u010dno 1.</li> <li>Podzadatak 5 [31 poen]: \\(N,M \\leq 100\\).</li> </ul>"},{"location":"takprog/2016_2017/drz/04_karibi/","title":"A1 - Karibi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Nekada davno, bilo je vreme programera koji nisu testirali svoje kodove, vreme Programera sa Kariba. Ovi programeri plovili su morem i sejali strah i nekvalitetne programe du\u017e karipskih ostrva; za sobom su ostavljali uplakane korisnike, nezavr\u0161ene aplikacije i \u010dlanove posade koji bi koristili C umesto C++-a. Svaki brod koji bi im se suprotstavio, dobio bi floating point eksep\u0161n i prestao bi da float...</p> <p>Popularno mesto za okupljanje Programera sa Kariba bilo je Karipsko ostrvo Tortuga. Zaliv ovog ostrva mo\u017eemo predstaviti binarnom matricom dimenzije \\(n \\times m\\) \u010dije je svako polje kopno (ozna\u010deno jedinicom) ili voda (ozna\u010deno nulom). Programerski brodovi dolaze u raznim du\u017einama i ukoliko je du\u017eina nekog broda \\(x\\), to zna\u010di da taj brod zauzima ta\u010dno \\(x\\) uzastopnih polja zaliva, bilo vertikalno ili horizontalno (\u0161irina broda je ta\u010dno jedno polje). Prema tome, brod du\u017eine \\(x\\) se mo\u017ee parkirati u zaliv ako i samo ako postoji \\(x\\) uzastopnih polja u istoj vrsti ili istoj koloni matrice zaliva pri \u010demu sva polja predstavljaju vodu i na nijednom od njih se ne nalazi deo nekog drugog broda. U op\u0161tem slu\u010daju, mo\u017ee postojati vi\u0161e na\u010dina za parkiranje.</p> <p>Jednog dana, u zaliv Tortuge stigao je programer D\u017eek Vrabac na svom brodu Black Perl du\u017eine \\(a\\) i re\u0161io da ga uparkira. D\u017eek zna da posle njega u zaliv sti\u017ee programer Barbosa na svom brodu Blue Pascal du\u017eine \\(b\\), kao i da Barbosa najvi\u0161e na svetu mrzi tri stvari: programera D\u017eeka, debug mod i nedovoljno mesta za parkiranje broda. Zato je D\u017eek odlu\u010dio da parkira svoj brod tako da posle njegovog parkiranja bude najmanje mogu\u0107e na\u010dina da se u zaliv uparkira Barbosin brod. Kako je programer D\u017eek poznat po tome \u0161to ne zna da programira, zatra\u017eio je pomo\u0107 od vas i kao nagradu ne\u0107e vam hakovati ra\u010dunar.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Milo\u0161 Puri\u0107 Ivan Sto\u0161i\u0107 <p>Broj \\(A_{i,j}\\) je jednak \\(1\\) ako je na polju \\((i,j)\\) u zalivu kopno, a ina\u010de \\(0\\).</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se \u010detiri prirodna broja \\(n\\), \\(m\\), \\(a\\) i \\(b\\), razdvojena razmakom, koja, redom, predstavljaju dimenzije zaliva, du\u017einu D\u017eekovog broda i du\u017einu Barbosinog broda. Zatim sledi opis zaliva - u narednih \\(n\\) redova nalazi se po \\(m\\) karaktera (bez razmaka) od kojih je svaki '0' ili '1'.</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan prirodan broj - najmanji mogu\u0107i broj na\u010dina za parkiranje Barbosinog broda nakon parkiranja D\u017eekovog broda.</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/04_karibi/#ulaz","title":"Ulaz","text":"<pre><code>5 6 3 3\n110111\n000001\n000001\n111101\n100010\n</code></pre>"},{"location":"takprog/2016_2017/drz/04_karibi/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2016_2017/drz/04_karibi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/drz/04_karibi/#ulaz_1","title":"Ulaz","text":"<pre><code>2 5 2 5\n00000\n00000\n</code></pre>"},{"location":"takprog/2016_2017/drz/04_karibi/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2016_2017/drz/04_karibi/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru su du\u017eine D\u017eekovog i Barbosinog broda po 3. Ukoliko D\u017eek parkira svoj brod tako da zauzima polja (1,3)(2,3)(3,3), Barbosa \u0107e imati samo dva na\u010dina za parkiranje svog broda - (2,5)(3,5)(4,5) i (5,2)(5,3)(5,4) (vrste su numerisane odozgo nadole a kolone s leva udesno). D\u017eek nikako ne mo\u017ee parkirati svoj brod tako da Barbosa ima manje od dva na\u010dina za parkiranje.</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq a \\leq max\\{n,m\\}\\), \\(2 \\leq b \\leq max\\{n,m\\}\\)</li> <li>Zaliv \u0107e biti takav da \u0107e postojati bar jedan na\u010din da D\u017eek uparkira svoj brod.</li> </ul> <p>Postoje \\(5\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [11 poena]: \\(1 \\leq n, m \\leq 80\\).</li> <li>Podzadatak 2 [12 poena]: \\(n = 1\\) i \\(1 \\leq m \\leq 2000\\).</li> <li>Podzadatak 3 [13 poena]: \\(a = 1\\) i \\(1 \\leq n, m \\leq 2000\\).</li> <li>Podzadatak 4 [22 poena]: \\(1 \\leq n, m \\leq 500\\).</li> <li>Podzadatak 5 [42 poen]: \\(1 \\leq n, m \\leq 2000\\).</li> </ul>"},{"location":"takprog/2016_2017/drz/04_karibi/#resenje-za-1-leq-nm-leq-80","title":"Re\u0161enje za \\(1 \\leq N,M \\leq 80\\):","text":"<p>Mo\u017eemo za svako parking mesto D\u017eekovog broda du\u017eine \\(a\\) sporo ra\u010dunati broj parking mesta za Barbosin brod du\u017eine \\(b\\) u tom slu\u010daju, koriste\u0107i prefiskne sume pojedina\u010dnih kolona i vrsta matrice \\(A\\). Vremenska slo\u017eenost: \\(O(N^2M^2)\\), memorijska slo\u017eenost: \\(O(NM)\\).</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#resenje-za-n1-i-1-leq-m-leq-2000","title":"Re\u0161enje za \\(N=1\\) i \\(1 \\leq M \\leq 2000\\):","text":"<p>Za ovaj podzadatak dovoljno je re\u0161enje izlo\u017eeno u prethodnom, ali je njega ovde mogu\u0107e lak\u0161e implementirati zato \u0161to je \\(N=1\\). Vremenska slo\u017eenost: \\(O(M^2)\\), memorijska slo\u017eenost: \\(O(M^2)\\).</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#resenje-za-a1-i-1-leq-nm-leq-2000","title":"Re\u0161enje za \\(a=1\\) i \\(1 \\leq N,M \\leq 2000\\):","text":"<p>Neka je \\(D_{i,j}^{b}\\) jednako \\(1\\) ako je \\(i+b-1 \\leq N\\) i \\(\\sum_{k=i}^{i+b-1} A_{k,j} = 0\\) (tj. ako su sva polja kolone \\(j\\) od \\((i,j)\\) do \\((i+b-1,j)\\) pod vodom), a \\(0\\) ina\u010de. Sli\u010dno defini\u0161emo  i \\(R_{i,j}^{b}\\) za polja \\((i,j)\\) i \\((i,j+b-1)\\). Analogno, mogu biti korisne i vrednosti \\(D_{i,j}^{a}\\) i \\(R_{i,j}^{a}\\) koje ra\u010dunamo na isti na\u010din, samo za brod du\u017eine \\(a\\). Ovi podaci nam omogu\u0107uju da proverimo da li je mogu\u0107e uparkirati brod du\u017eine \\(b\\) ili \\(a\\) u neko mesto, a mo\u017eemo ih lako prona\u0107i pomo\u0107u prefiksnih suma pojedina\u010dnih kolona i vrsta matrice \\(A\\). </p> <p>Sada mo\u017eemo da izra\u010dunamo broj \\(C_0\\) - na koliko na\u010dina je mogu\u0107e parkirati brod du\u017eine \\(b\\) u zalivu: \\(\\(C_0=\\sum_{i=1}^{N} \\sum_{j=1}^{M} D_{i,j}^{b}+R_{i,j}^{b}\\)\\) </p> <p>Poku\u0161a\u0107emo da brod du\u017eine \\(a\\) parkiramo sa po\u010detkom u svakom polju \\((i,j)\\) redom, i da izra\u010dunamo koliko smo pri tome blokirali mesta za parkiranje brodu du\u017eine \\(b\\). </p> <p>Na primer, vertikalnim parkiranjem broda du\u017eine \\(a\\) od polja \\((p,q)\\) do polja \\((p+a-1,q)\\) (gde je \\(p+a-1 \\leq N\\)) blokirali smo ta\u010dno \\(\\(V_{i,j}=(\\sum_{i=p}^{p+a-1} \\sum_{j=q-b+1}^{q} R_{i,j}^{b}) + (\\sum_{i=p-b+1}^{p+a-1} D_{i,q}^{b})\\)\\) parking mesta za brod du\u017eine \\(b\\). Pri tom se podrazumeva da ako je neka od granica u ovim sumama manja od \\(1\\), sumu \u0107emo po\u010deti od \\(1\\), odnosno ako je ve\u0107a od indeksa najve\u0107e kolone ili vrste (\\(N\\) ili \\(M\\) u zavisnosti od toga da li se radi o granici za \\(i\\) ili \\(j\\)), sumu \u0107emo zavr\u0161iti na odgovaraju\u0107em postoje\u0107em indeksu. Ova formula va\u017ei jer smo u stvari ovakvim parkiranjem broda du\u017eine \\(a\\), zauzeli sva mesta za brod du\u017eine \\(b\\) \u010diji se levi krajevi nalaze u podmatrici sa gornjim levim poljem \\((p,q-b+1)\\) i donjim desnim poljem \\((p+a-1,q)\\), kao i sva mesta \u010diji su gornji krajevi polja u \\(q\\)-toj koloni od \\((p-b+1,q)\\) do \\((p+a-1,q)\\).</p> <p>Na sli\u010dan na\u010din mo\u017eemo prona\u0107i izraz za broj blokiranih polja pri horizontalnom parkiranju broda du\u017eine \\(a\\) od polja \\((p,q)\\) do polja \\((p,q+a-1)\\) (gde je \\(q+a-1 \\leq M\\)):  \\(\\(H_{i,j}=(\\sum_{i=p-b+1}^{p} \\sum_{j=q}^{q+a-1} D_{i,j}^{b}) + (\\sum_{j=q-b+1}^{q+a-1} R_{p,j}^{b})\\)\\)</p> <p>U ovom slu\u010daju, parking mesta koja zauzimamo su ona sa gornjim krajevima u podmatrici sa gornjim levim poljem \\((p-b+1,q)\\) i donjim desnim poljem \\((p,q+a-1)\\), kao i parking mesta \u010diji su levi krajevi u \\(p\\)-toj  vrsti od polja \\((p,q-b+1)\\) do polja \\((p,q+a-1)\\).</p> <p>U ovom podzadatku prve sume u izrazima za \\(V_{i,j}\\) i \\(H_{i,j}\\) se znatno pojednostavljuju jer je \\(a=1\\), pa je mogu\u0107e koristiti standardne prefiksne sume svake kolone i svake vrste matrica \\(R_{i,j}^{b}\\) i \\(D_{i,j}^{b}\\) za ra\u010dunanje vrednosti \\(V_{i,j}\\) i \\(H_{i,j}\\).</p> <p>Najmanji broj na\u010dina za parkiranje Barbosinog broda koji D\u017eek Vrabac mo\u017ee da postigne dobijamo kao minimalnu vrednost koju uzima \\(\\min(C_0-V_{i,j},C_0-H_{i,j})\\) po svim poljima \\((i,j)\\) u zalivu. Vremenska slo\u017eenost: \\(O(NM)\\), memorijska slo\u017eenost: \\(O(NM)\\).</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#resenje-za-1-leq-nm-leq-500","title":"Re\u0161enje za: \\(1 \\leq N,M \\leq 500\\):","text":"<p>U ovom podzadatku je zbog manjih dimenzija matrice mogu\u0107e ra\u010dunanje \\(V_{i,j}\\) i \\(H_{i,j}\\) samo uz pomo\u0107 prefiksnih suma vrsta i kolona matrica \\(R_{i,j}^{b}\\) i \\(D_{i,j}^{b}\\). Na primer, u prvoj sumi u izrazu za \\(V_{i,j}\\) \u0107emo za svaku vrstu od \\(p\\) do \\(p+a-1\\) korististi prefiksnu sumu te vrste u matrici \\(R_{i,j}^{b}\\) da izra\u010dunamo  \\(\\sum_{j=q-b+1}^{q} R_{i,j}^{b}\\). Drugu sumu u izrazu za \\(V_{i,j}\\) mo\u017eemo i dalje ra\u010dunati sporim sabiranjem odgovaraju\u0107ih vrednosti \\(D_{i,j}^{b}\\). Vremenska slo\u017eenost: \\(O(NM \\cdot \\max(N,M))\\), memorijska slo\u017eenost: \\(O(NM)\\).</p>"},{"location":"takprog/2016_2017/drz/04_karibi/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Za dovoljno brzo ra\u010dunanje vrednosti \\(V_{i,j}\\) i \\(H_{i,j}\\) \u0107e nam biti potrebne dvodimenzionalne prefiksne sume matrica \\(R_{i,j}^{b}\\) i \\(D_{i,j}^{b}\\). Dvodimenzionalna prefiksna suma proizvoljne matrice \\(X\\) je matrica \\(Y\\) istih dimenzija za koju za svako njeno polje \\((p,q)\\) va\u017ei \\(Y_{p,q}=\\sum_{i=1}^{i=p} \\sum_{j=1}^{j=q} X_{i,j}\\). Pomo\u0107u nje mo\u017eemo u konstantnom  vremenu izra\u010dunati sumu brojeva u bilo kojoj podmatrici matrice \\(X\\). Na primer, sumu brojeva u podmatrici matrice \\(X\\) sa gornjim levim poljem \\((p,q)\\) i donjim desnim poljem \\((r,s)\\) nalazimo kao: \\(\\(\\sum_{i=p}^{i=r} \\sum_{j=q}^{j=s} X_{i,j}=Y_{r,s}-Y_{p-1,s}-Y_{r,q-1}+Y_{p-1,q-1}\\)\\)</p> <p>Ovo nam omogu\u0107ava da u konstantnom vremenu na\u0111emo vrednosti \\(V_{i,j}\\) i \\(H_{i,j}\\) za svako polje u zalivu. Minimalni broj mesta koji D\u017eek mo\u017ee posti\u0107i kao i pre dobijamo kao minimalnu vrednost koju uzima \\(\\min(C_0-V_{i,j},C_0-H_{i,j})\\) po svim poljima \\((i,j)\\).</p> <p>Vremenska slo\u017eenost: \\(O(NM)\\), memorijska slo\u017eenost: \\(O(NM)\\).</p> 04_karibi.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 2010;\n\nchar s[MAX_N][MAX_N];\nint U[MAX_N][MAX_N], L[MAX_N][MAX_N], R[MAX_N][MAX_N], D[MAX_N][MAX_N];\nint currSum[MAX_N];\n\n// broj horizontalnih nacina za postavljanje koje zauzima brod na pozicijiama [i][j1]...[i][j2] brodu duzine d\nint H(int i, int j1, int j2, int d)\n{\n    int l = j1 - L[i][j1] + 1;\n    int r = j2 + R[i][j2] - d;\n    if (r &lt; l) return 0;\n    int l1 = j1 - d + 1;\n    int r1 = j2;\n    return (std::min(r, r1) - std::max(l, l1) + 1);\n}\n// broj vertikalnih nacina za postavljanje koje zauzima brod na pozicijiama [i1][j]...[i2][j] brodu duzine d\nint V(int j, int i1, int i2, int d)\n{\n    int l = i1 - U[i1][j] + 1;\n    int r = i2 + D[i2][j] - d;\n    if (r &lt; l) return 0;\n    int l1 = i1 - d + 1;\n    int r1 = i2;\n    return (std::min(r, r1) - std::max(l, l1) + 1);\n}\n\nint solve(int n, int m, int a, int b, char s[][MAX_N])\n{\n    for (int i = 0; i &lt;= n + 1; i++)\n    {\n        s[i][0] = '1';\n        s[i][m + 1] = '1';\n    }\n    for (int j = 0; j &lt;= m + 1; j++)\n    {\n        s[0][j] = '1';\n        s[n + 1][j] = '1';\n    }\n\n    // racunanje U, L, R i D matrica\n    for (int i = 0; i &lt;= n; i++)\n    {\n        for (int j = 0; j &lt;= m; j++)\n        {\n            L[i][j] = U[i][j] = 0;\n            if (s[i][j] == '0')\n            {\n                L[i][j] = 1 + L[i][j - 1];\n                U[i][j] = 1 + U[i - 1][j];\n            }\n        }\n    }\n    for (int i = n + 1; i &gt;= 1; i--)\n    {\n        for (int j = m + 1; j &gt;= 1; j--)\n        {\n            R[i][j] = D[i][j] = 0;\n            if (s[i][j] == '0')\n            {\n                R[i][j] = 1 + R[i][j + 1];\n                D[i][j] = 1 + D[i + 1][j];\n            }\n        }\n    }\n\n    // racunanje ukupnog broja nacina da se postavi b-brod bez a-broda\n    int totalNumOfWays = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= m; j++)\n        {\n            if (L[i][j] &gt;= b) totalNumOfWays++;\n            if (U[i][j] &gt;= b) totalNumOfWays++;\n        }\n    }\n\n    int maxReduction = 0;\n    // proveri sve moguce horizontalne pozicije za a-brod\n    for (int i = 1; i &lt;= n; i++)\n    {\n        currSum[0] = 0;\n        for (int j = 1; j &lt;= m; j++)\n        {\n            if (s[i][j] == '0')\n            {\n                currSum[j] = currSum[j - 1] + V(j, i, i, b);\n            }\n            else\n            {\n                currSum[j] = 0;\n            }\n\n            if (L[i][j] &gt;= a)\n            {\n                int currReduction = H(i, j - a + 1, j, b) + currSum[j] - currSum[j - a];\n                if (currReduction &gt; maxReduction)\n                {\n                    maxReduction = currReduction;\n                }\n            }\n        }\n    }\n    // proveri sve moguce vertikalne pozicije za a-brod\n    for (int j = 1; j &lt;= m; j++)\n    {\n        currSum[0] = 0;\n        for (int i = 1; i &lt;= n; i++)\n        {\n            if (s[i][j] == '0')\n            {\n                currSum[i] = currSum[i - 1] + H(i, j, j, b);\n            }\n            else\n            {\n                currSum[i] = 0;\n            }\n\n            if (U[i][j] &gt;= a)\n            {\n                int currReduction = V(j, i - a + 1, i, b) + currSum[i] - currSum[i - a];\n                if (currReduction &gt; maxReduction)\n                {\n                    maxReduction = currReduction;\n                }\n            }\n        }\n    }\n\n    return totalNumOfWays - maxReduction;\n}\n\nint main()\n{\n    int n, m, a, b;\n    scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%s\", s[i] + 1);\n    }\n\n    int sol = solve(n, m, a, b, s);\n    printf(\"%d\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/","title":"A2 - Prorok","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Nakon \u0161to je proveo ceo dan gledaju\u0107i nau\u010dnofantasti\u010dne filmove, Petar je odlu\u010dio da iskoristi ideje i znanje koje je iz njih pokupio i napravi mehani\u010dkog proroka, odnosno ma\u0161inu koja odgovara na bilo kakvo da-ne pitanje koje joj se postavi.</p> <p>Nakon \u0161to je napravio proroka, Petar mu je postavio \\(N\\) pitanja i bele\u017eio odgovore koje je dobio. Da ne bi tro\u0161io previ\u0161e papira, svako pitanje je skra\u0107eno obele\u017eio identifikacionim brojem (tako da istim brojevima odgovara isto pitanje -- Petar je neka pitanja postavio vi\u0161e puta). Primetio je da su odgovori koje je dobio kontradiktorni, tj. da je na neka pitanja dobio i odgovor \"da\" i odgovor \"ne\".</p> <p>Petar pretpostavlja da je problem u neispravnoj prostor-vremenskoj ferfucni, zbog koje prorok na svako \\(K\\)-to postavljeno pitanje odgovara suprotno od ta\u010dnog odgovora (gde \\(2 \\leq K \\leq N\\)). Da bi mogao da po\u010dne popravke odmah, umesto da \u010deka da sazna prave odgovore, zamolio vas je da na\u0111ete najmanje \\(K\\) koje odgovara ovoj pretpostavci i dobijenim odgovorima.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Dimitrije Erdeljan - <p>Najjednostavnije re\u0161enje bi bilo da probamo svaku mogu\u0107u vrednost za period suprotnih odgovora \\(K\\), i ispi\u0161emo prvu koja daje konzistentne odgovore. Za svako \\(K\\), mo\u017eemo prvo okrenuti svaki \\(K\\)-ti odgovor, pa prebrojati odgovore \"da\" i \"ne\" na svako pitanje jednim prolazom kroz niz. Ovo zahteva prolazak kroz ceo niz za svaki od \\(N\\) kandidata za \\(K\\), tako da bi ukupna slo\u017eenost bila \\(\\mathcal{O}(N^2)\\).</p> <p>Na\u010din na koji vodimo evidenciju o broju odgovora na svako pitanje je bitan: po\u0161to njihovi identifikacioni brojevi mogu biti do \\(10^9\\), niz sa jednim elementom za svaki od njih ne\u0107e stati u memoriju. Umesto ovoga, mo\u017eemo koristiti strukturu kao \u0161to je <code>std::map</code>, po cenu dodatnog \\(\\mathcal{O}(\\log N)\\) faktora u slo\u017eenosti. Po\u0161to mo\u017eemo imati najvi\u0161e \\(N\\) razli\u010ditih pitanja, bolje re\u0161enje je da na po\u010detku \"prepakujemo\" brojeve u interval od \\(1\\) do \\(N\\), a zatim koristimo niz sa \\(N\\) \u010dlanova. Ovo mo\u017eemo uraditi, na primer, tako \u0161to sortiramo sva pitanja, i onda najmanjem dodelimo broj 0, slede\u0107em 1, i tako dalje.</p> <p>Da bi postigli bolju slo\u017eenost, mo\u017eemo iskoristiti slede\u0107u optimizaciju: po\u0161to se za svako \\(K\\) menja samo svaki \\(K\\)-ti odgovor, posmatra\u0107emo samo njih i ne\u0107emo prolaziti kroz ceo niz, osim na po\u010detku programa da bi izra\u010dunali neke po\u010detne vrednosti koje \u0107e nam biti potrebne. Za \\(K = 1\\) \u0107emo pro\u0107i kroz \\(N\\) vrednosti, za \\(K = 2\\) kroz \\(\\frac{N}{2}\\), i tako dalje, tako da \u0107e ukupna slo\u017eenost biti:</p> \\[ \\frac{N}{1} + \\frac{N}{2} + \\frac{N}{3} + \\dots = \\mathcal{O}(N \\log N) \\] <p>Za svako \\(K\\), na\u0161 algoritam je: * Po\u010dinjemo od po\u010detnog stanja, gde za svako pitanje imamo broj   odgovora \"da\" i \"ne\" datih na ulazu. * Promenimo svaki \\(K\\)-ti odgovor tako \u0161to odgovaraju\u0107em pitanju   prebacimo \\(1\\) iz \"originalnog\" odgovora u novi. * Proverimo da li postoji pitanje koje ima i \"da\" i \"ne\" odgovore.   Ako ne postoji, na\u0161li smo re\u0161enje \\(K\\). * Poni\u0161timo sve izmene koje smo napravili, na primer jo\u0161 jednim   prolaskom kroz svaki \\(K\\)-ti odgovor.</p> <p>Svaki od ovih koraka je jednostavan, osim tre\u0107eg -- prolazak kroz sva pitanja bi nas ko\u0161tao \\(\\mathcal{O}(N)\\) vremena, i ukupna slo\u017eenost bi opet bila kvadratna. Umesto toga, mo\u017eemo pro\u0107i samo kroz ona pitanja za koja smo menjali odgovore, i proveriti da va\u017ee dva uslova:</p> <ul> <li>Nijedno vi\u0161e nema i \"da\" i \"ne\" odgovore.</li> <li>Broj pitanja koja su na po\u010detku imala oba odgovora je isti kao   prethodno izra\u010dunat broj ovakvih pitanja u celom ulazu (tj. sva   kontradiktorna pitanja su \"ispravljena\").</li> </ul> 05_prorok.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nconst int N = 100005;\n\nstruct question\n{\n    int id, pos;\n    bool answer;\n} ;\n\nint n;\nquestion a[N];\nint cnt[N][2];  // cnt[n][x] == # of questions w/ id n and ans x\nint n_both;\n\nbool answer[N];\nint timestamp[N];\n\nbool is_valid(int k)\n{\n    int both = n_both, target = 0;\n    for(int i = k - 1; i &lt; n; i += k)\n    if(timestamp[a[i].id] != k)\n    {\n        timestamp[a[i].id] = k;\n        answer[a[i].id] = !a[i].answer;\n\n        if(cnt[a[i].id][0] &amp;&amp; cnt[a[i].id][1])\n        both--;\n        target += cnt[a[i].id][a[i].answer];\n    }\n    else\n    {\n        if(answer[a[i].id] != !a[i].answer)\n        return false;\n    }\n\n    return both == 0 &amp;&amp; target == n / k;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++)\n    {\n    char ans[10];\n    scanf(\"%d %s\", &amp;a[i].id, &amp;ans);\n    a[i].answer = (ans[0] == 'd');\n    a[i].pos = i;\n    }\n\n    // compress ids\n    std::sort(a, a + n, [](question a, question b) {\n        return a.id &lt; b.id;\n    });\n\n    int curr_val = 0, curr_id = a[0].id;\n    a[0].id = curr_val;\n    for(int i = 1; i &lt; n; i++)\n    if(a[i].id == curr_id)\n        a[i].id = curr_val;\n    else\n    {\n        curr_id = a[i].id;\n        curr_val++;\n        a[i].id = curr_val;\n    }\n\n    std::sort(a, a + n, [](question a, question b) {\n        return a.pos &lt; b.pos;\n    });\n\n    // precompute cnt\n    for(int i = 0; i &lt; n; i++)\n    cnt[a[i].id][a[i].answer]++;\n\n    for(int i = 0; i &lt; n; i++)\n    if(cnt[i][0] &amp;&amp; cnt[i][1])\n        n_both++;\n\n    // solve\n    for(int k = 2; k &lt;= n; k++)\n    if(is_valid(k))\n    {\n        printf(\"%d\\n\", k);\n        return 0;\n    }\n\n    printf(\"-1\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se jedan prirodan broj \\(N\\) -- broj pitanja koja je Petar postavio. U narednih \\(N\\) redova nalaze se identifikacioni broj \\(i\\)-tog pitanja \\(Q_i\\) i odgovor koji je prorok dao \\(A_i\\). Sve vrednosti \\(A_i\\) \u0107e biti ili \"da\" ili \"ne\".</p>"},{"location":"takprog/2016_2017/drz/05_prorok/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati \\(K\\) -- najmanju vrednost \"perioda\" sa kojim je mogu\u0107e da prorok gre\u0161i. Ukoliko takvo \\(K\\) ne postoji, ispisati -1.</p>"},{"location":"takprog/2016_2017/drz/05_prorok/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/05_prorok/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 da\n2 ne\n1 ne\n3 da\n2 ne\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/drz/05_prorok/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 da\n1 ne\n1 ne\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2016_2017/drz/05_prorok/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, ako su odgovori na pitanja sa identifikacionim brojevima \\(1, 2, 3\\) redom \"da\", \"ne\" i \"da\", odgovori proroka su konzistentni ako je na tre\u0107e postavljeno pitanje dao suprotan odgovor (tj. \\(K = 3\\)). Za \\(K = 2\\) se ne sla\u017eu odgovori na prvo i tre\u0107e pitanje (prorok na njih ne bi odgovorio suprotno), kao ni odgovori na drugo i peto (prorok bi na drugo pitanje odgovorio suprotno a ne peto ne bi).</p>"},{"location":"takprog/2016_2017/drz/05_prorok/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq Q_i \\leq 10^9\\)</li> </ul> <p>Postoje \\(3\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [20 poena]: \\(1 \\leq N \\leq 2000\\).</li> <li>Podzadatak 2 [35 poena]: \\(1 \\leq N \\leq 100000\\), i   za sve \\(i\\) va\u017ei \\(Q_i \\leq 200\\).</li> <li>Podzadatak 3 [45 poena]: \\(1 \\leq N \\leq 100000\\).</li> </ul>"},{"location":"takprog/2016_2017/drz/06_karte/","title":"A3 - Karte","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 600ms 64MB <p>Vu\u010dko je preturaju\u0107i po sobi, iza jednog ba\u0161tenskog rekvizita koji je dobio od drugara kao ro\u0111endanski poklon, prona\u0161ao stari \u0161pil karata. Na svakoj karti bio je ispisan jedan prirodan broj. On je odmah pozvao Kocu da igraju slede\u0107u igru: Prvo Vu\u010dko polo\u017ei sve karte licem nadole a zatim Koca bira dve karte, \u010dita brojeve sa njih i zatim tra\u017ei prirodan broj ve\u0107i od \\(1\\) koji deli oba izvu\u010dena broja. Ako se ispostavi da takav broj ne postoji, Vu\u010dko pobe\u0111uje. U suprotnom, niko ne pobe\u0111uje (svakako Koca ne pobe\u0111uje). Vu\u010dko sprema ispit iz verovatno\u0107e pa \u017eeli da kao ve\u017ebu izra\u010duna verovatno\u0107u da \u0107e pobediti u ovoj igri. Za to mu je potrebna va\u0161a pomo\u0107! Recite Vu\u010dku na koliko na\u010dina se mogu odabrati dve karte tako da on pobedi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 - <p>U ovom zadatku tra\u017ei se da se na\u0111e broj ure\u0111enih parova \\((i, j), 1 \\leq i &lt; j \\leq N\\) tako da su \\(A_i, A_j\\) uzajamno prosti brojevi. Za svaka dva broja \\(x, y\\) mo\u017eemo direktnom proverom, u vremenskoj slo\u017eenosti \\(O(min(x, y))\\) proveriti da li postoji neki prirodan broj, ve\u0107i od \\(1\\), koji deli oba ova broja. Ovakav algoritam je dovoljan za re\u0161avanje prvog podzadatka. Za drugi podzadatak mo\u017eemo koristiti Euklidov algoritam, koji u samo \\(O(log(min(x, y)))\\) deljenja nalazi NZD dva broja. Me\u0111utim, ovaj algoritam nije dovoljan za tre\u0107i podzadatak -- operacije deljenja su veoma skupe. Zato, za tre\u0107i, a i \u010detvrti podzadatak, prvo potra\u017eimo sve proste brojeve do \\(\\sqrt{10^8} = 10^4\\), npr. pomo\u0107u Eratostenovog sita, a zatim pomo\u0107u ovih brojeva faktori\u0161imo sve date brojeve, odnosno, napi\u0161imo ih u obliku proizvoda prostih brojeva. Primetimo da su dva broja uzajamno prosta ako i samo ako njihove liste prostih delilaca nemaju nijedan zajedni\u010dki element, \u0161to zna\u010di da pri pam\u0107enju listi prostih delilaca mo\u017eemo izostaviti duplikate. Po\u0161to je \\(2 \\times 3 \\times 5 \\times 7 \\times 9 \\times 11 \\times 13 \\times 17 \\times 19 &gt; 10^8\\), nijedan od datih brojeva ne\u0107e imati vi\u0161e od \\(8\\) razli\u010ditih prostih delilaca. Za tre\u0107i podzadatak, za svaka dva broja uporedimo njihove liste prostih delilaca i na ovaj na\u010din ispitujemo da li su oni uzajamno prosti. Ovaj korak se mo\u017ee uraditi u vremenskoj slo\u017eenosti \\(O(k+l)\\), gde su \\(k, l\\) du\u017eine listi za te brojeve, ako prethodno sortiramo sve ove liste. Za maksimalan broj poena mo\u017eemo koristiti slede\u0107i postupak. Prvo, modifikujmo postavku problema. Umesto broja ure\u0111enih parova oblika \\((i, j), 1 \\leq i &lt; j \\leq N\\) potra\u017eimo broj ure\u0111enih parova oblika \\((i, j), 1 \\leq i, j \\leq N\\). Od broja ovakvih parova treba oduzeti broj parova oblika \\((i, i), 1 \\leq i \\leq N\\), odnosno, broj jedinica u datom nizu, a zatim podeliti ovu razliku sa \\(2\\). Zatim, za svaki broj iz datog niza izra\u010dunajmo sve \"bezkvadratne\" delioce -- one koji nisu deljivi kvadratom nijednog prostog broja. Ako broj \\(x\\) ima \\(q\\) razli\u010ditih prostih delioca, onda on ima ta\u010dno \\(2^q\\) bezkvadratnih delioca. Ovo mo\u017eemo efikasno uraditi pomo\u0107u ve\u0107 dobijene proste faktorizacije. Na\u0161 cilj je da mo\u017eemo za svaki bezkvadratni broj da efikasno proverimo koliko brojeva iz datog niza je deljivo tim brojem. Ovo mo\u017eemo uraditi na vi\u0161e na\u010dina, brojanjem i/ili sortiranjem svih na\u0111enih bezkvadratnih delioca. Zatim, za neki broj \\(x\\) \u010diju prostu faktorizaciju imamo, mo\u017eemo proveriti koliko brojeva iz datog niza je uzajamno prosto sa njim pomo\u0107u principa uklju\u010denja-isklju\u010denja i prethodno pomenute provere. Prvo, uzmimo da su svi brojevi iz datog niza uzajamno prosti sa \\(x\\). Zatim, izbacimo sve one koji su deljivi sa \\(p_1, p_2, ..., p_q\\) pa ubacimo one koji su deljivi sa \\(p_1 p_2 , p_1 p_3, ..., p_{q-1} p_q\\), itd. Izraz za kona\u010dnu vremensku slo\u017eenost ovog algoritma je dosta komplikovan i stoga izostavljen. Ovo je dovoljno brzo i za poslednji, najop\u0161tiji podzadatak.</p>"},{"location":"takprog/2016_2017/drz/06_karte/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se jedan prirodan broj \\(N\\), broj karata u \u0161pilu. U narednih \\(N\\) redova nalazi se po jedan prirodan broj \\(A_i\\), broj sa \\(i\\)-te karte.</p>"},{"location":"takprog/2016_2017/drz/06_karte/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati jedan ceo broj -- broj na\u010dina da se izvuku dve karte tako da Vu\u010dko pobe\u0111uje.</p>"},{"location":"takprog/2016_2017/drz/06_karte/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/drz/06_karte/#ulaz","title":"Ulaz","text":"<pre><code>3\n2\n3\n6\n</code></pre>"},{"location":"takprog/2016_2017/drz/06_karte/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2016_2017/drz/06_karte/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/drz/06_karte/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1\n6\n10\n15\n</code></pre>"},{"location":"takprog/2016_2017/drz/06_karte/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/drz/06_karte/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, jedini na\u010din da Vu\u010dko pobedi jeste da Koca izvu\u010de prvu i drugu kartu. U drugom primeru, postoje tri na\u010dina -- ako Koca izvu\u010de prvu kartu i bilo koju od preostale tri.</p>"},{"location":"takprog/2016_2017/drz/06_karte/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq A_i \\leq 10^8\\)</li> </ul> <p>Postoje \\(4\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [9 poena]: \\(1 \\leq N, A_i \\leq 100\\).</li> <li>Podzadatak 2 [10 poena]: \\(1 \\leq N \\leq 1000\\)</li> <li>Podzadatak 3 [30 poena]: \\(1 \\leq N \\leq 7000\\).</li> <li>Podzadatak 4 [51 poena]: \\(1 \\leq N \\leq 30000\\).</li> </ul>"},{"location":"takprog/2016_2017/drz/06_karte/#napomene","title":"Napomene","text":"<p>Brojanje bezkvadratnih delioca mo\u017ee se posti\u0107i na vi\u0161e na\u010dina, kombinacijom sortiranja i binarne pretrage, brojanjem (sli\u010dno Counting Sort-u) za dovoljno male vrednosti, ili sme\u0161tanjem u mapu (C++).</p> 06_karte.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; f[30005];\nint a[30005], n;\n\nbool sl[10005];\nvector&lt;int&gt; prosti; // 1229 brojeva\n\n// svi brojevi do 100M imaju najvise 8 razlicitih prostih delioca\n\nint moj_lzcnt[256];\nint moj_parity[256];\n\nvoid sito_i_lzcnt() {\n    for (int i=2; i&lt;=10000; i++) {\n        if (!sl[i]) {\n            prosti.push_back(i);\n            for (int j=i*i; j&lt;=10000; j+=i) {\n                sl[j] = true;\n            }\n        }\n    }\n    for (int i=1; i&lt;256; i++) {\n        int x = i, c = 0;\n        while (x % 2 == 0) {\n            c++;\n            x &gt;&gt;= 1;\n        }\n        moj_lzcnt[i] = c;\n    }\n    moj_parity[0] = 1;\n    for (int i=1; i&lt;256; i++) {\n        moj_parity[i] = -moj_parity[i - (1 &lt;&lt; moj_lzcnt[i])];\n    }\n}\n\nvoid ucitaj() {\n    scanf(\"%d\", &amp;n);\n    for (int i=0; i&lt;n; i++) scanf(\"%d\", a+i);\n    sort(a, a+n);\n}\n\nvoid faktorisi() {\n    for (int i=0; i&lt;n; i++) {\n        int k = a[i];\n        for (int x : prosti) {\n            if (k % x == 0) {\n                f[i].push_back(x);\n                do {\n                    k /= x;\n                } while (k % x == 0);\n            }\n            if (x &gt; k) break;\n        }\n        if (k &gt; 1) {\n            f[i].push_back(k);\n        }\n    }\n}\n\nconst int MAX = 100'000'000;\nconst int LIMIT = 10'000'000;\nuint16_t br[LIMIT+5];\n\nint br_delioca;\nint delioci[256];\n\n// ne idu svi delioci vec samo oni koji nemaju isti prost broj vise puta\nvoid napuni_deliocima(int i) {\n    delioci[0] = 1;\n    br_delioca = 1 &lt;&lt; f[i].size();\n    for (int mask=1; mask&lt;br_delioca; mask++) {\n        int lz = moj_lzcnt[mask];\n        delioci[mask] = delioci[mask - (1 &lt;&lt; lz)] * f[i][lz];\n    }\n}\n\nint broj_deljivih(int x) {\n    if (x &lt;= LIMIT) {\n        return br[x];\n    }\n    int c = 0;\n    for (int y=x; y&lt;=MAX; y+=x) {\n        c += upper_bound(a, a+n, y) - lower_bound(a, a+n, y);\n    }\n    return c;\n}\n\nvoid resi() {\n    for (int i=0; i&lt;n; i++) {\n        napuni_deliocima(i);\n        for (int mask=1; mask&lt;br_delioca; mask++) {\n            if (delioci[mask] &lt;= LIMIT) {\n                br[delioci[mask]]++;\n            }\n        }\n    }\n    long long sol = 0;\n    for (int i=0; i&lt;n; i++) {\n        napuni_deliocima(i);\n        sol += n;\n        for (int mask=1; mask&lt;br_delioca; mask++) {\n            sol += moj_parity[mask] * broj_deljivih(delioci[mask]);\n        }\n    }\n    // odbaci jedinice\n    sol -= count(a, a+n, 1);\n\n    // odbaci simetricne parove\n    sol /= 2;\n\n    printf(\"%lld\\n\", sol);\n}\n\nint main() {\n    sito_i_lzcnt();\n    ucitaj();\n    faktorisi();\n    resi();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/01_trotoar/","title":"1 - Trotoar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Milutin mnogo voli da ide u \u0161kolu, tj. da pe\u0161a\u010di od ku\u0107e do \u0161kole. Njegov omiljeni predmet je matematika, omiljeni brojevi - celi brojevi, a omiljene operacije su mu sabiranje i mno\u017eenje jer ostale ne zna. </p> <p>Jednog dana, na putu do \u0161kole, nai\u0161ao je na tri cela broja \\(a\\), \\(b\\) i \\(c\\), napisana jedan za drugim kredom na trotoaru. Tada mu je sinula stra\u0161na ideja: dopisa\u0107e neku od njemu omiljenih operacija izme\u0111u prvog i drugog kao i izme\u0111u drugog i tre\u0107eg broja tako da rezultat bude najmanji mogu\u0107i broj; zatim \u0107e pobe\u0107i sa lica mesta. Odredite koji je to najmanji mogu\u0107i broj uzimaju\u0107i u obzir da Milutin nije mogao da menja redosled brojeva niti da dopisuje zagrade, ali da zna o prioritetu operacija.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2016_2017/kv1/01_trotoar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se tri cela broja \\(a\\), \\(b\\) i \\(c\\), razdvojena razmacima i u redosledu kojim su napisani na trotoaru.</p>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan ceo broj - tra\u017eeni najmanji mogu\u0107i broj koji mo\u017ee dobiti Milutin.</p>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/01_trotoar/#ulaz","title":"Ulaz","text":"<pre><code>1 2 1\n</code></pre>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/01_trotoar/#ulaz_1","title":"Ulaz","text":"<pre><code>-2 5 -7\n</code></pre>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#izlaz_1","title":"Izlaz","text":"<pre><code>-37\n</code></pre>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru najmanji broj dobijamo dopisivanjem dve operacije mno\u017eenja: \\(1 \\cdot 2 \\cdot 1 = 2\\), dok je za drugi primer potrebno prvo dopisati sabiranje pa mno\u017eenje : \\((-2) + 5 \\cdot (-7) = -37\\).</p>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#ogranicenja","title":"Ograni\u010denja","text":"<p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(40\\) poena va\u017ei\u0107e \\(1 &lt; a, b, c &lt; 100\\).</li> <li>U test primerima koji vrede \\(60\\) poena va\u017ei\u0107e \\(-1000 &lt; a, b, c &lt; 1000\\).</li> </ul>"},{"location":"takprog/2016_2017/kv1/01_trotoar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ovo je najlak\u0161i zadatak sa Kvalifikacija \u010dije je re\u0161enje pravolinijsko i slo\u017eenosti \\(O(1)\\). Potrebno i dovoljno je uo\u010diti da postoje samo \\(4\\) na\u010dina na koja se mogu postaviti operacije pa je potrebno vratiti samo \\(\\min\\{ a + b + c, a + b \\cdot c, a \\cdot b + c, a \\cdot b \\cdot c \\}\\). Ograni\u010denja su takva da re\u0161enje staje u \\(32\\)-bitni ceo broj. Napomenimo da nije lako odraditi analizu slu\u010dajeva na osnovu broja pozitivnih/negativnih brojeva me\u0111u \\(a\\), \\(b\\), \\(c\\); izme\u0111u ostalog, problem prave specijalni slu\u010dajevi kada su neki od njih \\(0\\) ili \\(\\pm 1\\) (npr. nije uvek optimalno koristiti samo sabiranje ako su svi brojevi pozitivni).</p> <p>Dodatno, za prvi podzadatak je re\u0161enje uvek \\(a + b + c\\) jer za sve realne (a samim tim i cele) brojeve \\(x, y \\geq 2\\) va\u017ei \\((x - 1)(y - 1) \\geq (2 - 1)(2 - 1) = 1\\) \u0161to je ekvivalento sa \\(x + y \\leq xy\\) \u0161to zna\u010di da se uvek isplati da vr\u0161imo sabiranje umesto mno\u017eenja.</p> 01_trotoar.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nint a, b, c, sol;\n\nint main()\n{\n    scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);\n\n    sol = 1000000000;\n    if (a + b + c &lt; sol)\n        sol = a + b + c;\n    if (a + b * c &lt; sol)\n        sol = a + b * c;\n    if (a * b + c &lt; sol)\n        sol = a * b + c;\n    if (a * b * c &lt; sol)\n        sol = a * b * c;\n\n    printf(\"%d\\n\", sol);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/","title":"2 - Papir, kamen, makaze","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Ne\u0161a i Luka na \u010dasovima informatike najvi\u0161e vole da igraju poznatu igru \"papir, kamen, makaze\". Nakon 1024 odigrane partije Ne\u0161u su bolele ruke i igra mu je dosadila, a \u010das je jo\u0161 uvek trajao. Zbog toga je odlu\u010dio da osmisli svoju, malo komplikovaniju verziju ove igre.</p> <p>U Ne\u0161inoj verziji on je napada\u010d i ima vojsku sa\u010dinjenu od tri divizije: \\(Na\\) vojnika koji za borbu koriste papir (da zbune protivnika), \\(Nb\\) vojnika koji su spretni u bacanju kamenja, i \\(Nc\\) vojnika kojima su oru\u017eje makaze. Lukin cilj u igri je da se odbrani i njegova vojska izgleda sli\u010dno: \\(La\\) vojnika u \"papir\" diviziji, \\(Lb\\) vojnika u \"kamen\" diviziji i \\(Lc\\) vojnika u \"makaze\" diviziji. </p> <p>Luka treba da rasporedi svoju vojsku tj. da za svakog svog vojnika odredi sa kojom Ne\u0161inom divizijom \u0107e se boriti, tako da \u0161to vi\u0161e Ne\u0161inih vojnika bude pora\u017eeno. Pri tome va\u017ee slede\u0107a pravila koja se odnose na Lukinu \"papir\" diviziju:</p> <ul> <li>Ako se jedan Lukin vojnik iz \"papir\" divizije bori sa Ne\u0161inom \"kamen\" divizijom, mo\u017ee da porazi dva vojnika. </li> <li>Ako se jedan Lukin vojnik iz \"papir\" divizije bori sa Ne\u0161inom \"papir\" divizijom, mo\u017ee da porazi jednog vojnika.</li> <li>Ako se dva Lukina vojnika iz \"papir\" divizije bore sa Ne\u0161inom \"makaze\" dizivijom, mogu da poraze jednog vojnika.</li> </ul> <p>Iz pravila se vidi (iako je to poznata \u010dinjenica) da je papir ja\u010di od kamena a slabiji od makaza. Analogna pravila va\u017ee i za druge dve Lukine divizije: kamen je ja\u010di od makaza a slabiji od papira, makaze su ja\u010de od papira a slabije od kamena.</p> <p>Po\u0161to nije pratio na \u010dasu, Luka ne ume sam da do\u0111e do najboljeg rasporeda, pa mu treba va\u0161a pomo\u0107. Koji je najve\u0107i broj Ne\u0161inih vojnika koje on mo\u017ee da porazi?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Nikola Jovanovi\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Spasi\u0107"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se tri nenegativna cela broja: \\(Na\\) - broj Ne\u0161inih vojnika u \"papir\" diviziji, \\(Nb\\) - broj Ne\u0161inih vojnika u \"kamen\" diviziji, \\(Nc\\) - broj Ne\u0161inih vojnika u \"makaze\" diviziji. U drugoj liniji standardnog ulaza nalaze se tri nenegativna cela broja: \\(La\\) - broj Lukinih vojnika u \"papir\" diviziji, \\(Lb\\) - broj Lukinih vojnika u \"kamen\" diviziji, \\(Lc\\) - broj Lukinih vojnika u \"makaze\" diviziji.</p>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan nenegativan ceo broj koji predstavlja maksimalan broj Ne\u0161inih vojnika koje Luka mo\u017ee da porazi.</p>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#ulaz","title":"Ulaz","text":"<pre><code>21 20 30\n10 17 10\n</code></pre>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#izlaz","title":"Izlaz","text":"<pre><code>71\n</code></pre>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#ulaz_1","title":"Ulaz","text":"<pre><code>1 1 3\n0 4 0\n</code></pre>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru Luka mo\u017ee da porazi celu Ne\u0161inu vojsku ako svoje vojnike rasporedi na slede\u0107i na\u010din: </p> <ul> <li>Svih 10 vojnika iz njegove \"papir\" divizije se bori sa Ne\u0161inom \"kamen\" divizijom.</li> <li>15 vojnika iz njegove \"kamen\" divizije se bori sa Ne\u0161inom \"makaze\" divizijom.</li> <li>2 vojnika iz njegove \"kamen\" divizije se bore sa Ne\u0161inom \"papir\" divizijom.</li> <li>Svih 10 vojnika iz njegove \"makaze\" divizije se bori sa  Ne\u0161inom \"papir\" divizijom.</li> </ul> <p>U drugom primeru Luka mo\u017ee da porazi najvi\u0161e 4 Ne\u0161ina vojnika. Jedan od rasporeda kojim je ovo mogu\u0107e posti\u0107i:</p> <ul> <li>2 vojnika iz njegove \"kamen\" divizije se bore sa Ne\u0161inom \"makaze\" divizijom.</li> <li>1 vojnik iz njegove \"kamen\" divizije se bori sa Ne\u0161inom \"kamen\" divizijom.</li> <li>1 vojnik iz njegove \"kamen\" divizije se ne bori.</li> </ul>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq Na, Nb, Nc, La, Lb, Lc \\leq 10^8\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 15 poena najvi\u0161e jedan od \\(Na, Nb, Nc\\) je razli\u010dit od nule.</li> <li>U test primerima koji vrede 15 poena najvi\u0161e jedan od \\(La, Lb, Lc\\) je razli\u010dit od nule.</li> <li>U test primerima koji vrede 15 poena va\u017ei \\(0 \\leq Na, Nb, Nc, La, Lb, Lc \\leq 10\\).</li> <li>U test primerima koji vrede 55 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Kako je najvi\u0161e jedna Ne\u0161ina divizija po broju razli\u010dita od \\(0\\), to nije bitno kako je napadamo po\u0161to \u0107e na kraju biti isti broj vojnika pora\u017eeno. Potrebno je samo implementirati ovo.</p>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Zadatak pristupamo pohlepno. Lukina jedina divizija prvo napada Ne\u0161inu protiv koje on ima prednost. Zatim, ako preostane vojnika, napada onu protiv koje gubi jednak broj vojnika. Na kraju, ako opet ostane vojnika, napada Ne\u0161inu diviziju protiv koje nema prednost.</p>"},{"location":"takprog/2016_2017/kv1/02_papir_kamen_makaze/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sli\u010dno kao ranije, odvija se \\(3\\) koraka, u svakom po \\(3\\) borbe. Prvo, sve Lukine divizije se prvo bore protiv onih prema kojima imaju prednost. Zatim, \\(3\\) borbe se odvijaju izme\u0111u divizija jednakih snaga. Na kraju se Lukine divizije bore protiv Ne\u0161inih prema kojima nemaju prednost.</p> 02_papir_kamen_makaze.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n[3], l[3];\n\nint Stage2()\n{\n    int neutral[3];\n    int score = 0;\n    for(int i = 0; i &lt;= 2; i++)\n    {\n        neutral[i] = min(l[i], n[i]);\n        score += neutral[i];\n    }\n    for(int i = 0; i &lt;= 2; i++)\n    {\n        int j = (i + 2) % 3;\n        int bad = min((l[i] - neutral[i]) / 2, (n[j] - neutral[j]));\n        score += bad;\n    }\n    return score;\n}\n\nint Branch(int i)\n{\n    if(i == 3)\n    {\n        return Stage2();\n    }\n    int score_stage2 = Branch(i + 1);\n    int j = (i + 1) % 3;\n    if(l[i] &gt; 0 &amp;&amp; n[j] == 1)\n    {\n        l[i]--;\n        n[j]--;\n        score_stage2 = max(score_stage2, 1 + Branch(i + 1));\n        l[i]++;\n        n[j]++;\n    }\n    return score_stage2;\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &amp;n[0], &amp;n[1], &amp;n[2]);\n    scanf(\"%d %d %d\", &amp;l[0], &amp;l[1], &amp;l[2]);\n    int score = 0;\n    for(int i = 0; i &lt;= 2; i++)\n    {\n        int j = (i + 1) % 3;\n        int good = min(l[i], n[j] / 2);\n        l[i] -= good;\n        n[j] -= good * 2;\n        score += good * 2;\n    }\n    score += Branch(0);\n    printf(\"%d\\n\", score);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/","title":"3 - Kul kule","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Kao \u0161to je ve\u0107ini \u0111aka poznato, draga profesorka robotike Katarina mnogo voli da se igra lego robotima i kockicama. Ovaj put na \u010das je donela specijalnog robota i \\(n\\) kula kockica. Na svakoj kuli se nalazi odre\u0111en broj naslaganih kockica koje predstavljaju visinu te kule, ta\u010dnije \\(i\\)-ta kula ima visinu \\(A_i\\) (sastavljena je od ta\u010dno \\(A_i\\) kockica). \u0110aci su primetili da ne sadr\u017ee sve kule podjednak broj kockica i \u017eele to da promene pomo\u0107u profesorkinog specijalnog robota. Naime, ovaj robot mo\u017ee izvr\u0161iti slede\u0107u operaciju:</p> <ul> <li>Robot mo\u017ee da uzme dve ili tri kockice sa beskona\u010dne gomile koja se nalazi pored datih kula (Katarina toliko voli   kockice da ih ima u neograni\u010denim koli\u010dinama) i da te kockice stavi na jednu od \\(n\\) kula. Tako se u jednoj operaciji pove\u0107ava visina odre\u0111ene kule za \\(2\\) ili \\(3\\) kockice.</li> </ul> <p>Kako su \u0111aci i sama profesroka malo nestrpljivi, molimo vas pomozite im da \u0161to pre izra\u010dunaju minimalan broj operacija potrebnih robotu da izjedna\u010di visine svih \\(n\\) kula.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Dimitrije Erdeljan Du\u0161an Zdravkovi\u0107"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(n\\), broj kula koje je donela profesorka. U drugom redu nalazi se niz \\(A\\) od \\(n\\) prirodnih brojeva razdvojenih razmakom, gde \\(A_i\\) predstavlja visinu \\(i\\)-te kule.</p>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati ceo broj koji predstavlja minimalan broj operacija navedenih u tekstu zadatka potrebnih robotu da izjedna\u010di visine svih kula.</p>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/03_kul_kule/#ulaz","title":"Ulaz","text":"<pre><code>3\n7 10 5\n</code></pre>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/03_kul_kule/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n1 5 1 5 2\n</code></pre>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru ukupno imamo \\(3\\) kule sa kockicama. Prva kula je visine \\(7\\), druga kula je visine \\(10\\), dok je tre\u0107a kula visine \\(5\\).  Robot mo\u017ee izjedna\u010diti visine kula u \\(3\\) operacije :</p> <ol> <li>Robot dodaje \\(3\\) kockice na prvu kulu.  Sada su visine kula { \\(10\\), \\(10\\), \\(5\\)}.</li> <li>Robot dodaje \\(3\\) kockice na tre\u0107u kulu.  Trenutne visine kula su { \\(10\\), \\(10\\), \\(8\\)}.</li> <li>Robot dodaje \\(2\\) kockice na tre\u0107u kulu.  Kona\u010dne visine kula su { \\(10\\), \\(10\\), \\(10\\)}.</li> </ol> <p>Pokazali smo kako robot mo\u017ee da izjedna\u010di visine kula u \\(3\\) operacije, mo\u017ee se pokazati da je nemogu\u0107e izjedna\u010diti pomenute kule u manje poteza. Minimalan broj potrebnih operacija je \\(3\\).</p>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#ogranicenja","title":"Ograni\u010denja","text":"<p>Test primeri su podeljeni u dve disjunktne gurpe:</p> <ul> <li>U test primerima koji vrede \\(40\\) poena va\u017ei\u0107e \\(1 \\leq n \\leq 100\\) i \\(1 \\leq A_i \\leq 1000\\).</li> <li>U test primerima koji vrede \\(60\\) poena va\u017ei\u0107e \\(1 \\leq n \\leq 10^5\\) i \\(1 \\leq A_i \\leq 10^9\\).</li> </ul>"},{"location":"takprog/2016_2017/kv1/03_kul_kule/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Da bismo mogli da na\u0111emo minimalan broj operacija za izjedna\u010davanje svih kula, prvo nam je potreban na\u010din da odredimo minimalan broj operacija potreban da bi se jednoj kuli dodalo \\(K\\) kockica. Ovo nije mogu\u0107e ako \\(K = 1\\), jer je svaka operacija dodaje barem dve kockice. Ako \\(K \\leq 2\\), optimalan algoritam je:</p> <ul> <li>dok \\(K\\) nije deljivo sa \\(3\\), dodaj dve kockice (i samim time smanji   \\(K\\) za \\(2\\))</li> <li>dodaj \\(K/3\\) grupa od po tri kockice</li> </ul> <p>Jasno je da je ovaj algoritam optimalan u slu\u010daju u kom je \\(K\\) deljivo sa \\(3\\). Ako \\(K\\) nije deljivo sa \\(3\\), sigurno moramo da iskoristimo barem jednu grupu od dve kockice, a ako pretpostavimo da je na\u0161 algoritam optimalan za \\(K-2\\) kockice, po indukciji je optimalan za svako \\(K\\) (gde su bazni slu\u010dajevi \\(K=2\\) i \\(K=3\\), za koje je potrebna jedna grupa).</p> <p>Primetimo da ove vrednosti (minimalni brojevi operacija) rastu sa K (po\u010dev od \\(K=2\\), vrednosti su: \\(1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, \\dots\\) -- svaka posle \\(1\\) se ponavlja tri puta). Dakle, minimalan ukupan broj operacija se posti\u017ee tako \u0161to odaberemo najmanju \"ciljnu visinu\" \\(T\\) na koju mo\u017eemo dovesti visine svih kula.</p> <p>Po\u0161to ne mo\u017eemo \"smanjivati\" kule, ovo \\(T\\) mora biti ve\u0107e ili jednako od svih vrednosti \\(A_i\\). Tako\u0111e ne sme biti jednako sa \\(A_i\\) ni za jedno \\(i\\), po\u0161to kule ne mo\u017eemo pove\u0107ati za samo jednu kockicu. Ako je \\(M\\) maksimalna vrednost u nizu \\(A_i\\), imamo dve mogu\u0107nosti:</p> <ul> <li>\\(M-1\\) se ne javlja u \\(A\\) -- optimalno je \\(T=M\\)</li> <li>u suprotnom, ne mo\u017eemo koristiti \\(T=M\\) (zbog \\(M-1\\)) ni \\(T=M+1\\) (zbog   \\(M\\)) -- optimalno je \\(T=M+2\\)</li> </ul> <p>Nakon \u0161to odredimo optimalnu vrednost za \\(T\\), potrebno je samo da saberemo broj potrebnih kockica za svaku kulu na osnovu opisanog algoritma. Kako \\(T\\) mo\u017eemo odrediti jednim prolazom kroz niz (gde pamtimo najve\u0107i i drugi najve\u0107i element), a broj dodatih kockica u \\(\\mathcal{O}(1)\\) po kuli (jer \u0107emo najvi\u0161e dvaput dodati dve kockice), ukupna slo\u017eenost algoritma je \\(\\mathcal{O}(N)\\).</p> 03_kul_kule.cpp<pre><code>#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#include&lt;algorithm&gt;\n\n\nusing namespace std;\n\nint n;\nlong long a[1000000];\n\nlong long calc(long long x)\n{\n    if (x%3==0) return(x/3); else\n    if (x%3==1) return((x-4)/3+2); else\n    return(x/3+1);\n}\n\nint main()\n{\n    scanf(\"%d\",&amp;n);\n\n    long long res=0;\n    long long maxi=0;\n    for (int i=0;i&lt;n;i++)\n    {\n        scanf(\"%lld\",&amp;a[i]);\n        maxi=max(maxi,a[i]);\n    }\n\n    int cnt=0;\n\n    for (int i=0;i&lt;n;i++)\n        if (maxi-a[i]==1) cnt++;\n\n    if (cnt==0)\n    {\n        for (int i=0;i&lt;n;i++)\n            res+=calc(maxi-a[i]);\n\n        printf(\"%lld\\n\",res);\n    } else\n    {\n        for (int i=0;i&lt;n;i++)\n            res+=calc(maxi-a[i]+2);\n\n        printf(\"%lld\\n\",res);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/","title":"4 - Filozof","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Mali Stojan od svih predmeta najvi\u0161e voli filozofiju (zapravo, pre bi se moglo re\u0107i da voli raspravljanje i filozofiranje). Nakon \u0161to je izgubio pola \u010dasa na raspravu sa Stojanom, profesor filozofije mu je postavio slede\u0107i zadatak, u nadi da \u0107e ga to okupirati bar na neko vreme:</p> <p>Stari gr\u010dki filozof Mile iz Talesa je u svojoj ba\u0161ti gajio pravougaonike - svakog dana bi posadio jedan. Pravougaonici su neobi\u010dne biljke i traju samo \\(K\\) dana, tako da bi Mile svakog dana tako\u0111e uklonio pravougaonik koji je posadio pre \\(K\\) dana. Po\u0161to se Mile pridr\u017eavao starogr\u010dkih na\u010dela ba\u0161tovanstva, sve pravougaonike je sadio tako da su im stranice paralelne koordinatnim osama.</p> <p>Da bi ih za\u0161titio od sunca, Mile je u ba\u0161ti imao jedan pravougaoni zaklon, koji je svakog dana pomerao tako da u potpunosti prekriva sve pravougaonike. Zbog ve\u0107 pomenutih na\u010dela, ovaj zaklon je tako\u0111e uvek morao biti paralelan osama i okrenut na istu stranu (nije se smeo rotirati).</p> <p>Iz Miletovih bele\u017eaka, poznate su pozicije i dimenzije svih pravougaonika koje je posadio tokom \\(N\\) dana, koliko se ukupno bavio ba\u0161tovanstvom. Na Stojanu je sada da prona\u0111e dimenzije najmanjeg zaklona koji bi uvek mogao da ih za\u0161titi od sunca. Pomozite mu da odredi ovo, da bi se \u0161to pre vratio raspravljanju i filozofiranju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Slobodan Mitrovi\u0107 Dimitrije Erdeljan Dragan Uro\u0161evi\u0107 Slobodan Mitrovi\u0107"},{"location":"takprog/2016_2017/kv1/04_filozof/#opis-ulaza","title":"Opis ulaza","text":"<p>Po\u0161to su test primeri potencijalno veoma veliki, da bi se izbeglo u\u010ditavanje celih primera, va\u0161 program treba da generi\u0161e primere na slede\u0107i na\u010din:</p> <p>Na prvom i jedinom redu standardnog ulaza nalazi se \u0161est brojeva: \\(N\\), \\(K\\), \\(M\\), \\(A\\), \\(B\\) i \\(S\\). Nizovi \\(X\\), \\(Y\\), \\(XX\\) i \\(YY\\), gde \\((X_i, Y_i)\\) i \\((XX_i, YY_i)\\) predstavljaju koordinate donjeg levog, odnosno gornjeg desnog pravougaonika koji je Mile zasadio i-tog dana, se generi\u0161u na slede\u0107i na\u010din (u pseudokodu dole, nizovi su indeksirani od 1):</p> <pre><code>for i from 1 to N:\n    if i == 1\n        X[i] = (A * S + B) mod M\n    else\n        X[i] = (A * YY[i-1] + B) mod M\n    Y[i] = (A * X[i] + B) mod M\n    XX[i] = (A * Y[i] + B) mod M\n    YY[i] = (A * XX[i] + B) mod M\n\n    if X[i] == XX[i]\n        XX[i] = XX[i] + 1\n    if X[i] &gt; XX[i]:\n        swap(X[i], XX[i])\n\n    if Y[i] == YY[i]\n        YY[i] = YY[i] + 1\n    if Y[i] &gt; YY[i]\n        swap(Y[i], YY[i])\n</code></pre> <p>Na primer, za ulaz</p> <pre><code>2 3 100000007 19997 31 73\n</code></pre> <p>generisane vrednosti su (svaki red odgovara vrednostima \\(X_i\\), \\(Y_i\\), \\(XX_i\\), \\(YY_i\\) redom):</p> <pre><code>1459812 29119072 95455781 91858558\n94042061 29119072 95455781 58962213\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati dva cela broja - tra\u017eenu minimalnu \u0161irinu i visinu zaklona.</p>"},{"location":"takprog/2016_2017/kv1/04_filozof/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/04_filozof/#ulaz","title":"Ulaz","text":"<pre><code>4 2 13 2 5 2\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/#izlaz","title":"Izlaz","text":"<pre><code>7 9\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/04_filozof/#ulaz_1","title":"Ulaz","text":"<pre><code>7 3 37 5 0 3\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/#izlaz_1","title":"Izlaz","text":"<pre><code>30 32\n</code></pre>"},{"location":"takprog/2016_2017/kv1/04_filozof/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi primer odgovara slede\u0107im vrednostima koordinata pravougaonika (redom \\(X_i\\), \\(Y_i\\), \\(XX_i\\), \\(YY_i\\)):</p> <pre><code>9 3 12 10\n11 1 12 3\n7 1 11 6\n4 0 5 2\n</code></pre> <p>Prvog dana, Mile mo\u017ee da zakloni prvi pravougaonik tako \u0161to postavi zaklon tako da mu je donji levi ugao u \\((9,3)\\). Drugog dana ga pomera na \\((9,1)\\). Tre\u0107eg dana, Mile uklanja prvi pravougaonik, tako da zaklon tada mo\u017ee da stoji na primer u \\((7,-2)\\). Nakon \u0161to ukloni drugi i doda \u010detvrti pravougaonik, pomera zaklon u \\((4,0)\\).</p>"},{"location":"takprog/2016_2017/kv1/04_filozof/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, K\\)</li> <li>\\(1 \\leq M \\lt 10^9\\)</li> <li>\\(0 \\leq A, B, S \\leq 10^9\\)</li> </ul> <p>Ograni\u010denja za \\(M\\), \\(A\\), \\(B\\) i \\(S\\) garantuju da \u0107e se sve koordinate nalaziti u intervalu \\([0, 10^9]\\). Me\u0111urezultati pri generisanju ulaza mogu biti izvan ovog intervala, tako da se preporu\u010duje kori\u0161\u0107enje 64-bitnih tipova za njih (long long u C/C++, int64 u Paskalu).</p> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 20 poena va\u017ei \\(N, K \\leq 1000\\)</li> <li>U test primerima koji vrede 50 poena va\u017ei \\(N, K \\leq 10^5\\)</li> <li>U test primerima koji vrede 30 poena va\u017ei \\(N, K \\leq 2 * 10^6\\)</li> </ul>"},{"location":"takprog/2016_2017/kv1/04_filozof/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ako sa \\(x_i\\) \\(y_i\\) ozna\u010dimo koordinate donjeg levog temena pravougaonika sa rednim brojem \\(i\\), a sa \\(xx_i\\) i \\(yy_i\\) koordinate gornjeg desnog temena pravougaonika sa rednim brojem \\(i\\), onda \u0107e kordinate donjg levog temena obuhvataju\u0107eg pravougaonika nakon dodavanja pravougaonika broj biti \\(j\\) </p> \\[ xo_j=\\min\\{x_{j-k+1}, x_{j-k+2},...x_j\\}, \\quad yo_j=\\min\\{y_{j-k+1}, y_{j-k+2},...y_j\\}. \\] <p>Jasno, koordinate gornjeg desnog temena \u0107e biti:</p> \\[ xxo_j=\\max\\{xx_{j-k+1}, xx_{j-k+2},...xx_j\\}, \\quad yyo_j=\\max\\{yy_{j-k+1}, yy_{j-k+2},...yy_j\\}. \\] <p>Ako je \\(j&lt;k\\), onda se formule neznatno menjaju te \u0107e koordinate donjeg levog temena biti</p> \\[ xo_j=\\min\\{x_{1}, x_{2},...x_j\\}, \\quad yo_j=\\min\\{y_{1}, y_{2},...y_j\\}. \\] <p>Analogno bi se odre\u0111ivale koordinate gornjeg desnog temena obuhvataju\u0107eg pravougaonika. Jasno, stranice minimalnog obuhvataju\u0107eg pravougaonika, nakon -tog dana imaju du\u017eine</p> \\[ dx_j = xxo_j - xo_j,\\quad dy_j=yyo_j-yo_j, \\] <p>a du\u017eine stranica minimalnog obuhvataju\u0107eg pravougaonika za kompletan period od dana \u0107e biti jednake maksimumima odgovaraju\u0107ih nizova sa du\u017einama.</p> <p>Prema tome, potrebno je samo odre\u0111ivati minimume (ili maksimume) za svakih \\(k\\) uzastopnih elemenata nekog niza (niza sastavljenog od \\(x\\) ili \\(y\\) koordinata temena pravougaonika). Opisa\u0107emo kako odre\u0111ujemo minimume od svakih \\(k\\) uzastopnih elemenata, a sli\u010dno se odre\u0111uju maskimumi. </p> <p>Svakako se na prvi pogled name\u0107e pravolinijsko re\u0161enje u kome se za svaki podniz od \\(k\\) uzastopnih ponovo  izra\u010dunava minimum i to re\u0161enje ima slo\u017eenost \\(\\Theta(nk)\\).</p> <p>Malo profinjenje ovog pravolinijskog re\u0161enja dobijamo tako \u0161to poku\u0161amo da iskoristimo prethodno izra\u010dunati minimum. Naime, pretpostavimo da smo zavr\u0161ili obradu elementa \\(x_i\\) i ve\u0107 izra\u010dunali minimum \\(xo_i\\) podniza od \\(k\\) uzastopnih kome je poslednji element \\(x_i\\). Kada se pomerimo na slede\u0107i element, treba da izra\u010dunamo \\(xo_{i+1}\\). Ako je \\(x_{i+1} \\leq xo_{i}\\), onda \u0107e \\(xo_{i+1}\\) biti jednako ba\u0161 \\(x_{i+1}\\) (\\(xo_{i+1}=x_{i+1}\\)). Ako je pak \\(x_{i+1} &gt;  xo_{i}\\), onda \\(x_{i+1}\\) ne mora biti minimum od \\(k\\) poslednjih uzastopnih. Me\u0111utim, ako je \\(xo_{i}=x_{i-k+1}\\), onda je prethodni minimum bio ba\u0161 jednak elementu koji \"ispada\" ia bloka uzastopnih i zbog toga treba ponovo izra\u010dunati minimum poslednjih \\(k\\).  Slo\u017eenost ovakvog re\u0161enja zavisi od izgleda ulaznih podataka (tj. od toga koliko \u010desto se de\u0161ava drugi slu\u010daj), a u najnepovoljnijem slu\u010daju mo\u017ee biti \\(\\Theta(nk)\\).</p> <p>Slede\u0107a varijanta re\u0161enja se dobija tako \u0161to se \"aktuelni elementi\" (tj. poslednjih \\(k\\) obra\u0111enih) \u010duvaju u min-hip-u. To obezbe\u0111uje da u konstantnom vremenu odre\u0111ujemo minimum od \\(k\\) uzastopnih. Me\u0111utim, treba imati u vidu da pri obradi narednog elementa niza, taj element treba dodati u hip i istovremeno element koji ispada iz bloka aktuelnih izbaciti iz hip-a. Slo\u017eenost ovih operacija je \\(\\Theta(\\log_2 k)\\) (po\u0161to se u hipu nalazi \\(k\\) elemenata) pa je tako slo\u017eenost kompletnog re\u0161enja \\(\\Theta(n\\log_2 k)\\).</p> <p>Za najefkasnije re\u0161enje zamislimo da smo ceo niz podelili na disjunktne blokove sastavljene od po \\(k\\) uzastopnih: prvi blok \u010dine elementi od prvog do \\(k\\)-og, drugi od \\(k+1\\)-og do \\(2k\\)-og, tre\u0107i od \\(2k+1\\)-og do \\(3k\\)-og, itd.  Tada \u0107e svaki blok od ta\u010dno \\(k\\) u\u0455astopnih biti sastavljen od delova iz ne vi\u0161e od dva uzastopna bloka: desni kraj jednog bloka (neka je to blok \\(B_1\\)) i levi kraj narednog bloka (neka je to blok \\(B_2\\)). Minimum tog bloka se mo\u017ee lako izra\u010dunati ako su prethodno izra\u010dunati minimumi za odgovaraju\u0107e delove iz blokova \\(B_1\\) i \\(B_2\\) (kao manji od ta dva minimuma). Minimumi svih ovih delova se mogu jednostavno izra\u010dunati sa dva prolaza kroz niz: jedan prolaz za ra\u010dunanje minimuma levih krajeva i jedan prolaz za ra\u010dunanje minimuma desnih krajeva.</p> <p>Prika\u017eimo jo\u0161 jedan postupak za odre\u0111ivanje minimuma za svakih \\(k\\) uzastopnih. Element \\(x_i\\)  je kandidat za najmanji element podnizova (od \\(k\\) uzastopnih) koji se zavr\u0161avaju na pozicijama \\(i, i+1, ..., i+k-1\\). Me\u0111utim, ako za \\(x_j\\) (\\(i&lt;j\\)) va\u017ei da je \\(x_j&lt;x_i\\), onda \\(x_i\\) prestaje biti kandidat za minimum podnizova koji se zavr\u0161avaju na pozicijama \\(j, j+1, ..., i+k-1\\) (zna\u010di mo\u017ee se eliminisati iz razmatranja).  Mo\u017eemo posmatrati i obratno: nakon uklju\u010divanja elementa \\(x_j\\), svi elementi uba\u010deni pre \\(x_j\\) koji imaju osobinu da su ve\u0107i (ili jednaki) od \\(x_j\\) ne mogu biti vi\u0161e kandidati za minimum od \\(k\\) uzastopnih (bez obzira \u0161to se nalaze u bloku od \\(k\\) poslednjih uzastopnih).  Zbog toga se mogu izbaciti iz razmatranja svi elemente niza \\(x\\) koji imaju osobinu da su ve\u0107i (ili jednaki) od \\(x_j\\). Primetimo da se taj element (\\(x_j\\)) dodaje na kraj liste kandidata (kao poslednji kandidat), zato \u0161to je on poslednji dodati i u jednom trenutku svi pre njega dodati \u0107e biti izba\u010deni te on ima \u0161anse da bude najmanji u podnizu od poslednjih \\(k\\) nakon izbacivanja tih prethodnih. Element koji se nalazi na po\u010detku liste kandidata jeste ba\u0161 najmanji za naredni blok uzastopnih. Ali kada u jednom trenutku on bude na rastojanju bar \\(k\\) od elementa koji se trenutno obra\u0111uje, on prestaje da bude kandidat i zato se bri\u0161e iz te liste kandidata. Prema tome, lista kandidata ima osobinu da se sa jedne strane (po\u010detka) elementi izbacuju kada prestanu da budu aktuelni, dok se sa druge strane i dodaju, ali isto tako i izbacuju kada se pojavi neki manji.</p> <p>Algoritamske smernice</p> <p>Radi ilustracije mogu\u0107e implementacije, prila\u017eemo telo funkcije koja kao argumente dobija: du\u017einu nizova koji sadr\u017ee \\(x\\) koordinate levih krajeva pravougaonika i \\(x\\) koordinate desnih krajeva tih pravougaonika (broj \\(n\\)), broj \\(k\\), kao i nizove sa \\(x\\) koordinatama levih krajeva i \\(x\\) koordinatama desnih krajeva, a koja vra\u0107a \u0161irinu minimalnog obuhvataji\u0107eg pravougaonika. Indeksiranje elemenata nizova kre\u0107e od nula (0).</p> <p>Jedna mogu\u0107a implementacija \u0455asnovana na podeli niza uz blokove du\u017eine \\(k\\) mo\u017ee imati slede\u0107i izgled:</p> <p><pre><code>int solve(int n, int k, int left[], int right[])\n{\n    int pref_min[MAXN], pref_max[MAXN];\n    int suff_min[MAXN], suff_max[MAXN];\n    for(int i = 0; i &lt; n; i++)\npref_min[i] = (i % k == 0) ? left[i] : min(pref_min[i - 1], left[i]);\n    for(int i = n - 1; i &gt;= 0; i--)\nsuff_min[i] = (i % k == k - 1) ? left[i] : min(suff_min[i + 1], left[i]);    \n    for(int i = 0; i &lt; n; i++)\npref_max[i] = (i % k == 0) ? right[i] : max(pref_max[i - 1], right[i]);\n    for(int i = n - 1; i &gt;= 0; i--)\nsuff_max[i] = (i % k == k - 1) ? right[i] : max(suff_max[i + 1], right[i]);\n    int res = 0;\n    for(int i = 0; i &lt; n; i++)\n    {\nint low = min(pref_min[i], suff_min[max(i - k + 1, 0)]);\nint high = max(pref_max[i], suff_max[max(i - k + 1, 0)]);\nres = max(res, high - low);\n    }\n    return res;\n}\n</code></pre> Implementacija zasnovana na formiranju liste (reda) kandidata za minimum (maksimum) od svakih \\(k\\) uzastopnih mo\u017ee imati slede\u0107i izgled:</p> <pre><code>int solve(int n, int k, int x1[], int x2[]) {\n  int dxm, dxt;\n  int qx1[MAXN], qx2[MAXN];\n  int qx1s, qx1e, qx2s, qx2e;\n  qx1s = qx2s = 0;\n  qx1e = qx2e = 1;\n  qx1[0] = qx2[0] = 0;\n  dxm = x2[0] - x1[0];\n  for (int i = 1; i &lt; n; i++) {\n      if (i - qx1[qx1s] &gt;= k) qx1s++;\n      if (i - qx2[qx2s] &gt;= k) qx2s++;\n      while ((qx1e &gt; qx1s) &amp;&amp; (x1[qx1[qx1e-1]] &gt;= x1[i])) qx1e--;\n      qx1[qx1e++] = i;\n      while ((qx2e &gt; qx2s) &amp;&amp; (x2[qx2[qx2e-1]] &lt;= x2[i])) qx2e--;\n      qx2[qx2e++] = i;\n      dxt = x2[qx2[qx2s]]-x1[qx1[qx1s]];\n      if (dxt &gt; dxm) dxm = dxt;\n  }  \n  return dxm;\n}\n</code></pre> 04_filozof.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nconst int N = 2000005;\n\n// (x,y) -- donji levi, (xx, yy) -- gornji desni\nint x[N], y[N], xx[N], yy[N];\nint pref_min[N], suff_min[N], pref_max[N], suff_max[N];\nint n, k;\n\nint solve(int left[], int right[])\n{\n    for(int i = 0; i &lt; n; i++)\n    pref_min[i] = (i % k == 0) ? left[i] : min(pref_min[i - 1], left[i]);\n    for(int i = n - 1; i &gt;= 0; i--)\n    suff_min[i] = (i % k == k - 1) ? left[i] : min(suff_min[i + 1], left[i]);\n\n    for(int i = 0; i &lt; n; i++)\n    pref_max[i] = (i % k == 0) ? right[i] : max(pref_max[i - 1], right[i]);\n    for(int i = n - 1; i &gt;= 0; i--)\n    suff_max[i] = (i % k == k - 1) ? right[i] : max(suff_max[i + 1], right[i]);\n\n    int res = 0;\n    for(int i = 0; i &lt; n; i++)\n    {\n    int low = min(pref_min[i], suff_min[max(i - k + 1, 0)]);\n    int high = max(pref_max[i], suff_max[max(i - k + 1, 0)]);\n\n    res = max(res, high - low);\n    }\n\n    return res;\n}\n\nlong long m, a, b, s;\nint rand(long long s) { return s = (a * s + b) % m; }\n\nint main()\n{\n\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; s;\n    for(int i = 0; i &lt; n; i++)\n    {\n    x[i] = rand(i ? yy[i - 1] : s);\n    y[i] = rand(x[i]);\n    xx[i] = rand(y[i]);\n    yy[i] = rand(xx[i]);\n\n    if(x[i] == xx[i]) xx[i]++;\n    if(x[i] &gt; xx[i]) swap(x[i], xx[i]);\n\n    if(y[i] == yy[i]) yy[i]++;\n    if(y[i] &gt; yy[i]) swap(y[i], yy[i]);\n\n    // cout &lt;&lt; x[i] &lt;&lt; \" \" &lt;&lt; y[i] &lt;&lt; \" \" &lt;&lt; xx[i] &lt;&lt; \" \" &lt;&lt; yy[i] &lt;&lt; endl;\n    }\n\n    printf(\"%d \", solve(x, xx));\n    printf(\"%d\\n\", solve(y, yy));\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/","title":"5 - Sportski centar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 200ms 64MB <p>Radi popularizacije sporta i rekreacije, \u0161kola planira izgradnju sportskog centra za svoje u\u010denike. Za tu svrhu dobila je veliko par\u010de zemlji\u0161ta. Pre po\u010detka izgradnje, potrebno je najpre ograditi \u010detvorougaoni deo zemlje. Komisija je odredila optimalnu povr\u0161inu sportskog centra \\(P\\). Me\u0111utim, to nije sve, ogradu nije mogu\u0107e postaviti bilo gde na zemlji\u0161tu, ve\u0107 je odre\u0111en spisak dozvoljenih lokacija koje mogu biti temena \u010detvorougla.</p> <p>Va\u0161 zadatak je da odraberete \u010detiri dozvoljena temena, tako da povr\u0161ina ogra\u0111enog zemlji\u0161ta bude \u0161to bli\u017ea \\(P\\). </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Ivan Dejkovi\u0107 Dragan Uro\u0161evi\u0107 Marko Savi\u0107"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(n\\), koji predstavlja broj dozvoljenih lokacija. U drugoj liniji nalazi se prirodan broj \\(P\\), optimalna povr\u0161ina zemlji\u0161ta. Svaka od narednih \\(n\\) linija sadr\u017ei po dva nenegativna cela broja \\(x\\) i \\(y\\), koordinate jedne dozvoljene lokacije.</p>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan pozitivan realan broj - najbli\u017ea mogu\u0107a povr\u0161ina koju je mogu\u0107e dobiti. Broj ispisati sa ta\u010dno dve cifre iza decimalne ta\u010dke. Ukoliko su dve vrednosti podjednako udaljene od optimalne, ispisati ve\u0107u.</p>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#ulaz","title":"Ulaz","text":"<pre><code>5\n30\n0 0\n10 0\n0 10\n10 10\n7 3\n</code></pre>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#izlaz","title":"Izlaz","text":"<pre><code>30.00\n</code></pre>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n10\n0 0\n3 0\n7 0\n3 3\n10 10\n</code></pre>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#izlaz_1","title":"Izlaz","text":"<pre><code>10.50\n</code></pre>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru mo\u017eemo posti\u0107i tra\u017eenu povr\u0161inu postavljanjem ograda od prve do druge lokacije, druge do \u010detvrte, \u010detvrte do pete i pete do prve. U drugom primeru nije mogu\u0107e dobiti tra\u017eenu vrednost, a najbli\u017eu mo\u017eemo posti\u0107i ako postavimo ograde od prve do druge lokacije, druge do tre\u0107e, tre\u0107e do \u010detvrte i \u010detvrte  do prve.</p>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq P \\leq 10^{18}\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(10\\) poena va\u017ei\u0107e \\(n \\leq 5\\) i \\(0 \\leq x, y \\leq 10\\).</li> <li>U test primerima koji vrede \\(30\\) poena va\u017ei\u0107e \\(n \\leq 100\\) i \\(0 \\leq x, y \\leq 10^9\\).</li> <li>U test primerima koji vrede \\(60\\) poena va\u017ei\u0107e \\(n \\leq 200\\) i \\(0 \\leq x, y \\leq 10^9\\).</li> </ul>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#napomena","title":"Napomena","text":"<p>Povr\u0161ina mora biti ve\u0107a od nule, to jest nije dozvoljeno izabrati \u010detiri kolinearne lokacije. Dozvoljeno je izabrati \u010detiri ta\u010dke tako da tri od njih budu kolinearne, kao u drugom primeru. \u010cetvorougao ne sme biti samopresecaju\u0107i.</p>"},{"location":"takprog/2016_2017/kv1/05_sportski_centar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Pravolinijsko re\u0161enje se dobija tako \u0161to se obra\u0111uje svaka \u010detvorka ta\u010daka i utvr\u0111uje da li je povr\u0161ina \u010detvorougla koji one odre\u0111uju bli\u017ea zadatoj povr\u0161ini. Pri odre\u0111ivanju povr\u0161ine \u010detvorougla koje odre\u0111uju ta\u010dke \\(A, B, C\\) i \\(D\\) treba iskoristiti \u010dinjenicu da bar jedna od njegovih dijagonala pripada \u010detvorouglu. Ta dijagonala deli \u010detvorougao na dva trougla, a povr\u0161ina \u010detvorougla \u0107e biti jednaka zbiru povr\u0161ina ta dva trougla. </p> <p>Kako odrediti tu dijagonalu? Pa ako npr. du\u017e \\(AC\\) predstavlja tu dijagonalu onda su ta\u010dke \\(B\\) i \\(D\\) sa razli\u010ditih strana prave koju odre\u0111uju ta\u010dke \\(A\\) i \\(C\\). Proveru mo\u017eemo izvesti tako \u0161to \u0107emo kroz ta\u010dke \\(A\\) i \\(C\\) postaviti pravu. Ako su \\(x_A\\) i \\(y_A\\) koordinata ta\u010dke \\(A\\),  a \\(x_C\\) i \\(y_C\\) koordinate ta\u010dke \\(C\\), onda je jedna\u010dina prave</p> \\[ \\frac{x-x_A}{x_C-x_A} = \\frac{y-y_A}{y_C-y_A} \\] <p>ili </p> \\[ (x-x_A)(y_C-y_A) \u2013 (y-y_A)(x_C-x_A) = 0 \\] <p>Ako neka tre\u0107a ta\u010dka ne pripada pravoj postavljenoj kroz ta\u010dke \\(A\\) i \\(C\\), onda izraz koji dobijamo kada u levoj strani gornjeg izraza zamenimo \\(x\\) i \\(y\\) sa koordinatama te ta\u010dke ima vrednost razli\u010ditu od nule. Ako su vrednosti koje se dobiju kada se \\(x\\) i \\(y\\) zamene koordinatama ta\u010dke \\(B\\), odnosno koordinatama ta\u010dke \\(D\\) razli\u010ditog znaka, onda su ta\u010dke \\(B\\) i \\(D\\) sa razli\u010ditih strana prave \\(AC\\).</p> <p>Kako odrediti povr\u0161inu trougla \u010dija su temena ta\u010dke \\(A(x_A,y_A)\\), \\(B(x_B,y_B)\\) i \\(C(x_C,y_C)\\)? Mo\u017eemo formirati vektore \\(\\vec{AB}=(x_B-x_A,y_B-y_A)\\) i \\(\\vec{AC}=(x_C-x_A,y_C-y_A)\\). Onda vektorski proizvod ova dva vektora predstavlja vektor \u010dija je du\u017eina jednaka povr\u0161ine paralelograma razapetog nad tim vektroima. Aritmeti\u010dki, izraz</p> \\[ (x_B-x_A)(y_C-y_A) \u2013 (x_C-x_A)(y_B-y_A) \\] <p>mo\u017ee biti i pozitivan i negativan (ali isto tako i nula, ako su ta\u010dke \\(A, B\\) i \\(C\\) kolinearne), a njegova apsolutna vrednost je jednaka ba\u0161 povr\u0161ini paralelograma razapetog nad vektorima  \\(\\vec{AB}\\) i \\(\\vec{AC}\\), odnosno dvostrukoj povr\u0161ini trougla \\(ABC\\). Napomenimo da ako si izrazi </p> \\[ (x_B-x_A)(y_C-y_A) \u2013 (x_C-x_A)(y_B-y_A)\\quad  i \\quad (x_B-x_A)(y_D-y_A) \u2013 (x_D-x_A)(y_B-y_A) \\] <p>( su koordinate ta\u010dke ), razli\u010ditog znaka, onda su ta\u010dke \\(C\\) i \\(D\\) sa razli\u010ditih strana prave \\(AB\\).</p> <p>Napredniji algoritam dobijamo tako \u0161to analiziramo sve mogu\u0107e parove ta\u010daka kao kandidate za dijagonalu \u010detvorougla i to onu dijagonalu koja pripada unutra\u0161njosti \u010detvorougla. Ako su \\(A\\) i \\(B\\) kandidati za krajeve dijagonale, onda ostale ta\u010dke delimo u dve grupe, zavisno od toga sa koje strane prave \\(AB\\) se nalaze. Neka su \\(P\u2019_1, P\u2019_2, \u2026, P\u2019_{n\u2019}\\) povr\u0161ine trouglova koji se nalaze sa jedne strane prave, a \\(P\u2019\u2019_1, P\u2019\u2019_2, \u2026, P\u2019\u2019_{n\u2019\u2019}\\) povr\u0161ine trouglova koji se nalaze sa druge strane prave \\(AB\\). Ta dva niza sortiramo (npr. u neopadaju\u0107em poretku). Nakon toga se simultano kre\u0107emo kroz nizove poku\u0161avaju\u0107i da sumu povr\u0161ina trouglova iz ta dva niza maksimalno pribli\u017eimo tra\u017eenoj vrednosti. Zbog toga po jednom od nizova kre\u0107emo od po\u010detka (tj. od najmanje povr\u0161ine), a po drugom od kraja (tj. od najve\u0107e povr\u0161ine). Ako je trenutni zbir manji od ciljane vrednosti, pomeramo se po nizu po kome idemo od po\u010detka (i na taj na\u010din pove\u0107avamo zbir). Ako je povr\u0161ina ve\u0107a od ciljane vrednosti, pomeramo se po nizu po kome se kre\u0107emo od kraja. Naravno, prekidamo u trenutku kada potro\u0161imo jedan od nizova. Slo\u017eenost dela koji se odnosi na obradu jednog para ta\u010daka (kao kandidata za krajeve dijagonale) je \\(\\Theta(n\\log n)\\) (sortiranje nizova sa povr\u0161inama). Kako je broj parova ta\u010daka, to je slo\u017eenost kompletnog postupka \\(\\Theta(n^3\\log n)\\).</p> <p>Algoritamske smernice</p> <p>Prila\u017eemo samo blok programa u kome se obra\u0111uje svaki par ta\u010daka kao krajevi dijagonale. Prepu\u0161tamo \u010ditaocu da dopuni sa blokom za u\u010ditavanje i ispis rezultata. Napominjemo da funkcija <code>area(i,j,k)</code> izra\u010dunava povr\u0161inu trougla \u010dija su temena ta\u010dke sa indeksima <code>i</code>, <code>j</code> i <code>k</code>,. </p> <pre><code>    for (int i=0; i&lt;n-1; i++) {\n        for (int j=i+1; j&lt;n; j++) {\n            // za svaki par ta\u010daka se analiziraju sve preostale ta\u010dke i dele\n            // u dve grupe, zavisno od toga sa koje strane \n            // dve fiksirane ta\u010dke se nalaze\n            left_cnt = 0;\n            right_cnt = 0;\n            // obrada ostalih ta\u010daka\n            for (int k=0; k&lt;n; k++) {\n                if (k == i || k == j) continue;\n                Triangle t;\n                t.index = k;\n                t.area = area(i, j, k);\n                if (t.area &gt; 0)\n                    tleft[left_cnt++] = t;\n                else if (t.area &lt; 0) {\n                    t.area = -t.area;\n                    tright[right_cnt++] = t;\n                }\n            }\n            if (left_cnt == 0 || right_cnt == 0) continue;\n            // Sortiramo trouglove sa jedne strane fiksiranog para ta\u010daka\n            sort(tleft, tleft + left_cnt);\n            // Sortiramo trouglove sa druge strane fiksiranog para ta\u010daka\n            sort(tright, tright + right_cnt);\n            // Kre\u0107emo sa razli\u010ditih krajeva sortiranih nizova\n            // i tra\u017eimo par trouglova za koji je zbir povr\u0161ina\n            // najbli\u017ei tra\u017eenom\n            pos_left = 0;\n            pos_right = right_cnt-1;\n            while (pos_left &lt; left_cnt &amp;&amp; pos_right &gt;= 0) {\n                sum = tleft[pos_left].area + tright[pos_right].area;\n                difference = abs_val(sum - 2 * target_area);\n                if (difference &lt; min_difference || \n                   (difference == min_difference &amp;&amp; sum &gt; sol)) {\n                    min_difference = difference;\n                    sol = sum;\n                }\n                if (sum &gt; 2 * target_area)\n                    pos_right--;\n                else\n                    pos_left++;\n            }\n        }\n</code></pre> 05_sportski_centar.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n\nusing namespace std;\n\n\nstruct Vector2D {\n    int x, y;\n\n    Vector2D(int _x, int _y) : x(_x), y(_y) {\n    }\n\n    Vector2D(istream&amp; is) {\n        int _x, _y;\n        is &gt;&gt; x &gt;&gt; y;\n        Vector2D(x, y);\n    }\n\n    Vector2D operator -(const Vector2D&amp; o) const {\n        return {x - o.x, y - o.y};\n    }\n\n    long long operator ^(const Vector2D&amp; o) const {\n        return 1ll*x*o.y - 1ll*y*o.x;\n    }\n};\n\n\nlong long areaTarget, areaBest;\nvector&lt;Vector2D&gt; points;\n\n\nvoid solve() {\n    long long diffBest = LLONG_MAX;\n\n    for (int i = 0; i &lt; points.size(); i++) {\n        for (int j = i + 1; j &lt; points.size(); j++) {\n            long long t[points.size() - 2];\n            int nt = 0;\n            for (int k = 0; k &lt; points.size(); k++) {\n                if (k != i &amp;&amp; k != j) {\n                    t[nt++] = (points[j] - points[i]) ^ (points[k] - points[i]);\n                }\n            }\n            sort(t, t + nt);\n\n            int k = 0;\n            int l = 0;\n\n            while (l &lt; nt) {\n                long long area = t[l] - t[k];\n                long long diff = llabs(area - areaTarget);\n\n                if (t[k] &lt; 0 &amp;&amp; t[l] &gt; 0) {\n                    if ((diff &lt; diffBest) || ((diff == diffBest) &amp;&amp; (area &gt; areaBest))) {\n                        areaBest = area;\n                        diffBest = diff;\n                    }\n                }\n\n                if (area &lt; areaTarget) {\n                    l++;\n                } else {\n                    k++;\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    int n;\n    cin &gt;&gt; n &gt;&gt; areaTarget;\n    areaTarget *= 2;\n\n    for (int i = 0; i &lt; n; i++) {\n        points.push_back(Vector2D(cin));\n    }\n\n    solve();\n\n    cout &lt;&lt; areaBest / 2 &lt;&lt; ((areaBest % 2 == 0) ? \".00\\n\" : \".50\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/","title":"6 - Kru\u017ena \u0161kola","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>\u0160kola se sastoji od \\(n\\) u\u010dionica raspore\u0111enih u krug. U nekim u\u010dionicama nalaze se profesori koji dr\u017ee \u010das, tako da je u svakoj u\u010dionici ili jedan ili nijedan profesor. Profesori su poznati po tome da ih mrzi da mnogo hodaju i da umeju da hodaju samo u smeru kazaljke na satu. Nakon \u0161to zvono ozna\u010di kraj \u010dasa, svaki profesor pogleda da li se u slede\u0107oj u\u010dionici (u smeru kazaljke na satu) nalazi profesor koji je upravo zavr\u0161io \u010das. Ako se ne nalazi, on \u0107e slede\u0107i \u010das odr\u017eati u toj slede\u0107oj u\u010dionici, dok ako je nekog bilo tamo on odlu\u010duje da ostane u istoj u\u010dionici u kojoj je malopre odr\u017eao \u010das, i ponovi \u010das istim \u0111acima (jadni oni).</p> <p>Na slici je dat primer kako se menja raspored profesora pri prelasku iz jednog \u0161kolskog \u010dasa u naredni. Crna polja ozna\u010davaju u\u010dionice sa profesorom, bela polja su u\u010dionice bez profesora.</p> <p></p> <p>Ako je poznat raspored profesora po u\u010dionicama na prvom \u010dasu, odrediti raspored na \\(k\\)-tom \u010dasu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Marko Savi\u0107 Aleksandar Vi\u0161nji\u0107 Nikola Spasi\u0107 <p>Zadatak re\u0161avamo u slo\u017eenosti \\(O(n)\\), te se odmah osvr\u0107emo na glavno re\u0161enje. Sporije implementacije mogu re\u0161iti podzadatke.</p>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalaze se prirodni brojevi \\(n\\), broj u\u010dionica u \u0161koli, i \\(k\\), redni broj \u010dasa za koji treba odrediti raspored. U drugoj liniji ulaza nalazi se opis u\u010dionica na prvom \u010dasu dat kao \\(n\\) karaktera. U\u010dionice su navedene u smeru kazaljke na satu, i za svaku u\u010dionicu zapisan je karakter \\(1\\) ako se u u\u010dionici nalazi profesor, odnosno \\(0\\) ako se ne nalazi.</p>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#opis-izlaza","title":"Opis izlaza","text":"<p>Neka je \\(S\\) niz od \\(n\\) elemenata koji predstavlja stanja u\u010dionica na \\(k\\)-tom \u010dasu. \\(S[i] = 0\\) ako je \\(i\\)-ta u\u010dionica na \u010dasu \\(k\\) prazna, odnosno \\(S[i] = 1\\) ako je u njoj profesor.</p> <p>U jedinu liniju izlaza ispisati opis u\u010dionica na \\(k\\)-tom \u010dasu, na slede\u0107i na\u010din. Ako je \\(n \\leq 10^5\\), ispisati niz \\(S\\) (bez razmaka). Ako je \\(n &gt; 10^5\\), ispisati \\(10^5\\) brojeva, svaki ili \\(0\\) ili \\(1\\), gde \\(i\\)-ti broj predstavlja XOR svih brojeva niza \\(S\\) na pozicijama \u010diji je indeks kongruentan sa \\(i\\) po modulu \\(10^5\\).</p> <p>Ovakav na\u010din ispisivanja se tra\u017ei da bi se u\u0161tedelo vreme potrebno za ispis, i ne menja su\u0161tinu zadatka. Ukoliko ve\u0107 imate izra\u010dunat niz \\(S\\), mo\u017eete iskoristiti slede\u0107i C++ kod za ispis.</p> <pre><code>int M = 100000;\nint l = min(n, M);\nfor (int i = 0; i &lt; l; i++) {\n    int a = 0;\n    for (int j = i; j &lt; n; j += M) {\n        a ^= S[j];\n    }\n    printf(\"%i\", a);\n}\n</code></pre> <p>U programskom jeziku Pascal, pod pretpostavkom da ste deklarisali ove promenljive, <pre><code>l, i, j, a : Longint;\nS : array[1..n] of Integer;\n</code></pre> za ispis mo\u017eete koristiti slede\u0107i kod. <pre><code>l := Min(n, M);\nfor i := 1 to l do\nbegin\n    a := 0;\n    j := i;\n    while (j &lt;= n) do\n    begin\n        a := a xor S[j];\n        j := j + M;\n    end;\n    Write(a);\nend;\n</code></pre></p>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#ulaz","title":"Ulaz","text":"<pre><code>16 2\n1011101100110100\n</code></pre>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#izlaz","title":"Izlaz","text":"<pre><code>0111011010101010\n</code></pre>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#ulaz_1","title":"Ulaz","text":"<pre><code>10 4\n1110010110\n</code></pre>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#izlaz_1","title":"Izlaz","text":"<pre><code>0101010111\n</code></pre>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi test primer je prikazan na slici u zadatku. U drugom test primeru raspored po \u010dasovima je:</p> <ol> <li>1110010110</li> <li>1101001101</li> <li>1010101011</li> <li>0101010111</li> </ol>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#ogranicenja","title":"Ograni\u010denja","text":"<p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 20 poena va\u017ei\u0107e \\(1 \\leq n \\leq 10^5\\) i \\(1 \\leq k \\leq 10^5\\).</li> <li>U test primerima koji vrede 12 poena va\u017ei\u0107e \\(1 \\leq n \\leq 10^5\\) i \\(10^5 &lt; k \\leq 10^9\\).</li> <li>U test primerima koji vrede  8 poena va\u017ei\u0107e \\(10^5 &lt; n \\leq 10^7\\),  \\(1 \\leq k \\leq 10^5\\) i broj profesora nije ve\u0107i od \\(10^5\\).</li> <li>U test primerima koji vrede 60 poena va\u017ei\u0107e \\(10^5 &lt; n \\leq 10^7\\),  \\(10^5 &lt; k \\leq 10^9\\).</li> </ul>"},{"location":"takprog/2016_2017/kv1/06_kruzna_skola/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Mo\u017eemo posmatrati prela\u017eenje profesora u slede\u0107u slobodnu u\u010dionicu kao pretvaranje svakog pojavljivanja podniske \\(10\\) u \\(01\\). \u0160tavi\u0161e, mo\u017eemo posmatrati i kao \"prela\u017eenje keca udesno\" ili \"prela\u017eenje nule ulevo\". Ova dva zadatka su analogna, te mo\u017eemo unapred odrediti onaj koji re\u0161avamo. Ispostavlja se da je jednostavnije re\u0161avati zadatak za karakter (\\(0\\) ili \\(1\\)) koji se manje puta pojavljuje u zadatoj niski (ako se oba pojavljuju isti broj puta, uzimamo bilo koji).</p> <p>Neka je bez umanjenja op\u0161tosti taj karakter \\(1\\), \u0161to zna\u010di da se on pojavljuje najvi\u0161e \\(\\lfloor \\frac{n}{2} \\rfloor\\) puta. Nadalje simuliramo proces u \u0161to je manje operacija mogu\u0107e. Najpre, korisno je particionisati kru\u017enu \u0161kolu u tri vrste particija:</p> <ol> <li>Uzastopni ke\u010devi: \\(111\\ldots 111\\)</li> <li>Uzastopne nule:  \\(000\\ldots 000\\)</li> <li>Naizmeni\u010dni ke\u010devi i nule, s tim da particija uvek po\u010dinje kecom i zavr\u0161ava se nulom: \\(1010\\ldots 10\\)</li> </ol> <p>Postavljamo prioritet da se prvo iskoriste particije tre\u0107e vrste, a tek onda ostale. Ovim se particija druge vrste ne\u0107e na\u0107i nakon particije prve vrste. Dalje posmatramo veli\u010dinu svake particije i odnose izme\u0111u particija razli\u010ditih vrsta tokom procesa. Navodimo sve mogu\u0107e slu\u010dajeve:</p> <ol> <li>prva-tre\u0107a: prva se smanjuje za \\(1\\), a tre\u0107a pove\u0107ava za \\(2\\).</li> <li>druga-prva: druga se smanjuje za \\(1\\), a prva ostaje nepromenjena.</li> <li>druga-tre\u0107a: druga se pove\u0107ava za \\(1\\), tre\u0107a ostaje nepromenjena.</li> <li>tre\u0107a-prva: tre\u0107a se smanjuje za \\(2\\), a prva se pove\u0107ava za \\(1\\).</li> <li>tre\u0107a-druga: tre\u0107a ostaje nepromenjena, a druga se smanjuje za \\(1\\).</li> </ol> <p>\u010citav proces je mogu\u0107e simulirati preko kru\u017ene liste. To je dvostruko povezana lista u kojoj povezujemo po\u010detak i kraj. Za svaki element te liste ra\u010dunamo koliko se u jednom trenutku smanji ili pove\u0107a veli\u010dina particije koju predstavlja na osnovu odnosa sa susedima, kao i kada \u0107e ta veli\u010dina pasti na \\(0\\). Kada se to desi bri\u0161emo element iz liste \u0161to je mogu\u0107e u\u010diniti u \\(O(1)\\). U stvari, za svaki element pamtimo trenutak u kome \u0107e  on biti izbrisan. To je mogu\u0107e u\u010diniti upotrebom pomo\u0107nog niza veli\u010dine \\(n\\), u kome za svaki mogu\u0107i trenutak pamtimo koje elemente treba obrisati ba\u0161 tad.</p> <p>Ispostavlja se da nakon odre\u0111enog vremena, upravo zato \u0161to smo pretpostavili da ke\u010deva ima manje od nula, ostaju samo particije vrste \\(2\\) i \\(3\\), tj. da se cela \u0161kola rotira odjednom. U stvari, nakon \\(n\\) trenutaka ovo \u0107e biti slu\u010daj. Ukoliko je \\(k-n&gt;0\\), kona\u010dno stanje liste ra\u010dunamo jednostavnom modularnom aritmetikom. Zato red veli\u010dine vrednosti \\(k\\) nije od va\u017enosti.</p> <p>Pa\u017eljiva implementacija dovodi do re\u0161enja ukupne slo\u017eenosti \\(O(n)\\). Kao \u0161to je ranije napomenuto, sporije implementacije mogu re\u0161iti podzadatke.</p> 06_kruzna_skola.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\n\nusing namespace std;\n\nconst int maxN = 10000000;\n\nint state[maxN];\nint n, t;\n\n\nstruct Particle {\n    int p, dir;\n    bool used = false;\n    int annihilated = 0;\n\n    Particle(int _p, int _dir):p(_p), dir(_dir) {}\n};\n\nvector&lt;Particle&gt; particles;\n\n\nvoid solve() {\n\n    for (int i = 0; i &lt; n; i++) {\n        int c = state[i];\n        int r = state[(i + 1) % n];\n        if (c == r) {\n            Particle p = Particle(i, c ? -1 : 1);\n            particles.push_back(p);\n        }\n    }\n\n    stack&lt;int&gt; s;\n    int last = -1;\n\n    for (int z = 0; z &lt; 2; z++) {\n        for (int i = 0; i &lt; particles.size(); i++) {\n            Particle *p = &amp;particles[i];\n            if (!p-&gt;used) {\n                if (p-&gt;dir == 1) {\n                    p-&gt;used = true;\n                    s.push(i);\n                } else {\n                    if (!s.empty()) {\n                        p-&gt;used = true;\n                        Particle *q = &amp;particles[s.top()];\n                        s.pop();\n                        int d = (p-&gt;p - q-&gt;p + n) % n;\n                        q-&gt;annihilated = p-&gt;annihilated = (d / 2 &lt;= t ? 2 : 1);\n                        last = i;\n                    }\n                }\n            }\n        }\n    }\n\n    int j = -1;\n    for (int i = 0; i &lt; particles.size(); i++) {\n        if (particles[i].annihilated == 0) {\n            j = i;\n            break;\n        }\n    }\n\n    int k, st;\n\n    if (j != -1) {\n        k = ((particles[j].p + particles[j].dir * t) % n + n) % n;\n        st = state[particles[j].p % n];\n    } else {\n        if (last != -1) {\n            k = ((particles[last].p - t + 2) % n + n) % n;\n            st = state[(particles[last].p + 2) % n];\n        } else {\n            k = t % n;\n            st = state[0];\n        }\n    }\n\n    std::fill(state, state + n, 0);\n\n    for (int i = 0; i &lt; particles.size(); i++) {\n        if (particles[i].annihilated != 2) {\n            state[((particles[i].p + particles[i].dir * t) % n + n) % n] = 1;\n        }\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        int j = (k + i) % n;\n        int nextState = (state[j] == st);\n        state[j] = st;\n        st = nextState;\n    }\n}\n\nchar ulaz[10000555];\n\nint main() {\n    scanf(\"%i %i\\n\", &amp;n, &amp;t);\n    t--;\n\n    gets(ulaz);\n    for (int i = 0; i &lt; n; i++) {\n        state[i] = ulaz[i] - '0';\n    }\n\n    solve();\n\n    int d = 100000;\n    int l = min(n, d);\n    for (int i = 0; i &lt; l; i++) {\n        int a = 0;\n        for (int j = i; j &lt; n; j += d) {\n            a ^= state[j];\n        }\n        printf(\"%i\", a);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/01_krompir/","title":"B1 - Krompir","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Mars. Druga najmanja planeta Solarnog sistema, pre\u010dnika dva puta manjeg od Zemlje \u010dija je godina otprilike dva puta du\u017ea od Zemljine, planeta koja poseduje dva prirodna satelita i drugu najvi\u0161u planinu u Sun\u010devom sistemu. Slu\u010dajnost? Tako ne misli Mateja Dejmon, astro-botani\u010dar koji je gre\u0161kom ostao ostavljen na ovoj planeti kada je pe\u0161\u010dana oluja omela istra\u017eiva\u010dku misiju Ares \\(3\\).</p> <p>On na raspolaganju ima svoju bazu, nekoliko kila krompira i plodno marsovsko zemlji\u0161te dimenzije \\(N \\times N\\) metara koje je on izdelio na \\(N^2\\) polja dimenzija \\(1 \\times 1\\) metar (raspore\u0111enih u \\(N\\) redova i \\(N\\) kolona) a zatim posadio \\(M\\) krompira u nekih \\(M\\) polja (tih \\(M\\) polja \u0107emo zvati po\u010detna polja).  Me\u0111utim, zbog posebnog sastava marsovskog zemlji\u0161ta, krompir je, osim na \\(M\\) po\u010detnih polja, izrastao i na svakom polju u \u010dijem se redu ili koloni nalazilo bar jedno od \\(M\\) po\u010detnih polja.</p> <p>Ukoliko vam je poznato gde je Mateja posadio krompire, pomozite mu da izra\u010duna na koliko je ukupno polja izrastao krompir kako bi procenio svoje zalihe za \u010dekanje na misiju Ares \\(4\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Ivan Dejkovi\u0107"},{"location":"takprog/2016_2017/okr/01_krompir/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(M\\), razdvojena razmakom, koja redom predstavljaju dimenziju zemlji\u0161ta i broj po\u010detnih polja na kojima je zasa\u0111en krompir. Zatim sledi opis po\u010detnih polja: u narednih \\(M\\) redova nalaze se po dva prirodna broja \\(x_i\\) i \\(y_i\\), razdvojena razmakom, koja ozna\u010davaju da je \\(i\\)-ti krompir zasa\u0111en u polju koje se nalazi u \\(x_i\\)-tom redu (gledano odozgo nadole) i \\(y_j\\)-toj koloni (gledano s leva nadesno).</p>"},{"location":"takprog/2016_2017/okr/01_krompir/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza treba ispisati jedan prirodan broj - ukupan broj polja na kojima je izrastao krompir.</p>"},{"location":"takprog/2016_2017/okr/01_krompir/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/okr/01_krompir/#ulaz","title":"Ulaz","text":"<pre><code>4 3\n1 1\n2 1\n3 3\n</code></pre>"},{"location":"takprog/2016_2017/okr/01_krompir/#izlaz","title":"Izlaz","text":"<pre><code>14\n</code></pre>"},{"location":"takprog/2016_2017/okr/01_krompir/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/okr/01_krompir/#ulaz_1","title":"Ulaz","text":"<pre><code>3 1\n2 2\n</code></pre>"},{"location":"takprog/2016_2017/okr/01_krompir/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2016_2017/okr/01_krompir/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru je \\(N = 4\\) i \\(M = 3\\), tj. Mateja Dejmon je zasadio 3 krompira \u010dije su po\u010detne pozicije prikazane na slici. Na istoj slici su sivom bojom ozna\u010dena sva polja na kojima je izrastao krompir i njih ima ukupno 14 \u0161to je re\u0161enje za ovaj primer. U drugom primeru krompir ne\u0107e izrasti u u ugaonim poljima zemlji\u0161ta \\(3 \\times 3\\) a u svim ostalim ho\u0107e.</p> <p></p>"},{"location":"takprog/2016_2017/okr/01_krompir/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^6\\)</li> <li>\\(1 \\leq x_i, y_i \\leq N\\)</li> <li>Sva po\u010detna polja su razli\u010dita</li> </ul> <p>Test primeri su podeljeni u \\(4\\) disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(M = 2\\).</li> <li>U test primerima koji vrede \\(30\\) poena va\u017ei \\(1 \\leq M \\leq 500\\), \\(1 \\leq N \\leq 500\\).</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(1 \\leq M \\leq 5000\\).</li> <li>U test primerima koji vrede \\(30\\) poena va\u017ei \\(1 \\leq M \\leq 10^5\\).</li> </ul>"},{"location":"takprog/2016_2017/okr/01_krompir/#napomena","title":"Napomena","text":"<p>Obratite pa\u017enju da je za re\u0161enje potrebno koristiti \\(64\\)-bitni tip podataka.</p>"},{"location":"takprog/2016_2017/okr/01_krompir/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Posmatrajmo slu\u010dajeve gde je broj po\u010detnih polja (\\(M\\)) mali, kao \u0161to i sugeri\u0161e prvi podzadatak. Jasno je da je za \\(M = 1\\) re\u0161enje \\(2N - 1\\) (samo polja u odgovaraju\u0107oj vrsti i koloni) bez obzira na to gde se po\u010detno polje nalazi. Za \\(M = 2\\) lako se uo\u010dava da je dovoljno posmatrati samo dva slu\u010daja: \\(1)\\) ukoliko po\u010detna polja nisu u istoj vrsti ni koloni, tada je re\u0161enje \\(4N - 4\\) jer zauzimamo po dve vrste i kolone, ali, u njihovom preseku se nalaze 4 polja koja brojimo 2 puta pa otud oduzimanje; \\(2)\\) ukoliko su po\u010detna polja su u istoj vrsti ili koloni tada imamo vrstu/kolonu manje pa je re\u0161enje \\(3N - 2\\). </p> <p>Za drugi podzadatak je dovoljno odraditi direktnu simulaciju -- za svako po\u010detno polje \\((x,y)\\) markirati sva polja neke matrice \\(N \\times N\\) oblika \\((x, i)\\) i \\((y, j)\\) i na kraju prebrojati markirana polja u matrici. Vremenska slo\u017eenost ovog pristupa je \\(O(M\\cdot N + N^2)\\) a memorijska \\(O(N^2)\\) pa je jasno da \u0107e nam za ostale podzadatke trebati bolji algoritam. </p> <p>Na osnovu prethodne diskusije, prirodno se name\u0107e \u010dinjenica da re\u0161enje ne zavisi od ta\u010dnih polo\u017eaja po\u010detnih polja ve\u0107 samo od njihovog me\u0111usobnog polo\u017eaja, a prevashodno od toga da li su u istoj vrsti/koloni. Neka je \\(a\\) broj vrsta u kojima se nalazi bar jedan krompir a \\(b\\) - broj kolona u kojima se nalazi bar jedan krompir. Jasno, na svakom polju ovih \\(a\\) vrsta i \\(b\\) kolona \u0107e izrasti krompir dok \u0107e ostala polja ostati prazna. Prema tome, ukupno imamo \\(a + b\\) pokrivenih vrsta/kolona koje me\u0111usobno imaju ukupno \\(ab\\) prese\u010dnih polja koja ne smemo da ra\u010dunamo dva puta, pa je ukupan broj polja sa krompirima jednak \\((a + b)N - ab\\). </p> <p>Slika \\(1\\):  Za \\(N = 8\\), \\(a = 4\\) i \\(b = 3\\) imamo \\((4+3)\\cdot 8 - 4\\cdot 3 = 44\\) sigurnih polja</p> <p></p> <p>Dakle, dovoljno je odrediti vrednosti \\(a\\) i \\(b\\). Broj \\(a\\) je jednak broju razli\u010ditih elemenata u nizu \\(x_1, x_2, \\ldots, x_M\\) (analogno za \\(b\\) i niz \\(y\\)) a ovo je poznat problem koji se mo\u017ee uraditi sortiranjem niza \\(x\\) i upore\u0111ivanjem uzastopnih elemenata. Slo\u017eenost ovog pristupa je slo\u017eenost soritranja niza du\u017eine \\(M\\) a za tre\u0107i podzadatak je dovoljno koristiti i algoritme sortiranja slo\u017eenosti \\(O(M^2)\\).</p> <p>Za kompletno re\u0161enje zadatka nije neophodno sortiranje; dovoljno je primetiti da su vrednosti niza \\(x\\) celi brojevi iz segmenta \\([1, N]\\) pa mo\u017eemo koristiti pomo\u0107ni logi\u010dki niz \\(row\\) du\u017eine \\(N\\) i za svako \\(x_i\\) markirati element \\(row[x_i]\\). Na kraju, broj markiranih elementa je upravo broj \\(a\\) (sli\u010dno i za drugi pomo\u0107ni niz i broj \\(b\\)). Vremenska slo\u017eenost ovog pristupa je \\(O(N + M)\\) uz \\(O(N)\\) memorije, i nosi maksimalan broj poena.</p> 01_krompir.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 1000100;\n\nint n, m;\nbool row[MAX_N], col[MAX_N];\nlong long a, b, sol;\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        row[i] = false;\n        col[i] = false;\n    }\n\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &amp;x, &amp;y);\n        row[x] = true;\n        col[y] = true;\n    }\n\n    a = 0LL;\n    b = 0LL;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        if (row[i] == true) a++;\n        if (col[i] == true) b++;\n    }\n\n    sol = a * n + b * n - a * b;\n    printf(\"%lld\\n\", sol);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/","title":"B2 - Raketa","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 256MB <p>Javna je tajna da ukoliko \u017eelite da idete na Mars morate imati raketu. Me\u0111utim, samo retki znaju da ukoliko \u017eelite i da stignete do Marsa, motori na va\u0161oj raketi moraju biti \u0161to izbalansiraniji.</p> <p>Po\u0161to je Mars \u010detvrta planeta Sun\u010devog sistema, raketa kojom \u017eelite da idete na njega mora imati \u010detiri motora, i oni moraju biti raspore\u0111eni u formaciju \\(2 \\times 2\\). Prilikom lansiranja, svaki od motora je pode\u0161en na neku svoju po\u010detnu snagu. Kapetan rakete pomo\u0107u sistema poluga mo\u017ee da poja\u010dava snagu motora, i to tako da prilikom svake operacije za 1 poja\u010da snagu ta\u010dno dva motora koja su ili u istoj vrsti ili u istoj koloni. U nauci o raketama, klackavost rakete se defini\u0161e kao razlika najve\u0107e i najmanje snage od snaga njena \u010detiri motora. Pomozite kapetanu da \u0161to bolje izbalansira raketu tako \u0161to \u0107e primenom raspolo\u017eivih operacija dovesti klackavost na najmanju mogu\u0107u vrednost.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Marko Savi\u0107 Marko Savi\u0107 Nikola Spasi\u0107 <p>Re\u0161enje mo\u017eete pogledati na slede\u0107oj adresi: Link</p> 02_raketa.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main() {\n    int a, b, c, d;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n    cout &lt;&lt; (abs(a+d-b-c) + 1) / 2;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/#opis-ulaza","title":"Opis ulaza","text":"<p>Sa standardnog ulaza se u\u010ditavaju \u010detiri nenegativna cela broja koji predstavljaju po\u010detne snage \u010detiri motora. U prvom redu ulaza zapisane su po\u010detne snage levog i desnog motora iz gornjeg reda, a u drugom redu ulaza zapisane su po\u010detne snage levog i desnog motora iz donjeg reda.</p>"},{"location":"takprog/2016_2017/okr/02_raketa/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedini red standardnog izlaza zapisati jedan broj koji predstavlja najmanju mogu\u0107u klackavost rakete koja se mo\u017ee posti\u0107i.</p>"},{"location":"takprog/2016_2017/okr/02_raketa/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/okr/02_raketa/#ulaz","title":"Ulaz","text":"<pre><code>1 1\n0 3\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/okr/02_raketa/#ulaz_1","title":"Ulaz","text":"<pre><code>9 8\n7 0\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/okr/02_raketa/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, ako operaciju poja\u010davanja snage primenimo jednom na gornju vrstu i dva puta na levu kolonu, dobi\u0107emo slede\u0107u konfiguraciju snaga. <pre><code>4 2\n2 3\n</code></pre> Kako nije mogu\u0107e posti\u0107i manju klackavost, optimalna klackavost je \\(4 - 2 = 2\\).</p>"},{"location":"takprog/2016_2017/okr/02_raketa/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>U \\(32%\\) test primera po\u010detna snaga svakog motora nije ve\u0107a od \\(44\\).</li> <li>U \\(44%\\) test primera po\u010detna snaga svakog motora nije ve\u0107a od \\(110\\).</li> <li>U \\(56%\\) test primera po\u010detna snaga svakog motora nije ve\u0107a od \\(1300\\).</li> <li>U \\(68%\\) test primera po\u010detna snaga svakog motora nije ve\u0107a od \\(10^7\\).</li> <li>U \\(100%\\) test primera po\u010detna snaga svakog motora nije ve\u0107a od \\(5 \\cdot 10^8\\).</li> </ul>"},{"location":"takprog/2016_2017/okr/03_marsovci/","title":"B3 - Marsovci","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Nakon mnogo godina istra\u017eivanja i rada, kao i bezbroj bezuspe\u0161nih poku\u0161aja prouzrokovanih nepa\u017eljivim programerima koji u kodu koji pokre\u0107e svemirski brod gre\u0161kom ostave komandu <code>system(\"PAUSE\")</code>, a neretko i <code>readln()</code>, prva ljudska ekspedicija je uspe\u0161no sletela na Mars! \u010cim su sleteli, mala Marina, vo\u0111a ekspedicije, je primetila da se ispred njih nalazi nepomi\u010dna kolona u kojoj stoji \\(n\\) Marsovaca. Na njeno veliko iznena\u0111enje, Marsovci nisu bili zeleni, ve\u0107 metalik roze boje.</p> <p>Nakon nekoliko dana proteklih u zbunjuju\u0107im poku\u0161ajima komunikacije, Marina je saznala visine svih Marsovaca (\\(H_1 \\dots H_N\\)) i kona\u010dno je shvatila da oni nepomi\u010dno stoje jer testiraju inteligenciju novih posetilaca i \u017eele da provere da li \u0107e Zemljani uspeti da na\u0107u podniz uzastopnih Marsovaca iz kolone, takav da je razlika najvi\u0161eg i najni\u017eeg Marsovca najve\u0107a mogu\u0107a.</p> <p>Kako je ovaj problem Marini previ\u0161e jednostavan, odlu\u010dila je da dodatno impresionira nove poznanike tako \u0161to \u0107e im re\u0107i koliko takvih podnizova postoji. Pomozite Marini da obori Marsovce s nogu i zapo\u010dne jedno novo prijateljstvo.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107 Dimitrije Erdeljan"},{"location":"takprog/2016_2017/okr/03_marsovci/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se jedan prirodan broj \\(N\\) - broj Marsovaca u koloni. U drugoj liniji standardnog ulaza nalazi se \\(N\\) prirodnih brojeva, \\(H_1 \\dots H_N\\) - visine Marsovaca (u metrima) redom, od prvog do poslednjeg u koloni.</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan nenegativan ceo broj koji predstavlja broj na\u010dina da se odabere podniz uzastopnih Marsovaca takav da je razlika najvi\u0161eg i najni\u017eeg me\u0111u njima najve\u0107a mogu\u0107a.</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#primeri","title":"Primeri","text":"<p> Ulaz Izlaz                  5                 3 5 2 1 4                               4              </p> <p> Ulaz Izlaz                  2                 21 8                               1              </p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru najve\u0107a mogu\u0107a razlika izme\u0111u najvi\u0161eg i najni\u017eeg Marsovca u nekom podnizu je 4 metra i mo\u017ee se dobiti na 4 razli\u010dita na\u010dina, i to ako odaberemo neki od narednih podnizova:</p> <ul> <li>od prvog do \u010detvrtog Marsovca, tj. \\([3, 5, 2, 1]\\)</li> <li>od drugog do petog Marsovca, tj. \\([5, 2, 1, 4]\\)</li> <li>od prvog do petog Marsovca, tj. \\([3, 5, 2, 1, 4]\\)</li> <li>od drugog do \u010detvrtog Marsovca, tj. \\([5, 2, 1]\\)</li> </ul> <p>U drugom primeru najve\u0107a mogu\u0107a razlika je 13 metara i mo\u017ee se dobiti samo ako u podniz uklju\u010dimo oba Marsovca.</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq Hi \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 15 poena va\u017ei \\(1 \\leq N \\leq 100\\).</li> <li>U test primerima koji vrede 20 poena va\u017ei \\(1 \\leq N \\leq 3000\\).</li> <li>U test primerima koji vrede 15 poena ne postoje dva Marsovca iste visine i va\u017ei \\(1 \\leq N \\leq 10^5\\).</li> <li>U test primerima koji vrede 50 poena va\u017ei \\(1 \\leq N \\leq 10^5\\).</li> </ul>"},{"location":"takprog/2016_2017/okr/03_marsovci/#napomena","title":"Napomena","text":"<p>Obratite pa\u017enju da je za re\u0161enje potrebno koristiti \\(64\\)-bitni tip podataka.</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#podzadatak-1","title":"Podzadatak \\(1\\)","text":"<p>U prvom podzadatku, dovoljno dobro je i bruteforce re\u0161enje. Prolaskom kroz svaki mogu\u0107i podniz uzastopnih Marsovaca odre\u0111ujemo maksimalnu i minimalnu visinu u njemu, njihovu razliku, i brojimo podnizove gde je ta razlika maksimalna. Ovaj pristup ima vremensku slo\u017eenost \\(O(N^3)\\).</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#podzadatak-2","title":"Podzadatak \\(2\\)","text":"<p>Mala modifikacija prethodnog pristupa mo\u017ee dovesti do vremenske slo\u017eenosti \\(O(N^2)\\). Ako prolazak kroz sve podnizove vr\u0161imo tako \u0161to fiksiramo levu granicu \\(L\\), a zatim pomeramo desnu granicu \\(R\\), mo\u017eemo u \\(O(1)\\) na\u0107i maksimum i minimum u svakom podnizu na osnovu prethodno izra\u010dunatih re\u0161enja. Konkretno, imamo da je \\(max(H_L, H_{L+1}, \\dots, H_{R+1}) = max(max(H_{L}, H_{L+1}, \\dots, H_{R}), H_{R+1})\\). Sli\u010dno va\u017ei i za minimum.</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#podzadatak-3","title":"Podzadatak \\(3\\)","text":"<p>U ovom momentu, neophodno je napraviti par bitnih opservacija koje predstavljaju prvi korak ka kompletnom re\u0161enju zadatka.</p> <p>Ozna\u010dimo sa \\(H_{min}\\) i \\(H_{max}\\) visinu najni\u017eeg, odnosno najvi\u0161eg Marsovca. Sada prime\u0107ujemo da je najve\u0107a mogu\u0107a razlika najvi\u0161eg i najni\u017eeg Marsovca u nekom podnizu uzastopnih Marsovaca jednaka \\(H_{max} - H_{min}\\). Ve\u0107u razliku nije mogu\u0107e dobiti, a upravo ova razlika se dobija u bilo kom podnizu u kom je \\(H_{max}\\) maksimum a \\(H_{min}\\) minimum - npr. ceo niz. Tako\u0111e, va\u017ei da je maksimum u nekom podnizu jednak \\(H_{max}\\) ako i samo ako se u njemu nalazi bar jedna vrednost \\(H_{max}\\) (sli\u010dno va\u017ei i za minimum). Sada se zadatak mo\u017ee svesti na brojanje podnizova koji sadr\u017ee barem jednog Marsovca visine \\(H_{max}\\) i barem jednog Marsovca visine \\(H_{min}\\). </p> <p>Dodatni uslov koji ovaj podzadatak unosi je da se vrednosti \\(H_{min}\\) i \\(H_{max}\\) pojavljuju ta\u010dno jednom u nizu visina. Ozna\u010dimo indeks (jedinstvenog) najvi\u0161eg Marsovca sa \\(i_{max}\\) a najni\u017eeg sa \\(i_{min}\\) i uzmimo da je (ne umanjuju\u0107i op\u0161tost) \\(i_{max} &lt; i_{min}\\). Sada do re\u0161enja dolazimo u konstantnom vremenu, uz malo ra\u010duna. Kako leva granica podniza ne sme biti ve\u0107a od \\(i_{max}\\) (ina\u010de se \\(H_{max}\\) ne nalazi u tom podnizu), a desna manja od \\(i_{min}\\) (ina\u010de se \\(H_{min}\\) ne nalazi u tom podnizu) broj podnizova koji sadr\u017ee i \\(H_{min}\\) i \\(H_{max}\\) je jednak \\((i_{max} + 1) * (N - i_{min})\\). Vremenska slo\u017eenost ovog pristupa je \\(O(n)\\).</p>"},{"location":"takprog/2016_2017/okr/03_marsovci/#podzadatak-4","title":"Podzadatak \\(4\\)","text":"<p>Ovde je potrebno malo komplikovanije re\u0161enje, budu\u0107i da dodatni uslov iz prethodnog podzadatka ne va\u017ei, pa najvi\u0161i (tj. najni\u017ei) Marsovac ne mora biti jedinstven. Brojanju podnizova pristupamo tako \u0161to pomeramo broja\u010d \\(L\\) od po\u010detka do kraja niza i u svakom koraku ra\u010dunamo koliko ima podnizova \u010dija je leva granica \\(L\\) a da sadr\u017ee barem jednog Marsovca visine \\(H_{max}\\) i barem jednog Marsovca visine \\(H_{min}\\). Kako bismo ovo efikasno izra\u010dunali u toku cele procedure odr\u017eavamo dva pokaziva\u010da \\(firstMax\\) i \\(firstMin\\) koji, za trenutno \\(L\\), pokazuju na prvo pojavljivanje Marsovca visine \\(H_{max}\\) (odnosno \\(H_{min}\\))  od pozicije \\(L\\) pa do kraja niza (uklju\u010duju\u0107i i \\(L\\)). Kako je leva granica podniza fiksirana na \\(L\\), a desna granica ne sme biti manja od \\(max(firstMax, firstMin)\\), u svakom koraky na kona\u010dno re\u0161enje dodajemo \\(N - max(firstMax, firstMin)\\). </p> <p>Ostalo je jo\u0161 da prodiskutujemo kako se ovi pokaziva\u010di efikasno odr\u017eavaju: ako nakon inkrementovanja \\(L\\) va\u017ei \\(firstMax&gt;=L\\) nije potrebna korekcija, a u suprotnom uve\u0107avamo \\(firstMax\\) za jedan sve do prvog narednog pojavljivanja \\(H_{max}\\) (ako naredno pojavljivanje ne postoji, mo\u017eemo odmah prestati sa brojanjem i ispisati trenutno re\u0161enje). Analogno odr\u017eavamo i drugi pokaziva\u010d.</p> <p>Iako se u jednom koraku uve\u0107anje pomenutih pokaziva\u010da mo\u017ee dogoditi i do \\(N\\) puta, u toku cele procedure \u0107e oni, kao i \\(L\\), pre\u0107i put od po\u010detka do kraja niza, pa je ukupna vremenska slo\u017eenost re\u0161enja \\(O(n)\\).</p> 03_marsovci.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 1000005\n#define MAXH 1000000005\n\nusing namespace std;\n\nint N, H[MAXN];\nint minh = MAXH, maxh = -1;\nint main()\n{\n    scanf(\"%d\", &amp;N);\n    for(int i = 0; i &lt; N; i++)\n    {\n        scanf(\"%d\", &amp;H[i]);\n        minh = min(minh, H[i]);\n        maxh = max(maxh, H[i]);\n    }\n    int first_min = -1;\n    int first_max = -1;\n    long long sol = 0;\n    for(int L = 0; L &lt; N; L++)\n    {\n        if(first_min &lt; L)\n        {\n            do\n            {\n                first_min++;\n            }\n            while(first_min &lt; N &amp;&amp; H[first_min] != minh);\n        }\n        if(first_max &lt; L)\n        {\n            do\n            {\n                first_max++;\n            }\n            while(first_max &lt; N &amp;&amp; H[first_max] != maxh);\n        }\n        if(first_min == N || first_max == N)\n        {\n            break;\n        }\n        int R = max(first_max, first_min);\n        sol += N - R;\n    }\n    printf(\"%lld\\n\", sol);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/04_baza/","title":"A1 - Baza","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Mars. \u010cetvrta planeta od Sunca, nazvana po Rimskom bogu rata, poznata i kao \"crvena planeta\" zbog gvo\u017e\u0111e(III)oksida koji preovla\u0111uje na njenoj povr\u0161ini, planeta \u010diji je astronomski simbol ujedno i simbol za mu\u0161ki rod, \u010diji dan traje \\(24\\) sata i \\(40\\) minuta i za koju se pri\u010da da poseduje podzemne vode. Za\u0161to su ove informacije bitne za zadatak? Nisu.</p> <p>Kako pri\u010da obi\u010dno ide, ljudska ekspedicija je sletela na Mars i odmah oformila bazu. Baza se nalazi na povr\u0161ini dimenzije \\(N \\times N\\) metara koja je, radi lak\u0161e navigacije, izdeljena na \\(N^2\\) kvadratnih sektora dimenzija \\(1 \\times 1\\) metar (raspore\u0111enih u \\(N\\) redova i \\(N\\) kolona). Ekspedicija, pou\u010dena klasi\u010dnim skaj-faj filmovima, \u017eeli da osigura bazu da ih ne bi iznenadilo neko opasno stvorenje poput Ejliena, Marvina Marsovca, D\u017eona Kartera ili Meta Dejmona. To \u0107e odraditi tako \u0161to \u0107e u nekim sektorima postaviti senzore. Ka\u017eemo da je sektor siguran ukoliko se u njegovom redu ili u njegovoj koloni nalazi bar jedan sektor sa senzorom (naravno, iz ovoga sledi da su i sektori sa senzorima sigurni).</p> <p>Pomozite ekspediciji da postavi senzore tako da ta\u010dno \\(M\\) sektora bude sigurno. Za\u0161to \\(M\\), a ne svi? Zato \u0161to tada ne bi bilo mesta iznena\u0111enjima, a tako skaj-faj filmovi ne funkcioni\u0161u.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Marko Savi\u0107"},{"location":"takprog/2016_2017/okr/04_baza/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(M\\), razdvojena razmakom, koja, redom, predstavljaju dimenziju baze i broj sektora koji mora koji moraju biti sigurni.</p>"},{"location":"takprog/2016_2017/okr/04_baza/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko je nemogu\u0107e postaviti senzore tako da ta\u010dno \\(M\\) sektora bude sigurno, u prvom i jedinom redu ispisati \\(-1\\). U suprotnom, u prvom redu ispisati broj senzora \\(K\\), a zatim u narednih \\(K\\) redova opisati gde treba postaviti te senzore: u svakom redu po dva prirodna broja \\(x_i\\) i \\(y_i\\) koja ozna\u010davaju da \\(i\\)-ti senzor treba postaviti u sektoru koji se nalazi u preseku \\(x_i\\)-te vrste i \\(y_i\\)-te kolone. Vrste su numerisane od \\(1\\) do \\(N\\) odozgo nadole, a kolone su numerisane od \\(1\\) do \\(N\\) sleva nadesno. U svakom sektoru sme biti najvi\u0161e jedan senzor. Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2016_2017/okr/04_baza/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/okr/04_baza/#ulaz","title":"Ulaz","text":"<pre><code>4 14\n</code></pre>"},{"location":"takprog/2016_2017/okr/04_baza/#izlaz","title":"Izlaz","text":"<pre><code>4\n1 1\n1 3\n2 1\n3 3\n</code></pre>"},{"location":"takprog/2016_2017/okr/04_baza/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/okr/04_baza/#ulaz_1","title":"Ulaz","text":"<pre><code>10 24\n</code></pre>"},{"location":"takprog/2016_2017/okr/04_baza/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2016_2017/okr/04_baza/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru je \\(N = 4\\) i \\(M = 14\\), tj. tra\u017ei se da ta\u010dno 14 sektora bude sigurno. Ovo je mogu\u0107e posti\u0107i i na slici je prikazan jedan od na\u010dina koji odgovara izlazu za ovaj primer. Crnim ta\u010dkama su ozna\u010dene pozicije senzora dok su sigurni sektori obojeni i ima ih ta\u010dno 14. Postoje i druga\u010dija (ta\u010dna) re\u0161enja. U drugom primeru nikako nije mogu\u0107e obezbediti da baza \\(10 \\times 10\\) ima ta\u010dno 24 sigurna sektora pa je odgovor '-1' (bez navodnika).</p> <p></p>"},{"location":"takprog/2016_2017/okr/04_baza/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq M \\leq 10^{12}\\).</li> </ul> <p>Test primeri su podeljeni u \\(4\\) disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(10\\) poena va\u017ei \\(1 \\le N \\leq 3\\).</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(1 \\leq N \\leq 1000\\), \\(M \\leq 4N\\).</li> <li>U test primerima koji vrede \\(25\\) poena va\u017ei \\(1 \\leq N \\leq 10^6\\).</li> <li>U test primerima koji vrede \\(45\\) poena va\u017ei \\(1 \\leq N \\leq 10^{18}\\).</li> </ul>"},{"location":"takprog/2016_2017/okr/04_baza/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Prvi podzadatak se re\u0161ava trivijalnim razmatranjem slu\u010dajeva; za drugi podzadatak se lako uo\u010dava (npr. uz par nacrtanih primera) da za \\(N &gt; 6\\) ne smemo imati (ukupno) vi\u0161e od 4 vrste/kolone koje sadr\u017ee senzore (jer mora biti \\(M \\leq 4N\\)) pa je broj senzora i njihov raspored prili\u010dno ograni\u010den (pokazati da pri svim pomenutim uslovima broj senzora ne sme biti ve\u0107i od 4!).</p> <p>Razmatraju\u0107i kako polo\u017eaj senzora uti\u010de na broj sigurnih sektora i koriste\u0107i re\u0161enje prvog problema za B kategoriju (obavezno pro\u010ditati i taj problem/re\u0161enje!), uo\u010dava se da je dovoljno znati broj vrsta i broj kolona sa bar po jednim senzorom: ukoliko imamo ta\u010dno \\(a\\) vrsta i ta\u010dno \\(b\\) kolona sa bar po jednim senzorom tada je ukupan broj sigurnih sektora jednak \\((a+b)N - ab\\). Dakle, mogu\u0107e je dobiti ta\u010dno \\(M\\) sigurnih sektora ako i samo ako postoje prirodni brojevi \\(1 \\leq a \\leq N\\) i \\(1 \\leq b \\leq N\\) za koje va\u017ei $$ (a+b)N - ab = M. $$ Transformacijom prethodne jedna\u010dine za \\(a \\neq N\\) dobijamo \\(b = \\frac{M - aN}{N - a}\\), pa je jedan od na\u010dina za re\u0161avanje ove jedna\u010dine ispitivanje svih kandidate za \\(a\\) me\u0111u brojevima \\(1,2,\\ldots N\\) i provera (za svaki od njih) da li je dobijeni broj \\(b\\) ceo i iz segmenta \\([1,N]\\). Ovo vodi re\u0161enju slo\u017eenosti \\(O(N)\\) \u0161to je dovoljno za tre\u0107i podzadatak.</p>"},{"location":"takprog/2016_2017/okr/04_baza/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za kompletno re\u0161enje, potrebno je smanjiti broj kandidata za promeljive \\(a\\) i \\(b\\) iz gornje jedna\u010dine. Glavna stvar je uo\u010diti da osim trivijalne nejednakosti \\(a \\leq N\\) (broj vrsta je \\(N\\)) va\u017ei i \\(aN \\leq M\\) jer \\(a\\) vrsta sa senzorima zna\u010di bar \\(aN\\) sigurnih polja (ovo smo mogli zaklju\u010diti i iz formule \\(b = \\frac{M - aN}{N - a}\\)). Mno\u017ee\u0107i nejednakosti \\(a \\leq N\\) i \\(a \\leq \\frac{M}{N}\\) dobijamo \\(a \\cdot a \\leq N \\cdot \\frac{M}{N}\\), odnosno \\(a \\leq \\sqrt{M}\\) i analogno \\(b \\leq \\sqrt{M}\\). Dakle, jedini kandidati za \\(a\\) su \\(1,2,\\ldots \\sqrt{M}\\) pa direktna provera daje re\u0161enje slo\u017eenosti \\(O(\\sqrt{M})\\) \u0161to nosi maksimalan broj poena. </p> <p>Ipak, re\u0161enje jo\u0161 uvek nije kompletno -- da li za sve prirodne brojeve \\(a\\) i \\(b\\) mo\u017eemo postaviti senzore tako da imamo ta\u010dno \\(a\\) vrsta i ta\u010dno \\(b\\) kolona sa bar po jednim senzorom? Odgovor je potvrdan - npr. ovo mo\u017eemo odraditi tako \u0161to postavimo senzore u svim sektorima \\((i,j)\\) za koje je \\(1 \\leq i \\leq a\\) i \\(1 \\leq j \\leq b\\) (gornja-leva podmatrica dimenzije \\(a \\times b\\)) ali je tada slo\u017eenosti algoritma moramo dodati i slo\u017eenost ispisa koja je \\(O(ab)\\) \u0161to mo\u017ee biti i \\(\\Theta(M)\\) a ovo je previ\u0161e sporo. Sre\u0107om, mogu\u0107e je postaviti svega \\(\\max\\{a, b\\} = O(\\sqrt{M})\\) senzora ukoliko ih (uz pretpostavku \\(a \\leq b\\)) postavljamo u sektore \\((1, 1)\\), \\((2, 2)\\), \\(\\ldots\\), \\((a, a)\\), \\((a, a + 1)\\), \\((a, a + 2)\\), \\(\\ldots\\), \\((a, b)\\), kao na slici. Ovaj raspored senzora kompletira re\u0161enje.</p> <p>Slika \\(1\\):  Raspored \\(\\max\\{a, b\\}\\) senzora za \\(N = 8\\), \\(a = 4\\) i \\(b = 6\\):</p> <p></p> 04_baza.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nlong long n, m;\n\nvoid solve()\n{\n\n    if (n == 1 &amp;&amp; m == 1)\n    {\n        printf(\"1\\n\");\n        printf(\"1 1\\n\");\n        return;\n    }\n    if (n == 1 &amp;&amp; m != 1)\n    {\n        printf(\"-1\\n\");\n        return;\n    }\n\n    long long upBound = (n &lt; m / n ? n : m / n);\n\n    for (long long a = 1LL; a &lt;= upBound; a++) // a = 1 hvata slucaj m = n^2\n    {\n        if (m - a * n &gt; 0 &amp;&amp; n - a &gt; 0 &amp;&amp; (m - a * n) % (n - a) == 0)\n        {\n            long long b = (m - a * n) / (n - a); // uvek vazi a &lt;= b\n\n            printf(\"%lld\\n\", b);\n            for (long long i = 1; i &lt;= a; i++)\n            {\n                printf(\"%lld %lld\\n\", i, i);\n            }\n            for (long long i = a + 1; i &lt;= b; i++)\n            {\n                printf(\"%lld %lld\\n\", a, i);\n            }\n            return;\n        }\n    }\n\n    printf(\"-1\\n\");\n    return;\n}\n\nint main()\n{\n    scanf(\"%lld%lld\", &amp;n, &amp;m);\n    solve();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/","title":"A2 - Kosmodrom","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 256MB <p>Nakon uspe\u0161ne ekspedicije, na Marsu je izgra\u0111en ,,Bibop'', prvi veliki kosmodrom u Sun\u010devom sistemu. Sa njega svakog dana pole\u0107e \\(N\\) raketa, i za svaku raketu se zna njeno planirano vreme poletanja \\(T_i\\) (mereno u marsovskim sekundama proteklim od pono\u0107i).</p> <p>Kada raketa treba da poleti, u nju se utovaruje teret koji treba da ponese. Po\u0161to radnici na kosmodromu dr\u017ee sve kutije sa teretom naslagane jednu na drugu, mogu da utovare samo teret iz kutije koja je na vrhu gomile. Sre\u0107om, veoma su brzi -- proces utovarivanja ne zahteva nimalo vremena. Ako se desi da kutija koju tra\u017ee nije na vrhu, lansiranje rakete mora da sa\u010deka dok se ne utovare sve kutije koje su iznad tra\u017eene.</p> <p>Da bi olak\u0161ali ovaj proces lansiranja, na kosmodromu postoji ure\u0111aj koji mo\u017ee da uzme proizvoljan broj kutija sa vrha gomile i prevrne ih (tako da budu pore\u0111ane suprotnim redosledom). Po\u0161to je ovaj proces spor i mo\u017ee o\u0161tetiti teret, ure\u0111aj se mo\u017ee iskoristiti samo jednom i to na po\u010detku dana (pre prvog poletanja).</p> <p>Radnici ,,Bibopa'' su gre\u0161kom pore\u0111ali kutije sa teretom po rednim brojevima raketa umesto po redu letenja (tako da je na vrhu kutija namenjena za raketu \\(1\\), ispod nje za raketu \\(2\\), i tako dalje). Pomozite im da odaberu broj kutija koje \u0107e okrenuti ovim ure\u0111ajem, tako da najdu\u017ee vreme koje neka od raketa provede \u010dekaju\u0107i na teret bude \u0161to manje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Nepoznato Slobodan Mitrovi\u0107"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se jedan prirodan broj \\(N\\) -- broj raketa koje pole\u0107u tokom dana. U drugom redu standardnog ulaza nalazi se \\(N\\) prirodnih brojeva, \\(T_1, T_2, \\dots, T_N\\), gde je \\(i\\)-ti broj vreme poletanja rakete sa rednim brojem \\(i\\).</p>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan prirodan broj, koji predstavlja minimalno \"najdu\u017ee vreme \u010dekanja\", koje se dosti\u017ee za optimalan izbor prevrnutih kutija.</p>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/okr/05_kosmodrom/#ulaz","title":"Ulaz","text":"<pre><code>5\n6 3 8 2 5\n</code></pre>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#izlaz","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/okr/05_kosmodrom/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n2 2 1\n</code></pre>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, prva raketa koja treba da poleti je raketa \\(4\\), dve sekunde posle pono\u0107i, ali ne mo\u017ee odmah da poleti jer njen teret nije na vrhu gomile. Slede\u0107a po redu je raketa \\(2\\) (tri sekunde posle pono\u0107i), koja tako\u0111e mora da \u010deka, a zatim raketa \\(5\\), koja isto \u010deka.</p> <p>Nakon \u0161to poleti raketa \\(1\\) (\u0161est sekundi posle pono\u0107i), koja ne mora da \u010deka na svoju kutiju, raketa \\(2\\) odmah mo\u017ee da poleti, jer je njen teret sada na vrhu. Ona je, dakle, \u010dekala \\(6-3=3\\) sekunde. Dve sekunde kasnije (osam sekundi posle pono\u0107i) raketa \\(3\\) pole\u0107e bez \u010dekanja, a odmah zatim i rakete \\(4\\) i \\(5\\), sa \u010dekanjima od \\(6\\) i \\(3\\) sekunde redom.</p> <p>Ako radnici okrenu gornje \u010detiri kutije, tako da je redosled vremena poletanja raketa (od vrha gomile do dna) \\(2,8,3,6,5\\), raketa koja pole\u0107e tri sekunde posle pono\u0107i \u0107e \u010dekati najdu\u017ee -- pet sekundi. Nijedan izbor ne daje \u010dekanja koja su sva kra\u0107a od pet sekundi, tako da je ovo optimalno re\u0161enje.</p> <p>U drugom primeru, ako se cela gomila prevrne, nijedna raketa ne mora da \u010deka -- po\u0161to utovarivanje tereta ne oduzima vreme, nijedna raketa koja pole\u0107e dve sekunde posle pono\u0107i ne mora da \u010deka.</p>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T_i \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 20 poena va\u017ei \\(1 \\leq N \\leq 100\\).</li> <li>U test primerima koji vrede 30 poena va\u017ei \\(1 \\leq N \\leq 2000\\).</li> <li>U test primerima koji vrede 50 poena va\u017ei \\(1 \\leq N \\leq 200000\\).</li> </ul>"},{"location":"takprog/2016_2017/okr/05_kosmodrom/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Da bismo odredili prona\u0161li optimalno re\u0161enje, isproba\u0107emo svih \\(N + 1\\) mogu\u0107ih izbora za broj prevrnutih kutija \\(K\\) (gde \\(0 \\leq K \\leq N\\)). Neophodno je da za svako \\(K\\) odredimo najve\u0107e \u010dekanje, i onda je ukupno re\u0161enje minimum tih vrednosti.</p> <p>Najve\u0107e \u010dekanje \u0107emo odrediti tako \u0161to za svaku raketu izra\u010dunamo koliko \u0107e \u010dekati i uzmemo maksimum tih vrednosti. Ovo mo\u017eemo da uradimo u \\(O(N^3)\\) -- nakon \u0161to \"okrenemo\" prvih \\(K\\) elemenata niza \\(T\\), za svaku kutiju znamo da \u0107e se \"osloboditi\" kada sve kutije iznad nje budu odnesene, tj. da \u0107e \\(i\\)-ta kutija biti na vrhu gomile u trenutku \\(max(T_j : j &lt; i)\\) i samim tim \u010dekati \\(min(0, T_i - max(T_j : j &lt; i))\\) (na kutiju ne mo\u017ee da se \u010deka negativno dugo). Ra\u010dunanje ovih maksimuma u linearnom vremenu (prola\u017eenjem kroz \\(T\\)) daje ukupno kvadratnu slo\u017eenost za odre\u0111ivanje \u010dekanja svih raketa (za fiksno \\(K\\)).</p> <p>Ako za ra\u010dunanje gore opisanih maksimuma iskoristimo ve\u0107 izra\u010dunatu vrednost za prethodni element niza (posmatramo maksimum prethodne vrednosti i trenutnog elementa \\(T_{i-1}\\)), mo\u017eemo odrediti sva \u010dekanja u jednom prolazu kroz niz, tako da je ukupna slo\u017eenost \\(O(N^2)\\) (\\(O(N)\\) za svako \\(K\\)).</p> <p>Za fiksno \\(K\\), kutije mo\u017eemo podeliti u dve grupe -- one koje su u prevrnutom delu gomile i kutije ispod prevrnutog dela. Ozna\u010dimo maksimalna \u010dekanja u ove dve grupe sa \\(U_K\\) i \\(D_K\\) redom.</p> <p>Za fiksno \\(K\\), najve\u0107e \u010dekanje u okrenutom delu gomile je uzrokovano ili jednom od kutija iz prvih \\(K-1\\) (u originalnom nizu) koja \u010deka na \\(K\\)-tu (sada gornju), ili \u010dekanjem jedne od prvih \\(K-1\\) na drugu iz istog skupa. Prva vredmost se mo\u017ee odrediti kao \\(min(0, T_K - max(T_i : i &lt; K))\\), a druga je jednaka \\(U_{K-1}\\), tako da se ceo niz \\(U\\) mo\u017ee izra\u010dunati u \\(O(N)\\) (opet, neophodno je da pamtimo maksimume svih prefiksa i ra\u010dunamo ih kao u prethodnom delu).</p> <p>Po\u0161to na kutije koje nisu okrenute ne uti\u010de raspored kutija iznad njih, za vremena \u010dekanja koja uti\u010du na \\(D_K\\) mo\u017eemo uzeti vremena za \\(K=0\\) (koja ra\u010dunamo u \\(O(N)\\) na ranije opisan na\u010din), gde je \\(D_K\\) maksimum sufiksa ovog niza. Kao i za \u010dekanja, ovo mo\u017eemo odrediti u jednom prolazu (unazad), na osnovu ve\u0107 izra\u010dunatog \\(D_{K+1}\\).</p> <p>Nakon \u0161to u linearnom vremenu izra\u010dunamo nizove \\(U\\) i \\(D\\), kona\u010dno re\u0161enje je najmanja vrednost \\(max(U_i, D_i)\\), tako da je ukupna slo\u017eenost algoritma \\(O(N)\\).</p> 05_kosmodrom.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nconst int N = 200005;\nint a[N], orig_wait[N];\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++)\n    scanf(\"%d\", &amp;a[i]);\n\n    int orig_max = 0;\n    for(int i = 0; i &lt; n; i++)\n    {\n    orig_max = max(a[i], orig_max);\n    orig_wait[i] = orig_max - a[i];\n    }\n\n    for(int i = n - 1; i &gt;= 0; i--)\n    orig_wait[i] = max(orig_wait[i], orig_wait[i + 1]);\n\n    int top_min = 1 &lt;&lt; 30, top_wait = 0;\n    int res = orig_wait[0];\n    for(int i = 0; i &lt; n; i++)\n    {\n    top_min = min(a[i], top_min);\n    top_wait = max(a[i] - top_min, top_wait);\n\n    res = min(res, max(top_wait, orig_wait[i + 1]));\n    }\n\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/okr/06_mingo/","title":"A3 - Mingo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Sada, kada je odradio takmi\u010denje, Miroslav je shvatio koliko je programiranje naporno, te je odlu\u010dio da pobegne na Mars. On je na internetu nai\u0161ao na nagradnu igru Mingo u kojoj je glavna nagrada put na Mars.</p> <p>Nagradna igra se sastoji u tome da svaki takmi\u010dar na listi\u0107u izabere ta\u010dno \\(K\\) razli\u010ditih prirodnih brojeva, gde je svaki broj iz skupa \\({1, 2, 3, ..., M}\\). Nakon toga se vr\u0161i \\(Q\\) izvla\u010denja, gde svako izvla\u010denje podrazumeva nasumi\u010dan odabir ta\u010dno \\(K\\) razli\u010ditih brojeva iz prethodno pomenutog skupa. Svaki listi\u0107 va\u017ei za svih \\(Q\\) izvla\u010denja, i takmi\u010dar koji ima listi\u0107 sa svim izvu\u010denim brojevima u bilo kom od \\(Q\\) izvla\u010denja dobija put na Mars.</p> <p>Kako bi pove\u0107ao svoje \u0161anse, Miroslav je popunio \\(N\\) listi\u0107a. Kako je sada te\u0161ko pratiti sve te listi\u0107e, on je zamolio vas da mu pomognete.</p> <p>On \u017eeli da za svako izvla\u010denje u svakom trenutku zna koliko listi\u0107a ima svaki do tada izvu\u010den broj, tj. za svako izvla\u010denje posebno, nakon izvu\u010denog \\(i\\)-tog broja on \u017eeli da zna koliko njegovih listi\u0107a sadr\u017ei svaki od izvu\u010denih \\(i\\) brojeva u tom izvla\u010denju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Demjan Grubi\u0107 Demjan Grubi\u0107 Nepoznato Du\u0161an Zdravkovi\u0107"},{"location":"takprog/2016_2017/okr/06_mingo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze brojevi \\(N, K\\) i \\(M\\), koji redom ozna\u010davaju broj listi\u0107a koje je Miroslav popunio, broj razlitih brojeva koje je potrebno obele\u017eiti na listi\u0107u i najve\u0107i broj koji je mogu\u0107e obele\u017eiti. Slede\u0107ih \\(N\\) redova opisije listi\u0107e koje je popunio Miroslav, gde se u \\(i\\)-tom redu nalazi \\(K\\) brojeva koji ozna\u010davaju izabrane brojeve na \\(i\\)-tom listi\u0107u. Nakon toga se nalazi jedan red sa brojem \\(Q\\) koji predstavlja broj izvla\u010denja. U narednih \\(Q\\) redova se nalazi opis svih izvla\u010denja. U \\(i\\)-tom redu se nalazi \\(K\\) brojeva koji predstavljaju brojeve u redosledu u kojem su bili izvla\u010deni.</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standarni izlaz je potrebno ispisati \\(Q\\) redova, gde \\(i\\)-ti red odgovara re\u0161enju za \\(i\\)-to izvla\u010denje, tj. \\(j\\)-ti broj u \\(i\\)-tom redu predstavlja broj listi\u0107a koji sadr\u017ee svaki od izvu\u010denih \\(j\\) brojeva u \\(i\\)-tom izvla\u010denju.</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/okr/06_mingo/#ulaz","title":"Ulaz","text":"<pre><code>3 3 15\n2 1 3\n1 10 4\n4 11 1\n2\n1 4 11 \n4 3 11\n</code></pre>"},{"location":"takprog/2016_2017/okr/06_mingo/#izlaz","title":"Izlaz","text":"<pre><code>3 2 1\n2 0 0\n</code></pre>"},{"location":"takprog/2016_2017/okr/06_mingo/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/okr/06_mingo/#ulaz_1","title":"Ulaz","text":"<pre><code>2 7 39\n7 6 5 4 3 2 1\n1 2 3 4 5 6 8\n2\n4 3 5 1 2 6 7\n6 5 4 3 2 8 39\n</code></pre>"},{"location":"takprog/2016_2017/okr/06_mingo/#izlaz_1","title":"Izlaz","text":"<pre><code>2 2 2 2 2 2 1\n2 2 2 2 2 1 0\n</code></pre>"},{"location":"takprog/2016_2017/okr/06_mingo/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru kod prvog izvla\u010denja re\u0161enje je \"3 2 1\" zato \u0161to broj 1 Miroslav ima na sva 3 listi\u0107a. Nakon drugog izvu\u010denog broja imamo kombinaciju \"1 4\" koja se pojavljuje na 2 listi\u0107a. Na kraju tre\u0107eg izvla\u010denja imamo kombinaciju brojeva \"1 4 11\" i jedini listi\u0107 koji ima sva 3 broja iz kombinacije jeste tre\u0107i listi\u0107 te je odgovor 1. U drugom izvla\u010denju prvog test primera, broj 4 sadr\u017ee listi\u0107i 2 i 3. Dok ne postoje listi\u0107i koji sadr\u017ee sve brojeve iz kombinacija \"4 3\" i \"4 3 13\".</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10000\\)</li> <li>\\(1 \\leq K \\leq 8\\)</li> <li>\\(K \\leq M \\leq 500\\)</li> <li>\\(1 \\leq Q \\leq 20000\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 15 poena va\u017ei \\(Q \\leq 10\\).</li> <li>U test primerima koji vrede 15 poena va\u017ei \\(K = 3, M &lt; 100\\).</li> <li>U test primerima koji vrede 30 poena va\u017ei \\(K \\leq 5, M &lt; 100\\).</li> <li>U test primerima koji vrede 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2016_2017/okr/06_mingo/#podzadatak-1","title":"Podzadatak \\(1\\)","text":"<p>Jasno da svaki listi\u0107 mo\u017eemo posmatrati kao \\(K\\)-to\u010dlani podskup skupa \\(\\{1, 2, 3, \u2026., M\\}\\), te tako imamo ukupno \\(N\\)  podskupova sa po \\(K\\) elemenata (\\(K\\)-to\u010dlanih). Ozna\u010dimo te podskupove sa \\(S_1, S_2, \u2026, S_N\\). Za svako pojedina\u010dno izvla\u010denje i svaki broj \\(j\\) izme\u0111u 1 i \\(K\\) potrebno je odrediti koliko ima skupova u nizu \\(S_1, S_2, \u2026, S_N\\) koji sadr\u017ee kao poskup skup sastavljen od prvih \\(j\\) brojeva izvu\u010denih u tom izvla\u010denju.</p> <p>Naivna varijanta se sastoji ba\u0161 od brojanja koliko ima listi\u0107a (tj. skupova) kojima je  skup sastavljen od prvih \\(j\\) izvu\u010denih brojeva podskup (tj. koliko ima skupova-listi\u0107a koji sadr\u017ee svih \\(j\\) prvih izvu\u010denih brojeva). Zavisno od implementacije, slo\u017eenost ovog re\u0161enja mo\u017ee biti \\(O(QNK)\\) ili \\(O(QNK^2)\\).</p> <p>Svaka od naprednijih varijanti podrazumeva preprocesiranje listi\u0107a tako da se za svako \\(j\\in \\{1, 2, ..., K\\}\\) formiraju svi podskupovi sa ta\u010dno \\(j\\) od \\(K\\) izvu\u010denih brojeva. Zatim se podskupovi iste kardinalnosti (sa istim brojem elemenata) sme\u0161taju u kolekciju koja \u0107e omogu\u0107iti efikasno odre\u0111ivanje koliko se puta neki podskup (sa istim brojem elemenata) pojavljuje u datoj kolekciji. Primetimo da je broj podskupova sa \\(j\\) elemenata skupa koji ima \\(K\\) elemenata jednak \\(\\binom{K}{j}\\). Tako \u0107e ukupan broj poskupova sa \\(j\\) elemenata skupova \\(S_1, S_2, \u2026, S_N\\) biti \\(N\\times\\binom{K}{j}\\). Ukupan broj svih podskupova (za sve vrednosti \\(j\\)) \u0107e biti \\(N\\times (2^K-1)\\).</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#podzadatak-2","title":"Podzadatak \\(2\\)","text":"<p>Elementi skupova (tj. izvu\u010deni brojevi) su brojevi manji od 100. Podskupovi koje izdvajamo imaju najvi\u0161e 3 elementa i elementi svakog podskupa se mogu sortirati, a zatim posmatrati kao cifre nekog broja u sistemu sa osnovom 100 (budu\u0107i da su elementi manji od 100). Tako \u0107e svaki podskup biti predstavljen kao najvi\u0161e trocifren broj u sistemu sa osnovom 100, odnosno svaki skup mo\u017ee biti predstavljen pomo\u0107u broja koji je manji od milion. Zahvaljuju\u0107i tome mogu se izbrojati pojavljivanja svakog podskupa i zapamititi u nizu du\u017eine 1000000 (tj. sa milion elemenata).</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#podzadatak-3","title":"Podzadatak \\(3\\)","text":"<p>U podzadatku tri se skupovi opet mogu predstaviti pomo\u0107u brojeva u sistemu sa osnovom 100 ali kako u podzadatku 3 broj \\(K\\) mo\u017ee imati vrednost 5, to \u0107e biti najvi\u0161e potocifreni brojevi i njihova vrednost je ograni\u010dena sa 10 milijardi. Ovaj put ne mo\u017eemo primeniti obi\u010dno brojanje, ve\u0107 formiramo nizove sa brojevima koji predstavljaju skupove. Nizove mo\u017eemo sortirati i na kraju jednim prolazom izbrojati broj pojavljivanja svake vrednosti (tj. svakog podskupa). Pri odgovaranju na upite podskup koji se sastoji od \\(j\\) prvih izvu\u010denih brojeva predstavimo kao broj (na isti na\u010din kao i podskupove oformljene od listi\u0107a) i binarnom pretragom pronalazimo u nizu brojeva koji predstavljaju podskupove listi\u0107a. </p>"},{"location":"takprog/2016_2017/okr/06_mingo/#podzadatak-4","title":"Podzadatak \\(4\\)","text":"<p>U podzadatku \u010detiri maksimalni broj izvu\u010denih brojeva, kao i maksimalna vrednost izvu\u010denih brojeva su takvi da se podskupovi sa vi\u0161e elemenata ne mogu reprezentovati pomo\u0107u celobrojnih tipova podr\u017eanih u jezicima koji se koriste za takmi\u010denje. Zbog toga je potrebno podskupove predstaviti na neki drugi na\u010din. Jedan od na\u010dina je struktura koja sadr\u017ei broj elemenata u podskupu i elemente podskupa sme\u0161tene u niz koji je sortiran. Nad tako reprezentovanim podskupovima mo\u017eemo definisati pore\u0111enje (uobi\u010dajeno leksikografsko pore\u0111enje). Koriste\u0107i to pore\u0111enje mo\u017eemo sorirati nizove koji sadr\u017ee sve podskupove sa istim brojem elemenata. Nakon toga brojanje koliko puta se neki podskup \\(P\\) pojavljuje u nizu obavljamo varijacijom binarne pretrage u kojoj prvo odre\u0111ujemo deo niza sa podskupovima u kome se prvi element poklapa sa prvim elementom podskupa \\(P\\), zatim u tako izdvojenom podnizu (odre\u0111en je po\u010detnim i krajnjim elementom podniza) deo u kome se drugi element poklapa sa drugim elementom podskupa \\(P\\), itd. Postupak prekidamo kada iscrpimo sve elemente podskupa \\(P\\), nakon \u010dega je broj podskupova jednak du\u017eini izdvojenog podniza, ili kada podniz u kome se elementi mogu poklapati sa podskupom \\(P\\) postane prazan (tada je odgovor nula).</p>"},{"location":"takprog/2016_2017/okr/06_mingo/#glavno-resenje","title":"glavno re\u0161enje","text":"<p>Poslednji podzadatak mo\u017ee biti re\u0161en i tako \u0161to se podskupovi sme\u0161taju u he\u0161 tabelu, pri \u010demu u toku dodavanja istovremeno brojimo koliko se puta pojavljuju podskupovi. Nakon toga odgovaranje na upite se svodi na pronala\u017eenje odgovaraju\u0107ih skupova u he\u0161 tabeli i izdvajanju informacije koliko puta se taj podskup nalazi u he\u0161 tabeli.</p> <p>Pokazalo se da maksimum poena mo\u017ee biti osvojen i tako \u0161to se svakim izvu\u010denim brojem u jednom konkretnom izvla\u010denju izdvoje samo listi\u0107i koji sadr\u017ee sve do tog trenutka izvu\u010dene brojeve. Broj izdvojenih listi\u0107a je odgovor za konkretno izvla\u010denje i konkretan broj izvu\u010denih brojeva. Kada se nakon toga obra\u0111uje slede\u0107i izvu\u010deni broj, analiziraju se samo listi\u0107i koji su izdvojeni i od njih izdvajaju samo oni koji sadr\u017ee izvu\u010deni broj. Uz pa\u017eljivu implementaciju dobija se re\u0161enje koje se izvr\u0161ava u predvi\u0111enom vremenu.</p> 06_mingo.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MaxN = 10000;\nconst int MaxK = 8;\nconst int MaxM = 500;\nconst int MaxKombZaIgracaZaILoptica = 70; // binom(MaxK, MaxK/2)\n\nint N; // broj ljudi\nint K; // broj kuglica koje se izvlace\nint M; // kuglice imaju brojeve {1, 2, 3, ..., M}\nint Q; // broj izvlacenja\n\nint kombIgraca[MaxN][MaxK];\n\nint trenutnoElemenata[MaxK+1];\nint sveMoguceKombinacije[MaxK+1][MaxN*MaxKombZaIgracaZaILoptica][MaxK];\nint komb[MaxK];\n\nint firstElement[2][MaxM+1];\nint lastElement[2][MaxM+1];\nint nextElement[2][MaxN*MaxKombZaIgracaZaILoptica];\n\nint sortiranRaspored[MaxK+1][MaxN*MaxKombZaIgracaZaILoptica];\n\n/*\nO(N*K*logK) ili O(N*K^2)\n*/\nvoid UlazIgraci()\n{\n    scanf(\"%d%d%d\", &amp;N, &amp;K, &amp;M);\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; K; ++j) {\n            scanf(\"%d\",&amp;kombIgraca[i][j]);\n        }\n\n        // nije bitno koji sort\n        // posto sortiramo K elemenata\n        sort(kombIgraca[i], kombIgraca[i]+K);\n    }\n}\n\n/*\nO(N*K*2^K)\n*/\nvoid UbaciUNizove()\n{\n    memset(trenutnoElemenata, 0, sizeof(trenutnoElemenata));\n\n    for (int i = 0; i &lt; N; ++i) {\n        int bitmaskEnd = (1 &lt;&lt; K);\n        for (int bitmask = 1; bitmask &lt; bitmaskEnd; ++bitmask) {\n            int cntBit = 0;\n            for (int bit = 0; bit &lt; K; ++bit) {\n                if ((bitmask &gt;&gt; bit) &amp; 1) {\n                    komb[cntBit++] = kombIgraca[i][bit];\n                }\n            }\n\n            for (int j = 0; j &lt; cntBit; ++j) {\n                sveMoguceKombinacije[cntBit][trenutnoElemenata[cntBit]][j] = komb[j];\n            }\n            trenutnoElemenata[cntBit]++;\n        }\n    }\n}\n\n/*\nO(SUM_{i=1..K} i*(binom(K, i)*N+M)) ~ O(K*N*2^K + K^2*M)\n*/\nvoid SortSveNizove()\n{\n    for (int brojLoptica = 1; brojLoptica &lt;= K; ++brojLoptica) {\n\n        int now = 0;\n        int prev = 1;\n\n        memset(firstElement, -1, sizeof(firstElement));\n        memset(lastElement, -1, sizeof(lastElement));\n        for (int i = 0; i &lt; trenutnoElemenata[brojLoptica]; ++i) {\n            if (lastElement[prev][1] == -1) {\n                firstElement[prev][1] = lastElement[prev][1] = i;\n            }\n            else {\n                nextElement[prev][ lastElement[prev][1] ] = i;\n                lastElement[prev][1] = i;\n            }\n\n            nextElement[prev][i] = -1;\n        }\n\n        for (int trenIdx = brojLoptica-1; trenIdx &gt;= 0; --trenIdx) {\n            for (int i = 1; i &lt;= M; ++i) {\n                for (int j = firstElement[prev][i]; j != -1; j = nextElement[prev][j]) {\n                    int idxNiza = j;\n                    int vrednost = sveMoguceKombinacije[brojLoptica][idxNiza][trenIdx];\n\n                    if (lastElement[now][vrednost] == -1) {\n                        firstElement[now][vrednost] = lastElement[now][vrednost] = idxNiza;\n                    }\n                    else {\n                        nextElement[now][ lastElement[now][vrednost] ] = idxNiza;\n                        lastElement[now][vrednost] = idxNiza;\n                    }\n\n                    nextElement[now][idxNiza] = -1;\n                }\n            }\n\n            memset(firstElement[prev], -1, sizeof(firstElement[prev]));\n            memset(lastElement[prev], -1, sizeof(lastElement[prev]));\n\n            now = 1 - now;\n            prev = 1 - prev;\n        }\n\n        int trenElement = 0;\n        for (int i = 1; i &lt;= M; ++i) {\n            for (int j = firstElement[prev][i]; j != -1; j = nextElement[prev][j]) {\n                int idxNiza = j;\n                sortiranRaspored[brojLoptica][trenElement++] = idxNiza;\n            }\n        }\n    }\n}\n\n/*\nO(log(binom(K, K/2) * N)) ~ O(N*logN)\n*/\nint BinarySearch(int vrednostTrazeneKuglice, int idxKuglice, int donjaGranica, int gornjaGranica, bool prvi, int brojKuglica)\n{\n    int left = donjaGranica;\n    int right = gornjaGranica;\n\n    while (right - left) {\n        int mid = (left + right) / 2;\n        int idxUNesortitanomNizu = sortiranRaspored[brojKuglica][mid];\n        int vrednostKugliceUNizu = sveMoguceKombinacije[brojKuglica][idxUNesortitanomNizu][idxKuglice];\n\n        if (prvi) {\n            if (vrednostKugliceUNizu &gt;= vrednostTrazeneKuglice) right = mid;\n            else                                                left = mid + 1;\n        }\n        else {\n            if (vrednostKugliceUNizu &gt; vrednostTrazeneKuglice) right = mid;\n            else                                               left = mid + 1;\n        }\n    }\n\n    // ako trazimo poslednji\n    // onda moramo smanjiti pokazivac za 1\n    if (donjaGranica != gornjaGranica) {\n        int idxUNesortitanomNizu = sortiranRaspored[brojKuglica][left];\n        int vrednostKugliceUNizu = sveMoguceKombinacije[brojKuglica][idxUNesortitanomNizu][idxKuglice];\n        if (!prvi &amp;&amp; (vrednostKugliceUNizu != vrednostTrazeneKuglice)) {\n            left--;\n        }\n    }\n\n    if (left == -1) return -1;\n\n    int idxUNesortitanomNizu = sortiranRaspored[brojKuglica][left];\n    int vrednostKugliceUNizu = sveMoguceKombinacije[brojKuglica][idxUNesortitanomNizu][idxKuglice];\n\n    if (vrednostTrazeneKuglice != vrednostKugliceUNizu) return -1;\n    return left;\n}\n\n/*\nO(K*log(binom(K, K/2) * N)) ~ O(K*K*logN) (gubi se dosta na uproscavanju verovatno)\n*/\nint BinarySearchNiz(int brojKuglica, int *trazenNiz)\n{\n    int donjaGranica = 0;\n    int gornjaGranica = trenutnoElemenata[brojKuglica] - 1;\n\n    for (int trenutnoPoredimKuglicu = 0; trenutnoPoredimKuglicu &lt; brojKuglica; ++trenutnoPoredimKuglicu) {\n        int trenutnaKuglicaKojaSeTrazi = trazenNiz[trenutnoPoredimKuglicu];\n\n        int tmp_donjaGranica  = BinarySearch(trenutnaKuglicaKojaSeTrazi, trenutnoPoredimKuglicu, donjaGranica, gornjaGranica, true, brojKuglica);\n        int tmp_gornjaGranica = BinarySearch(trenutnaKuglicaKojaSeTrazi, trenutnoPoredimKuglicu, donjaGranica, gornjaGranica, false, brojKuglica);\n\n        donjaGranica = tmp_donjaGranica;\n        gornjaGranica = tmp_gornjaGranica;\n\n        if (donjaGranica == -1) return 0;\n    }\n\n    return gornjaGranica - donjaGranica + 1;\n}\n\n/*\nO(Q*K*log(binom(K, K/2) * N)) ~ O(Q*K*K*logN)\n*/\nvoid UcitajIOdradiUpite()\n{\n    scanf(\"%d\", &amp;Q);\n    for (int q = 0; q &lt; Q; ++q) {\n        for (int i = 1; i &lt;= K; ++i) {\n            scanf(\"%d\", &amp;komb[i-1]);\n\n            // nije bitno kako cemo sortirati\n            sort(komb, komb+i);\n            int resenje = BinarySearchNiz(i, komb);\n\n            if (i &gt; 1) {\n                printf(\" \");\n            }\n            printf(\"%d\", resenje);\n        }\n        printf(\"\\n\");\n    }\n}\n\n/*\nO(SUM_{i=1..K] i*(binom(K, i)*N+M)) ~ O(K*N*2^K + K^2*M)\n+\nO(Q*K*log(binom(K, K/2) * N)) ~ O(Q*K*K*logN)\n````````````~~\nO(K*N*2^K + K^2*M + Q*K^2*logN)\n\nukoliko se koristi sort()\n~ O(K*N*2^K*(K*logN) + Q*K^2*logN)\n*/\nint main()\n{\n    UlazIgraci();\n    UbaciUNizove();\n    SortSveNizove();\n    UcitajIOdradiUpite();\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/","title":"1 - Klikeri","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 64MB <p>Malo je poznato da je za odr\u017eavanje drugog dana SIO potrebno aktivirati ma\u0161inu koju Komisija dr\u017ei u jednom podrumu, koja \u0107e zameniti zadatke za prvi dan sa zadacima za drugi. Ta ma\u0161ina ima prili\u010dno komplikovan sistem za aktivaciju, koji \u010dine traka du\u017eine \\(L\\) polja, od kojih na \\(N\\) postoje prekida\u010di.</p> <p>Na traci se nalazi \\(N\\) klikera (svi su na razli\u010ditim poljima), i za aktivaciju je neophodno da se u istom trenutku na svakom prekida\u010du nalazi po kliker. \u010clanovi Komisije ovo obi\u010dno posti\u017eu tako \u0161to odjednom gurnu sve klikere, tako da se kre\u0107u levo ili desno (razli\u010diti klikeri se mogu kretati u razli\u010ditim smerovima) konstantnom brzinom od jednog polja u sekundi. Klikeri se mogu sudarati sa krajevima trake ili me\u0111usobno, u kom slu\u010daju se odbijaju i nastavljaju istom brzinom u suprotnom smeru (pogledajte obja\u0161njenje primera za primer odbijanja).</p> <p>Po\u0161to \u010dlan Komisije koji je trebalo da aktivira ma\u0161inu nema vremena da smisli kako \u0107e to uraditi, jer gleda utakmicu izme\u0111u Man\u010dester Vilid\u017ea i Fejk Madrida, na vama je da odredite kako treba usmeriti klikere. Po\u0161to do drugog dana SIO nema previ\u0161e vremena, treba da prona\u0111ete re\u0161enje koje \u0107e aktivirati ma\u0161inu u \u0161to kra\u0107em vremenu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Dimitrije Erdeljan Ivan Sto\u0161i\u0107 <p>Mo\u017eemo zanemariti odbijanje klikera: ako se dva klikera odbiju, pozicija koja se dobija je identi\u010dna kao da su se mimoi\u0161li. Koriste\u0107i ovo, za fiksno T je lako odrediti dve mogu\u0107e pozicije u koje svaki kliker mo\u017ee sti\u0107i.</p> <p>Postoji 2N kandidata za re\u0161enje: za prvi kliker na N na\u010dina mo\u017eemo fiksirati prekida\u010d na kom \u0107e se na\u0107i. Do njega mo\u017ee sti\u0107i na dva na\u010dina \u2013 ili direktno ili odbijanjem od zida (dovoljno je odabrati zid za koji br\u017ee sti\u017ee do prekida\u010da, jer ako mo\u017ee da se re\u0161i za jedan zid, mo\u017ee i za drugi tako \u0161to obrnemo sve smerove). Ostaje samo da proverimo da li se mogu odabrati smerovi za fiksno T tako da svi klikeri zavr\u0161e na prekida\u010dima.</p> <p>Konstrui\u0161imo bipartitni graf u kom \u010dvorovi sa jedne strane predstavljaju klikere, a sa druge strane prekida\u010de. Grana od klikera do prekida\u010da postoji ukoliko taj kliker mo\u017ee da bude na tom prekida\u010du za T sekundi (dakle, svaki kliker ima najvi\u0161e dve izlazne grane). O\u010dito je da re\u0161enje postoji ukoliko mo\u017eemo upariti svaki kliker sa po jednim prekida\u010dem, odnosno ukoliko postoji perfect matching na ovom grafu, \u0161to mo\u017eemo proveriti u O(N) (jer postoji O(N) \u010dvorova i grana).</p> <p>Ovaj graf ima jednu specijalnu osobinu: stepen svakog \u010dvora je najvi\u0161e dva. Samim tim, sa\u010dinjen je od izolovanih \u010dvorova, puteva i ciklusa. Ako postoji izolovan \u010dvor, matching ne postoji. U suprotnom, potreban i dovoljan uslov je da su du\u017eine svih puteva parne (ciklusi sigurno imaju matching), tako da je dovoljno proveriti ovo umesto \u201credovnog\u201d matching algoritma.</p> 01_klikeri.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nconst int N = 30005;\nint marble[N], target[N];\nint n, len;\n\nint left[2 * N], right[2 * N]; // targets represented as N and above\n\nint abs(int x) { return x &lt; 0 ? -x : x; } \n\nint shift(int pos, int diff)\n{\n    pos += diff;\n    if(pos &lt;= 0) pos = 1 - pos;\n    if(pos &gt; len) pos = 2 * len - pos + 1;\n    return pos;\n}\n\nvoid make_jumps(int from[], int to[], int left[], int right[], int t)\n{   \n    int j = n - 1;\n    for(int i = 0; i &lt; n; i++)\n    {\n    int pos = shift(from[i], -t);\n    if(from[i] &lt;= t)\n        while(j &amp;&amp; to[j] &gt; pos) j--;\n    else\n    {\n        if((i &amp;&amp; from[i - 1] &lt;= t) || (i == 0)) j = 0;\n        while(j &lt; n - 1 &amp;&amp; to[j] &lt; pos) j++;\n    }\n\n    if(to[j] == pos) left[i] = j;\n    else left[i] = -1;\n    }\n\n    j = 0;\n    for(int i = 0; i &lt; n; i++)\n    {\n    int pos = shift(from[i], t);\n    if(from[i] &gt;= len - t + 1)\n    {\n        if((i &amp;&amp; from[i - 1] &lt; len - t + 1) || (i == 0)) j = n - 1;\n        while(j &amp;&amp; to[j] &gt; pos) j--;\n    }\n    else\n        while(j &lt; n - 1 &amp;&amp; to[j] &lt; pos) j++;\n\n    if(to[j] == pos) right[i] = j;\n    else right[i] = -1;\n    }\n}\n\nbool can_activate(int t)\n{\n    make_jumps(marble, target, left, right, t);\n    for(int i = 0; i &lt; n; i++)\n    {\n    if(left[i] != -1) left[i] += N;\n    if(right[i] != -1) right[i] += N;\n    }\n\n    make_jumps(target, marble, left + N, right + N, t);\n\n    for(int i = 0; i &lt; n; i++)\n    {\n        if(left[i] == -1 &amp;&amp; right[i] == -1)\n        return false; \n\n    else if((left[i] == -1) != (right[i] == -1))\n    {\n        int curr = (left[i] == -1) ? right[i] : left[i];\n        int prev = i;\n        int cnt = 2;\n\n        while(1)\n        {\n            if(left[curr] == -1 || right[curr] == -1)\n            break;\n\n        int tmp = curr;\n        curr = left[curr] + right[curr] - prev; // stupid hack\n        prev = tmp;\n\n        cnt++;\n        }\n\n        if(cnt % 2 != 0) return false;\n    }\n\n    // don't care about those with two matches: either in cycle\n    // (so OK) or on path (will check when starting from an end of\n    // the path)\n    }\n\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &amp;len, &amp;n);\n    for(int i = 0; i &lt; n; i++)\n    scanf(\"%d\", &amp;marble[i]);\n    for(int i = 0; i &lt; n; i++)\n    scanf(\"%d\", &amp;target[i]);\n\n    std::sort(marble, marble + n);\n    std::sort(target, target + n);\n\n    int res = 1 &lt;&lt; 30;\n    for(int i = 0; i &lt; n; i++)\n    {\n    // go directly\n    int t = abs(marble[0] - target[i]);\n    if(can_activate(t))\n        res = std::min(res, t);\n\n    // bounce off a wall\n    t = std::min(abs(marble[0] + target[i] - 1), abs(marble[0] - (2 * len - target[i] + 1)));\n    if(can_activate(t))\n        res = std::min(res, t);\n    }\n\n    if(res == (1 &lt;&lt; 30))\n    res = -1;\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja \\(L\\) i \\(N\\) -- broj polja na traci i broj klikera. U drugom redu nalazi se \\(N\\) brojeva \\(A_1, A_2, \\dots, A_n\\), koji predstavljaju trenutne pozicije svih klikera. U tre\u0107em i poslednjem redu se tako\u0111e nalazi \\(N\\) brojeva \\(B_1, B_2, \\dots, B_n\\), koji predstavljaju pozicije prekida\u010da.</p> <p>Pozicije su indeksirane od 1, tj. prvom polju trake odgovara \\(A_i = 1\\), a poslednjem \\(A_i = L\\).</p>"},{"location":"takprog/2016_2017/sio/01_klikeri/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan ceo broj \\(T\\) -- najmanje vreme (u sekundama) za koje je mogu\u0107e dovesti sve klikere na prekida\u010de. Ukoliko je to nemogu\u0107e, ispisati -1.</p>"},{"location":"takprog/2016_2017/sio/01_klikeri/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/01_klikeri/#ulaz","title":"Ulaz","text":"<pre><code>4 2\n2 4\n1 4\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/sio/01_klikeri/#ulaz_1","title":"Ulaz","text":"<pre><code>8 4\n1 3 6 7\n1 3 5 8\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2016_2017/sio/01_klikeri/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, ako se prvi kliker kre\u0107e levo, a druga desno, posle jedne sekunde \u0107e se prva pomeriti jedno polje levo, a druga udariti u kraj trake i vratiti se na svoju po\u010detnu poziciju (treba\u0107e joj pola sekunde da do\u0111e do zida i pola sekunde nazad, tako da joj pozicija ostaje ista).</p> <p>U drugom primeru, pravci u kojima je potrebno da se klikeri kre\u0107u da bi se doveli na prekida\u010de za dve sekunde su redom: desno, levo, desno i levo. Prve dve kuglice \u0107e se sudariti i vratiti na po\u010detne pozicije. Druge dve \u0107e se tako\u0111e me\u0111usobno odbiti.</p>"},{"location":"takprog/2016_2017/sio/01_klikeri/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, L\\)</li> <li>\\(1 \\leq A_i, B_i \\leq L\\)</li> <li>Sve pozicije \\(A_i\\) \u0107e biti me\u0111usobno razli\u010dite.</li> <li>Sve pozicije \\(B_i\\) \u0107e biti me\u0111usobno razli\u010dite.</li> </ul> <p>Postoji \\(5\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [15 poena]: \\(N, L \\leq 8\\).</li> <li>Podzadatak 2 [20 poena]: \\(N, L \\leq 100\\).</li> <li>Podzadatak 3 [20 poena]: \\(N, L \\leq 3000\\).</li> <li>Podzadatak 4 [25 poena]: \\(N \\leq 1000\\), \\(L \\leq 10^9\\).</li> <li>Podzadatak 5 [20 poena]: \\(N \\leq 3000\\), \\(L \\leq 10^9\\).</li> </ul>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/","title":"2 - Zadu\u017eenja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 64MB <p>\u010clanovi Komisije su vrlo zauzeti ljudi i uvek se pogodi da najvi\u0161e obaveza (koje nemaju veze sa SIO-om) imaju neposredno pred SIO. Na\u017ealost, neko mora i da smi\u0161lja zadatke i pravi test primere pa se uvek uo\u010di SIO-a organizuje popularna trka zadu\u017eenja. </p> <p>U komisiji ima \\(k\\) \u010dlanova i svi \u017eive u jednom gradu koji ima \\(n\\) raskrsnica numerisanih brojevima od \\(1\\) do \\(n\\) i \\(m\\) dvosmernih ulica koje povezuju neke od raskrsnica. Za svakog \u010dlana komisije je poznato na kojoj raskrsnici \u017eivi i za svaku ulicu je poznata njena du\u017eina u metrima. Svake godine se odabere kru\u017ena staza -- niz od nekoliko (bar 3) razli\u010ditih raskrsnica \\(x_1, x_2, \\ldots, x_l\\) pri \u010demu izme\u0111u svake dve uzastopne raskrnice na kru\u017enoj stazi postoji neka ulica (tj. postoje ulice izme\u0111u raskrsnica \\(x_1\\) i \\(x_2\\), \\(x_2\\) i \\(x_3\\), \\(\\ldots\\), \\(x_l\\) i \\(x_1\\)). Ulice kru\u017ene staze se pokrivaju posebnim materijalom pogodnim za tr\u010danje -- kada neko tr\u010di njima, on prelazi \\(1\\) metar za \\(a\\) sekundi dok na ostalim ulicama prelazi \\(1\\) metar za \\(b\\) sekundi (dakle, svi \u010dlanovi komisije tr\u010de istom brzinom). Svaki \u010dlan komisije mora tr\u010dati od svoje raskrsnice do neke raskrsnice na kru\u017enoj stazi (po izboru) a zatim optr\u010dati ta\u010dno jedan krug kru\u017ene staze. Ko prvi zavr\u0161i trku, ide svojim izmi\u0161ljenim obavezama a ostali moraju da prave test primere.</p> <p>Ispostavlja se da \u010dlanovi Komisije zbog svojih obaveza nisu imali vremena da treniraju pa im je mnogo bitnije da pobednik bude odlu\u010den \u0161to pre (jer tada ostali mogu prekinuti tu napornu aktivnost) nego da pobede u trci. Zato planiraju da urgiraju kod gradskih vlasti da se ove godine izabere takva kru\u017ena staza za koju va\u017ei da je vreme potrebno pobedniku da zavr\u0161i trku -- najmanje mogu\u0107e. Pomozite \u010dlanovima Komisije da odaberu takvu kru\u017enu stazu kako bi stigli da naprave test primere za ovaj zadatak.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Ivan Dejkovi\u0107 <p>Ozna\u010dimo optimalnu stazu (ciklus u grafu) sa C a njenu ukupnu du\u017einu sa w\u00a9. Jasno je da \u0107e tada tra\u017eeno vreme biti</p> <p>a * w\u00a9 + b * minimalno_rastojanje(neki \u010dlan komisije, ciklus C)</p> <p>pa ovaj izraz treba minimizovati po C. Izraz se mo\u017ee uprostiti ako za svaki \u010dvor unapred izra\u010dunamo A(u) - rastojanje od \u010dvora u do njemu najbli\u017eeg \u010dlana komisije pomno\u017eeno brojem b (nazovimo ovo \u201cte\u017eina \u010dvora\u201d). Za ovo nam je dovoljan Floyd-Warshall ili pu\u0161tanje Dijkstre iz svakog \u010dlana komisije (slo\u017eenost je O(n^3) ili O(kmlog(n))). Dakle, potrebno je prona\u0107i ciklus C za koji va\u017ei da je a*w\u00a9 + min{A(u) | u iz C} minimalno.</p> <p>Problem mo\u017eemo posmatrati i iz drugog ugla: za \u010dvor u, ozna\u010dimo sa MinCyc(u) du\u017einu najkra\u0107eg ciklusa kome je \u010dvor u \u010dvor minimalne te\u017eine (dakle, NE najkra\u0107i od SVIH ciklusa koji sadr\u017ee u). Tada je minimum po ciklusima C (a*w\u00a9 + min{A(u) | u iz C}) = min po \u010dvorovima u (MinCyc(u) + A(u)) pa je za svaki \u010dvor dovoljno izra\u010dunati vrednost MinCyc.</p> <p>Najtrivijalniji na\u010din je: za svaki \u010dvor u, izbaciti iz grafa sve \u010dvorove te\u017eine ne ve\u0107e od u (uklju\u010duju\u0107i i sam \u010dvor u), na\u0107i sva najkra\u0107a rastojanja d[x][y] izme\u0111u \u010dvorova novog grafa i staviti MinCyc(u) = minimum (w(u,x) + w(u,y) + d[x][y]) gde su x i y susedi \u010dvora u koji su ostali u novom grafu. Slo\u017eenost ovog pristupa je O(n^4) ili O(n^2 * m * log(n)).</p> <p>Ukoliko sortiramo \u010dvorove opadaju\u0107e po vrednosti A(u), tada va\u017ei MinCyc(u) = najkra\u0107i od SVIH ciklusa na skupu \u010dvorova {1, 2, \u2026, u} koji sadr\u017ei \u010dvor u. Sada mo\u017eemo vrednosti MinCyc ra\u010dunati modifikovanim Floyd-Warshall algoritmom: ovaj algoritam ima osobinu da neposredno pre k-tog koraka (spolja\u0161nja od 3 ugnje\u017edene for petlje) ima izra\u010dunate vrednosti d[u][v] - najkra\u0107e rastojanje od u do v preko prvih k-1 \u010dvorova. Prema tome, za trenutni \u010dvor k va\u017ei MinCyc(k) = minimum (w(k,u) + w(k,v) + d[u][v]) po svim susedima u,v \u010dvora k za koje je u &lt; k, v &lt; k i d[u][v] != INF. Ako ovaj minimum ra\u010dunamo na po\u010detku svake spolja\u0161nje for petlje, slo\u017eenost Floyd-Warshalla ostaje O(n^3) i imamo vrednosti svih MinCyc(u) \u0161to je dovoljno za re\u0161enje zadatka.</p> <p>Podzadaci uklju\u010duju slu\u010dajeve za \u010dije je re\u0161avanje dovoljan pristup slo\u017eenosti O(n^4) poput gore pomenutog, slu\u010dajeve gde je a = 0 (tada je re\u0161enje min A(u) me\u0111u svim \u010dvorovima u koji pripadaju bar jednom ciklusu) i slu\u010dajeve gde je b = 0 (klasi\u010dno tra\u017eenje najkra\u0107eg ciklusa u grafu). Zadatak se mo\u017ee uraditi i pu\u0161tanjem Dijkstre iz svih \u010dvorova sa komisijama (istovremeno) i fiksiranjem \u010dvora koji \u0107e biti \u201culaz\u201d u kru\u017enu stazu a zatim za njega ra\u010dunati najkra\u0107i ciklus koji ga sadr\u017ei i sastavljen je od \u010dvorova \u201cispod njega\u201d u Dijkstra-stablu (ovo je su\u0161tinski ista ideja kao i u gore pomenutom re\u0161enju jer je redosled obilaska Dijsktrom rastu\u0107i po vrednostima A).</p> 02_zaduzenja.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAX_N = 510;\nconst int MAX_M = MAX_N * MAX_N;\nconst long long INFTY = 1000000000000000000LL;\n\nint n, m, k, a, b;\nint home[MAX_N];\nint x[MAX_M], y[MAX_M], z[MAX_M];\n\n//----------------------------------------\nlong long d[MAX_N][MAX_N];\nlong long weight[MAX_N][MAX_N];\n\nstruct minDist\n{\n    int ind;\n    long long val;\n};\n\nbool cmp(const minDist&amp; a, const minDist&amp; b)\n{\n    return (a.val &gt; b.val);\n}\n\nminDist s[MAX_N];\nlong long val[MAX_N];\nint inv[MAX_N];\n\nlong long FindShortestTime(int n, int m, int k, int a, int b, int home[], int x[], int y[], int z[]) \n{\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            d[i][j] = INFTY;\n        }\n    }\n    for (int i = 1; i &lt;= n; i++) d[i][i] = 0LL;\n\n    for (int i = 1; i &lt;= m; i++)\n    {\n        d[x[i]][y[i]] = z[i];\n        d[y[i]][x[i]] = z[i];\n    }\n\n    for (int k = 1; k &lt;= n; k++)\n    {\n        for (int i = 1; i &lt;= n; i++)\n        {\n            for (int j = 1; j &lt;= n; j++)\n            {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        s[i].ind = i;\n        s[i].val = INFTY;\n        for (int j = 1; j &lt;= k; j++)\n        {\n            s[i].val = min(s[i].val, d[i][home[j]]);\n        }\n    }\n    sort(s + 1, s + n + 1, cmp);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        inv[s[i].ind] = i;\n        val[i] = s[i].val;\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            d[i][j] = INFTY;\n            weight[i][j] = -1;\n        }\n    }\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int u = inv[x[i]];\n        int v = inv[y[i]];\n        d[u][v] = z[i];\n        d[v][u] = z[i];\n        weight[u][v] = z[i];\n        weight[v][u] = z[i];\n    }\n\n    long long sol = INFTY;\n\n    for (int w = 1; w &lt;= n; w++)\n    {\n        for (int u = 1; u &lt; w - 1; u ++)\n        {\n            for (int v = u + 1; v &lt; w; v++)\n            {\n                if (weight[w][u] != -1 &amp;&amp; weight[w][v] != -1 &amp;&amp; d[u][v] != INFTY)\n                {\n                    sol = min(sol, val[w] * b + (weight[w][u] + weight[w][v] + d[u][v]) * a);\n                }\n            }\n        }\n\n        for (int u = 1; u &lt;= n; u++)\n        {\n            for (int v = 1; v &lt;= n; v++)\n            {\n                d[u][v] = min(d[u][v], d[u][w] + d[w][v]);\n            }\n        }\n    }\n\n    return sol;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;a, &amp;b);\n    for (int i = 1; i &lt;= k; i++)\n    {\n        scanf(\"%d\", &amp;home[i]);\n    }\n    for (int i = 1; i &lt;= m; i++)\n    {\n        scanf(\"%d%d%d\", &amp;x[i], &amp;y[i], &amp;z[i]);\n    }\n\n    printf(\"%lld\\n\", FindShortestTime(n, m, k, a, b, home, x, y, z));\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se pet prirodnih brojeva \\(n\\), \\(m\\), \\(k\\), \\(a\\) i \\(b\\) koji, redom, predstavljaju podatke iz teksta zadatka. U narednom redu nalazi se \\(k\\) prirodnih brojeva \\(r_i\\) -- redni brojevi raskrsnica na kojima \u017eive \u010dlanovi komisije. U narednih \\(m\\) redova nalaze se po tri broja \\(x_i\\), \\(y_i\\) i \\(z_i\\) koji ozna\u010davaju  da izme\u0111u raskrsnice broj \\(x_i\\) i raskrsnice broj \\(y_i\\) postoji ulica du\u017eine \\(z_i\\) metara.</p>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan ceo broj - najmanji vreme (u sekundama) potrebno da pobednik zavr\u0161i trku pri optimalnom izboru kru\u017ene staze. Uvek \u0107e postojati bar jedno re\u0161enje.</p>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/02_zaduzenja/#ulaz","title":"Ulaz","text":"<pre><code>8 12 3 1 2\n4 2 7\n1 5 1\n7 5 6\n2 7 1\n7 3 11\n8 1 7\n2 3 20\n4 6 2\n1 6 2\n2 4 10\n8 6 8\n7 8 15\n5 8 5\n</code></pre>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#izlaz","title":"Izlaz","text":"<pre><code>20\n</code></pre>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/sio/02_zaduzenja/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3 1 10 5\n2\n1 2 11\n2 3 12\n3 1 13\n</code></pre>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#izlaz_1","title":"Izlaz","text":"<pre><code>360\n</code></pre>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru imamo ukupno 8 raskrsnica i 3 \u010dlana Komisije koji \u017eive na raskrsnicama 4, 2 i 7. Optimalno je odabrati kru\u017enu stazu 5-8-6-1-5. Tada pri optimalnom tr\u010danju, \u010dlan Komisije koji \u017eivi na raskrsnici broj 4 tr\u010di do staze ulicom 4-6 du\u017eine 2 a zatim tr\u010di stazom (ulicama 6-8, 8-5, 5-1 i 1-6) dok ne obi\u0111e celu stazu, tj. dok se ne vrati na raskrsnicu 6. Ukupno mu je trebalo \\(2 \\cdot b + 8 \\cdot a + 5 \\cdot a + 1 \\cdot a + 2 \\cdot a\\) = 20 sekundi. \u010clanovi komisije sa raskrsnica 2 i 7 bi, redom, zavr\u0161ili trku posle 30 i 28 sekundi; dakle, za ovaj izbor kru\u017ene staze, \u010dlan sa raskrsnice 4 je pobednik i trka se prekida posle 20 sekundi. Ne postoji izbor kru\u017ene staze tako da pobednik bude odlu\u010den za manje od 20 sekundi.</p>"},{"location":"takprog/2016_2017/sio/02_zaduzenja/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(3 \\leq n \\leq 500\\)</li> <li>\\(n \\leq m \\leq n(n-1)/2\\)</li> <li>\\(1 \\leq k \\leq n\\)</li> <li>\\(0 \\leq a, b \\leq 10^6\\)</li> <li>\\(1 \\leq r_i \\leq n\\), \\(r_i \\neq r_j\\) za \\(i \\neq j\\)</li> <li>\\(1 \\leq x_i, y_i \\leq n\\), \\(x_i \\neq y_i\\), \\(1 \\leq z_i \\leq 10^9\\)</li> <li>Izme\u0111u svake dve raskrsnice postoji najvi\u0161e jedna ulica. </li> <li>Mogu\u0107e je do\u0107i od bilo koje raskrsnice do bilo koje druge raskrsnice koriste\u0107i date ulice.</li> </ul> <p>Postoji \\(6\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [8 poena]: \\(n \\leq 10\\).</li> <li>Podzadatak 2 [15 poena]: \\(n \\leq 80\\).</li> <li>Podzadatak 3 [18 poena]: \\(a = 0\\).</li> <li>Podzadatak 4 [20 poena]: \\(b = 0\\).</li> <li>Podzadatak 5 [16 poena]: \\(k = 1\\).</li> <li>Podzadatak 6 [23 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2016_2017/sio/03_tetke/","title":"3 - Tetke","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 192MB <p>U klju\u010dnom momentu, kada je trebalo da se pripreme zadaci za SIO, \\(N\\) \u010dlanova Komisije je shvatilo da moraju pod hitno da odnesu lek svojim tetkama. Poznato je da se ku\u0107a svake tetke nalazi na nekom od polja matrice \\(A \\times B\\), kao i da ne postoji polje na kome su dve ku\u0107e.</p> <p>Kako bi ubedili Potpredsednika Komisije da je njihovo odsustvo opravdano, svi \u010dlanovi su redom javno objavili na kom polju se nalazi ku\u0107a njihove tetke, kao i na kojoj je nadmorskoj visini. Potpredsednik nije od ju\u010de, i pa\u017eljivo bele\u017ei sve \u0161to \u010duje. Pored toga, iako ne zna nadmorske visine svih polja u matrici, on zna da je apsolutna razlika nadmorske visine svaka dva susedna polja u matrici ta\u010dno 1 (polja su susedna ako dele stranicu). Imaju\u0107i to u vidu, on nakon objave svakog \u010dlana proba da rekonstrui\u0161e celu matricu, tj. da dodeli svakom polju neku nadmorsku visinu, kako bi se uverio da su sve objave bile istinite (ova rekonstrukcija ne mora nu\u017eno biti jedinstvena).</p> <p>Ako nakon objave nekog \u010dlana, Potpredsenik po prvi put ne mo\u017ee da odredi visinu svakog polja tako da bude u skladu sa svim dosada\u0161njim objavama (tj. ne postoji matrica konzistentna sa svim dosada\u0161njim objavama), jasno je da je taj \u010dlan lupio glupost. Va\u0161 zadatak je da prona\u0111ete prvog \u010dlana Komisije koji je lupio glupost.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Jovanovi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 <p>Ozna\u010dimo sa dist(i,j) menhetn rastojanje izmedju i-tog i j-tog polja a sa h[i] visinu i-tog polja.</p> <p>Lema: Skup od n polja sa visinama u matrici je konzistentan (u smislu da postoji opisana matrica koja sadr\u017ei ova polja) ako i samo ako va\u017ee slede\u0107a dva uslova (1) Svi parni h[i]-ovi su na poljima \u010diji je zbir koordinata paran, a svi neparni h[i]-ovi na poljima \u010diji je zbir koordinata neparan ili obrnuto (2) Za svaka dva polja i i j vazi |h[i] - h[j]| &lt;= dist(i,j)</p> <p>Ovo su o\u010digledno potrebni uslovi, dok je za obrnut smer dovoljno pokazati da ako ovi uslovi va\u017ee, tada za bilo koje polje (x,y) postoji vrednost h koju mo\u017eemo upisati u njega tako da ova dva uslova va\u017ee i za novi skup polja sa ovim poljem (to bi zna\u010dilo da mozemo da popunimo celu matricu i da va\u017ee ova dva uslova, ali onda je ta matrica ok na osnovu primene tih uslova na susedna polja). Ideja dokaza je: u novo poolje (ozna\u010dimo ga sa n+1) mo\u017eemo upisati konzistentnu vrednost (u smislu (2)) akko je pesek svih segmenata (na realnoj pravoj) [h[i] - dist(i,n+1), h[i] + dist(i,n+1)] neparazn (tada upisujemo odgovaraju\u0107u vrednost iz preseka vode\u0107i ra\u010duna i o (1)) a ovo se pokazuje koriste\u0107i ve\u0107 pretpostavljene uslove za prvih n polja i nejednakost trougla.</p> <p>Uslov (1) se mo\u017ee trivijalno proveravati nezavisno od uslova (2) pa se koncentri\u0161emo isklju\u010divo na uslov (2). Nazovimo par polja (i, j) \u201clo\u0161\u201d ukoliko ne zadovoljava uslov (2) tj. ukoliko va\u017ei () |h[i] - h[j]| &gt; |x[i] - x[j]| + |y[i] - y[j]| Koriste\u0107i oznake Vpp(i) = L[i] + x[i] + y[i], Vpm(i) = h[i] + x[i] - y[i], Vmp(i) = h[i] - x[i] + y[i], Vmm(i) = h[i] - x[i] - y[i] mo\u017eemo se osloboditi apsolutnih vrednosti iz () razlikovanjem slu\u010dajeva. Ta\u010dnije, va\u017ei:</p> <p>Za polje i postoji polje j za koje je (i,j) lo\u0161 par ako i samo ako je ta\u010dno bar jedno od slede\u0107ih tvr\u0111enja</p> <p>j je \u201cgore-levo\u201d od i i va\u017ei Vmm(i) &gt; Vmm(j) j je \u201cgore-levo\u201d od i i va\u017ei Vpp(i) &lt; Vpp(j) \u2026 (ukupno 8 slu\u010daja koja zavise od polo\u017eaja gore/dole-levo/desno i odnosa h[i] i h[j]) Ovo mo\u017eemo re\u0161avati 2D segmentnim stablom - za svako novo polje postavljamo 8 upita \u201cvrati min/max iz date 2D oblasti\u201d i ubacujemo ga u strukturu posle upita. Me\u0111utim, ovde je problem memorijsko ograni\u010denje - \u010dak i implicitno (dinami\u010dko) stablo uz kompresiju koordinata zauzima n * log^2(n) memorije \u0161to je prakti\u010dno nemogu\u0107e uklopiti u zadata ograni\u010denja.</p> <p>Bolji pristup je kori\u0161\u0107enje binarne pretrage po re\u0161enju - tada problem postaje \u201cda li postoji lo\u0161 par me\u0111u prvih m polja\u201d i vi\u0161e nije bitno da vratimo najmanji indeks tj. da na prethodne upite odgovaramo redom. Koristimo \u201coffline\u201d pristup - sortiramo sva polja npr. po y-koordinati a zatim ih redom ubacujemo u obi\u010dno segmentno stablo (indeksirano po x-koordinatama) uz upite \u201cmin/max na segmentu\u201d (potrebno je 2 puta pro\u0107i kroz stablo, po jednom u svakom smeru). Vremenska slo\u017eenost ovog pristupa je O(n * log^2(n)) a memorijska je O(n) i nosi maksimalan broj poena.</p> <p>Podzadaci uklju\u010duju slu\u010dajeve kada prolazi re\u0161enje slo\u017eenosti O(n^2) (\u0161to je jedan od na\u010dina za \u201cproveru\u201d leme za vreme takmi\u010denja), 1D slu\u010daj (novo polje je dovoljno uporediti sa njegovim susedima), slu\u010dajeve u kojima su visine polja mali brojevi (na osnovu (*) za svako polje je dovoljno proveriti samo ona koja su na rastojanju ne ve\u0107em od MaxH a njih ima O(MaxH^2)) kao i slu\u010daj gde prolazi 2D segmentno.</p> 03_tetke.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 100005\n#define MAXH 100000005\n#define INF 2110000000\n#define mid (l+r)/2\nusing namespace std;\n\nstruct house\n{\n    int r, c;\n    int h;\n    int newc;\n    int idx;\n};\n\nint N, A, B;\nhouse a[MAXN];\n\n// indeks onog koji kvari parnost, N+1 ako su svi ok\nint ParityCheck() \n{\n    int val = (a[1].h + a[1].r + a[1].c) % 2;\n    for(int i = 1; i &lt;= N; i++)\n    {\n        if((a[i].h + a[i].r + a[i].c) % 2 != val)\n        {\n            return i;\n        }\n    }\n    return N+1;\n}\n\nbool ManhattanCheck(const house &amp;a, const house &amp;b) \n{\n    int dist = abs(a.r - b.r) + abs(a.c - b.c);\n    return dist &gt;= abs(a.h - b.h);\n}\n\n\nstruct VS\n{\n    int v1, v2, v3, v4;\n};\n// Node template\nstruct node\n{\n    bool NULLNODE;\n    VS minv;\n    VS maxv;\n    node(){ NULLNODE = false; }\n    node(bool nullNode) {NULLNODE = nullNode;}\n    void print()\n    {\n        cout&lt;&lt;\"MIN: [\"&lt;&lt;minv.v1&lt;&lt;\", \"&lt;&lt;minv.v2&lt;&lt;\", \"&lt;&lt;minv.v3&lt;&lt;\", \"&lt;&lt;minv.v4&lt;&lt;\"]\"&lt;&lt;endl;\n        cout&lt;&lt;\"MAX: [\"&lt;&lt;maxv.v1&lt;&lt;\", \"&lt;&lt;maxv.v2&lt;&lt;\", \"&lt;&lt;maxv.v3&lt;&lt;\", \"&lt;&lt;maxv.v4&lt;&lt;\"]\"&lt;&lt;endl;\n    }\n};\n\nstruct seg3\n{\n\n    // Merging function\n    node segMerge(node a, node b)\n    {\n        // RMinQ\n        if(a.NULLNODE) return b;\n        if(b.NULLNODE) return a;\n        node ret;\n        ret.minv.v1 = min(a.minv.v1, b.minv.v1);\n        ret.minv.v2 = min(a.minv.v2, b.minv.v2);\n        ret.minv.v3 = min(a.minv.v3, b.minv.v3);\n        ret.minv.v4 = min(a.minv.v4, b.minv.v4);\n        ret.maxv.v1 = max(a.maxv.v1, b.maxv.v1);\n        ret.maxv.v2 = max(a.maxv.v2, b.maxv.v2);\n        ret.maxv.v3 = max(a.maxv.v3, b.maxv.v3);\n        ret.maxv.v4 = max(a.maxv.v4, b.maxv.v4);\n        return ret;\n    }\n\n    // Original array, segment tree\n    node seg[MAXN*4];\n\n    // Build\n    void init(int idx, int l, int r)\n    {\n        if(l == r)\n        {\n            // Leaf node\n            seg[idx].minv.v1 = seg[idx].minv.v2 = \n            seg[idx].minv.v3 = seg[idx].minv.v4 = INF;\n            seg[idx].maxv.v1 = seg[idx].maxv.v2 = \n            seg[idx].maxv.v3 = seg[idx].maxv.v4 = -INF;\n            return;\n        }\n        init(2*idx, l, mid);\n        init(2*idx+1, mid+1, r);\n        seg[idx] = segMerge(seg[2*idx], seg[2*idx+1]);\n    }\n\n    // a[qi] = v\n    void update(int qi, node v, int idx, int l, int r)\n    {\n        if(l == r)\n        {\n            // Leaf node\n            seg[idx] = v;\n            return;\n        }\n        if(qi &lt;= mid) update(qi, v, 2*idx, l, mid);\n        else update(qi, v, 2*idx+1, mid+1, r);\n        seg[idx] = segMerge(seg[2*idx], seg[2*idx+1]);\n    }\n\n    // max &amp; min[lq..rq]?\n    node query(int lq, int rq, int idx, int l, int r)\n    {\n        if(lq &lt;= l &amp;&amp; rq &gt;= r)\n        {\n            // Canonic cover\n            return seg[idx];\n        }\n        node ret(true);\n        if(lq &lt;= mid) ret = segMerge(ret, query(lq, rq, 2*idx, l, mid));\n        if(rq &gt; mid) ret = segMerge(ret, query(lq, rq, 2*idx+1, mid+1, r));\n        return ret;\n    }\n};\n\nconst bool operator&lt;(const house&amp; a, const house&amp; b) \n{\n    if(a.r == b.r)\n    {\n        return a.c &lt; b.c;\n    }\n    return a.r &lt; b.r;\n}\n\nbool cmpc(house a, house b)\n{\n    if(a.c == b.c)\n    {\n        return a.r &lt; b.r;\n    }\n    return a.c &lt; b.c;\n}\n\nseg3 seg;\n\nint scaling_cols = 0;\n\nbool IsValid(int k)\n{\n    // take first k\n    vector&lt;house&gt; houses(a+1, a+k+1);\n    sort(houses.begin(), houses.end());\n    seg.init(1, 1, scaling_cols);\n    for(house&amp; H : houses) \n    {\n        // build me\n        node me;\n        me.minv.v1 = H.h - H.r - H.c;\n        me.minv.v2 = H.h - H.r + H.c;\n        me.minv.v3 = H.h + H.r - H.c;\n        me.minv.v4 = H.h + H.r + H.c;\n        me.maxv = me.minv;\n        // do queries\n        node lres = seg.query(1, H.newc, 1, 1, scaling_cols);\n        node rres = seg.query(H.newc, scaling_cols, 1, 1, scaling_cols);\n        // query, use minv for me always\n        // DIRECT LEFT V1\n        // DIRECT RIGHT V2\n        if(me.minv.v1 &gt; lres.minv.v1 || me.minv.v2 &gt; rres.minv.v2)\n        {\n            return false;\n        }\n        // INDIRECT LEFT V3\n        // INDIRECT RIGHT V4\n        if(lres.maxv.v4 &gt; me.minv.v4 || rres.maxv.v3 &gt; me.minv.v3)\n        {\n            return false;\n        }\n        // update\n        seg.update(H.newc, me, 1, 1, scaling_cols);\n    }\n    return true;\n}\n\nbool cmpidx(house a, house b)\n{\n    return a.idx &lt; b.idx;\n}\n\nint main() \n{\n    scanf(\"%d %d %d\", &amp;N, &amp;A, &amp;B);\n    for(int i = 1; i &lt;= N; i++)\n    {\n        scanf(\"%d %d %d\", &amp;a[i].r, &amp;a[i].c, &amp;a[i].h);\n        a[i].idx = i;\n    }\n    sort(a+1, a+N+1, cmpc);\n    a[1].newc = 1;\n    for(int i = 2; i &lt;= N; i++)\n    {\n        if(a[i].c == a[i-1].c)\n        {\n            a[i].newc = a[i-1].newc;\n        } else {\n            a[i].newc = a[i-1].newc + 1; \n        }\n    }\n    scaling_cols = a[N].newc;\n    sort(a+1, a+N+1, cmpidx);\n\n    // Scale\n    // Dp\n    int pidx = ParityCheck();\n    int midx = N+1;\n    int hi = N, lo = 2, pivot;\n    while(hi &gt; lo)\n    {\n        pivot = (hi + lo) / 2;\n        bool valid = IsValid(pivot);\n        if(valid)\n        {\n            lo = pivot + 1;\n        }\n        else\n        {\n            hi = pivot;\n        }\n    }\n    if(!IsValid(hi))\n    {\n        midx = hi;\n    }\n    int sol = min(pidx, midx);\n    if(sol == N+1)\n    {\n        printf(\"bravo komisijo\\n\");\n    }\n    else\n    {\n        printf(\"%d\\n\", sol);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se tri prirodna broja \\(N\\), \\(A\\) i \\(B\\) -- broj \u010dlanova komisije tj. broj ku\u0107a, broj redova matrice i broj kolona matrice. U svakom od narednih \\(N\\) redova nalaze se tri prirodna broja \\(R_i\\), \\(C_i\\) i \\(H_i\\) koji ozna\u010davaju red, kolonu i nadmorsku visinu ku\u0107e u kojoj \u017eivi tetka \\(i\\)-tog \u010dlana Komisije.</p>"},{"location":"takprog/2016_2017/sio/03_tetke/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan prirodan broj koji predstavlja indeks \u010dlana Komisije koji je lupio glupost (\u010dlanovi su indeksirani po\u010dev\u0161i od broja \\(1\\)). Ukoliko takav \u010dlan ne postoji, ispisati \"bravo komisijo\" (bez navodnika).</p>"},{"location":"takprog/2016_2017/sio/03_tetke/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/03_tetke/#ulaz","title":"Ulaz","text":"<pre><code>4 3 5\n1 2 1\n2 1 3\n2 5 21\n2 2 8\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/sio/03_tetke/#ulaz_1","title":"Ulaz","text":"<pre><code>5 6 5\n1 1 5\n4 2 3\n4 5 6\n5 2 2\n1 3 5\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#izlaz_1","title":"Izlaz","text":"<pre><code>bravo komisijo\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, nakon prve dve objave mogu\u0107e je odrediti visinu za svako polje tako da se ispo\u0161tuju uslovi, npr:</p> <pre><code>2 1 2 3 4\n3 2 3 4 3\n4 3 4 5 4\n</code></pre> <p>Nakon tre\u0107e objave, ne postoji na\u010din da se to uradi, pa je tre\u0107i \u010dlan Komisije lupio glupost.</p> <p>U drugom primeru, postoji raspored visina koji se uklapa sa svih pet objava, npr:</p> <pre><code>5 4 5 6 7 8\n4 5 6 7 6 7\n3 4 5 6 5 6\n4 3 4 5 6 5\n3 2 3 4 5 4\n</code></pre>"},{"location":"takprog/2016_2017/sio/03_tetke/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq A, B \\leq 10^9\\)</li> <li>\\(1 \\leq N \\leq 10^5\\)</li> <li>Za svako \\(H_i\\) va\u017ei \\(1 \\leq H_i \\leq 10^8\\)</li> </ul> <p>Postoji \\(5\\) podzadataka, u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [11 poena]: \\(B = 1\\).</li> <li>Podzadatak 2 [11 poena]: \\(N \\leq 1000\\).</li> <li>Podzadatak 3 [16 poena]: Za svako \\(H_i\\) va\u017ei \\(1 \\leq H_i \\leq 10\\).</li> <li>Podzadatak 4 [28 poena]: \\(A, B \\leq 800\\).</li> <li>Podzadatak 5 [34 poena]: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2016_2017/sio/04_neonke/","title":"4 - Neonke","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje - - <p>Kao \u0161to ste ve\u0107 videli, za uspe\u0161no odr\u017eavanje drugog dana SIO bilo je potrebno oti\u0107i u Komisijski tajni podrum i precizno aktivirati ma\u0161inu koja \u0107e zameniti zadatke izme\u0111u dva dana. Po\u0161to ste prethodnog dana uspe\u0161no odredili na\u010din na koji je ovo potrebno uraditi, \u010dlanovi Komisije su uspeli da aktiviraju ma\u0161inu, i drugi dan SIO mo\u017ee biti odr\u017ean.</p> <p>Me\u0111utim, ova aktivacija ma\u0161ine nije bila bez posledica. Naime, Komisijski podrum je izuzetno lo\u0161e osvetljen, tako da je navigacija bila jako te\u0161ka, i odre\u0111eni \u010dlanovi Komisije su bili povre\u0111eni. Kako se uskoro o\u010dekuje poseta IZS (Inspekcije za odr\u017eavanje Zdravlja i Sigurnosti\u2122), Komisija je odlu\u010dila da prikladno osvetli podrum neonskim sijalicama (\"neonkama\"). </p> <p>Podrum je predstavljen kao matrica od \\(N \\times M\\) polja. Neonka postavljena na poziciji \\((x_n, y_n)\\) je u mogu\u0107nosti da osvetli polja \\((x, y)\\) za koja va\u017ei \\(x_n - R \\leq x \\leq x_n + R\\) i \\(y_n - R \\leq y \\leq y_n + R\\), gde je \\(R\\) ja\u010dina svetlosti neonke. Za ovo polje tako\u0111e mora va\u017eiti da unutar pravougaonika odre\u0111enog koordinatama \\((x, y)\\) i \\((x_n, y_n)\\) nema ni jednog zida! </p> <p>Na primer, ako je \\(R = 3\\), polja ozna\u010dena sa <code>'S'</code> bi bila osvetljena neonkom postavljenom na poziciju ozna\u010denu sa <code>'N'</code>:</p> <pre><code>.#...SSS........\n.#...SSS#.......\n.####SSS#.......\n....#SSNSSS.....\n....#SSSSSS.....\n....#SSS#.......\n....#SSS#.......\n</code></pre> <p>Zbog umanjenja brojnosti Komisije, anga\u017eovana je pomo\u0107 malog Perice, koji je bio odsutan jure\u0107i nau\u010dne konferencije tokom celog ovogodi\u0161njeg ciklusa takmi\u010denja. Kako Perica nema vremena da se anga\u017euje, \u010dak ni kada je to najpotrebnije, odlu\u010dio je da naplati postavljanje svake neonke sa \\(C\\) dinara, i ru\u010dno paljenje svake neonke sa \\(P\\) dinara. Na sre\u0107u, nije neophodno ru\u010dno upaliti svaku neonku -- ukoliko svetlost od jedne neonke zahvati drugu, ona se onda sama pali. Mo\u017eete smatrati da \u0107e Perica paliti neonke tako da je broj ru\u010dnih paljenja minimalan.</p> <p>Na vama je da odredite na koje pozicije u podrumu treba postaviti neonke, tako da se osvetli \u0161to vi\u0161e njegovih polja. Komisija je odvojila ograni\u010den bud\u017eet za malog Pericu -- ovaj bud\u017eet ne sme da se prema\u0161i!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Marko Savi\u0107 <p>Prvi zadatak sa drugog dana Srpske Informati\u010dke Olimpijade predstavlja challenge tip problema, tj. problema u kome najoptimalnije re\u0161enje nije neophodno poznato. Stoga, cilj je bio maksimizovati pogodnost re\u0161enja, sa parcijalnim nagra\u0111ivanjem za re\u0161enja koja su izme\u0111u odre\u0111enih grani\u010dnih vrednosti. Zadatak je uklju\u010divao pravilno raspore\u0111ivanje resursa, tako da se maksimizira prekrivanje prostorije neonskim sijalicama. Odre\u0111ene u\u0161tede su bile mogu\u0107e ukoliko se sijalice \u201cnadovezuju\u201d jedne na drugu (tj. ukoliko jedna sijalica upada u svetlost druge), \u0161to mo\u017ee zna\u010dajno umanjiti ukupnu cenu, ali i broj pokrivenih polja. Dodatne probleme izaziva relativno neoptimalan efekat blizine zidovima.</p> <p>Generalno najbolji na\u010din da se \u201cnapadne\u201d ovakav problem i njemu sli\u010dni je da se napravi neka \u201cosnovna\u201d strategija za postavljanje neonki, sa svom neophodnom infrastrukturom (pomo\u0107nim metodama itd.), pa da se nakon toga isprobavaju razne varijacije osnovnog algoritma, koje vi\u0161e uzimaju u obzir razli\u010dite aspekte problema\u2014uzimaju\u0107i za svaki test primer onaj algoritam koji daje najbolje rezultate.</p> <p>Verovatno najva\u017eniji deo izgradnje re\u0161enja je metoda koja odre\u0111uje efekte postavljanja nove neonke na neko polje (na potencijalno ve\u0107 parcijalno osvetljenom podrumu). Ovo je izuzetno korisno iako je takmi\u010darima bio dat na kori\u0161\u0107enje detaljan vizualizator, i predstavlja glavni algoritamski izazov ovog zadatka, jer \u010dini inkrementalno pravljenje re\u0161enja izuzetno prakti\u010dnim. Ova metoda zahteva prera\u010dunavanje broja osvojenih polja, kao i spajanje nove neonke sa nekim drugim povezanim komponentama neonki, ukoliko je ovo primenljivo. Po\u0161to su ja\u010dine neonki u test primerima bile relativno male, bilo je prikladno direktno ispitati sva polja u kvadratu oko potencijalne nove neonke. Za jednostavno odr\u017eavanje povezanih komponenti mogu\u0107e je bilo koristiti bilo koju strukturu za odr\u017eavanje disjunktnih skupova.</p> <p>Nakon \u0161to je ova metoda u mestu, mogu\u0107e je bilo definisati neke osnovne strategije (Komisijske konstante za ocenjivanje su odre\u0111ivane na osnovu najboljeg i najgoreg u\u010dinka ovih strategija na test primerima):</p> <p>Gramzivo (greedy) re\u0161enje fokusirano na pokrivenost: u svakom koraku, odabrati polje koje pokriva najvi\u0161e nepokrivenih polja. Ovo re\u0161enje je izuzetno neefikasno ukoliko je konstanta P velika, jer \u0107e rezultovati velikim brojem komponenti koje moraju da se odvojeno pale! 1-\u201czmija\u201d re\u0161enje, gde se prvo polje bira gramzivo, a sva naredna polja odre\u0111uju tako da sve neonke konstantno ostaju u jednoj komponenti. Ovo re\u0161enje je jako efektivno ako je cena dodavanja nove neonke zna\u010dajno manja od cene paljenja jedne neonke, i ukoliko je mogu\u0107e identifikovati povezanu komponentu u test primeru koja sadr\u017ei ve\u0107inu slobodnih polja. nepovezano k-\u201czmija\u201d re\u0161enje, koje predstavlja korekciju prethodnog algoritma za vi\u0161estruke odvojene povezane komponente slobodnih polja\u2014krenuti ne od jednog nego od k gramzivo odabranih polja u odvojenim povezanim komponentama, i onda se od njih \u0161iriti tako da broj komponenti ne raste. nasumi\u010dno k-\u201czmija\u201d re\u0161enje, gotovo identi\u010dno kao prethodno, s tim da se po\u010detna polja ne biraju tako da budu u odvojenim komponentama, nego potpuno nasumi\u010dno. Ovo mo\u017ee biti vrlo efektivno ako ima dosta prostora u podrumu, uz naznaku da \u0107e potencijalno u nekom momentu neke komponente da se spoje. Nakon pravljenja osnovnog re\u0161enja, mogu\u0107e je dodatno ga pobolj\u0161ati stohasti\u010dnom hill-climber strategijom (ova strategija nije bila kori\u0161\u0107enja pri ra\u010dunanju gornjih granica), gde se pozicije neonki nasumi\u010dno pomeraju za neku malu vrednost, ili se neonke potpuno izbacuju i postavljaju ponovo na neko drugo mesto. Tokom ove procedure, sve vreme pamtimo do sada najbolje dobijeno re\u0161enje.</p> <p>Test primeri (\u010dije matrice su povu\u010dene sa finala Google-ovog Hash Code 2017 takmi\u010denja, koje je i slu\u017eilo kao glavna inspiracija za ovaj problem) su bili direktno dostupni takmi\u010darima, tako da o njima ne moramo dodatno raspravljati. Prvi test primer je dizajniran da bude jednostavno maksimalno re\u0161iv (dokle god je kori\u0161\u0107enja k-\u201czmijska\u201d strategija ili neka njena varijanta), dok su parametri ostalih test primera birani da pokriju \u0161irok spektar scenarija, poput:</p> <p>Veliki prostor, izuzetno mali polupre\u010dnik, jeftino pravljenje novih komponenti; Veliki prostor, izuzetno veliki polupre\u010dnik; Sku\u010deni prostor (sa mnogo odvojenih sitnih komponenti). Zadovoljstvo nam je da vidimo da je zna\u010dajan broj takmi\u010dara poku\u0161ao da se oproba u re\u0161avanju bar jednog test primera. Posebne \u010destitke Du\u0161anu \u017divanovi\u0107u za osvojenih 98 poena na ovom zadatku! U prilogu mo\u017eete videti vizuelizaciju njegovih poslatih re\u0161enja za sva \u010detiri test primera. Nadam se da vam se zadatak svideo! </p> 04_neonke.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nlong long numComponents;\n\nstruct Node\n{\n    int parent;\n    int rank;\n};\nNode DSU[10000001];\n\ninline void MakeSet(int x)\n{\n    DSU[x].parent = x;\n    DSU[x].rank = 0;\n    numComponents++;\n}\n\ninline int Find(int x)\n{\n    if (DSU[x].parent == x) return x;\n    DSU[x].parent = Find(DSU[x].parent);\n    return DSU[x].parent;\n}\n\ninline void Union(int x, int y)\n{\n    int xRoot = Find(x);\n    int yRoot = Find(y);\n    if (xRoot == yRoot) return;\n    numComponents--;\n    if (DSU[xRoot].rank &lt; DSU[yRoot].rank)\n    {\n        DSU[xRoot].parent = yRoot;\n    }\n    else if (DSU[xRoot].rank &gt; DSU[yRoot].rank)\n    {\n        DSU[yRoot].parent = xRoot;\n    }\n    else\n    {\n        DSU[yRoot].parent = xRoot;\n        DSU[xRoot].rank++;\n    }\n}\n\nint n, m, r;\nint c, p, b;\n\nvector&lt;string&gt; board;\nbool mark[1001][1001];\nint poz[1001][1001];\n\nint placetest(int x, int y, int nid, bool doit)\n{\n    if (doit) MakeSet(nid);\n\n    int total = 0;\n\n    int ly = -1;\n    int ry = m;\n\n    for (int dx=0;dx&gt;=-r;dx--)\n    {\n        int xt = x + dx;\n        if (xt &lt; 0) break;\n        if (board[xt][y] != '.') break;\n\n        // top-left\n        for (int dy=0;dy&gt;=-r;dy--)\n        {\n            int yt = y + dy;\n            if (yt &lt;= ly) break;\n            if (board[xt][yt] != '.')\n            {\n                ly = max(ly, yt);\n                break; // no need to go on\n            }\n\n            // If field is unoccupied, occupy it\n            if (!mark[xt][yt])\n            {\n                if (doit) mark[xt][yt] = true;\n                total++;\n            }\n            // If there is someone else here, union it\n            if (doit &amp;&amp; poz[xt][yt])\n            {\n                Union(nid, poz[xt][yt]);\n            }\n        }\n\n        // top-right\n        for (int dy=0;dy&lt;=r;dy++)\n        {\n            int yt = y + dy;\n            if (yt &gt;= ry) break;\n            if (board[xt][yt] != '.')\n            {\n                ry = min(ry, yt);\n                break;\n            }\n\n            // If field is unoccupied, occupy it\n            if (!mark[xt][yt])\n            {\n                if (doit) mark[xt][yt] = true;\n                total++;\n            }\n            // If there is someone else here, union it\n            if (doit &amp;&amp; poz[xt][yt])\n            {\n                Union(nid, poz[xt][yt]);\n            }\n        }\n    }\n\n    ly = -1;\n    ry = m;\n\n    // now expand down\n    for (int dx=0;dx&lt;=r;dx++)\n    {\n        int xt = x + dx;\n        if (xt &gt; n - 1) break;\n        if (board[xt][y] != '.') break;\n\n        // bottom-left\n        for (int dy=0;dy&gt;=-r;dy--)\n        {\n            int yt = y + dy;\n            if (yt &lt;= ly) break;\n            if (board[xt][yt] != '.')\n            {\n                ly = max(ly, yt);\n                break; // no need to go on\n            }\n\n            // If field is unoccupied, occupy it\n            if (!mark[xt][yt])\n            {\n                if (doit) mark[xt][yt] = true;\n                total++;\n            }\n            // If there is someone else here, union it\n            if (doit &amp;&amp; poz[xt][yt])\n            {\n                Union(nid, poz[xt][yt]);\n            }\n        }\n\n        // top-right\n        for (int dy=0;dy&lt;=r;dy++)\n        {\n            int yt = y + dy;\n            if (yt &gt;= ry) break;\n            if (board[xt][yt] != '.')\n            {\n                ry = min(ry, yt);\n                break;\n            }\n\n            // If field is unoccupied, occupy it\n            if (!mark[xt][yt])\n            {\n                if (doit) mark[xt][yt] = true;\n                total++;\n            }\n            // If there is someone else here, union it\n            if (doit &amp;&amp; poz[xt][yt])\n            {\n                Union(nid, poz[xt][yt]);\n            }\n        }\n    }\n\n    return total;\n}\n\nint cntflds()\n{\n    int ret = 0;\n    for (int i=0;i&lt;n;i++)\n    {\n        for (int j=0;j&lt;m;j++)\n        {\n            if (mark[i][j]) ret++;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;\n    cin &gt;&gt; c &gt;&gt; p &gt;&gt; b;\n\n    board.resize(n);\n    for (int i=0;i&lt;n;i++) cin &gt;&gt; board[i];\n\n    int numRs = 0;\n\n    // Overly conservative because why not\n    while ((numRs + 1) * c + (numComponents + 1) * p &lt;= b)\n    {\n        int best = -1;\n        int bx = -1, by = -1;\n        for (int i=0;i&lt;n;i++)\n        {\n            for (int j=0;j&lt;m;j++)\n            {\n                if (!poz[i][j] &amp;&amp; board[i][j] == '.' &amp;&amp; ((1 +numRs) % 3 != 0 || mark[i][j]))\n                {\n                    int cur = placetest(i, j, numRs + 1, false);\n                    if (cur &gt; best)\n                    {\n                        best = cur;\n                        bx = i, by = j;\n                    }\n                }\n            }\n        }\n\n        // No need to update stuff if done\n        if (best == 0) break;\n\n        placetest(bx, by, ++numRs, true);\n        poz[bx][by] = numRs;\n        cout &lt;&lt; bx + 1 &lt;&lt; \" \" &lt;&lt; by + 1 &lt;&lt; endl;\n        cerr &lt;&lt; \"Fields covered: \" &lt;&lt; cntflds() &lt;&lt; endl;\n    }\n\n    cerr &lt;&lt; \"Fields covered: \" &lt;&lt; cntflds() &lt;&lt; endl;\n    cerr &lt;&lt; \"Cost spent: \" &lt;&lt; (numRs * c + numComponents * p) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/04_neonke/#napomena","title":"Napomena","text":"<p>Ovo je zadatak sa poznatim ulazom (output-only zadatak). Vama su dati ulazni fajlovi (<code>case-01.in</code>, <code>case-02.in</code>, <code>case-03.in</code>, <code>case-04.in</code>), dok vi treba da po\u0161aljete samo odgovaraju\u0107e izlazne fajlove za njih (<code>case-01.out</code>, <code>case-02.out</code>, <code>case-03.out</code>, <code>case-04.out</code>).</p>"},{"location":"takprog/2016_2017/sio/04_neonke/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaznih fajlova nalaze se tri prirodna broja \\(N\\), \\(M\\) i \\(R\\) - visina i \u0161irina plana podruma, i ja\u010dina svetlosti svake neonke, redom. U drugom redu nalaze se tri prirodna broja \\(C\\), \\(P\\) i \\(B\\): cena jedne neonke, cena ru\u010dnog paljenja jedne neonke, i ukupan bud\u017eet dostupan Komisiji, redom. U preostalih \\(N\\) redova nalazi se po \\(M\\) karaktera, koji predstavljaju plan podruma, \\({\\bf Z}\\), jedan po jedan red, redom. Svaki karakter mo\u017ee biti <code>'.'</code>, <code>'#'</code> ili <code>'-'</code>, tako da <code>'.'</code> predstavlja slobodno polje, dok preostala dva karaktera predstavljaju zidove.</p>"},{"location":"takprog/2016_2017/sio/04_neonke/#opis-izlaza","title":"Opis izlaza","text":"<p>Va\u0161i izlazni fajlovi treba da sadr\u017ee pozicije svih neonki koje Komisija treba da kupi: za svaku neonku, potrebno je u zasebnom redu izlaza prilo\u017eiti dva cela broja \\(X_i\\) i \\(Y_i\\), koji predstavljaju poziciju \\(i\\)-te neonke koju Komisija treba da kupi. Obavezno mora da va\u017ei \\(1 \\leq X_i \\leq N\\), \\(1 \\leq Y_i \\leq M\\), i \\({\\bf Z}_{X_i, Y_i} = \\text{'.'}\\).</p>"},{"location":"takprog/2016_2017/sio/04_neonke/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/04_neonke/#ulaz","title":"Ulaz","text":"<pre><code>8 22 3\n1 100 220\n--########--########--\n-#########--#########-\n-#......######......#-\n-#..................#-\n-#..................#-\n-#..................#-\n-####################-\n--##################--\n</code></pre>"},{"location":"takprog/2016_2017/sio/04_neonke/#izlaz","title":"Izlaz","text":"<pre><code>4 7 \n4 10\n</code></pre>"},{"location":"takprog/2016_2017/sio/04_neonke/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ukoliko postavimo neonke na date dve pozicije, onda \u0107e osvetljenost podruma biti slede\u0107a (sa <code>'N'</code> obele\u017eavamo pozicije neonki, a sa <code>'S'</code> pozicije koje su osvetljene):</p> <pre><code>--########--########--\n-#########--#########-\n-#.SSSSS######......#-\n-#.SSSNSSNSSS.......#-\n-#.SSSSSSSSSS.......#-\n-#.SSSSSSSSSS.......#-\n-####################-\n--##################--\n</code></pre> <p>Dovoljno je ru\u010dno upaliti samo jednu od ove dve neonke da bi se obe upalile. Stoga je ukupna utro\u0161ena cena za ovo re\u0161enje \\(2 \\times C + 1 \\times P = 102\\), \u0161to je unutar na\u0161eg bud\u017eeta, tako da je re\u0161enje korektno. Ovo re\u0161enje ukupno osvetljava \\(35\\) polja (i ne predstavlja optimalno re\u0161enje!).</p>"},{"location":"takprog/2016_2017/sio/04_neonke/#bodovanje","title":"Bodovanje","text":"<p>Va\u0161e re\u0161enje za neki od ulaza \u0107e se smatrati neva\u017ee\u0107im ukoliko je ispunjen bar jedan od slede\u0107ih uslova: - izlazni fajl sadr\u017ei neparan broj celih brojeva; - izlazni fajl sadr\u017ei poziciju koja je izvan ograni\u010denja datog plana; - izlazni fajl sadr\u017ei poziciju na kojoj se nalazi zid; - izlazni fajl sadr\u017ei dve iste pozicije; - ukupna cena postavljanja i ru\u010dnog paljenja neonki prema\u0161uje zadati bud\u017eet.</p> <p>U suprotnom, neka je \\(k\\) ukupan broj polja koje va\u0161e re\u0161enje osvetljava. Za svaki ulaz definisane su konstante \\(A\\) i \\(B\\) tako da: - Ukoliko va\u017ei \\(k \\geq B\\), osvajate 25 poena za taj ulaz; - Ukoliko va\u017ei \\(k \\leq A\\), osvajate 0 poena za taj ulaz; - Ina\u010de, osvajate \\(\\lfloor 25 \\times \\frac{k - A}{B - A}\\rfloor\\) poena za taj ulaz.</p>"},{"location":"takprog/2016_2017/sio/04_neonke/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Na kori\u0161\u0107enje vam je dat program sa kojim mo\u017eete lak\u0161e da testirate svoje re\u0161enje (<code>Neonke.jar</code>). </p> <p>Pokretanjem ovog programa iz direktorijuma u kome se nalaze i odgovaraju\u0107i <code>case-??.in</code> i <code>case-??.out</code> fajlovi, mo\u0107i \u0107ete da vizuelizujete va\u0161e re\u0161enje za date ulaze, kao i informacije poput koli\u010dine polja koje ste osvetlili i ukupne cene koju ste potro\u0161ili.</p> <p>Sve neonke koje se upale kao posledica jednog ru\u010dnog paljenja \u0107e unutar programa biti prikazane istom bojom.</p>"},{"location":"takprog/2016_2017/sio/05_virus/","title":"5 - Virus","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Sunce ponovo sija, Beograd je ozeleneo i rascvetao se, topli dani su se vratili i kao \u0161to se mo\u017ee pretpostaviti \u010dlanovi komisije iznenada vi\u0161e nemaju vremena za SIO. Me\u0111utim, da bi olak\u0161ali sebi posao tajno su zaposlili jednog mladog \u010dlana da napravi zadatke za njih. Ono \u0161to nisu znali jeste da je on skovao podmukli plan sa ciljem da upropasti SIO i preuzme posao komisije. Nazva\u0107emo na\u0161eg zlikovca Nikola.</p> <p>Nikola je instalirao virus na \\(N\\) ra\u010dunara namenjenih takmi\u010darima. Sasvim slu\u010dajno se desilo da je tih \\(N\\) ra\u010dunara povezano pomo\u0107u \\(N-1\\) kablova (jedan kabal spaja dva ra\u010dunara) tako da ra\u010dunari formiraju stablo.</p> <p>Komisija je morala da se ponovo aktivira i sanira novonastali problem. 'Antivirus', koji su napravili u te svrhe, funkcioni\u0161e tako \u0161to komisija bira dva ra\u010dunara \\(a\\) i \\(b\\), a zatim pokre\u0107e svoj program koji sa svakog ra\u010dunara na putu od \\(a\\) do \\(b\\), uklju\u010duju\u0107i i njih, bri\u0161e virus ako postoji. </p> <p>Pomozite komisiji da spasi sve zara\u017eene ra\u010dunare i to pomo\u0107u minimalnog broja pokretanja antivirusa tako \u0161to \u0107ete odrediti taj broj i navesti im parove ra\u010dunara za koje treba da pozovu program.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Nenad Bauk Nenad Bauk Nikola Spasi\u0107 <p>Zadatak se svodi na: za dato stablo sa N \u010dvorova, izabrati minimalan broj parova \u010dvorova (neka je taj broj P) tako da se svaki \u010dvor stabla nalazi na bar jednom od P puteva \u010diji su krajevi izbaranih P parova \u010dvorova. Drugim recima, unija tih P puteva treba da \u2018prekrije\u2019 ceo graf.</p> <p>Prvo treba uo\u010diti da je uvek optimalno da se pove\u017eu dva lista u grafu. Jedini na\u010din da se neki list \u2018prekrije\u2019 je da taj list bude jedan od \u010dvorova iz skupa odabranih P parova. Prema tome, donja granica re\u0161enja je P = floor((L+1)/2) gde L broj listova u stablu, a floor je funkcija koja vra\u0107a donji ceo deo.</p> <p>Uzmimo proizvoljan \u010dvor X koj nije list. Kad bismo izabrali P parova \u010dvorova tako da svaki par \u010dine neka dva lista i da put izme\u0111u ta dva lista prolazi kroz X, ceo graf bi bio prekriven. Zaista, ovim smo prekrili put od svakog lista do X, a to je celo stablo. Uslov da putevi izme\u0111u listova svakog para prolaze kroz X je ekvivalentan sa uslovim da listovi svakog para pripadaju razli\u010ditim podstablima sinova \u010dvora X.</p> <p>Umesto da proizvoljno biramo \u010dvor X, mo\u017eemo izabrati \u010dvor za koji va\u017ei da podstablo svakog njegovog sina sadrzi najvise L / 2 listova (nije te\u0161ko pokazati da takav \u010dvor uvek postoji a mo\u017eemo ga prona\u0107i uz pomo\u0107 jednog DFS obilaska grafa i ra\u010dunanjem broja listova u svakom podstablu). Koriste\u0107i ovu osobinu \u010dvora X, mozemo da pove\u017eemo floor((L+1)/2) parova listova tako da svaki od pomenutih puteva prolazi kroz \u010dvor X, npr. za svako i &lt;= L/2, mo\u017eemo upariti i-ti i (i + L/2)-ti \u010dvor (redni brojevi na osnovu DFS obilaska).</p> <p>Slozenost: O(n)</p> 05_virus.cpp<pre><code>/* kod koji prolazi sve test primere */\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n#define MAXN 200010\n\nint N;\n\nvector&lt;int&gt; graph[MAXN];\n\nint leavesBelow[MAXN];\nint maxLeaves[MAXN];\n\nint countLeavesBelow(int node, int par)\n{\n    if (graph[node].size() == 1)\n    {\n        leavesBelow[node] =  1;\n    }\n\n    for (int i = 0; i &lt; graph[node].size(); i++)\n    {\n        int target = graph[node][i];\n\n        if (target != par)\n        {\n            leavesBelow[node] += countLeavesBelow(target, node);\n        }\n    }\n\n    return leavesBelow[node];\n}\n\n\nint countMaxLeaves(int node, int par, int leavesAbove)\n{\n    maxLeaves[node] = leavesAbove;\n\n    for (int i = 0; i &lt; graph[node].size(); i++)\n    {\n        int target = graph[node][i];\n\n        if (target == par) continue;\n\n        // Update max at current node\n        maxLeaves[node] = max(maxLeaves[node], leavesBelow[target]);\n\n        countMaxLeaves(target, node, leavesAbove + leavesBelow[node] - leavesBelow[target]);\n    }\n}\n\nint getCentroid()\n{\n    int centroid = 1;\n\n    for (int i = 2; i &lt;= N; i++)\n    {\n        if (graph[i].size() &gt; 1 &amp;&amp; maxLeaves[i] &lt;= maxLeaves[centroid])\n            centroid = i;\n    }\n\n    return centroid;\n}\n\nvector&lt;int&gt; leaves;\n\nvoid getLeavesBelow(int node, int par)\n{\n    if (graph[node].size() == 1)\n        leaves.push_back(node);\n\n    for (int i = 0; i &lt; graph[node].size(); i++)\n    {\n        int target = graph[node][i];\n\n        if (target != par)\n            getLeavesBelow(target, node);\n    }\n}\n\n\nvector&lt;pair&lt;int,int&gt;&gt; solution;\n\nint main() {\n\n    //freopen(\"./input/case17.in\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    cin &gt;&gt; N;\n\n    for (int i = 0; i &lt; N - 1; i++)\n    {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    // Special case\n    if (N &lt;=  2)\n    {\n        cout &lt;&lt; 1 &lt;&lt; endl;\n        cout &lt;&lt; min(1,N) &lt;&lt; ' ' &lt;&lt; max(1, N) &lt;&lt; endl;\n        return 0;\n    }\n\n\n    countLeavesBelow(1, -1);\n    countMaxLeaves(1, -1, 0);\n\n    /*\n    for (int i = 1; i &lt;= N; i++)\n    {\n        cout &lt;&lt; leavesBelow[i] &lt;&lt; ' ' &lt;&lt; maxLeaves[i] &lt;&lt; endl;\n    }\n    */\n\n    int centroid = getCentroid();\n\n    // cout &lt;&lt; centroid &lt;&lt; endl;\n\n    for (int i = 0; i &lt; graph[centroid].size(); i++)\n    {\n        int target = graph[centroid][i];\n\n        getLeavesBelow(target, centroid);\n    }\n\n    int totalLeaves = leaves.size();\n\n    if (totalLeaves % 2)\n    {\n        leaves.push_back(centroid);\n    }\n\n    // Output solution\n    cout &lt;&lt; leaves.size() / 2 &lt;&lt; endl;\n\n\n    for (int i = 0; i &lt; leaves.size() / 2; i++)\n    {\n        cout &lt;&lt; leaves[i] &lt;&lt; ' ' &lt;&lt; leaves[i + leaves.size() / 2] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/05_virus/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se jedan prirodni broj \\(N\\) - broj ra\u010dunara zara\u017eenih virusom. U narednih \\(N-1\\) redova nalaze se po dva prirodna broja \\(a\\) i \\(b\\) koja ozna\u010davaju da su ra\u010dunari \\(a\\) i \\(b\\) povezani.</p>"},{"location":"takprog/2016_2017/sio/05_virus/#opis-izlaza","title":"Opis izlaza","text":"<p>Opis izlaznih podataka.</p>"},{"location":"takprog/2016_2017/sio/05_virus/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/05_virus/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 3\n1 4\n2 3\n3 5\n</code></pre>"},{"location":"takprog/2016_2017/sio/05_virus/#izlaz","title":"Izlaz","text":"<pre><code>2\n1 4\n2 5\n</code></pre>"},{"location":"takprog/2016_2017/sio/05_virus/#ogranicenja","title":"Ograni\u010denja","text":"<p>Postoje \\(3\\) podzadatka u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [20 poena]: \\(n \\leq 20\\). </li> <li>Podzadatak 2 [35 poena]: \\(n \\leq 5000\\). </li> <li>Podzadatak 3 [45 poena]: \\(n \\leq 200000\\).</li> </ul>"},{"location":"takprog/2016_2017/sio/05_virus/#napomena","title":"Napomena","text":"<p>Mo\u017ee da postoji vi\u0161e na\u010dina na koje se mogu povezati ra\u010dunari kako bi se dobilo optimalno re\u0161enje. Potrebno je ispisati samo jedan, proizvoljan na\u010din kao re\u0161enje zadatka.</p>"},{"location":"takprog/2016_2017/sio/06_pogled/","title":"6 - Pogled","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>\u010clanovi Komisije su u periodima dokolice do\u0161li na zanimljivu ideju da na zgradama jednog mesta naprave vidikovce. Zgrade su pore\u0111ane na nekoj zami\u0161ljenoj liniji. Na svakoj od njih mogu biti postavljena najvi\u0161e dva ure\u0111aja za posmatranje od kojih je jedan usmeren prema po\u010detku tog niza zgrada (na levu stranu), a drugi prema kraju niza zgrada (na desnu stranu).  Me\u0111utim, postavljanje ure\u0111aja koji je okrenut prema po\u010detku se mo\u017ee izvesti samo ako izme\u0111u zgrade na koji se ure\u0111aj postavlja i po\u010detka niza ne postoji zgrada ve\u0107e visine. Sli\u010dno postavljanje ure\u0111aja koji je okrenut prema kraju se mo\u017ee izvesti samo ako izme\u0111u te zgrade i kraja niza ne postoji zgrada ve\u0107e visine. Dozvoljeno je sru\u0161iti neke zgrade, ako se time dobija mogu\u0107nost postavljanja ure\u0111aja za posmatranje na nekim zgradama. Za svaku zgradu je poznata cena ru\u0161enja. Postavljanje svakog ure\u0111aja donosi odre\u0111enu zaradu i za svaku zgradu su poznate zarada ako je postavljen ure\u0111aj koji je okrenut na levo i zarada od ure\u0111aja koji je okrenut na desno. Ukupna zarada od postavljenih ure\u0111aja je jednaka razlici zbira zarada od postavljenih ure\u0111aja i tro\u0161kova ru\u0161enja zgrada koje treba sru\u0161iti. Zbog zauzetosti nekim drugim aktivnostima, oni ne mogu da odvoje vreme i da odrede koje zgrade treba sru\u0161iti i gde postaviti ure\u0111aje tako da zarada bude \u0161to ve\u0107a. Pomozite im da izra\u010dunaju najve\u0107u mogu\u0107u zaradu koja se mo\u017ee dosti\u0107i postavljanjem ure\u0111aja (uz neophodna ru\u0161enja).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dragan Uro\u0161evi\u0107 Nikola Milosavljevi\u0107 Dimitrije Erdeljan i Ivan Sto\u0161i\u0107 <p>Neka je L[i] = optimalna zarada za prvih i zgrada ukoliko postavljamo samo ure\u0111aje okrenute ulevo i poslednji postavljeni ure\u0111aj je na i-toj zgradi. Analgo se defini\u0161e R[i] za desne ure\u0111aje i nije te\u0161ko zaklju\u010diti da je re\u0161enje zadatka max {L[i] + R[i]} i da se ova dva niza ra\u010dunaju simetri\u010dno pa nadalje gledamo samo za L[i]. Neka su h[], v[] i c[] visine, zarade i cene ru\u0161enja, redom. Zadatak re\u0161avamo dinami\u010dkim programiranjem. Va\u017ei</p> <p>(1) L[i] = v[i] + maximum { L[j] - suma {c[k] | j &lt; k &lt; i, h[k] &gt; h[i]} | j &lt; i, h[j] &lt; h[i] }</p> <p>(sa desne strane je maximum po svim zgradama j &lt; i koje su ni\u017ee od i; to je kandidat za pretposlednju zgradu, a moramo sru\u0161iti sve zgrade izme\u0111u j i i koje su vi\u0161e od h[i] dok \u0107e cena preostaih ru\u0161enja zgrada vi\u0161ih od h[i] a levo od j biti ura\u010dunata u L[j] jer je h[j] &lt; h[i]). U cilju nala\u017eenja boljeg re\u0161enja od O(n^2), jedan od na\u010dina je da se dinamika radi po visinama a ne redom s leva udesno; to ujedno omogu\u0107ava da ne moramo da proveravamo uslov h[j] &lt; h[i] u (1). Za dato i treba nam indeks j &lt; i za koji je vrednost</p> <p>L[j] - suma {c[k] | j &lt; k &lt; i, h[k] &gt; h[i]} (*)</p> <p>maksimalna. Me\u0111utim, primetimo da (*) dosti\u017ee maksimum u indeksu j ako i smo ako izraz</p> <p>L[j] - suma {c[k] | j &lt; k, h[k] &gt; h[i]} (**)</p> <p>dosti\u017ee maksimum maksimum u indeksu j (ostatak sume ne zavisi od j). Ovim smo izbacili parametar i iz granica pa sada mo\u017eemo prebaciti pri\u010du na segmentno stablo i ra\u010dunanje nekih upita.</p> <p>Neka su na po\u010detku svi L[i] = -INF. Posmatrajmo niz A du\u017eine n koji je u i-tom koraku dinamike (idemo od najmanje do najve\u0107e zgrade) definisan sa (uzimamo da je h[0] = 0)</p> <p>(2) A[j] = L[j] - suma {c[k] | j &lt; k, h[k] &gt; h[i]}</p> <p>(dakle, na po\u010detku za sve j va\u017ei A[j] = -INF - suma {c[k] | j &lt; k}). Kako ra\u010dunamo vrednosti L[i] redom po visinama zgrada, treba odraditi n koraka i u i-tom koraku:</p> <p>a) Odrediti L[i] kao L[i] = v[i] + max(A[1],A[2],\u2026,A[i]) + suma { c[k] | i &lt; k, h[k] &gt; h[i]}; b) Update-ovati niz A, tj. pove\u0107ati A[i] za (L[i] + INF) i za sve j &lt; i pove\u0107ati A[j] za c[i].</p> <p>Formula iz a) je ta\u010dna jer zamenom A[i] iz (2) dobijamo (1) (do tada su izra\u010dunati svi A[j] za h[j] &lt; h[i]). Deo \u201c+ suma\u2026\u201d je tu da bismo nadoknadili razliku izme\u0111u () i (*). Kod dela b), menja se vi\u0161e elemenata niza A na osnovu definicije (2). Obe ove operacije mo\u017eemo raditi u slo\u017eenosti O(log n) - dovoljno nam je segmetno stablo nad nizom A koje podr\u017eava \u201cvrati maximum na segmentu\u201d i \u201cpove\u0107aj sve elemente iz datog segmenta za dati broj\u201d a to je max-segmento sa lazy propagation-om. Za upit U(i) = suma { c[k] | i &lt; k, h[k] &gt; h[i]} mo\u017eemo koristiti (drugo) suma-segmentno stablo nad nizom c[] pri \u010demu u i-tom koraku vra\u0107amo sumu na segmentu [i, n] a zatim izbacujemo element c[i] (tj. postavljamo c[i] = 0) jer dinamiku radimo po visinama i za svaki naredni upit j va\u017ei h[j] &gt; h[i] pa vrednsot c[i] ne u\u010destvuje u sumi. Ukupna slo\u017eenost je O(n log n).</p> <p>Podzadaci uklju\u010duju slu\u010dajeve kada prolazi dinami\u010dko programiranje u slo\u017eenosti O(n^2) tj. direktno dinami\u010dko iz formule (1), slu\u010dajeve gde se ne isplati ru\u0161iti zgrade (tada je re\u0161enje jedinstveno - postaviti levi ur\u0111aj na prvu zgradu, zatim na prvu narednu koja nije zaklonjena prvom, zatim na prvu narednu koja nije zaklonjena drugom izabranom itd. do najvi\u0161e zgrade i sl. za desne ure\u0111aje) kao i slu\u010dajeve gde su cena zgrada 0 \u0161to zna\u010dajno pojednostavljuje formulu (1) na L[i] = v[i] + maximum { L[j] | j &lt; i, h[j] &lt; h[i] } pa ovo mo\u017eemo re\u0161avati sli\u010dno kao LIS konstrukcijom max-segmentnog nad nizom L[i] (koje je indeksirano visinama ako ra\u010dunamo vrednosti L[i] od 1 do n ili je indeksirano pozicijama ako ra\u010dunamo vrednosti L[i] po visinama).</p> 06_pogled.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;stdlib.h&gt;\n#include&lt;math.h&gt; \n//#include&lt;algorithm&gt;\n#include&lt;string.h&gt;\n\n# define MAXN 100100\n# define MAXN2 ((1&lt;&lt;18)+1)\n#define INF 0x1FFFFFFFFFFFFFLL\n//#define INF 10000000000LL\n\nusing namespace std;\n\nint n;\n\nint ord[MAXN];\nint ht[MAXN], ct[MAXN], lc[MAXN], rc[MAXN];\n\nlong long ls[MAXN], rs[MAXN];\n\nlong long ctc[MAXN];\nlong long smc[MAXN];\n\n\nlong long tree_sum[MAXN2];\nlong long lazy_sum[MAXN2];\nlong long tree_max[MAXN2];\nlong long lazy_max[MAXN2];\n\nlong long sum(long long a, long long b) {\n    return a + b;\n}\n\nlong long max(long long a, long long b) {\n    if (a &gt; b) return a; else return b;\n}\n\n\nvoid build_tree_sum(int node, int a, int b, long long arr[]) {\n    if(a &gt; b) return;                       \n\n    if(a == b) {                            \n        tree_sum[node] = arr[a];        \n        return;\n    }\n\n    build_tree_sum(node*2, a, (a+b)/2, arr);    \n    build_tree_sum(node*2+1, 1+(a+b)/2, b, arr); \n\n    tree_sum[node] = sum(tree_sum[node*2], tree_sum[node*2+1]); \n}\n\nvoid update_tree_sum(int node, int a, int b, int i, int j, long long value) {\n\n    if(lazy_sum[node] != 0) {                           \n        tree_sum[node] += (b - a + 1) * lazy_sum[node]; \n\n        if(a != b) {\n            lazy_sum[node*2] += lazy_sum[node];         \n            lazy_sum[node*2+1] += lazy_sum[node];       \n        }\n\n        lazy_sum[node] = 0;                             \n    }\n\n    if(a &gt; b || a &gt; j || b &lt; i)                         \n        return;\n\n    if(a &gt;= i &amp;&amp; b &lt;= j) {                              \n            tree_sum[node] += (b - a + 1) * value;\n\n        if(a != b) {                                    \n            lazy_sum[node*2] += value;                   \n            lazy_sum[node*2+1] += value;                \n        }\n\n        return;\n    }\n\n    update_tree_sum(node*2, a, (a+b)/2, i, j, value);       \n    update_tree_sum(1+node*2, 1+(a+b)/2, b, i, j, value);   \n\n    tree_sum[node] = sum(tree_sum[node*2], tree_sum[node*2+1]); \n}\n\nlong long query_tree_sum(int node, int a, int b, int i, int j) {\n\n    if(a &gt; b || a &gt; j || b &lt; i) return 0;                   \n\n    if(lazy_sum[node] != 0) {                               \n        tree_sum[node] += (b - a + 1) * lazy_sum[node];     \n\n        if(a != b) {\n            lazy_sum[node*2] += lazy_sum[node];             \n            lazy_sum[node*2+1] += lazy_sum[node];           \n        }\n\n        lazy_sum[node] = 0;                                 \n    }\n\n    if(a &gt;= i &amp;&amp; b &lt;= j) \n        return tree_sum[node];\n\n    long long q1 = query_tree_sum(node*2, a, (a+b)/2, i, j);        \n    long long q2 = query_tree_sum(1+node*2, 1+(a+b)/2, b, i, j);    \n\n    long long res = sum(q1, q2);                                    \n\n    return res;\n}\n\nvoid build_tree_max(int node, int a, int b, long long arr[]) {\n    if(a &gt; b) return;                   \n\n    if(a == b) {                        \n        tree_max[node] = arr[a]; \n        return;\n    }\n\n    build_tree_max(node*2, a, (a+b)/2, arr);        \n    build_tree_max(node*2+1, 1+(a+b)/2, b, arr);    \n\n    tree_max[node] = max(tree_max[node*2], tree_max[node*2+1]); \n}\n\nvoid update_tree_max(int node, int a, int b, int i, int j, long long value) {\n\n    if(lazy_max[node] != 0) {                   \n        tree_max[node] += lazy_max[node];       \n\n        if(a != b) {\n            lazy_max[node*2] += lazy_max[node];         \n                lazy_max[node*2+1] += lazy_max[node];   \n        }\n\n        lazy_max[node] = 0;                     \n    }\n\n    if(a &gt; b || a &gt; j || b &lt; i)                 \n        return;\n\n    if(a &gt;= i &amp;&amp; b &lt;= j) {                      \n        tree_max[node] += value;\n\n        if(a != b) {                            \n            lazy_max[node*2] += value;          \n            lazy_max[node*2+1] += value;\n        }\n\n        return;\n    }\n\n    update_tree_max(node*2, a, (a+b)/2, i, j, value);           \n    update_tree_max(1+node*2, 1+(a+b)/2, b, i, j, value);       \n\n    tree_max[node] = max(tree_max[node*2], tree_max[node*2+1]); \n}\n\nlong long query_tree_max(int node, int a, int b, int i, int j) {\n\n    if(a &gt; b || a &gt; j || b &lt; i) return -2*INF;      \n\n    if(lazy_max[node] != 0) {                       \n        tree_max[node] += lazy_max[node];           \n\n        if(a != b) {\n            lazy_max[node*2] += lazy_max[node];     \n            lazy_max[node*2+1] += lazy_max[node];   \n        }\n\n        lazy_max[node] = 0;                         \n    }\n\n    if(a &gt;= i &amp;&amp; b &lt;= j)                            \n        return tree_max[node];\n\n    long long q1 = query_tree_max(node*2, a, (a+b)/2, i, j);        \n    long long q2 = query_tree_max(1+node*2, 1+(a+b)/2, b, i, j);    \n\n    long long res = max(q1, q2);                                    \n\n    return res;\n}\n\n\n\n\nvoid read() {\n    int i;\n    scanf(\"%d\", &amp;n);\n    for (i = 1; i &lt;= n; i++) {\n        scanf(\"%d%d%d%d\", &amp;ht[i], &amp;ct[i], &amp;lc[i], &amp;rc[i]);\n    }\n}\n\nint cmpht(const void *p1, const void *p2) {\n    const int *pi1 = (const int *)p1;\n    const int *pi2 = (const int *)p2;\n    return ht[*pi1] - ht[*pi2];\n}\n\nlong long solve() {\n    int i, j;\n    for (i = 0; i &lt; n; i++) \n        ord[i] = i+1;\n    qsort(ord, n, sizeof(int), cmpht);\n    ls[n] = smc[n] = -INF;\n    ctc[n] = ct[n];\n    for (i = n-1; i &gt;= 1; i--) {\n        smc[i] = smc[i+1] - ct[i+1];\n        ctc[i] = ct[i];\n        ls[i] = -INF;\n    } \n    smc[0] = smc[1] - ct[1] + INF;\n    ctc[0] = 0;\n    build_tree_sum(1, 0, n, ctc);\n    build_tree_max(1, 0, n, smc);\n    memset(lazy_max, 0, sizeof lazy_max);\n    memset(lazy_sum, 0, sizeof lazy_sum);\n    for (i = 0; i &lt; n; i++) {\n        j = ord[i];\n        ls[j] = lc[j];\n        if (j &gt; 0) \n            ls[j] += query_tree_max(1, 0, n, 0, j-1);\n        ls[j] += query_tree_sum(1, 0, n, j, n);\n        update_tree_max(1, 0, n, j, j, INF+ls[j]);\n        smc[j] += INF + ls[j];\n        if (j &gt; 0) {\n            update_tree_max(1, 0, n, 0, j-1, ct[j]);\n        }\n        update_tree_sum(1, 0, n, j, j, -ct[j]);\n    }\n\n    rs[1] = smc[1] = -INF;\n    ctc[1] = ct[1];\n    for (i = 2; i &lt;= n; i++) {\n        smc[i] = smc[i-1] - ct[i-1];\n        ctc[i] = ct[i];\n        rs[i] = -INF;\n    } \n    smc[n+1] = smc[n] - ct[n] + INF;\n    ctc[n+1] = 0;\n    build_tree_sum(1, 1, n+1, ctc);\n    build_tree_max(1, 1, n+1, smc);\n    memset(lazy_max, 0, sizeof lazy_max);\n    memset(lazy_sum, 0, sizeof lazy_sum);\n    for (i = 0; i &lt; n; i++) {\n        j = ord[i];\n        rs[j] = rc[j];\n        rs[j] += query_tree_max(1, 1, n+1, j+1, n+1);\n        rs[j] += query_tree_sum(1, 1, n+1, 1, j);\n        update_tree_max(1, 1, n+1, j, j, INF+rs[j]);\n        update_tree_max(1, 1, n+1, j+1, n+1, ct[j]);\n        update_tree_sum(1, 1, n+1, j, j, -ct[j]);\n    }\n\n    long long rez;\n    rez = ls[1] + rs[1];\n    for (i = 2; i &lt;= n; i++) \n        if (ls[i] + rs[i] &gt; rez)\n            rez = ls[i] + rs[i];\n    printf(\"%lld\\n\", rez);\n    return rez;\n}\n\nmain() {\n    read();\n    solve();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2016_2017/sio/06_pogled/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu se nalazi jedan prirodan broj: \\(n\\) - broj zgrada. U narednih \\(n\\) redova se nalazi po \\(4\\) broja i oni predstavljaju podatke za odgovaraju\u0107u zgradu: visina zgrade, cena ru\u0161enja zgrade, zarada ako na njoj postoji ure\u0111aj okrenut ulevo (pri \u010demu levo nema niti jedna zgrada ve\u0107e visine, tj. sve zgrade koje su bile ve\u0107e visine su sru\u0161ene) i zarada ako je na zgradi postavljen ure\u0111aj koji je okrenut udesno (pri \u010demu su zgrade ve\u0107e visine desno od te zgrade sru\u0161ene). Visine zgrada su razli\u010diti brojevi, tj. ne postoje dve zgrade iste visine.</p>"},{"location":"takprog/2016_2017/sio/06_pogled/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu izlaza ispisati maksimalnu mogu\u0107u zaradu koja predstavlja razliku zbira svih zarada od ure\u0111aja raspore\u0111enih na zgradama i zbira tro\u0161kova ru\u0161enja zgrada koje su morale da budu sru\u0161ene.</p>"},{"location":"takprog/2016_2017/sio/06_pogled/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2016_2017/sio/06_pogled/#ulaz","title":"Ulaz","text":"<pre><code>10\n1041 18 23 27\n1169 29 16 29\n1962 14 23 23\n1281 27 29 28\n1995 21 29 26\n1391 14 22 13\n1815 19 26 29\n1718 18 20 13\n1771 25 29 18\n1837 15 14 26\n</code></pre>"},{"location":"takprog/2016_2017/sio/06_pogled/#izlaz","title":"Izlaz","text":"<pre><code>149\n</code></pre>"},{"location":"takprog/2016_2017/sio/06_pogled/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako se rasporede ure\u0111aji na zgradama 1, 2, 3 i 5 (zgrade su numerisane brojevima od 1 do \\(n\\), sleva nadesno) tako da su okrenuti levo, zbir zarada \u0107e biti \\(23+16+23+29 = 91\\). Ako se na zgradama 5, 7, 9 rasporede ure\u0111aji tako da gledaju desno, mora se sru\u0161iti zgrada broj 10. Zbir zarada od postavljenih ure\u0111aja je \\(26+29+18 = 73\\). Ru\u0161enje zgrade 10 ko\u0161ta 15. Tako je ukupna zarada \\(91 + 73 - 15 = 149\\). </p>"},{"location":"takprog/2016_2017/sio/06_pogled/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2016_2017/sio/06_pogled/#ulaz_1","title":"Ulaz","text":"<pre><code>8\n1771 25 14 13\n1270 21 24 16\n1018 19 23 24\n1729 26 25 16\n1817 18 26 22\n1861 26 13 18\n1541 19 20 23\n1645 25 14 17\n</code></pre>"},{"location":"takprog/2016_2017/sio/06_pogled/#izlaz_1","title":"Izlaz","text":"<pre><code>98\n</code></pre>"},{"location":"takprog/2016_2017/sio/06_pogled/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>Ukupan broj zgrada nije ve\u0107i od \\(100.000\\) (\\(n\\leq 100.000\\)).</li> <li>Visine zgrada su celi brojevi izme\u0111u \\(1\\) i \\(1.000.000.000\\).</li> <li>Cene ru\u0161enja zgrada su celi brojevi izme\u0111u \\(0\\) i \\(2.000.000\\).</li> <li>Zarade od ure\u0111aja su celi brojevi izme\u0111u  \\(1\\) i \\(20.000\\).</li> </ul> <p>Postoje \\(4\\) podzadatka u kojima dodatno va\u017ei:</p> <ul> <li>Podzadatak 1 [\\(16\\) poena]: \\(n \\leq 1000\\). </li> <li>Podzadatak 2 [\\(12\\) poena]: cene ru\u0161enja zgrada su izme\u0111u \\(1.000.000\\) i \\(2.000.000\\), a zarade od postavljanja ure\u0111aja za posmatranje izme\u0111u \\(5\\) i \\(10\\).</li> <li>Podzadatak 3 [\\(25\\) poena]: cene ru\u0161enja zgrada su jednake nuli (za svaku od zgrada). </li> <li>Podzadatak 4 [\\(47\\) poena]: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/drz/01_pola_pola/","title":"B1 - Pola-pola","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Natalija i Mila se po ceo dan dosa\u0111uju pa su re\u0161ile da igraju slede\u0107u igru. Mila otvara Noutped, pravi prazan fajl a zatim redom kuca u Noutpedu mala slova engleskog alfabeta. Me\u0111utim, s vremena na vreme, Natalija uzima iskucani tekst, deli ga na dva jednaka dela a zatim menja redosled tim polovinama. Natalija je jako pa\u017eljiva pa ovo radi samo kada je du\u017eina teksta pozitivan paran broj. Na\u017ealost, njima se pokvario hard disk pa je ovaj fajl izgubljen. Sre\u0107om, one se se\u0107aju svih akcija koje su izvele i u kom redosledu. Pomozite im da rekonstrui\u0161u tekst koji je sadr\u017eao Noutped pre nego \u0161to im se pokvario hard disk.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Vladimir Milovanovi\u0107 Slobodan Mitrovi\u0107 <p>Klju\u010dno je uvideti da je najefikasniji na\u010din za re\u0161avanje ovog problema kori\u0161\u0107enje listi (ili pak dvostranih redova) kao strukture podataka za \u010duvanje slova. Preciznije govore\u0107i, neophodne su dve ovakve strukture u kojima bi se u svakom trenutku \u010duvale i odr\u017eavale prva, odnosno druga polovina trenutnog niza slova.</p> <p>Svako (neparno) ubacivanje novog slova zapravo predstavlja dodavanje novog \u010dlana na kraj jedne liste (reda), pri \u010demu treba voditi ra\u010duna da se prilikom svakog drugog (tj. parnog) dodavanja, prvi \u010dlan te liste (reda) izbaci i doda na kraj prve liste (reda). Time bi obe liste (reda) u svakom trenutku bile ili podjednake du\u017eine ili bi se razlikovale najvi\u0161e za jedan \u010dlan.</p> <p>Operacija zamene redosleda prve i druge polovine se svodi na trivijalnu zamenu dva pokaziva\u010da i odvija se samo kada su liste (redovi) jednakih du\u017eina. Kako se dodavanje i prebacivanje \u010dlanova, kao i promena mesta nad ovim strukturama podataka mogu uraditi u konstantnoj slo\u017eenosti, \\(\\mathcal{O}(1)\\), i kako ukupno imamo \\(N\\) ovakvih operacija, tako je, ra\u010dunaju\u0107i tu i krajnje ispisivanje rezultata, zadatak na ovaj na\u010din re\u0161en u linearnoj \\(\\mathcal{O}(N)\\) vremenskoj slo\u017eenosti.</p> 01_pola_pola.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int q;\n    cin &gt;&gt; q;\n    deque&lt;char&gt; leva, desna;\n\n    while (q--) {\n        int t;\n        cin &gt;&gt; t;\n        if (t == 1) {\n            char x;\n            cin &gt;&gt; x;\n            desna.push_back(x);\n            if (desna.size() == leva.size() + 2) {\n                leva.push_back(desna.front());\n                desna.pop_front();\n            }\n        } else {\n            if (leva.size() != desna.size()) {\n                cerr &lt;&lt; \"bad\\n\";\n                return 1;\n            }\n            swap(leva, desna);\n        }\n    }\n\n    cout &lt;&lt; string(leva.begin(), leva.end());\n    cout &lt;&lt; string(desna.begin(), desna.end());\n    cout &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se jedan prirodan broj \\(N\\) - broj akcija koje su izvele Mila i Natalija. U narednih \\(N\\) redova nalazi se opis jedne akcije. Sa <code>1 x</code> ozna\u010davamo akciju u kojoj je Mila dodala slovo <code>x</code> na kraj fajla u Noutpedu. Sa <code>2</code> ozna\u010davamo akciju u kojoj je Natalija zamenila prvu i drugu polovinu fajla.</p>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedini red standardnog izlaza ispisati rekonstruisani izgled fajla nakon svih akcija.</p>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/drz/01_pola_pola/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 a\n1 b\n2\n1 c\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#izlaz","title":"Izlaz","text":"<pre><code>bac\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/drz/01_pola_pola/#ulaz_1","title":"Ulaz","text":"<pre><code>9\n1 a\n1 b\n2\n1 a\n1 m\n2\n1 a\n1 d\n2\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#izlaz_1","title":"Izlaz","text":"<pre><code>aadamb\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru Mila dodaje slova a i b nakon \u010dega Natalija deli ovaj tekst na dva dela (od po jednog slova) i zamenjuje ih. Na kraju, Mila zapisuje c pa je kona\u010dni izgled teksta bac.</p> <p>U drugom primeru izgled teksta nakon svakog poteza je slede\u0107i:</p> <pre><code>a\nab\nba\nbaa\nbaam\namba\nambaa\nambaad\naadamb\n</code></pre>"},{"location":"takprog/2017_2018/drz/01_pola_pola/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq N \\leq 500000\\).</li> </ul> <p>Postoji pet podzadataka:</p> <ul> <li>Podzadatak \\(1\\) [\\(4\\) poena]: Mila uvek pi\u0161e isto slovo.</li> <li>Podzadatak \\(2\\) [\\(13\\) poena]: \\(N \\leq 5000\\).</li> <li>Podzadatak \\(3\\) [\\(19\\) poena]: Mila ne\u0107e zapisati vi\u0161e od 5000 slova.</li> <li>Podzadatak \\(4\\) [\\(22\\) poena]: Mila pi\u0161e samo slova a ili b, \\(N \\leq 50000\\).</li> <li>Podzadatak \\(5\\) [\\(42\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/drz/02_trik/","title":"B2 - Trik","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Umesto da u\u010di za test iz programiranja, mali Aleksa je \u010ditav dan ve\u017ebao trikove sa karticama. Sada mu nije preostalo ni\u0161ta drugo nego da odu\u0161evi svog profesora Dragana jednim trikom, i nada se da \u0107e dobiti bolju ocenu zbog toga.</p> <p>On poseduje za svaki broj od \\(1\\) do \\(N\\) po dve kartice na kojoj je ispisan taj broj, i \\(K\\) d\u017eoker kartica na kojima je ispisano slovo \\(J\\).</p> <p>Trik se sastoji u tome da \u0107e Aleksa prome\u0161ati i rasporediti kartice tako da se izme\u0111u svake dve kartice koje imaju isti broj na sebi, nalazi ta\u010dno toliko kartica koliki je taj broj. Npr, izme\u0111u dve kartice sa brojem 3 treba da se nalaze ta\u010dno 3 kartice.</p> <p>Ovakav raspored je te\u0161ko napraviti bez znanja programiranja, i zato vas mali Aleksa moli za pomo\u0107. Za dato \\(N\\) i \\(K\\) ispi\u0161ite raspored kartica kojim \u0107e Aleksa odu\u0161eviti profesora.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Du\u0161an Zdravkovi\u0107 Vladimir Milovanovi\u0107 Ivan Sto\u0161i\u0107 <p>Najpre, lako se dokazuje da u op\u0161tem slu\u010daju za proizvoljno \\(N\\), nije mogu\u0107e sklopiti odgovaraju\u0107i niz bez d\u017eokera. Naime, kako kartice ozna\u010dene neparnim brojevima, \\(1, 3, 5,\\ldots\\), moraju sadr\u017eati neparan broj kartica izme\u0111u njih, ove kartice se uvek pojavljuju na mestima u nizu, odnosno indeksima, sa istom parno\u0161\u0107u. Sa druge strane, kartice ozna\u010dene parnim brojevima, \\(2, 4, 6,\\ldots\\), sadr\u017ee paran broj kartica izme\u0111u njih, pa se stoga pojavljuju na pozicijama suprotne parnosti. U nizu koji sadr\u017ei samo \\(2N\\) kartica, postoji ta\u010dno \\(N\\) parnih i ta\u010dno \\(N\\) neparnih indeksa, od kojih bi, bez smanjenja op\u0161tosti uz pretpostavku da je \\(N\\) parno, po \\(N/2\\) parnih i neparnih pozicija bilo zauzeto karticama sa parnim brojevima na sebi, to jest, \\(2, 4, 6,\\ldots\\), pa bi nakon njihovog raspore\u0111ivanja u nizu preostalo \\(N/2\\) parnih i \\(N/2\\) neparnih indeksa bez mogu\u0107nosti da se kartice ozna\u010dene neparnim brojevima, \\(1, 3, 5,\\ldots\\), rasporede na odgovaraju\u0107i na\u010din.</p> <p>Iako je opisani niz nemogu\u0107e sastaviti bez d\u017eokera, za proizvoljno \\(N\\) potreban je i dovoljan samo jedan d\u017eoker da se ispune uslovi opisani postavkom zadatka. Nije te\u0161ko uo\u010diti da se sve kartice ozna\u010dene neparnim i parnim brojevima mogu ugnezditi jedna u drugu na slede\u0107i na\u010din za neparno \\(N\\):</p> <ul> <li>\\(N, N-2, N-4,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-4, N-2, N\\)</li> <li>\\(N-1, N-3, N-5,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-5, N-3, N-1\\)</li> </ul> <p>odnosno na identi\u010dan na\u010din i za parno \\(N\\):</p> <ul> <li>\\(N-1, N-3, N-5,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-5, N-3, N-1\\)</li> <li>\\(N, N-2, N-4,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-4, N-2, N\\)</li> </ul> <p>te se njihovim spajanjem dobija re\u0161enje koje sadr\u017ei ukupno tri d\u017eokera (jednog u podnizu kartica ozna\u010denih neparnim i dva u podnizu kartica ozna\u010denih parnim brojevima).</p> <p>U svakom slu\u010daju, sada izme\u0111u nesusednih d\u017eokera tako spojenih podnizova ima ta\u010dno \\(N\\), to jest \\(N+1\\) kartica, me\u0111u kojima su i po jedna kartica ozna\u010dena brojevima \\(N-1\\) i \\(N\\), bez obzira na to da li je \\(N\\) parno ili neparno i koji je od ugne\u017e\u0111enih podnizova prvi, a koji drugi, odnosno:</p> <ul> <li>\\(N-1, N-3, N-5,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-5, N-3, N-1, N, N-2, N-4,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-4, N-2, N\\)</li> <li>\\(N, N-2, N-4,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-4, N-2, N, N-1, N-3, N-5,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-5, N-3, N-1\\)</li> </ul> <p>Ukoliko sada, (u prvom slu\u010daju) izvadimo kartice ozna\u010dene brojem \\(N-1\\) dobi\u0107emo ta\u010dno \\(N-1\\) karticu izme\u0111u dva bli\u017ea nesusedna d\u017eokera:</p> <ul> <li>\\(N-3, N-5,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-5, N-3, N, N-2, N-4,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-4, N-2, N\\)</li> <li>\\(N, N-2, N-4,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-4, N-2, N, N-3, N-5,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-5, N-3\\)</li> </ul> <p>pa zamenom odgovaraju\u0107ih d\u017eokera karticama ozna\u010denim sa \\(N-1\\) dobijamo tra\u017eeni niz, to jest:</p> <ul> <li>\\(N-3, N-5,\\ldots, 7, 5, 3, 1, N-1, 1, 3, 5, 7,\\ldots, N-5, N-3, N, N-2, N-4,\\ldots, 6, 4, 2, N-1, J, 2, 4, 6,\\ldots, N-4, N-2, N\\)</li> <li>\\(N, N-2, N-4,\\ldots, 7, 5, 3, 1, N-1, 1, 3, 5, 7,\\ldots, N-4, N-2, N, N-3, N-5,\\ldots, 6, 4, 2, N-1, J, 2, 4, 6,\\ldots, N-5, N-3\\)</li> </ul> <p>za parno i neparno \\(N\\), respektivno.</p> <p>Sli\u010dno tome, bilo je (u drugom slu\u010daju) mogu\u0107e izvaditi i kartice ozna\u010dene brojem \\(N\\), pa bi izme\u0111u druga dva nesusedna d\u017eokera bilo \\(N\\) kartica:</p> <ul> <li>\\(N-1, N-3, N-5,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-5, N-3, N-1, N-2, N-4,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-4, N-2\\)</li> <li>\\(N-2, N-4,\\ldots, 7, 5, 3, 1, J, 1, 3, 5, 7,\\ldots, N-4, N-2, N-1, N-3, N-5,\\ldots, 6, 4, 2, J, J, 2, 4, 6,\\ldots, N-5, N-3, N-1\\)</li> </ul> <p>\u010dijom bismo zamenom karticama ozna\u010denim brojem \\(N\\) na jo\u0161 jedan mogu\u0107i na\u010din dobili tra\u017eeni niz, zapravo:</p> <ul> <li>\\(N-1, N-3, N-5,\\ldots, 7, 5, 3, 1, N, 1, 3, 5, 7,\\ldots, N-5, N-3, N-1, N-2, N-4,\\ldots, 6, 4, 2, J, N, 2, 4, 6,\\ldots, N-4, N-2\\)</li> <li>\\(N-2, N-4,\\ldots, 7, 5, 3, 1, N, 1, 3, 5, 7,\\ldots, N-4, N-2, N-1, N-3, N-5,\\ldots, 6, 4, 2, J, N, 2, 4, 6,\\ldots, N-5, N-3, N-1\\)</li> </ul> <p>tako\u0111e za parno i neparno \\(N\\), respektivno.</p> <p>Prethodnim se dokazuje da je u op\u0161tem slu\u010daju koriste\u0107i samo jednu d\u017eoker karticu mogu\u0107e konstruisati tra\u017eeni niz za proizvoljno \\(N\\), pa je i slo\u017eenost ovog algoritma linearna po \\(N\\), odnosno \\(\\mathcal{O}(N)\\). Trivijalnim dodavanjem preostalih \\(K-1\\) d\u017eokera bilo na po\u010detak ili na kraj ovako formiranog niza, zadatak je re\u0161en u ukupnoj slo\u017eenosti \\(\\mathcal{O}(N+K)\\).</p> 02_trik.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    int n,j,t,p,i;\n\n    scanf(\"%d%d\", &amp;n, &amp;j);\n\n    t = n;\n    if (n%2 == 0) t--;\n    for(i=t-2; i&gt;=1; i-=2) printf(\"%d \", i);\n    printf(\"%d \", t);\n    for(i=1; i&lt;t; i+=2) printf(\"%d \", i);\n\n    p = n;\n    if (n%2 == 1) p--;\n    for(i=p; i&gt;=2; i-=2) printf(\"%d \", i);\n\n    if (n%2 == 1) printf(\"J %d \", t);\n    else printf(\"%d J \", t);\n\n    for(i=2; i&lt;=p; i+=2) printf(\"%d \", i);\n\n    for(i=2; i&lt;=j; i++) printf(\"J \");\n\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/02_trik/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva prirodana broja \\(N\\) i \\(K\\), koja redom ozna\u010davaju do kog broja Aleksa poseduje kartice, i broj d\u017eoker kartica.</p>"},{"location":"takprog/2017_2018/drz/02_trik/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu standardnog izlaza ispisati ta\u010dno \\(2 \\cdot N + K\\) oznaka kartica koje predstavljaju raspored tim redom. Oznaka kartice sa brojem je taj broj, dok je oznaka d\u017eoker kartice slovo \"J\". Ukoliko postoji vi\u0161e re\u0161enja, mo\u017eete ispisati bilo koje.</p>"},{"location":"takprog/2017_2018/drz/02_trik/#primeri","title":"Primeri","text":""},{"location":"takprog/2017_2018/drz/02_trik/#ulaz-1","title":"Ulaz 1","text":"<pre><code>3 4\n</code></pre>"},{"location":"takprog/2017_2018/drz/02_trik/#izlaz-1","title":"Izlaz 1","text":"<pre><code>1 J 1 2 J 3 2 J J 3\n</code></pre>"},{"location":"takprog/2017_2018/drz/02_trik/#ulaz-2","title":"Ulaz 2","text":"<pre><code>7 5\n</code></pre>"},{"location":"takprog/2017_2018/drz/02_trik/#izlaz-2","title":"Izlaz 2","text":"<pre><code>3 7 4 6 3 5 J 4 J 7 6 5 J J 2 J 1 2 1\n</code></pre>"},{"location":"takprog/2017_2018/drz/02_trik/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru imamo 3 para kartica sa brojevima 1 do 3, i 4 d\u017eokera. Jedan mogu\u0107i izlaz je: 1 J 1 2 J 3 2 J J 3 zbog toga \u0161to se izme\u0111u dve kartice sa brojem 1 nalazi ta\u010dno jedna kartica (J), izme\u0111u dve kartice sa brojem 2 se nalaze ta\u010dno dve kartice (J 3), izme\u0111u dve kartice sa brojem 3 se nalaze ta\u010dno tri kartice (2 J J).</p>"},{"location":"takprog/2017_2018/drz/02_trik/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(2 \\leq N, K \\leq 222222\\).</li> </ul> <p>Postoji pet podzadatka:</p> <ul> <li>Podzadatak \\(1\\) [\\(3\\) poena]: \\(N, K \\leq 4\\).</li> <li>Podzadatak \\(2\\) [\\(5\\) poena]: \\(N \\leq 8, K = 128\\).</li> <li>Podzadatak \\(3\\) [\\(32\\) poena]: \\(N, K \\leq 64\\).</li> <li>Podzadatak \\(4\\) [\\(22\\) poena]: \\(K = 22\\).</li> <li>Podzadatak \\(5\\) [\\(38\\) poena]: \\(K = 2\\).</li> </ul>"},{"location":"takprog/2017_2018/drz/03_esikez/","title":"B3 - Esikez","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Esikez je grad u kojem \u017eivi oko sto dvadeset miliona stanovnika. Kroz grad prolaze dva nadaleko poznata bulevara Naprolenez i Melkefrener. Na svakom od njih nalazi se veliki broj fontana. Ove fontane su neplanski gra\u0111ene hiljadama godina, pa je zato gradona\u010delnica odlu\u010dila da kona\u010dno celu ovu situaciju dovede u red. Sre\u0107om, za oba bulevara va\u017ei da na njemu ne postoje dve fontane iste boje. Vlast \u017eeli da sru\u0161i neke od fontana tako da nizovi fontana koji preostanu nakon ovog ru\u0161enja budu isti za oba bulevara, ta\u010dnije, od svih fontana koje preostanu, prva fontana sa Naproleneza treba da bude iste boje kao prva fontana sa Melkefrenera, druga fontana sa Naproleneza treba da bude iste boje kao druga fontana sa Melkefrenera, i tako dalje, i poslednja fontana sa Naproleneza treba da bude iste boje kao poslednja fontana sa Melkefrenera. Naravno, treba da ostane isti broj fontana na oba bulevara. Ako se sru\u0161e sve fontane, u tom slu\u010daju ne preostaje nijedna fontana pa i tad ka\u017eemo da su nizovi fontana jednaki.</p> <p>Pomozite gradona\u010delnici tako \u0161to \u0107ete joj re\u0107i koliko najmanje fontana treba da sru\u0161i.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Dragan Uro\u0161evi\u0107 Aleksa Plav\u0161i\u0107 <p>Lako se zaklju\u010duje da je potrebno odrediti najdu\u017ei zajedni\u010dki podniz za nizove koji predstavljaju boje fontana na dva bulevara iz zadatka. Tako\u0111e je dobro poznat algoritam baziran na dinami\u010dkom programiranju za odre\u0111ivanje najdu\u017eeg zajedni\u010dkog podniza dva data niza. Me\u0111utim, slo\u017eenost tog algoritma Je jednaka \\(\\Theta(NM)\\), gde su i du\u017eine ta dva niza.</p> <p>Ono \u0161to karakteri\u0161e ove nizove je \u010dinjenica da su u svakom od njih sve vrednosti me\u0111usobno razli\u010dite. Ozna\u010dimo sa \\(a\\) i \\(b\\) ta dva niza. Onda \u0107emo formirai tre\u0107i niz koji \u0107e imati isti broj elemenata kao niz \\(b\\), tako da je \\(c_i\\) indeks elementa niza \\(a\\) koji se poklapa sa elementom \\(b_i\\)  (ako takav element ne postoji onda \u0107e odgovaraju\u0107i element niza \\(c\\) imati vrednost \\(-1\\)). Ovo mo\u017eemmo izvesti tako \u0161to \u0107emo sortirati elemenete niza \\(a\\) uz priru\u017eivanje pozicija na kojima se nalaze u originalnom nizu, a zatim primeniti binarnu pretragu pri tra\u017eenju svakog od elemenata niza \\(b\\).</p> <p>Nakon toga \u0107emo iz niza \\(c\\) izbaciti sve element koji imaju vrednost \\(-1\\) i ono \u0161to je ostalo u nizu \\(c\\) su indeksi elemenata niza \\(a\\) koji se pojavljuju u nizu \\(b\\), ali ba\u0161 u redosledu u kome se pojavljuju (od po\u010detka prema kraju niza \\(b\\)). </p> <p>Nije te\u0161ko zaklju\u010diti da \u0107e du\u017eina najdu\u017eeg zajedni\u010dkog podniza za nizove \\(a\\) i \\(b\\) biti jednaka du\u017eini najdu\u017eeg rastu\u0107eg podniza (ne obavezno uzastopnih elemenata) niza \\(c\\).</p> <p>Najdu\u017ei rastu\u0107i niz niza \\(c\\) mo\u017eemo odrediti kori\u0161\u0107enjem dinami\u010dkog programiranja. Obra\u0111uje se jedan po jedan element niza \\(c\\) i nakon obrade \\(i\\)-tog elementa poznata je du\u017eina najdu\u017eeg rastu\u0107eg podinza za niz koga \u010dini prvih \\(i\\) elemenata niza \\(c\\) (neka je to h) i tako\u0111e za svako \\(g \\leq h\\) je poznata najmanja mogu\u0107a vrednost poslednjeg elementa u rastu\u0107em podnizu du\u017eine \\(g\\) )te vrednosti obrazuju niz koji \u0107emo nazvati \\(d\\)). Pri obradi \\(i+1\\)-og elementa niza \\(c\\) odre\u0111uje se najmanji indeks \\(g\\) sa osobinom da je \\(c_{i+1} &lt; d_g\\), To zna\u010di da je \\(d_{g-1} &lt; c_{i+1} &lt; d_g\\). Ako takav element ne postoji onda se \\(c_i\\) mo\u017ee dodati na kraj niza du\u017eine \\(h\\) i formirati rastu\u0107i podniz du\u017eine \\(h+1\\) (tj. vrednost za \\(h\\) se pove\u0107ava za 1 i vrednost odgovaraju\u0107eg \\(d_h\\) se izjedna\u010dava sa \\(c_{i+1}\\)). U suprotnom se mo\u017ee smanjiti vrednost \\(d_g\\) (tj. najmanja mogu\u0107a vrednost poslednjeg elementa u rastu\u0107em podnizu du\u017eine \\(g\\)).</p> <p>Ako na opisani na\u010din obradimo sve elemente niza \\(c\\), krajnja vrednost za \\(h\\) \u0107e biti du\u017eina najdu\u017eeg rastu\u0107eg podniza (tj. re\u0161enje na\u0161eg zadatka). Slo\u017eenost opisanog algoritma je \\(O(N\\log N)\\).</p> 03_esikez.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, k;\npair&lt;int, int&gt; a[200005];\nint b[200005];\nint bsel[200005];\nint dp[200005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i=0; i&lt;n; i++) {\n        cin &gt;&gt; a[i].first;\n        a[i].second = i;\n    }\n    for (int i=0; i&lt;m; i++)\n        cin &gt;&gt; b[i];\n\n    sort(a, a+n);\n\n    for (int i=0; i&lt;m; i++) {\n        auto p = lower_bound(a, a+n, pair&lt;int, int&gt;(b[i], -1));\n        if (p != a+n &amp;&amp; p-&gt;first == b[i]) {\n            bsel[k++] = p-&gt;second;\n        }\n    }\n\n    int h = 0;\n    for (int i=0; i&lt;k; i++) {\n        auto p = lower_bound(dp+1, dp+h+1, bsel[i]);\n        *p = bsel[i];\n        if (p == dp+h+1)\n            h++;\n    }\n    cout &lt;&lt; n+m-h-h &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/03_esikez/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva prirodna broja \\(N, M\\) odvojena razmakom - broj fontana na Naprolenezu i Melkefreneru, redom. U narednom redu nalazi se \\(N\\) prirodnih brojeva \\(a_i\\) odvojenih razmakom, koji predstavljaju boje fontana na Naprolenezu. U narednom redu nalazi se \\(M\\) prirodnih brojeva \\(b_i\\) odvojenih razmakom, koji predstavljaju boje fontana na Melkefreneru.</p>"},{"location":"takprog/2017_2018/drz/03_esikez/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati najmanji broj fontana koje treba sru\u0161iti tako da se dobiju isti nizovi fontana na oba bulevara.</p>"},{"location":"takprog/2017_2018/drz/03_esikez/#primer","title":"Primer","text":""},{"location":"takprog/2017_2018/drz/03_esikez/#ulaz","title":"Ulaz","text":"<pre><code>4 6\n4 2 1 6\n3 2 5 9 6 1\n</code></pre>"},{"location":"takprog/2017_2018/drz/03_esikez/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2017_2018/drz/03_esikez/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ru\u0161imo fontane na slede\u0107i na\u010din:</p> <pre><code>. 2 1 .\n. 2 . . . 1\n</code></pre> <p>Dobijaju se nizovi \\(2,1\\). Nije mogu\u0107e sru\u0161iti manje od \\(6\\) fontana.</p>"},{"location":"takprog/2017_2018/drz/03_esikez/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq N, M \\leq 200000\\).</li> <li>\\(1 \\leq a_i, b_i \\leq 2 \\times 10^9\\).</li> <li>\\(a_i \\neq a_j\\) za svako \\(i, j\\), \\(1 \\leq i &lt; j \\leq N\\).</li> <li>\\(b_i \\neq b_j\\) za svako \\(i, j\\), \\(1 \\leq i &lt; j \\leq M\\).</li> </ul> <p>Postoji \u0161est podzadataka:</p> <ul> <li>Podzadatak \\(1\\) [\\(3\\) poena]: \\(N, M \\leq 2\\).</li> <li>Podzadatak \\(2\\) [\\(11\\) poena]: \\(N+M \\leq 20\\).</li> <li>Podzadatak \\(3\\) [\\(10\\) poena]: \\(N \\leq 18\\).</li> <li>Podzadatak \\(4\\) [\\(21\\) poen]: \\(N, M \\leq 1000\\)</li> <li>Podzadatak \\(5\\) [\\(14\\) poena]: \\(N, M \\leq 10000\\)</li> <li>Podzadatak \\(6\\) [\\(41\\) poen]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/drz/04_super_velika/","title":"A1 - Super velika matrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 64MB <p>Zli duh Milojica je re\u0161io da uni\u0161ti veliki grad Pajazitovo. Pajazitovo je zanimljiv grad, sastoji se samo od zgrada. Ukupno se nalazi \\(n\\) zgrada u Pajazitovu, visina \\(i\\)-te zgrade iznosi \\(A_i\\). Kako je uni\u0161tenje jednog tako kompleksnog grada veoma te\u0161ko, Milojica je u pohod pozvao i njegovih \\(m\\) dece. Svako dete ima sposobnost da jednim strujnim udarom smanji visinu zgrade u odre\u0111enom intervalu za \\(1\\). Dete sa rednim brojem \\(i\\) mo\u017ee smanjiti visine zgrada u intervalu [\\(L_i, R_i\\)]. Mali duhovi jako slaba\u0161na stvorenja, oni mogu ograni\u010den broj puta da iskoriste strujni udar. Dete sa rednim brojem \\(i\\) mo\u017ee iskoristiti ne vi\u0161e od \\(K_i\\) strujnih udara, nakon toga trajno gubi tu mo\u0107. Jednu zgradu mo\u017ee napasti vi\u0161e duhova, i svaki duh mo\u017ee napasti vi\u0161e zgrada.</p> <p>Kako Milojica nije tako dobar sa matematikom, zamolio vas je da ispitate da li njegovih \\(m\\) dece mogu uni\u0161titi Pajazitovo u potpunosti. Pajazitovo se smatra uni\u0161tenim u potpunosti ako sve zgrade imaju visinu \\(0\\).</p> <p>\u0160ta vi\u0161e Milojica nije siguran koji grad je ta\u010dno Pajazitovo(duhovi sa toliko dece znaju ponekad da pome\u0161aju gradove), tako da \u017eeli da sakupi informacije o mogu\u0107em uni\u0161tenju \\(t\\) razli\u010ditih gradova.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Ivan Sto\u0161i\u0107 <p>Ovaj problem se mo\u017ee re\u0161iti kori\u0161\u0107enjem pohlepnog algoritma. Ru\u0161imo redom zgrade po\u010dev\u0161i od prve. Ako trenutno ru\u0161imo \\(i\\)-tu zgradu onda mo\u017eemo odrediti skup dece \\(\\{j_1, j_2, ..., j_p\\}\\) koji mogu da u\u010destvuju u ru\u0161enju te zgrade (tj. broj \\(i\\) pripada intervalima zgrada koje mogu ru\u0161iti ta deca-duhovi). Ako ne postoji nijedno dete koje mo\u017ee ru\u0161iti tu zgradu, onda grad ne mo\u017ee biti uni\u0161ten. Ako postoji bar jedno dete koje mo\u017ee ru\u0161iti tu zgradu, onda biramo ono dete iz skupa \\(\\{j_1, j_2, ..., j_p\\}\\) koje ima najmanju vrednost za \\(R\\), odnosno \u010diji interval zgrada koje mo\u017ee ru\u0161iti se najranije zavr\u0161ava. </p> <p>Ako je broj preostalih spratova manji od broja strujnih udara koje ima na raspolaganju to dete, onda uni\u0161timo zgradu, notiramo da se broj strujnih udara tog deteta smanjio za broj poru\u0161enih spratova i prelazimo na slede\u0107u zgradu. </p> <p>Ako je broj strujnih udara manji ili jednak od visine te zgrade, onda primenimo sve strujne udare tog deteta i smanjimo visinu zgrade za broj primenjenih strujnih udara. Kako je to dete ve\u0107 potro\u0161ilo svoju mo\u0107, izbacujemo ga iz skupa dece koju mo\u017eemo koristiti za ru\u0161enje. Ako je visina zgrade postala nula, onda je ona poru\u0161ena i prelazimo na slede\u0107i zgradu. </p> <p>Pri prelasku na slede\u0107u zgradu, moramo a\u017eurirati skup dece koja mogu biti kori\u0161\u0107ena za ru\u0161enje: izbacuju se ona deca kod kojih je desni kraj intervala manji od trenutne zgrade i dodaju deca \u010diji je levi kraj jednak indeksu te zgrade. </p> <p>Da bi ubrzali taj postupak dodavanja dece koju mo\u017eemo koristiti za ru\u0161enje, deca se na po\u010detku sortiraju po levim krajevima intervala. </p> <p>Kako bi efikasno birali dete koje \u0107e ru\u0161iti zgradu (tj. dete koje ima najmanji desni kraj), decu koja mogu ru\u0161iti trenutnu zgradu dr\u017eimo u prioritetnom redu. Slo\u017eenost dela za sortiranje dece je \\(O(n\\log n)\\), a slo\u017eenost ru\u0161enja \u0107e biti \\(O((n+m)\\log n)\\)</p> 04_super_velika.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxi=5e5+5;\n\npriority_queue&lt;pair&lt;int,int&gt;&gt; pq;\nint l[maxi],r[maxi],k[maxi],a[maxi];\nint n,m;\nvector&lt;int&gt; v[maxi];\n\nvoid clear()\n{\n    for (int i=1;i&lt;=n+1;i++)\n        v[i].clear();\n\n    while(!pq.empty())\n        pq.pop();\n}\nvoid solve()\n{\n  scanf(\"%d%d\",&amp;n,&amp;m);\n  clear();\n\n  for (int i=1;i&lt;=n;i++)\n    scanf(\"%d\",&amp;a[i]);\n\n  for (int i=1;i&lt;=m;i++)\n  {\n      scanf(\"%d\",&amp;l[i]);\n      v[l[i]].push_back(i);\n  }\n  for (int i=1;i&lt;=m;i++)\n      scanf(\"%d\",&amp;r[i]);\n\n  for (int i=1;i&lt;=m;i++)\n      scanf(\"%d\",&amp;k[i]);\n\n  for (int i=1;i&lt;=n;i++)\n  {\n      for (int j:v[i])\n      pq.push({-r[j],j});\n\n      while(a[i]&gt;0 &amp;&amp; !pq.empty())\n      {\n          pair&lt;int,int&gt; value=pq.top();\n          int idx= value.second;\n          pq.pop();\n          if (r[idx]&gt;=i)\n          {\n              int sub=min(k[idx],a[i]);\n              k[idx]-=sub;\n              a[i]-=sub;\n              if (k[idx]&gt;0) pq.push({-r[idx],idx});\n          }\n      }\n\n      if (a[i]&gt;0)\n      {\n          printf(\"NE\\n\");\n          return;\n      }\n  }\n\n  printf(\"DA\\n\");\n  return;\n}\n\nint main()\n{\n    int t;\n    cin&gt;&gt;t;\n\n    while(t--)\n        solve();\n\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/04_super_velika/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(t\\), broj gradova za koje je potrebno ispitati da li je mogu\u0107e uni\u0161tenje.</p> <p>Svaki od \\(t\\) gradova je opisan sa \\(5\\) linija:</p> <p>U prvoj liniji se nalaze prirodni brojevi \\(n\\), \\(m\\), broj zgrada u Pajazitovu i broj Miloji\u010dine dece.</p> <p>U drugoj liniji se nalazi niz \\(A\\) od \\(n\\) brojeva, \\(A_1\\), \\(A_2\\), \\(\\dots\\), \\(A_n\\), visine svake od \\(n\\) zgrada redom.</p> <p>U tre\u0107oj liniji se nalazi niz \\(L\\) od \\(m\\) brojeva, \\(L_1\\), \\(L_2\\), \\(\\dots\\), \\(L_m\\), levi krajevi intervala za svako dete.</p> <p>U \u010detvrtoj liniji se nalazi niz \\(R\\) od \\(m\\) brojeva, \\(R_1\\), \\(R_2\\), \\(\\dots\\), \\(R_m\\), desni krajevi intervala za svako dete.</p> <p>U petoj liniji se nalazi niz \\(K\\) od \\(m\\) brojeva, \\(K_1\\), \\(K_2\\), \\(\\dots\\), \\(K_m\\), maksimalni broj strujnih udara za svako dete.</p>"},{"location":"takprog/2017_2018/drz/04_super_velika/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardnom izlazu u \\(t\\) linija ispisati re\u0161enje zadatka. U \\(i\\)-toj liniji ispisati <code>DA</code> ukoliko Miloji\u010dina deca mogu uni\u0161titi \\(i\\)-ti grad, u suprotnom ispisati <code>NE</code>.</p>"},{"location":"takprog/2017_2018/drz/04_super_velika/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/drz/04_super_velika/#ulaz","title":"Ulaz","text":"<pre><code>2\n3 2\n1 4 2\n1 2\n3 3\n3 4\n1 1\n10\n1\n1\n6\n</code></pre>"},{"location":"takprog/2017_2018/drz/04_super_velika/#izlaz","title":"Izlaz","text":"<pre><code>DA\nNE\n</code></pre>"},{"location":"takprog/2017_2018/drz/04_super_velika/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>\u017delimo da saznamo informacije za \\(2\\) grada.</p> <p>U prvom gradu postoje tri zgrade visina redom (\\(1, 4, 2\\)), Milojica vodi \\(2\\) deteta. Prvo dete mo\u017ee napadati bilo koju zgradu u intervalu [\\(1, 3\\)] i mo\u017ee da izvr\u0161i najvi\u0161e \\(3\\) strujna udara. Drugo dete mo\u017ee napadati zgrade u intervalu [\\(2, 3\\)] i ukupno mo\u017ee izvr\u0161iti \\(4\\) strujna udara. Deca mogu uni\u0161titi zgrade u potpunosti, jedan od mogu\u0107ih redosleda operacija:</p> <ul> <li>prvo dete izvr\u0161i \\(1\\) strujni udar na prvoj zgradi i uni\u0161ti prvu zgradu</li> <li>drugo dete izvr\u0161i \\(4\\) strujna udara na drugoj zgradi i uni\u0161ti drugu zgradu </li> <li>prvo dete izvr\u0161i preostala \\(2\\) strujna udara na tre\u0107oj zgradi i uni\u0161ti tre\u0107u zgradu</li> </ul> <p>U drugom gradu postoji samo jedna zgrada visine \\(10\\) i Milojica ima jedno dete koje mo\u017ee smanjiti visinu zgrade najvi\u0161e za \\(6\\). Nije mogu\u0107e uni\u0161titi zgradu u potpunosti.</p>"},{"location":"takprog/2017_2018/drz/04_super_velika/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq t \\leq 7\\).</li> <li>\\(1 \\leq n,m \\leq 10^5\\).</li> <li>\\(1 \\leq A_i, K_i \\leq 10^9\\).</li> <li>\\(1 \\leq L_i \\leq R_i \\leq n\\).</li> </ul> <p>Postoje tri podzadatka: </p> <ul> <li>Podzadatak \\(1\\) [\\(20\\) poena]: \\(1 \\leq n, m, A_i \\leq 100\\).</li> <li>Podzadatak \\(2\\) [\\(30\\) poena]: \\(1 \\leq n, m \\leq 10^3\\).</li> <li>Podzadatak \\(3\\) [\\(50\\) peona]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/","title":"A2 - Sort na stablu","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Nakon potpunog uni\u0161tenja Pajazitova, duh Milojica je re\u0161io da po\u010dasti svoju decu zlatnicima. On je spremio za svako od \\(n\\) dece po jedan zlatnik. Zlatnici su numerisani brojevima od \\(1\\) do \\(n\\), i na svakom zlatniku je napisan njegov jedinstven broj. Broj na zlatniku ozna\u010dava indeks deteta kojem je Milojica namenio taj zlatnik. Kako su mali duhovi veoma disciplinovana stvorenja oni su se pore\u0111ali u niz du\u017eine \\(n\\) sortirano rastu\u0107e po indeksu. Na\u017ealost, Milojica nije verovao u svoju decu i zlatnike je pore\u0111ao u nekom poretku koji ne mora biti rastu\u0107i. Da bi izbegao nezadovoljstvo svoje dece, on mora sortirati niz zlatnika u rastu\u0107em poretku. Za ovaj poduhvat on koristi jedno stablo sa \\(m\\) \u010dvorova koje je preko korena (\u010dvora numerisanog sa \\(1\\)) povezano sa prvom pozicijom u nizu zlatnika.</p> <p>U jednom potezu Milojica mo\u017ee pomeriti jedan zlatnik na susedno polje ako se u tom trenutku na tom polju ne nalazi nijedan zlatnik. Pod poljem smatramo neku poziciju u nizu zlatnika ili neki \u010dvor u stablu. Primetimo da sa pozicije \\(1\\) u nizu, zlatnik mo\u017eemo pomeriti na poziciju \\(2\\) ili u koren stabla. Sli\u010dno, iz korena stabla zlatnik mo\u017eemo pomeriti u neko od njegove dece ili na poziciju \\(1\\) u nizu.</p> <p>Postavlja se jednostavno pitanje: Da li Milojica nakon kona\u010dno mnogo koraka mo\u017ee rastu\u0107e sortirati svoje zlatnike? Kako su duhovi malo zaboravna bi\u0107a, Milojica nije siguran koji je ta\u010dno poredak zlatnika ostavio i kako izgleda stablo povezano sa nizom, pa vas je zamolio da odgovorite na tra\u017eeno pitanje za \\(t\\) razli\u010ditih rasporeda zlatnika i izgleda stabla.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an \u017divanovi\u0107 Aleksa Plav\u0161i\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107 <p>Ako razmislimo o na\u010dinima na koje se stablo mo\u017ee koristiti pri sortiranju prirodno se name\u0107u zamene, pa umesto originalnog problema sortiranja posmatrajmo prvo problem zamene dva susedna elementa iz niza, konkretno zlatnika na indeksima \\(k-1\\) i \\(k\\). Nazovimo \u010dvor stabla najbli\u017ei korenu koji ima vi\u0161e od jednog sina ra\u010dva. Zamenu zlatnika vr\u0161imo tako \u0161to premestimo deo niza zaklju\u010dno sa indeksom \\(k-2\\) negde u dubinu stabla, zatim postavimo zlatnike sa indeksima \\(k-1\\) i \\(k\\) u razli\u010dita podstabla ra\u010dve, vratimo ih u niz u obrnutom redosledu, i zatim vratimo deo niza zaklju\u010dno sa indeksom \\(k-2\\) (istim redom). Potreban i dovoljan uslov za ovo je da podstablo ra\u010dve (ne uklju\u010duju\u0107i samu ra\u010dvu) ima barem \\(k\\) elemenata. Lako se vidi da u suprotnom zlatnici na indeksima \\(k-1\\) i \\(k\\) nikada ne mogu zameniti mesta.</p> <p>Sada kada znamo proceduru za zamenu dva susedna zlatnika algoritmom nalik na bubble sort izvodimo sortiranje celog niza. Sortiranje je mogu\u0107e ukoliko je mogu\u0107a zamena para susednih zlatnika sa najve\u0107im indeksima (primetimo da ovo nisu uvek zlatnici \\(n-1\\) i \\(n\\), jer neki sufiks niza mo\u017ee biti ve\u0107 sortiran). Prostim pore\u0111enjem veli\u010dine podstabla ra\u010dve i indeksa poslednjeg zlatnika koji nije na svom mestu dobijamo odgovor na upit.</p>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(t\\), broj upita za koje \u017eelimo da ispitamo mogu\u0107nost sortiranja.</p> <p>Svaki upit je opisan na slede\u0107i na\u010din:</p> <p>U prvoj liniji upita nalazi se prirodan broj \\(n\\), broj zlatnika i broj Miloji\u010dine dece.</p> <p>U drugoj liniji upita nalazi se permutacija brojeva \\(\\{1, 2, \\dots, n\\}\\): \\(p_1, p_2, \\dots, p_n\\), po\u010detni raspored zlatnika u nizu.</p> <p>U tre\u0107oj liniji upita nalazi se prirodan broj \\(m\\), broj \u010dvorova u stablu.</p> <p>Narednih \\(m-1\\) linija sadr\u017ee po dva broja \\(u_i\\), \\(v_i\\), parove povezanih \u010dvorova u stablu.  </p>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(t\\) linija koje predstavljaju odgovore na upite. U \\(i\\)-toj liniji ispisati <code>DA</code> ako je u \\(i\\)-tom upitu mogu\u0107e rastu\u0107e sortirati niz zlatnika, a u suprotnom ispisati <code>NE</code>.</p>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#ulaz","title":"Ulaz","text":"<pre><code>2\n3\n3 1 2\n4\n1 2\n2 3\n1 4\n3\n3 2 1\n2\n2 1\n</code></pre>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#izlaz","title":"Izlaz","text":"<pre><code>DA\nNE\n</code></pre>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi upit izgleda kao na slici. Milojica ima tri deteta i tri zlatnika. Zlatnici su pore\u0111ani u redosledu \\([3, 1, 2]\\). Stablo ima \u010detiri \u010dvora. </p> <p>Jedan od mogu\u0107ih algoritama sortiranja bi imao slede\u0107e korake:</p> <ol> <li>Pomeriti zlatnik sa brojem \\(3\\) koji se nalazi na poziciji \\(1\\) u nizu najpre u koren stabla (\u010dvor numerisan sa \\(1\\)), nakon toga u \u010dvor numerisan sa \\(4\\).</li> <li>Pomeriti zlatnik sa brojem \\(1\\) koji se nalazi na poziciji \\(2\\) u nizu najpre na poziciju \\(1\\) u nizu, nakon toga u koren stabla, potom u \u010dvor numerisan sa \\(2\\) i na kraju u \u010dvor numerisan sa \\(3\\).</li> <li>Pomeriti zlatnik sa brojem \\(2\\) koji se nalazi na poziciji \\(3\\) u nizu najpre na poziciju \\(2\\), nakon toga na poziciju \\(1\\), posle toga u koren stabla i najzad u \u010dvor numerisan sa \\(2\\).</li> <li>Vratiti zlatnik sa brojem \\(3\\) koji se nalazi u \u010dvoru numerisanom sa \\(4\\) prvo u koren stabla, nakon toga na poziciju \\(1\\) u nizu, pa na poziciju \\(2\\) i na kraju na poziciju \\(3\\).</li> <li>Vratiti zlatnik sa brojem \\(2\\) koji se nalazi u \u010dvoru numerisanom sa \\(2\\) prvo u koren stabla, nakon toga na poziciju \\(1\\) u nizu i na kraju na poziciju \\(2\\).</li> <li>Vratiti zlatnik sa brojem \\(1\\) koji se nalazi u \u010dvoru numerisanom sa \\(3\\) prvo u \u010dvor numerisan sa \\(2\\), nakon toga u koren stabla i na kraju na poziciju \\(1\\) u nizu.</li> </ol> <p>Nakon navedenih operacija niz zlatnika \u0107e biti sortiran rastu\u0107e, pa je odgovor na ovaj upit <code>DA</code>.</p> <p>U drugom upitu imamo permutaciju zlatnika sortiranu u opadaju\u0107em poretku i stablo sa dva \u010dvora. Kako god pomerali zlatnike nije mogu\u0107e sortirati ih rastu\u0107e, pa je odgovor <code>NE</code>.</p>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq t \\leq 7\\).</li> <li>\\(1 \\leq n,m \\leq 10^5\\).</li> <li>\\(1\\leq p_i \\leq n\\).</li> <li>\\(1 \\leq u_i, v_i \\leq m\\).</li> <li>\\(u_i \\neq v_i\\).</li> </ul> <p>Postoje \u010detiri podzadatka:</p> <ul> <li>Podzadatak \\(1\\) [\\(12\\) poena]:  \\(n=3\\), \\(m=4\\).</li> <li>Podzadatak \\(2\\) [\\(18\\) poena]: \\(1 \\leq n\\leq 5\\), \\(1\\leq m \\leq 7\\).</li> <li>Podzadatak \\(3\\) [\\(25\\) poena]: Samo koren stabla mo\u017ee da ima vi\u0161e od jednog deteta.</li> <li>Podzadatak \\(4\\) [\\(45\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#napomena","title":"Napomena","text":"<p>Stablo je neusmeren povezan graf sa \\(m\\) \u010dvorova i \\(m-1\\) veza. Koren stabla je \u010dvor koji nema svog pretka u stablu.</p>"},{"location":"takprog/2017_2018/drz/05_sort_na_stablu/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Oba broja potrebna za re\u0161avanje upita mo\u017eemo jednostavno na\u0107i. Jednim prolazom kroz niz zlatnika nalazimo poslednji indeks \\(k\\) takav da je \\(p_k \\neq k\\). Prolaskom kroz stablo nalazimo ra\u010dvu i veli\u010dinu odgovaraju\u0107eg podstabla, \\(R\\). Za \\(R &gt;= k\\) ispisujemo \\(DA\\), a u suprotnom \\(NE\\). U zadacima sa vi\u0161e upita tj. vi\u0161e test primera po jednom pokretanju programa va\u017eno je posebnu pa\u017enju obratiti na globalno stanje programa koje je neophodno reset-ovati izme\u0111u test primera. U ovom zadatku bi primer bio broj dece za svaki \u010dvor u stablu - ukoliko zaboravimo da anuliramo ovo polje mo\u017eemo dobiti neo\u010dekivane rezultate.</p> 05_sort_na_stablu.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxi=1e6+2;\nvector&lt;int&gt; v[maxi];\nint ans,n,m;\nint p[maxi];\n\nvoid ocisti()\n{\n    for (int i=1; i&lt;=m;i++)\n        v[i].clear();\n    ans=0;\n}\nvoid dfs(int x, int pred)\n{\n    int sz=0;\n    int last=0;\n    ans++;\n    for (int i:v[x])\n        if (i!=pred)\n        {\n            sz++;\n            last=i;\n        }\n\n    if (sz==1) dfs(last,x);\n    return;\n}\n\nvoid solve()\n{\n    scanf(\"%d\",&amp;n);\n\n    for (int i=1; i&lt;=n; i++)\n        scanf(\"%d\",&amp;p[i]);\n\n    scanf(\"%d\",&amp;m);\n    ocisti();\n\n    for (int i=1; i,i&lt;m; i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&amp;x,&amp;y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    int poz=0;\n    for (int i=1; i&lt;=n; i++)\n        if (p[i]!=i) poz=i;\n\n    dfs(1,0);\n    ans=m-ans;\n    if (ans&gt;=poz) printf(\"DA\\n\");\n    else\n        printf(\"NE\\n\");\n\n    return;\n}\nint main()\n{\n    int t;\n    cin&gt;&gt;t;\n\n    while(t--)\n        solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/06_obaranje/","title":"A3 - Obaranje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Poznato je da svaki novi \u010dlan Komisije mora da polo\u017ei drevni ispit isku\u0161enja kako bi postao punopravni \u010dlan i ujedno nau\u010dio da vozi. Ispitom isku\u0161enja rukovodi drevni \u010dlan komisije - Instruktor, a ispit se pola\u017ee na slede\u0107i na\u010din. U ravni se postavi komisiomobil (koga mo\u017eemo zamisliti kao pravougaonik sa stranicama paralelnim koordinatnim osama) i \\(N\\) takmi\u010dara koji su pisali bar jednu \u017ealbu (koje mo\u017eemo zamisliti kao ta\u010dke jer su mali i bezna\u010dajni). Kandidat seda u komisiomobil i cilj je da potisne svoju mr\u017enju prema \u017ealbama i ne obori nijednog takmi\u010dara. Prolaznost na ispitu je vrlo niska...</p> <p>Do\u0161ao je red i na mladog Zokija Obara\u010da da proba da polo\u017ei ispit. Me\u0111utim, Instruktor zna da je Zokijeva mr\u017enja prema \u017ealbama previ\u0161e jaka i da \u0107e ovog puta biti ozbiljnijih povreda. Zato je odlu\u010dio da blokira komisiomobil tako \u0161to \u0107e probosti svoj drevni anti-\u017ealbeni \u0161tap kroz jednu njegovu ta\u010dku (unutar ili na ivici pravougaonika) - time \u0107e komisiomobil mo\u0107i samo da se (stalno) okre\u0107e oko te ta\u010dke. Naravno, mogu\u0107e je da \u0107e tim okretanjem biti oboreno nekoliko takmi\u010dara - ka\u017eemo da je takmi\u010dar oboren ako se u nekom trenutku na\u0111e unutar ili na granici komisiobila dok se ovaj okre\u0107e. Instruktor ra\u010duna da je to bolje nego dati Zokiju odre\u0161ene ruke...</p> <p>Na vama je da pomognete Instruktoru -- odredite koliko najmanje takmi\u010dara mora biti oboreno pri optimalnom izboru ta\u010dke probadanja pravougaonika. Ukoliko pomognete Instruktoru, dobijate ve\u0107e \u0161anse za pre\u017eivljavanje ukoliko se \u017ealite i budete izabrani kao statisti za neki od budu\u0107ih ispita...</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Du\u0161an Zdravkovi\u0107 <p>Ozna\u010dimo (proizvoljnu) ta\u010dku probadanja sa \\(T\\) i neka je njeno rastojanje do najudaljenijeg temena pravougaonika jedanko \\(r_T\\). Nije te\u0161ko zaklju\u010diti da, okretanjem oko ta\u010dke probadanja, pravougaonik pokriva povr\u0161 koja je zapravo krug \\(K(T, r_T)\\) sa centrom u \\(T\\) i polupre\u010dnikom \\(r_T\\). Dakle, treba izabrati ta\u010dku \\(T\\) unutar pravougaonika takvu da krug (uklju\u010duju\u0107i i granicu) \\(K(T, r_T)\\) sadr\u017ei \u0161to manje od datih \\(N\\) ta\u010daka; ozna\u010dimo broj ta\u010dka unutar pomenutog kruga sa \\(c(T)\\) a sa \\(opt\\) - optimalno re\u0161enje (koje treba izra\u010dunati).</p> <p>Neka su temena pravougaonika \\(ABCD\\), njegov centar \\(O\\) a \\(P_1\\), \\(P_2\\), \\(P_3\\) i \\(P_4\\), redom, sredi\u0161ta stranica \\(BC\\), \\(CD\\), \\(DA\\) i \\(AB\\). Ozna\u010dimo sa \\(a\\) du\u017e \\(P_1P_3\\) (horizontalna srednja linija) a sa \\(b\\) du\u017e \\(P_2P_4\\) (vertikalna srednja linija). Neka su ta\u010dke u kojima su takmi\u010dari \\(Q_1, Q_2, \\ldots, Q_N\\). Iako se najmanja vrednost \\(r_T\\) dosti\u017ee kada je \\(T = O\\), nama nije bitan samo polupre\u010dnik ve\u0107 i pozicija kruga. Slede\u0107a lema predstavlja klju\u010dno zapa\u017eanje:</p> <p>Lema: Postoji ta\u010dka \\(T\\) koja pripada \\(a \\cup b\\) i za koju je \\(c(T) = opt\\).</p> <p>Zaista, posmatrajmo bilo koju optimalnu ta\u010dku probadanja \\(T\\) -- neka je, bez umanjenja op\u0161tosti, u donjem-desnom \"kvadrantu\" tj. pravougaoniku \\(P_4BP_1O\\). Tada je odgovaraju\u0107i krug \\(K(T, |TD|)\\). Neka je \\(T'\\) prese\u010dna ta\u010dka du\u017ei \\(TD\\) i \\(a \\cup b\\) (ako ih ima vi\u0161e, neka je to prese\u010dna ta\u010dka bli\u017ea \\(T\\)). Nije te\u0161ko uo\u010diti da se probadanjem u ta\u010dki \\(T'\\) dobija krug \\(K'(T', |T'D|)\\) koji je ceo sadr\u017ean u krugu \\(K(T, |TD|)\\) pa va\u017ei \\(c(T') \\leq c(T)\\). Dakle, zaista je dovoljno razmatrati samo ta\u010dke na \"srednjim linijama pravougaonika\" za optimalnu ta\u010dku probadanja.</p> <p>Najlak\u0161i na\u010din je razlikovanje 4 slu\u010daja tj. tra\u017eenje optimalne ta\u010dke na du\u017eima \\(OP_1\\), \\(OP_2\\), \\(OP_3\\) i \\(OP_4\\). Razmotrimo slu\u010daj kada je ta\u010dka \\(T\\) na \\(OP_1\\) -- tada \u0107e polupre\u010dnik kruga biti \\(|TD|\\). Neka su \\(x\\)-koordinate ta\u010daka \\(O\\) i \\(P_1\\), redom, \\(L\\) i \\(R\\). Neka je \\(Q_i\\) proizvoljna ta\u010dka i neka je \\(X_i\\) presek du\u017ei \\(OP_1\\) i simetrale du\u017ei \\(Q_iD\\) (ukoliko presek postoji). Da bi ta\u010dka \\(Q_i\\) bila van kruga \\(K(T, |TD|)\\), ta\u010dka \\(T\\) mora biti sa \"prave strane\" ta\u010dke \\(X_i\\); preciznije, ako je \\(Q_i\\) \"levo\" od stranice \\(CD\\), mora va\u017eiti \\(T \\in (X_i, R)\\) a ako je \\(Q_i\\) \"desno\" od \\(CD\\), mora va\u017eiti \\(T \\in (L, X_i)\\). </p> <p></p> <p>Na ovaj na\u010din dobijamo najvi\u0161e \\(N\\) podintervala intervala \\((L, R)\\) i zadatak se svodi na odabir ta\u010dke iz \\((L, R)\\) koju sadr\u017ei najvi\u0161e pomenutih intervala (odgovaraju\u0107i krug sa centrom u toj ta\u010dki ne\u0107e sadr\u017eati ta\u010dno one ta\u010dke koje odgovaraju intervalima koje sadr\u017ee taj centar). Ovo se mo\u017ee re\u0161iti na nekoliko na\u010dina a najlak\u0161i je sortirati krajeve intervala, svim levim krajevima dodeliti \\(+1\\), svim desnim \\(-1\\) i odabrati ta\u010dku tako da je suma krajeva intervala levo od nje najve\u0107a mogu\u0107a. Slo\u017eenost ovog algoritma je \\(O(N \\log N)\\) zbog sortiranja.</p> <p>Za lak\u0161u implementaciju pomenutog algoritma, korisno je na po\u010detku translirati sliku tako da je centar pravougaonika u \\((0,0)\\). Dodatno, isti algoritam se mo\u017ee iskoristiti 4 puta (uvek tra\u017eenje centra na du\u017ei \\(OP_1\\)) pri \u010demu se pre svakog poziva cela slika rotira \\(90^\\circ\\) ulevo. Tra\u017eenje odgovaraju\u0107ih ta\u010daka \\(X_i\\) na du\u017ei \\(OP_1\\) se mo\u017ee uraditi jednostavnom analiti\u010dkom geometrijom (ukoliko je slika centrirana i za ta\u010dku \\(Q_i=(x_i,y_i)\\) va\u017ei \\(x_i \\neq x_D\\), tada je presek odgovaraju\u0107e simetrale sa \\(x\\)-osom upravo u ta\u010dki \\(X_i = \\frac{1}{2}(\\frac{(y_i - y_D)(y_i+y_D) + (x_i + x_D)(x_i -x_D)}{x_i - x_D})\\) ); vrednost \\(X_i\\) je mogu\u0107e odrediti i ternarnom pretragom - tra\u017eenje ta\u010dke (na datoj du\u017ei) koja je podjednako udaljena od \\(D\\) i \\(Q_i\\).</p> <p>Podzadaci: za prvi podzadatak je uvek optimalno da centar bude u sredi\u0161tu du\u017ei \\(AB\\) (donja stranica pravougaonika). Za drugi podzadatak je dovoljna analiza nekoliko slu\u010dajeva (\u0161to se svodi na proveru da li dva intervala imaju presek). U tre\u0107em podzadatku je dovoljno ispitati da li postoji ta\u010dka koja je sadr\u017eana u svim intervalima \u0161to se mo\u017ee uraditi jednostavnije u \\(O(N)\\); tako\u0111e, mogu\u0107 je i slede\u0107i pristup: za svaku ta\u010dku \\(Q_i\\) odredimo geometrijsko mesto ta\u010daka optimalnog centra tako da odgovaraju\u0107i krug ne sadr\u017ei datu ta\u010dku - mo\u017ee se pokazati da je taj skup ta\u010daka u op\u0161tem slu\u010daju \u010detvorougao; zatim proverimo da li je presek svih takvih skupova neprazan. U \u010detvrtom podzadatku je je dovoljno odrediti tra\u017eenu ta\u010dku na intervalu \\((L,R)\\) u slo\u017eenosti \\(O(N^2)\\).</p> 06_obaranje.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAX_N = 100010;\nconst double EPS = 1e-8;\n\nstruct point\n{\n    point() {}\n    point(int x1, int y1) : x(x1), y(y1) {}\n    int x, y;\n};\n\nstruct pointVal\n{\n    pointVal() {}\n    pointVal(double x1, int v1) : x(x1), val(v1) {}\n    double x;\n    int val;\n};\n\npoint points[MAX_N];\nint n;\nint x, y, a, b;\nint opt_sol;\n\ndouble eq(double a, double b)\n{\n    return (fabs(a - b) &lt; EPS);\n}\n\nbool cmp(pointVal&amp; A, pointVal&amp; B)\n{\n    if (!eq(A.x, B.x))\n        return A.x &lt; B.x;\n    return A.val &gt; B.val;\n}\n\n// rotacija za 90 stepeni ulevo, (x, y) -&gt; (-y, x)\nvoid rotatePlane(int n, int&amp; w, int&amp; h, point p[])\n{\n    swap(w, h);\n    w = -w; h = -h;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        swap(p[i].x, p[i].y);\n        p[i].x = -p[i].x;\n    }\n}\n\nint outside(int cx, int cy, int x, int y, int n, point p[])\n{\n    int ret = 0;\n    long long rSqr = ((long long)cx - x) * ((long long)cx - x) + ((long long)cy - y) * ((long long)cy - y);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        long long distSqr = ((long long)cx - p[i].x) * ((long long)cx - p[i].x) + ((long long)cy - p[i].y) * ((long long)cy - p[i].y);\n        if (distSqr &gt; rSqr) ret++;\n    }\n    return ret;\n}\n\n// (w, h) - gornje-levo teme pravougaonika, centar u (0, 0)\n// trazimo optimalan centar na duzi (0,0) - (0, -w) (centar pravougaonika - sredina desne strane)\nvoid solveLine(int n, int w, int h, point p[])\n{\n    opt_sol = max(opt_sol, outside(-w, 0, w, h, n, p)); // proverimo desni kraj\n\n    double L = 0.0, R = -w;\n    vector&lt;pointVal&gt; v; v.clear();\n    for (int i = 1; i &lt;= n; i++)\n    {\n        if (p[i].x == w)\n        {\n            v.push_back(pointVal(L, 1));\n            v.push_back(pointVal(R, -1));\n            continue;\n        }\n\n        double x = (((double)p[i].y - h) / ((double)p[i].x - w) * ((double)p[i].y + h) + ((double)p[i].x + w)) / 2;\n\n        if (p[i].x &gt; w &amp;&amp; x &gt; L)\n        {\n            v.push_back(pointVal(L, 1));\n            v.push_back(pointVal(min(x, R), -1));\n        }\n        if (p[i].x &lt; w &amp;&amp; x &lt; R)\n        {\n            v.push_back(pointVal(max(L, x), 1));\n            v.push_back(pointVal(R, -1));\n        }   \n    }\n\n    if (v.size() &gt; 0)\n    {\n        sort(v.begin(), v.end(), cmp);\n        int sum = 0, maxSum = -1, optInd = 0;\n        for (int i = 0; i &lt; (int)v.size() - 1; i++)\n        {\n            sum = sum + v[i].val;\n            if (!eq(v[i].x, v[i + 1].x))\n            {\n                if (sum &gt; maxSum)\n                {\n                    maxSum = sum;\n                    optInd = i;\n                }\n            }\n        }\n        opt_sol = max(opt_sol, maxSum);\n    }\n}\n\nint solve(int n, int a, int b, int x, int y, point p[])\n{\n    // centriranje pravougaonika i ostalih tacaka\n    int w = -a / 2, h = b / 2; // (koordinata novog gornjeg-levog temena)\n    for (int i = 1; i &lt;= n; i++)\n    {\n        p[i].x = p[i].x + (w - x);\n        p[i].y = p[i].y + (h - y);\n    }\n\n    opt_sol = outside(0, 0, w, h, n, p); // provera za centar\n\n    solveLine(n, w, h, p);\n    rotatePlane(n, w, h, p);\n    solveLine(n, w, h, p);\n    rotatePlane(n, w, h, p);\n    solveLine(n, w, h, p);\n    rotatePlane(n, w, h, p);\n    solveLine(n, w, h, p);\n\n    return opt_sol;\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;a, &amp;b);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%d%d\", &amp;points[i].x, &amp;points[i].y);\n    }\n\n    int sol = solve(n, a, b, x, y, points);\n    printf(\"%d\\n\", n - sol);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/drz/06_obaranje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\) - broj takmi\u010dara. U narednom redu nalaze se 4 cela broja \\(X\\), \\(Y\\), \\(A\\) i \\(B\\) koja predstavljaju, redom, koordinate gornjeg-levog temena pravougaonika (komisiobila) i njegovu \u0161irinu i visinu. U narednih \\(N\\) redova nalaze se po dva cela broja \\((x_i, y_i)\\) koja predstavljaju koordinate odgovaraju\u0107eg takmi\u010dara.</p>"},{"location":"takprog/2017_2018/drz/06_obaranje/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati nenegativan ceo broj \\(K\\) -- najmanji broj takmi\u010dara koji mora biti oboren pri optimalnom izboru ta\u010dke probadanja komisiobila (obratiti pa\u017enju da optimalna ta\u010dka probadanja ne mora imati celobrojne koordinate u op\u0161tem slu\u010daju).</p>"},{"location":"takprog/2017_2018/drz/06_obaranje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/drz/06_obaranje/#ulaz","title":"Ulaz","text":"<pre><code>5\n-12 8 20 12\n9 1\n-9 -9\n3 12\n13 -4\n-5 13\n</code></pre>"},{"location":"takprog/2017_2018/drz/06_obaranje/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2017_2018/drz/06_obaranje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Pravougaonik (komisiomobil) je dimenzija \\(20 \\times 12\\), gornje levo teme mu je \\((-12, 8)\\) i po\u010detna pozicija mu je predstavljena punom linijom. Ukoliko za ta\u010dku probadanja izaberemo ta\u010dku \\((-3.5, -3)\\) (ozna\u010dena 'X' na slici) tada \u0107e pravougaonik, okretanjem oko te ta\u010dke oboriti prvog i drugog takmi\u010dara a ostali \u0107e izbe\u0107i nezgodu. Postoje i drugi izbori ta\u010dke probadanja za koje su oborena samo dva takmi\u010dara ali ne postoji nijedan izbor tako da bude oboren najvi\u0161e jedan takmi\u010dar; dakle, re\u0161enje je \\(2\\).</p>"},{"location":"takprog/2017_2018/drz/06_obaranje/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(-10^7 \\leq X, Y \\leq 10^7\\).</li> <li>\\(2 \\leq A, B \\leq 10^7\\), \\(A\\) i \\(B\\) su parni brojevi.</li> <li>\\(-10^7 \\leq x_i, y_i \\leq 10^7\\).</li> <li>Nijedna od \\(N\\) ta\u010daka na ulazu ne pripada pravougaoniku.</li> <li>Mogu\u0107e je da se dva ili vi\u0161e takmi\u010dara nalaze na istoj poziciji.</li> </ul> <p>Postoji pet podzadataka:</p> <ul> <li>Podzadatak \\(1\\) [\\(6\\) poena]: Za svakog takmi\u010dara va\u017ei \\(y_i &gt; Y\\).</li> <li>Podzadatak \\(2\\) [\\(11\\) poena]: \\(N = 2\\).</li> <li>Podzadatak \\(3\\) [\\(15\\) poena]: Re\u0161enje \u0107e uvek biti \\(0\\) ili \\(1\\).</li> <li>Podzadatak \\(4\\) [\\(29\\) poena]: \\(N \\leq 10^3\\).</li> <li>Podzadatak \\(5\\) [\\(39\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/","title":"1 - Prva cifra","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Mabu i D\u017eo mnogo vole da prodaju pala\u010dinke. Kako je u ovim hladnim decembarskim danima potra\u017enja za pala\u010dinkama zna\u010dajno opala oni su primorani da kratke zimske dane dodatno prekrate zami\u0161ljaju\u0107i razli\u010dite brojeve. Mabu je zamislio prirodan broj \\(A\\), dok je D\u017eo zamislio prirodan broj \\(B\\).</p> <p>Za neki prirodan broj \\(X\\)  ka\u017eemo da je lep\u0161i od prirodnog broja \\(Y\\) ako je prva cifra sleva broja \\(X\\) ve\u0107a od prve cifre sleva broja  \\(Y\\), ili ako su im prve cifre sleva jednake i broj \\(X\\) je ve\u0107i od broja \\(Y\\).</p> <p>Mabua i D\u017eoa interesuje koji je od datih brojeva \\(A\\) i \\(B\\) lep\u0161i.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Aleksa Plav\u0161i\u0107 Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 <p>Zadatak je osmi\u0161ljen tako da bude najlak\u0161i u ovom krugu kvalifikacija. Potrebno je uraditi upravo ono \u0161to pi\u0161e u tekstu - uporediti prvu cifru brojeva, a ukoliko su iste, onda uporediti cele brojeve.</p>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj i jedinoj liniji standardnog ulaza nalaze se dva razli\u010dita broja \\(A\\) i \\(B\\), brojevi koje su zamislili Mabu i D\u017eo redom.</p>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je potrebno ispisati lep\u0161i od brojeva \\(A\\) i \\(B\\).</p>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#ulaz","title":"Ulaz","text":"<pre><code>4506 29985\n</code></pre>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#izlaz","title":"Izlaz","text":"<pre><code>4506\n</code></pre>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#ulaz_1","title":"Ulaz","text":"<pre><code>777 778\n</code></pre>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#izlaz_1","title":"Izlaz","text":"<pre><code>778\n</code></pre>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru  \\(A = 4506\\)  i \\(B = 29985\\). Prva cifra sleva broja \\(A\\) je ve\u0107a od prve cifre sleva broja \\(B\\) (\\(4 &gt; 2\\)), tako da je broj \\(A\\) lep\u0161i od broja \\(B\\).</p> <p>U drugom primeru \\(A =777\\)  i \\(B= 778\\). Prva cifra sleva broja \\(A\\) je jednaka prvoj cifri sleva broja \\(B\\) (obe iznose \\(7\\)), kako va\u017ei \\(778 &gt; 777\\) odnosno \\(B &gt; A\\), broj \\(B\\) je lep\u0161i od broja \\(A\\).</p>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq A,B \\leq 10^9\\).</li> <li>Brojevi \\(A\\) i \\(B\\) su razli\u010diti.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(20\\) poena brojevi \\(A\\) i \\(B\\) imaju jednak broj cifara.</li> <li>U test primerima koji vrede \\(20\\) poena sve cifre u broju \\(A\\) su jednake i sve cifre u broju \\(B\\) su jednake.</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(A = B + 1\\) ili \\(B = A + 1\\).</li> <li>U test primerima koji vrede \\(40\\) peona nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv1/01_prva_cifra/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Elegantno re\u0161enje je u\u010ditati brojeve kao stringove, i uporediti prvi karakter stringa, a ukoliko je prvi karakter isti, onda prebaciti string u broj (npr. koriste\u0107i atoi funkciju u C++, ili StrToInt funkciju u Pascalu) i uporediti brojeve jednostavnim pore\u0111enjem.</p> <p>Ukoliko brojeve u\u010ditamo u Integer formatu, prvu cifru broja mo\u017eemo dobiti jednostavnom funkcijom (primer dat u C++):</p> <pre><code>int prvaCifra(int a) {\nwhile (a &gt;= 10) {\na /= 10;\n}\nreturn a;\n}\n</code></pre> 01_prva_cifra.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main()\n{\n    int x,y,x1,y1;\n\n    cin&gt;&gt;x&gt;&gt;y;\n\n    x1=x;\n    y1=y;\n\n    while(x1&gt;=10) x1/=10;\n    while(y1&gt;=10) y1/=10;\n\n    if (x1&gt;y1 || ((x1==y1) &amp;&amp; (x&gt;y))) cout&lt;&lt;x&lt;&lt;\"\\n\"; else\n        cout&lt;&lt;y&lt;&lt;\"\\n\";\n\n   return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/","title":"2 - Transformacija matrice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 128MB <p>Nakon duge igre sa brojevima, Mabu i D\u017eo su re\u0161ili da promene temu njihove zabave. Sada su na red do\u0161le matrice! Mabu je napisao na papiru kvadratnu matricu \\(A\\), dok je D\u017eo napisao kvadratnu matricu \\(B\\). Obe kvadratne matrice su iste dimenzije i ona iznosi \\(n\\) (svaka matrica ima ta\u010dno \\(n\\) vrsta i \\(n\\) kolona).</p> <p>Kada su napisali matrice na papiru, Mabu je odjednom po\u017eeleo da promeni svoju matricu u onu koju je D\u017eo napisao (\u017eeleo je da transformi\u0161e matricu \\(A\\) u matricu \\(B\\)). Za ovaj poduhvat Mabu sme da koristi slede\u0107e dve operacije proizvoljan broj puta u proizvoljnom redosledu:</p> <p>\\(1.\\) Promena vrednosti jednog elementa u matrici \\(A\\) - element mo\u017ee da se zameni proizvoljnom vredno\u0161\u0107u</p> <p>\\(2.\\) Rotacija matrice \\(A\\) za \\(90\\) stepeni u desno.</p> <p>Mabua interesuje minimalan broj operacija koje mora da izvr\u0161i na matrici \\(A\\) kako bi dobio matricu \\(B\\).  </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Aleksa Plav\u0161i\u0107 Du\u0161an Zdravkovi\u0107 Slobodan Mitrovi\u0107 <p>Prvo \u0161to je potrebno primetiti u zadatku je da redosled operacija koje izvr\u0161avamo nad prvom matricom nije bitan. Tj. isto \u0107e biti ukoliko prvo promenimo vrednost jednog elementa, pa onda rotiramo matricu, ili ukoliko prvo rotiramo, pa onda zamenimo vrednost. To zna\u010di da prvo mo\u017eemo raditi operacije rotacije, pa tek onda posle toga operacije promene vrednosti.</p> <p>Tako\u0111e, mo\u017eemo primetiti da nikada ne\u0107emo rotirati matricu vi\u0161e od 3 puta, jer ako je rotiramo 4 puta, onda dolazimo u istu poziciju kao na po\u010detku. Time smo zadatak sveli na 4 slu\u010daja, u zavisnosti od toga koliko puta smo rotirali matricu (0 do 3 puta). Svaki put kada je rotiramo, proveri\u0107emo koliko se elemenata razlikuje, a broj razli\u010ditih elemenata plus broj trenutnih rotacija do sada nam daje koliko je ukupno potrebno operacija za taj slu\u010daj. Na kraju, zapamti\u0107emo najmanji broj potrebnih operacija koji nam je trebao u nekom od ta 4 slu\u010daja.</p>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei prirodan broj \\(n\\) , dimenziju kvadratnih matrice koje su napisali Mabu i D\u017eo.</p> <p>Slede\u0107ih \\(n\\) linija standarnog ulaza sadr\u017ei po \\(n\\) prirodnih brojeva koji predstaljaju matricu \\(A\\). </p> <p>Poslednjih \\(n\\) linija standarnog ulaza sadr\u017ei po \\(n\\) prirodnih brojeva koji predstaljaju matricu \\(B\\).</p>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati minimalan broj operacija potrebnih da se matrica \\(A\\) transformi\u0161e u matricu \\(B\\).</p>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#primer-1","title":"Primer \\(1\\)","text":""},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#ulaz","title":"Ulaz","text":"<pre><code>2\n1 2\n3 8\n6 1\n8 5\n</code></pre>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#primer-2","title":"Primer \\(2\\)","text":""},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n5\n5\n</code></pre>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru matricu \\(A\\) mo\u017eemo transformisati u matricu \\(B\\) sa najmanje \\(3\\) koraka.</p> <p>\\(1.\\) Promena vrednosti polja (\\(2\\), \\(1\\)) , \\(A_{2,1} = 6\\).</p> <p>\\(2.\\) Rotacija matrice za \\(90\\) stepeni u desno.</p> <p>\\(3.\\)  Promena vrednosti polja (\\(2\\), \\(2\\)) , \\(A_{2,2} = 5\\).</p> <p>U drugom primeru matrice \\(A\\) i \\(B\\) imaju samo po jedan element i on ima vrednost \\(5\\) u obe matrice. Nije potrebno izvr\u0161iti neku operaciju, tako da je re\u0161enje \\(0\\).</p>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 1000\\).</li> <li>\\(1 \\leq A_{i,j}, B_{i,j} \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei\u0107e ograni\u010denje \\(n = 2\\).</li> <li>U test primerima vrednim \\(20\\) poena za optimalno re\u0161enje bi\u0107e potrebne samo operacije prvog tipa.</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei\u0107e ograni\u010denje \\(1 \\leq n \\leq 50\\).</li> <li>U test primerima vrednim \\(30\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv1/02_transformacija_matrice/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Za rotaciju kvadratne matrice \\(A\\) veli\u010dine \\(NxN\\) za 90 stepeni u desno je potrebno da primetimo da \u0107e na mesto polja \\((x,y)\\) do\u0107i polje \\((y, N+1-x)\\), ukoliko su polja indeksirana po\u010dev od 1. Tj. ukoliko \u017eelimo da dobijemo matricu \\(A'\\) koja je rotirana verzija matrice \\(A\\), mo\u017eemo je izra\u010dunati preko formule: \\(A'[x][y] = A[y][N+1-x]\\).</p> 02_transformacija_matrice.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxN=1005;\n\nint a[maxN][maxN],b[maxN][maxN];\nint n;\n\nint calc(int a[][maxN],int b[][maxN], int n) //funkcija koja racuna broj polja koja se razlikuju u matricama a i b\n{\n   int diff=0;\n\n   for (int i=1;i&lt;=n;i++)\n    for (int j=1;j&lt;=n;j++)\n        if (a[i][j]-b[i][j]) diff++;\n\n    return diff;\n}\n\nvoid rotate(int a[][maxN], int n)\n{\n    int c[maxN][maxN];\n\n    for (int i=1;i&lt;=n;i++)\n        for (int j=1;j&lt;=n;j++)\n        c[j][n-i+1]=a[i][j];\n\n    for (int i=1;i&lt;=n;i++)\n        for (int j=1;j&lt;=n;j++)\n        a[i][j]=c[i][j];\n}\n\nint main()\n{\n    scanf(\"%d\",&amp;n);\n\n    for (int i=1;i&lt;=n;i++)\n        for (int j=1;j&lt;=n;j++)\n        scanf(\"%d\",&amp;a[i][j]);\n\n    for (int i=1;i&lt;=n;i++)\n        for (int j=1;j&lt;=n;j++)\n        scanf(\"%d\",&amp;b[i][j]);\n\n     int ans=calc(a,b,n);\n\n     rotate(a,n);\n\n     ans=min(ans,calc(a,b,n)+1);\n\n     rotate(a,n);\n\n     ans=min(ans,calc(a,b,n)+2);\n\n     rotate(a,n);\n\n     ans=min(ans,calc(a,b,n)+3);\n\n     printf(\"%d\\n\",ans);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/","title":"3 - Prodavnice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Jedan grad ima \\(n\\) stanovnika i samo jednu ulicu koju mo\u017eemo prestaviti \\(x\\)-osom. Za svakog stanovnika je poznata koordinata njegove ku\u0107e na \\(x\\)-osi, (mogu\u0107e je da nekoliko ku\u0107a ima istu koordinatu). U ovaj grad dolazi poznati sajber-prevarant D\u017eimi Rudar koji planira da otvori ta\u010dno dve prodavnice opreme za rudarenje bitkoina - u jednoj \u0107e prodavati pijuke a u drugoj a\u0161ove. D\u017eimi Rudar zna da \u0107e, nakon otvaranja prodavnica, svaki stanovnik pojuriti u njemu najbli\u017eu prodavnicu da kupi opremu a ukoliko su obe prodavnice podjednako udaljene, stanovnik \u0107e slu\u010dajno odabrati jednu od njih (njima nije bitno da li im treba pijuk ili a\u0161ov, bitno da se rudare bitkoini). </p> <p>D\u017eimi \u017eeli da optimalno izgradi prodavnice i ve\u0107 je napravio \\(m\\) potencijalnih planova: svaki plan je par brojeva \\((A_i, B_i)\\) i ozna\u010dava da D\u017eimi \u017eeli da sagradi prodavnicu pijuka na koordinati \\(A_i\\) i prodavnicu a\u0161ova na koordinati \\(B_i\\) na \\(x\\)-osi. D\u017eimi ima molbu za vas: za svaki od \\(m\\) potencijalnih planova, izra\u010dunajte ukupnu razdaljinu koju bi pre\u0161li svi stanovnici ukoliko bi prodavnice bile izgra\u0111ene na koordinatama zadatim u tom planu. Ukoliko ovo odradite, dobijate \\(5\\)kg bitkoina od D\u017eimija! Podsetimo se da je rastojanje izme\u0111u ta\u010daka \\(X\\) i \\(Y\\) na \\(x\\)-osi jednako \\(|X - Y|\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Aleksa Plav\u0161i\u0107 i Ivan Sto\u0161i\u0107 <p>Jasno je da je za svaki upit \\((A, B)\\) potrebno izra\u010dunati vrednost izraza \\(\\sum_{i=1}^n \\min(|x_i - A|, |x_i - B|)\\) tj. sumu rastojanja do najbli\u017ee prodavnice. Direktno ra\u010dunanje ove sume za svaki upit daje re\u0161enje slo\u017eenosti \\(O(nm)\\) \u0161to je dovoljno samo za \\(20\\) poena.</p> <p>Posmatrajmo slu\u010daj kada uvek va\u017ei \\(A_i = B_i\\) tj. kada je potrebno izra\u010dunati \\(\\sum_{i=1}^n |x_i - A|\\). Za po\u010detak, prirodan korak je sortiranje niza \\(x\\) -- nadalje pretpostavljamo da je \\(x_1 \\leq x_2 \\leq \\ldots \\leq x_n\\). Za datu vrednost \\(A\\) mo\u017eemo binarnom pretragom u slo\u017eenosti \\(O(\\log n)\\) odrediti najve\u0107u vrednost \\(ind\\) za koju va\u017ei \\(x_{ind} &lt; A\\) (ili ustanoviti da takva vrednost ne postoji ako je \\(A \\leq x_1\\)). Sada va\u017ei</p> \\[ \\sum_{i=1}^n |x_i - A| = \\sum_{i = 1}^{ind} (A - x_i) + \\sum_{i=ind+1}^n (x_i - A) = ind \\cdot A - s_{ind} + (s_n - s_{ind}) - (n - ind)\\cdot A \\] <p>gde je \\(s\\) niz prefiksnih suma niza \\(x\\), tj. \\(s_i = x_1 + x_2 + \\ldots + x_i\\). Prema tome, ukoliko na po\u010detku (pre svih upita) sortiramo niz \\(x\\) i izra\u010dunamo niz prefiksnih suma, mo\u017eemo za svaki upit odraditi binarnu pretragu i vratiti rezultat iz prethodne jedna\u010dine (bez sumiranja). Slo\u017eenost ovog pristupa je \\(O(n \\log n + m \\log n)\\).</p> <p>Prethodni algoritam se jednostavno modifikuje i u slu\u010daju kada je \\(A_i \\neq B_i\\). U tom slu\u010daju, za upit \\((A, B)\\) (npr. neka je \\(A &lt; B\\)) binarnom pretragom prona\u0111emo najve\u0107u vrednost \\(mid\\) za koju va\u017ei \\(x_{mid} &lt; \\frac{A+B}{2}\\); to zna\u010di da \u0107e svi stanovnici sa koordinatama \\(x_1, x_2, \\ldots, x_{mid}\\) i\u0107i u prodavnicu \\(A\\) a stanovnici sa koordinatama \\(x_{mid+1}, x_{mid+2}, \\ldots, x_n\\) u prodavnicu \\(B\\). Zatim dva puta primenimo prethodni algoritam, jednom za podniz \\(x[1, mid]\\) i vrednost \\(A\\), a drugi put za podniz \\(x[mid+1, n]\\) i vrednost \\(B\\).</p> <p>Za dodatne podzadatke je tako\u0111e predvi\u0111en ovaj algoritam ali je za njih dovoljna potencijalno lak\u0161a imeplementacija i manja analiza specijalnih slu\u010dajeva o kojima treba voditi ra\u010duna prilikom implementacije re\u0161enja za \\(100\\) poena -- npr. kada su vrednosti \\(A\\) ili \\(B\\) ili \\(\\frac{A+B}{2}\\) levo ili desno od niza \\(x\\) (npr. kada svi idu u samo jednu prodavnicu). Ovo se u potpunosti mo\u017ee zaobi\u0107i pametno dizajniranom funkcijom za pomenutu binarnu pretragu.</p> 03_prodavnice.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 100000;\n\nint n, m;\nint a[MAX_N + 10];\nlong long pref[MAX_N + 10];\n\n// max ind tako da a[ind] &lt; val\nint lastLessThan(int l, int r, int a[], double val)\n{\n    if (l &gt; r || !(val &gt; a[l]))\n        return l - 1;\n    while (l &lt; r)\n    {\n        int m = (l + r + 1) / 2;\n        if (a[m] &lt; val)\n            l = m;\n        else\n            r = m - 1;\n    }\n    return l;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; i++)\n        scanf(\"%d\", &amp;a[i]);\n\n    sort(a + 1, a + n + 1);\n    pref[0] = 0LL;\n    for (int i = 1; i &lt;= n; i++)\n        pref[i] = pref[i - 1] + a[i];\n\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int A, B;\n        scanf(\"%d%d\", &amp;A, &amp;B);\n        if (A &gt; B)\n            swap(A, B);\n        int Y = lastLessThan(1, n, a, (A + B) / 2.0);\n        // [1, Y] u A, [Y + 1, n] u B\n\n        int X = lastLessThan(1, Y, a, A);\n        int Z = lastLessThan(Y + 1, n, a, B);\n        // a[1] &lt;= a[2] &lt;= ... &lt;= a[X] &lt; A &lt;= a[X+1] &lt;= ... &lt;= a[Y] &lt; (A + B)/2 &lt; a[Y+1] &lt;= ... &lt;= a[Z] &lt; B &lt;= a[Z+1] &lt;= ... &lt;= a[n]\n        long long sol \n            = ((long long)A * X - pref[X]) \n            + (pref[Y] - pref[X] - (long long)A * (Y - X))\n            + ((long long)B * (Z - Y) - (pref[Z] - pref[Y])) \n            + (pref[n] - pref[Z] - (long long)B * (n - Z));\n        printf(\"%lld\\n\", sol);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(n\\) i \\(m\\), broj ku\u0107a i broj upita, redom. U narednom redu nalazi se \\(n\\) prirodnih brojeva \\(X_i\\) koji predstavljaju koordinate ku\u0107a. U narednih \\(m\\) redova nalaze se po dva prirodna broja \\(A_i\\) i \\(B_i\\) koji predstavljaju plan za izgradnju prodavnica na tim koordinatama.</p>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(m\\) prirodnih brojeva, u svakom redu po jedan, koji predstavljaju odgovore na datih \\(m\\) upita u odgovaraju\u0107em redosledu.</p>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv1/03_prodavnice/#ulaz","title":"Ulaz","text":"<pre><code>5 2\n12 50 70 1 10\n10 100\n60 8\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#izlaz","title":"Izlaz","text":"<pre><code>81\n33\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv1/03_prodavnice/#ulaz_1","title":"Ulaz","text":"<pre><code>3 1\n1000000000 1000000000 1000000000\n1 2\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#izlaz_1","title":"Izlaz","text":"<pre><code>2999999994\n</code></pre>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru, prvi plan predvi\u0111a izgradnju prodavnice pijuka i a\u0161ova na koordinatama \\(10\\) i \\(100\\), redom. U tom slu\u010daju, prvi stanovnik (sa koordinatom \\(12\\)) ide u prodavnicu pijuka i prelazi rastojanje \\(|10 - 12| = 2\\); drugi stanovnik (koordinata \\(50\\)) tako\u0111e ide u prodavnicu pijuka i prelazi rastojanje \\(|50 - 10| = 40\\); tre\u0107i stanovnik ide u prodavnicu a\u0161ova i prelazi rastojanje \\(|70 - 100| = 30\\); \u010detvrti stanovnik prelazi rastojanje \\(9\\) dok peti prelazi rastojanje \\(0\\). Ukupno pre\u0111eno rastojanje je \\(2 + 40 + 30 + 9 + 0 = 81\\). U slu\u010daju drugog plana (prodavnice na koordinatama \\(60\\) i \\(8\\)) ukupno pre\u0111eno rastojanje je \\(4 + 10 + 10 + 7 + 2 = 33\\).</p>"},{"location":"takprog/2017_2018/kv1/03_prodavnice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 10^5\\).</li> <li>\\(1 \\leq m \\leq 10^5\\).</li> <li>\\(1 \\leq X_i \\leq 10^9\\).</li> <li>\\(1 \\leq A_i, B_i \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima koji vrede \\(20\\) poena va\u017ei\u0107e \\(1 \\leq N, M \\leq 1000\\).</li> <li>U test primerima koji vrede \\(15\\) poena va\u017ei\u0107e \\(A_i = B_i\\) za svako \\(i\\).</li> <li>U test primerima koji vrede \\(15\\) poena va\u017ei\u0107e \\(A_i \\leq min X\\) i \\(max X \\leq B_i\\) za svako \\(i\\).</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei\u0107e \\(1 \\leq A_i, B_i, X_i \\leq 10^6\\).</li> <li>U test primerima koji vrede \\(30\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/","title":"4 - Okrnjen trougao","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Dok je prenosio veliki stakleni trougao Cimi je za trenutak izgubio ravnote\u017eu te je tre\u0107e teme trougla udarilo o pod (primetiti da kako Cimi ima samo dve ruke mogao je u jedinici vremena da dr\u017ei samo \\(2\\) temena velikog staklenog trougla). Od nekada velikog staklenog trougla ostao je jedan stakleni mnogougao koji je Cimiju ostao u rukama dok se ostatak stakla pri kontaktu sa tlom razbio u neupotrebljivo male komadi\u0107e. Cimiju je ovaj doga\u0111aj bio izuzetno zanimljiv i \u017eeli da o njemu razgovara sa ostalim radnicima ali razmi\u0161lja da malo izmeni pri\u010du kako bi umanjio \u0161tetu koju je napravio, koja se izra\u017eava u povr\u0161ini stakla koja je sada neupotrebljiva. Pomozite Cimiju time \u0161to \u0107ete mu za dati prost mnogougao (ne obavezno konveksan) re\u0107i kolika je minimalna razlika u povr\u0161inama izme\u0111u njega i trougla koji ga sadr\u017ei a sa njim deli bar jednu stranicu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Spasi\u0107 Ivan Sto\u0161i\u0107 i Nikola Spasi\u0107 Nikola Spasi\u0107 Andrej Iva\u0161kovi\u0107 <p>Posmatrajmo neki trougao \\(T\\) koji zadovoljava uslove zadatka. Kako trougao \\(T\\) sadr\u017ei dati mnogougao \\(M\\), a \\(T\\) je konveksan skup, va\u017ei\u0107e i \\(K \\subseteq T\\), gde je \\(K\\) konveksni omota\u010d mnogougla \\(M\\), jer je \\(K\\) po definiciji najmanji konveksan skup koji sadr\u017ei \\(M\\). Dakle, u zadatku se tra\u017ei da za dati mnogougao na\u0111emo trougao najmanje povr\u0161ine koji sadr\u017ei njegov konveksni omota\u010d, sa dodatnim ograni\u010denjem da neka stranica trougla bude jednaka nekoj stranici datog mnogougla, neka je to stranica \\(BC\\).</p> <p>Temena \\(B, C\\) moraju biti susedna temena u konveksnom omota\u010du, jer se u suprotom stranica trougla nalazi u strogoj unutra\u0161njosti konveksnog omota\u010da pa ga trougao ne mo\u017ee sadr\u017eati. Iz prethodno re\u010denog proizilazi da konveksni omota\u010d i trougao imaju zajedni\u010dku stranicu. Posmatrajmo sada neku stranicu \\(BC\\) konveksnog omota\u010da. Pretpostavi\u0107emo da na\u0161 trougao ba\u0161 tu stranicu deli sa \\(K\\). Kako nam treba trougao minimalne povr\u0161ine njegove preostale stranice moraju imati isti pravac kao i stranice koje su susedne stranici \\(BC\\), neka su to stranice \\(AB, CD\\). Stoga za svaku stranicu konveksnog omota\u010da treba proveriti da li se produ\u017eeci susednih strana \\(AB, CD\\) seku sa odgovaraju\u0107e strane i da li je stranica \\(BC\\) konveksnog omota\u010da ujedno i stranica mnogougla, \u0161to nam je dovoljno da zaklju\u010dimo da postoji trougao sa odgovaraju\u0107im svojstvima. Zatim, nalazimo presek pravih \\(E = AB \\cap CD\\) i to je tre\u0107a ta\u010dka na\u0161eg trougla. Sada znamo sva temena trougla, odredimo povr\u0161inu a zatim i razliku povr\u0161ina izme\u0111u njega i po\u010detnog mnogougla.</p>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se ceo broj \\(n\\) koji predstavlja broj temena mnogougla. U narednih \\(n\\) linija standardnog ulaza nalaze se po dva cela broja \\(x_i, y_i\\) koji predstavljaju koordinate temena mnogougla. (Uzastupna temena kao i prvo i poslednje dele stranicu)</p>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza napisati realan broj koji predstavlja minimalnu razliku definisanu u tekstu zadatka. Ukoliko ne postoji ni jedan trougao koji odgovara opisu ispisati \\(-1\\).</p>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#ulaz","title":"Ulaz","text":"<pre><code>4\n2 0\n0 2\n0 5\n5 0\n</code></pre>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n0 0\n1 1\n2 0\n1 7\n</code></pre>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U \\(1\\). primeru optimalno je odabrati trougao sa koordinatama temena \\((0,0)\\), \\((5,0)\\) i \\((0,5)\\).</p> <p>U \\(2\\). primeru optimalno je odabrati trougao sa koordinatama temena \\((0,0)\\), \\((2,0)\\) i \\((1,7)\\).</p>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq n \\leq 10^5\\).</li> <li>\\(-10^9 \\leq x_i, y_i \\leq 10^9\\).</li> <li>U 50% primera va\u017ei \\(n \\leq 1000\\).</li> </ul>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#napomena","title":"Napomena","text":"<p>Ukoliko ne postoji tra\u017eeni trougao, va\u0161 program mora ispisati ceo broj \\(-1\\). U suprotnom, ako je va\u0161 program ispisao broj \\(a\\), a re\u0161enje komisije je realan broj \\(b\\), va\u0161e re\u0161enje se prihvata kao ta\u010dno pod uslovom da va\u017ei \\(\\frac{|a-b|}{b} \\leq 10^{-6}\\) ili va\u017ei \\(|a-b| \\leq 10^{-6}\\).</p>"},{"location":"takprog/2017_2018/kv1/04_okrnjen_trougao/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Zbog na\u010dina na koji su data temena mnogougla mo\u017eemo u linearnom vremenu na\u0107i konveksni omota\u010d. (videti \u010dlanak na Vikipediji). Povr\u0161ina trougla kome znamo koordinate mo\u017ee se dobiti kao polovina intenziteta vektorskog proizvoda dve njegove stranice (odnosno odgovaraju\u0107ih vektora). Ozna\u010dena povr\u0161ina nekonveksnog mnogougla mo\u017ee se na\u0107i kao zbir ozna\u010denih povr\u0161ina proizvoljnog razbijanja tog mnogougla na trouglove - videti link. Dalje, potrebno je na\u0107i povr\u0161inu trougla \\(BCE\\) gde je \\(E\\) presek pravih \\(AB\\) i \\(CD\\). U teoriji, ovo se mo\u017ee uraditi nala\u017eenjem jedna\u010dina te dve prave i re\u0161avanjem sistema od dve jedna\u010dine sa dve nepoznate, a zatim primenom gore pomenute formule za povr\u0161inu trougla. Me\u0111utim, problem nastaje zbog upotrebe tipa double za predstavljanje koeficijenata i re\u0161enja ove jedna\u010dine. Sre\u0107om, postoji daleko jednostavniji na\u010din za nala\u017eenje povr\u0161ine trougla \\(BCE\\). Va\u017ei slede\u0107a jednakost: \\(P(BCE) = \\frac{P(ABC) P(BCD)}{P(BCF)}\\), gde je \\(F\\) ta\u010dka dobijena pomeranjem ta\u010dke \\(D\\) za vektor \\(CB\\), \u0161to se mo\u017ee relativno lako dokazati alatima elementarne geometrije. </p> 04_okrnjen_trougao.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MAXN = 200050;\n\ntypedef long long ll;\ntypedef double real_t;\n\nstruct pt {\n    ll x, y;\n\n    pt operator- (const pt&amp; other) const {\n        return {x - other.x, y - other.y};\n    }\n\n    bool operator&lt; (const pt&amp; other) const {\n        return x &lt; other.x || (x == other.x &amp;&amp; y &lt; other.y);\n    }\n};\n\nll det(pt a, pt b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nll det(pt a, pt b, pt c) {\n    return det(a-c, b-c);\n}\n\nset&lt;pair&lt;pt, pt&gt;&gt; s;\n\nint n;\npt a[MAXN], h[MAXN];\nint n1, n2, m;\n\nvoid scan(int dir, pt* b, int&amp; num) {\n    int s = dir &gt; 0 ? 0 : n-1;\n    int e = dir &gt; 0 ? n : -1;\n\n    num = 0;\n\n    for (int i=s; i!=e; i+=dir) {\n        while (num &gt;= 2 &amp;&amp; det(b[num-2], b[num-1], a[i]) &lt;= 0) {\n            num--;\n        }\n        b[num++] = a[i];\n    }\n\n    num--;\n}\n\nreal_t sol = 0.0;\nbool sol_found = false;\n\nvoid process_sol(pt a, pt b, pt c, pt d, ll cross_det) {\n    // naci povrsinu trougla cije su dve tacke b, c\n    // a treca nastala presekom polupravih b-&gt;a i c-&gt;d\n    // \n    real_t area = det(a, b, c);\n    area *= det(b, c, d);\n    area /= cross_det;\n    area /= 2;\n\n    if (area &lt; 0) {\n        area *= -1;\n    }\n\n    if (!sol_found || area &lt; sol) {\n        sol_found = true;\n        sol = area;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i=0; i&lt;n; i++) {\n        scanf(\"%lld%lld\", &amp;a[i].x, &amp;a[i].y);\n    }\n\n    a[n] = a[0];\n    real_t poly_area = 0.0;\n    for (int i=0; i&lt;n; i++) {\n        s.insert({a[i], a[i+1]});\n        poly_area += det(a[i], a[i+1]);\n    }\n\n    poly_area /= 2;\n\n    if (poly_area &lt; 0) {\n        poly_area *= -1;\n    }\n\n    sort(a, a+n);\n    scan(+1, h, n1);\n    scan(-1, h+n1, n2);\n    m = n1 + n2;\n\n    h[m] = h[0];\n    h[m+1] = h[1];\n    h[m+2] = h[2];\n\n    for (int i=0; i&lt;m; i++) {\n        pt a = h[i];\n        pt b = h[i+1];\n        pt c = h[i+2];\n        pt d = h[i+3];\n\n        // Ne nalazimo duz u skupu originalnih duzi\n        if (s.count({b, c}) + s.count({c, b}) == 0) {\n            continue;\n        }\n\n        // proverimo da li je zbir spoljnjih uglova abc i bcd &gt; 180\n        // ako jeste imamo resenje\n\n        ll cross_det = det(b-a, d-c);\n\n        if (cross_det &lt; 0) {\n            // imamo levo skretanje\n            process_sol(a, b, c, d, cross_det);\n        }\n    }\n\n    // fprintf(stderr, \"%.9f\\n\", poly_area);\n    // fprintf(stderr, \"%.9f\\n\", sol);\n\n    // odstampaj povrsinu\n    if (sol_found) {\n        cout.precision(20);\n        cout &lt;&lt; fixed &lt;&lt; (sol - poly_area) * 1.000002 &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"-1\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/","title":"5 - Nagrade","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Kao \u0161to se ina\u010de \u010desto de\u0161ava u takmi\u010darskim zadacima, na\u0161li ste se u \u010dudnoj situaciji: dato vam je \\(N\\) gomila nov\u010di\u0107a (\\(i\\)-ta gomila sadr\u017ei \\(A_i\\) nov\u010di\u0107a). Planirate da organizujete \\(N\\) takmi\u010denja, gde \u0107ete za svako od njih iskoristiti jednu gomilu kao nagradni fond (\\(A_1\\) za prvo, \\(A_2\\) za drugo, i tako dalje). </p> <p>Za svako takmi\u010denje treba da odaberete koliko \u0107e u\u010desnika biti nagra\u0111eno (obele\u017ei\u0107emo broj nagra\u0111enih na \\(i\\)-tom takmi\u010denju sa \\(B_i\\)). Sve nagrade na jednom takmi\u010denju su iste, tako da \\(A_i\\) mora biti deljivo sa \\(B_i\\). Dodatno, sve vrednosti \\(B_i\\) moraju biti prosti brojevi (niste sigurni za\u0161to, ali neko vam je rekao da je to dobra ideja).</p> <p>Da bi ciklus takmi\u010denja bio interesantniji, planirate da odaberete vrednosti \\(B_i\\) tako da su nagrade na svim takmi\u010denjima razli\u010dite, tj. da za svaki par vrednosti \\((i,j)\\) va\u017ei \\(\\frac{A_i}{B_i} \\neq \\frac{A_j}{B_j}\\). Va\u0161 zadatak je da napi\u0161ete program koji \u0107e prona\u0107i ovakvu podelu ili utvrditi da to nije mogu\u0107e.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Boris Grubi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Ivan Sto\u0161i\u0107 <p>Prvo, za svaki broj sa ulaza na\u0111imo sve razli\u010dite proste brojeve koji ga dele. Ovo se mo\u017ee uraditi efikasno pomo\u0107u modifikacije Eratostenovog sita, kojom se svaki broj \\(x &lt; M\\) mo\u017ee faktorizovati u logaritamskoj slo\u017eenosti, gde je \\(M\\) gornja granica za Eratostenovo sito.</p> <p>Ovih razli\u010ditih prostih brojeva ima ne vi\u0161e od \\(6\\), jer je proizvod najmanjih \\(7\\) prostih brojeva ve\u0107i od \\(2 \\times 10^5\\). Sada, za svaki broj na\u0111imo koli\u010dnik njega i svakog razli\u010ditog prostog broja koji ga deli. Neka je za \\(i\\)-ti broj \\(P_i\\) lista njegovih razli\u010ditih prostih delilaca a \\(C_i\\) lista  koja se dobija kada se \\(A_i\\) podeli sa svakim elementom liste \\(P_i\\). Cilj zadatka je da na\u0111emo niz razli\u010ditih brojeva \\(B\\) tako da je za svako \\(i\\), \\(B_i = A_i / P_{i, j} = C_{i, j}\\) za neko \\(j\\). Ovaj problem je poznat i pod nazivom sistem razli\u010ditih predstavnika familije skupova \\(C\\). Ovo se mo\u017ee re\u0161iti u polinomijalnom vremenu tako \u0161to se predstavi kao bipartitni graf, gde su \u010dvorovi sa leve strane indeksi iz originalnog niza, a sa desne strane koli\u010dnici. Za svako \\(i\\) dodajemo granu od \u010dvora \\(i\\) sa leve strane do \u010dvorova \\(C_{i, j}\\) sa desne, za svako \\(j\\). Svaki sistem razli\u010ditih predstavnika sada odgovara jednom perfektnom sparivanju (me\u010dingu) u ovom grafu, odnosno me\u010dingu gde je svaki \u010dvor sa leve strane sparen. Dakle \u017eelimo da ispitamo da li ovako dobijen graf ima me\u010ding sa \\(N\\) grana i koji je to me\u010ding.</p> <p>Najjednostavniji i najpoznatiji algoritam jeste Ford-Fulkersonov algoritam koji radi u slo\u017eenosti \\(O(VE)\\), gde je \\(V\\) broj \u010dvorova, a \\(E\\) broj grana u grafu, \u0161to u na\u0161em slu\u010daju, zbog gore pomenutog ograni\u010denja na broj grana iznosi \\(O(N^2)\\). Primetimo da ne moramo da dodajemo sve \u010dvorove sa desne strane ve\u0107 samo one koji se bar jednom pojavljuju kao koli\u010dnici.</p> 05_nagrade.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nconst int P = 2000005;\nbool is_prime[P];\nstd::vector&lt;int&gt; primes;\n\nvoid gen_primes()\n{\n    for(int i = 0; i &lt; P; i++)\n    is_prime[i] = true;\n\n    for(int i = 2; i &lt; P; i++)\n    if(is_prime[i])\n    {\n        primes.push_back(i);\n        for(int j = 2 * i; j &lt; P; j += i)\n        is_prime[j] = false;\n    }\n}\n\nconst int N = 10000;\nstruct node\n{\n    int v;\n    node *next;\n    bool valid;\n    node(int vv, node *n, bool x) { v = vv; next = n; valid = x; } \n} *graph[N];\n\nstd::map&lt;int, int&gt; factors;\nstd::vector&lt;int&gt; vals;\n\nint register_factor(int x)\n{\n    if(factors.find(x) != factors.end())\n    return factors[x];\n    factors[x] = vals.size();\n    vals.push_back(x);\n\n    return vals.size() - 1;\n}\n\nvoid add_edge(int i, int j)\n{\n    graph[i] = new node(j, graph[i], true);\n    graph[j] = new node(i, graph[j], false);\n}\n\nbool mark[N];\nint prev[N];\n\nbool dfs(int curr, int sink)\n{\n    if(curr == sink) return true;\n\n    for(node *i = graph[curr]; i; i = i-&gt;next)\n    if(i-&gt;valid &amp;&amp; !mark[i-&gt;v])\n    {\n        mark[i-&gt;v] = true;\n        if(dfs(i-&gt;v, sink))\n        {\n        i-&gt;valid = false;\n        for(node *j = graph[i-&gt;v]; j; j = j-&gt;next)\n            if(j-&gt;v == curr)\n            j-&gt;valid = true;\n        return true;\n        }\n    }\n\n    return false;\n}\n\nint matching(int left)\n{\n    int n = vals.size() + 2;\n    int source = n - 2, sink = n - 1;\n\n    for(int i = 0; i &lt; left; i++)\n    add_edge(source, i);\n    for(int i = left; i &lt; source; i++)\n    add_edge(i, sink);\n\n    int res = 0;\n    while(true)\n    {\n    for(int i = 0; i &lt; n; i++)\n        mark[i] = false;\n\n    if(!dfs(source, sink)) break;\n    res++;\n    }\n\n    return res;\n}\n\nint main()\n{\n    gen_primes();\n\n    int n;\n    std::cin &gt;&gt; n;\n    vals.resize(n);\n\n    for(int i = 0; i &lt; n; i++)\n    {\n    std::cin &gt;&gt; vals[i];\n\n    int n_f = 0;\n    int last = 0;\n\n    int curr = vals[i];\n    for(int p : primes)\n    {\n        if(p * p &gt; curr) break;\n        if(curr % p == 0)\n        {\n        n_f++;\n        last = p;\n        add_edge(i, register_factor(vals[i] / p));\n\n        curr /= p;\n        }\n    }\n\n    if(n_f &amp;&amp; curr != 1)\n        add_edge(i, register_factor(vals[i] / curr));\n    if(n_f == 0 &amp;&amp; vals[i] &gt; 1)\n        add_edge(i, register_factor(1));\n    }\n\n    int res = matching(n);\n    if(res != n)\n    std::cout &lt;&lt; -1 &lt;&lt; std::endl;\n    else\n    {\n    for(int i = 0; i &lt; n; i++)\n        for(node *j = graph[i]; j; j = j-&gt;next)\n        if(!j-&gt;valid)\n            std::cout &lt;&lt; vals[i] / vals[j-&gt;v] &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se jedan ceo broj \\(N\\) -- broj takmi\u010denja koja organizujete. U drugom redu nalazi se \\(N\\) brojeva \\(A_1, A_2, \\ldots, A_N\\), koji predstavljaju broj nov\u010di\u0107a u nagradnim fondovima pojedina\u010dnih takmi\u010denja.</p>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati \\(N\\) brojeva \\(B_1, B_2, \\ldots, B_N\\) -- broj nagra\u0111enih takmi\u010dara na svakom takmi\u010denju, tako da su uslovi iz teksta zadatka zadovoljeni. Ukoliko to nije mogu\u0107e, ispisati \\(-1\\).</p> <p>Ukoliko postoji vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv1/05_nagrade/#ulaz","title":"Ulaz","text":"<pre><code>4\n10 8 15 7\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#izlaz","title":"Izlaz","text":"<pre><code>2 2 5 7\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv1/05_nagrade/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n2 7\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, jedno mogu\u0107e re\u0161enje je da se na prvom takmi\u010denju dodele dve nagrade od po \\(5\\) nov\u010di\u0107a, na drugom dve od po \\(4\\), na tre\u0107em pet od po \\(3\\) i na \u010detvrtom sedam nagrada od po jednog nov\u010di\u0107a. Po\u0161to su sve nagrade razli\u010dite, i na svakom takmi\u010denju je nagra\u0111en prost broj takmi\u010dara, ova podela zadovoljava date uslove. Mogu\u0107a su i druga re\u0161enja, na primer da se na prvom takmi\u010denju nagradi pet, a na tre\u0107em tri takmi\u010dara.</p> <p>U drugom primeru, jedino re\u0161enje gde je nagra\u0111en prost broj takmi\u010dara je <code>2 7</code> (jer \\(1\\) nije prost broj). Kako su na njemu nagrade na oba takmi\u010denja iste (po jedan nov\u010di\u0107), ono ne zadovoljava sve uslove, tako da ne postoji re\u0161enje.</p>"},{"location":"takprog/2017_2018/kv1/05_nagrade/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N\\).</li> <li>\\(1 \\leq A_i\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(N \\leq 8, A_i \\leq 1000\\).</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei \\(N \\leq 1000, A_i \\leq 3000\\).</li> <li>U test primerima koji vrede \\(60\\) poena va\u017ei \\(N \\leq 1000, A_i \\leq 200000\\).</li> </ul>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/","title":"1 - Mala matrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Data je matrica \\(A\\) koja ima dve vrste i tri kolone (tj. dimenzija \\(2\\times 3\\)). Elementi matrice su celi brojevi koji su ve\u0107i od nule ili jednaki nuli. Zameniti sve elemente matrice koji su jednaki nuli pozitivnim celim brojevima (prirodnim brojevima), tako da zbir svih elemenata u prve dve kolone bude jednak zbiru elemenata u poslednje dve kolone. Ako ima vi\u0161e mogu\u0107ih na\u010dina da se to izvede, odrediti onu zamenu kod koje je zbir svih elemenata matrice minimalan. Ako postoji vi\u0161e razli\u010ditih matrica sa minimalnim zbirom, od\u0161tampati bilo koju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Plav\u0161i\u0107 i Ivan Sto\u0161i\u0107 <p>Primetimo da ako su zbirovi podmatrice koju \u010dine prve dve kolone i podmatrice koju \u010dine poslednje dve kolone jednaki, onda su jednaki zbir elemenata u prvoj koloni i zbir elemenata u tre\u0107oj koloni. Prema tome, proverava\u0107emo da li mo\u017eemo da podesimo vrednosti nula-elemenata tako da zbir prve i zbir tre\u0107e kolone budu jednaki. Elementi koji se nalaze u drugoj (srednjoj) koloni ne uti\u010du na zbir i zbog toga je dovoljno one koji su jednaki nuli postaviti na jedan.</p> <p>Neka je \\(nz\\) ukupan broj nula u prvoj i tre\u0107oj koloni.</p> <p>Ako je \\(nz=0\\), onda u tim dvema kolonama nema niti jedan element koji se mo\u017ee promeniti. Ako su zbirovi tih kolona jednaki, onda problem ima re\u0161enje i to je matrica u kojoj je samo srednja kolona a\u017eurirana tako \u0161to su elementi koji su jednaki nuli zamenjeni jedinicom.</p> <p>Ako je \\(nz=1\\), onda je samo jedan element jednak nuli i on mo\u017ee promeniti vrednost. Njegova vrednost se odredi tako da zbirovi prve i tre\u0107e kolone budu jednaki. Ako je ta vrednost ve\u0107a od nule, onda problem ima re\u0161enje.</p> <p>Ako je \\(nz=3\\), onda je samo jedan od \\(4\\) elementa u prvoj i tre\u0107oj koloni razli\u010dit od nule. Neka je \\(k\\) redni broj kolone u kojoj se nalazi taj ne-nula element. Jedno od re\u0161enja se dobija tako \u0161to se drugi element u koloni  \\(k\\) izjedna\u010di sa jedan, a elementi u koloni \\(4-k\\) (kolone numerisane brojevima \\(1\\), \\(2\\) i \\(3\\)) izjedna\u010de sa odgovaraju\u0107im elementima (ista vrsta) u koloni  \\(k\\).</p> <p>Ako je \\(nz=4\\), onda su sva \u010detiri elementa jednaki nuli i treba ih promeniti u jedan.</p> <p>Ako je \\(nz=2\\), imamo dva podslu\u010daja:</p> <p>Ne-nula elementi su u istoj koloni (neka je to kolona \\(k\\)). Tada elemente u koloni \\(4-k\\) treba izjedna\u010diti sa odgovaraju\u0107im u koloni \\(k\\) (to je jedno od mogu\u0107ih re\u0161enja).</p> <p>Ne-nula elementi su u razli\u010ditim kolonama. Neka su vrednosti tih elemenata \\(a\\) i \\(b\\) (obele\u017eeni tako da je \\(a\\leq b\\)). Jedno od mogu\u0107ih re\u0161enja se dobija tako \u0161to se nula-element u koloni u kojoj je \\(b\\) izjedna\u010di sa \\(1\\), a nula-element u koloni u kojoj je \\(a\\) izjedna\u010di sa \\(b-a+1\\). Lako se proverava da ovo re\u0161enje zadovoljava sve uslove zadatka.</p> 01_mala_matrica.cpp<pre><code># include &lt;stdio.h&gt;\n\nlong long a[2][3];\n\nint resi4() {\n  a[0][0] = a[0][2] = a[1][0] = a[1][2] = 1;\n  return 1;\n}\n\nint resi0() {\n  if (a[0][0] + a[1][0] == a[0][2] + a[1][2]) return 1;\n  return 0;\n}\n\nint resi1() {\n  int i, j;\n  i = 0; j = 0;\n  while (i &lt; 2) {\n    if (a[i][j] == 0) break;\n    j += 2;\n    if (j &gt; 2) {\n      i++; j = 0;\n    }\n  }\n  if (i &gt;= 2) return 0;\n  a[i][j] = a[i][2-j] + a[1-i][2-j] - a[1-i][j];\n  if (a[i][j] &lt;= 0) return 0; else return 1;\n}\n\nint resi3() {\n  int i, j;\n  i = 0; j = 0;\n  while (i &lt; 2) {\n    if (a[i][j] != 0) break;\n    j += 2;\n    if (j &gt; 2) {\n      i++; j = 0;\n    }\n  }\n  if (i &gt;= 2) return 0;\n  a[i][2-j] = a[i][j];\n  a[1-i][j] = a[1-i][2-j] = 1;\n  return 1;\n}\n\nint resi2() {\n  int i1, j1, i2, j2;\n  if ((a[0][0] != 0) &amp;&amp; (a[1][0] != 0)) {\n    a[0][2] = a[0][0];\n    a[1][2] = a[1][0];\n    return 1;\n  }\n  if ((a[0][2] != 0) &amp;&amp; (a[1][2] != 0)) {\n    a[0][0] = a[0][2];\n    a[1][0] = a[1][2];\n    return 1;\n  }\n  if (a[0][0] != 0) {\n    i1 = j1 = 0;\n  } else {\n    i1 = 1; j1 = 0;\n  }\n  if (a[0][2] != 0) {\n    i2 = 0; j2 = 2;\n  } else {\n    i2 = 1; j2 = 2;\n  }\n  if (a[i1][j1] &gt;= a[i2][j2]) {\n    a[1-i1][j1] = 1;\n    a[1-i2][j2] = 1 + a[i1][j1] - a[i2][j2];\n    return 1;\n  } else {\n    a[1-i2][j2] = 1;\n    a[1-i1][j1] = 1 + a[i2][j2] - a[i1][j1];\n    return 1;\n  } \n  return 0;\n}\n\nmain() {\n  int nz;\n  int i, j, k;\n  for (i = 0; i &lt; 2; i++)\n    for (j = 0; j &lt;= 2; j++)\n      scanf(\"%lld\", &amp;a[i][j]);\n  if (a[0][1] == 0) a[0][1] = 1;\n  if (a[1][1] == 0) a[1][1] = 1;\n  nz = 0;\n  if (a[0][0] == 0) nz++;\n  if (a[0][2] == 0) nz++;\n  if (a[1][0] == 0) nz++;\n  if (a[1][2] == 0) nz++;\n  switch (nz) {\n    case 0:\n      k = resi0();\n      break;\n    case 1:\n      k = resi1();\n      break;\n    case 2:\n      k = resi2();\n      break;\n    case 3:\n      k = resi3();\n      break;\n    case 4:\n      k = resi4();\n      break;\n  }\n  if (k == 1) {\n    for (i = 0; i &lt; 2; i++) {\n      for (j = 0; j &lt; 3; j++) \n        printf(\"%lld \", a[i][j]);\n      printf(\"\\n\");\n    }\n  } else {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#opis-ulaza","title":"Opis ulaza","text":"<p>U dva reda standardnog ulaza se nalaze po tri cela broja koji predstavljaju dve vrste date matrice.</p>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#opis-izlaza","title":"Opis izlaza","text":"<p>Ako ne postoji matrica sa tra\u017eenim osobinama ispisati \\(-1\\) u prvom redu standardnog izlaza. Ako postoji matrica sa tra\u017eenim osobinama, ispisati elemente te matrice, u svakom od dva reda po jednu vrstu matrice.</p>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#ulaz","title":"Ulaz","text":"<pre><code>1 5 6\n0 5 2\n</code></pre>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#izlaz","title":"Izlaz","text":"<pre><code>1 5 6\n7 5 2\n</code></pre>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#ulaz_1","title":"Ulaz","text":"<pre><code>3 0 2\n1 5 0\n</code></pre>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#izlaz_1","title":"Izlaz","text":"<pre><code>3 1 2\n1 5 2\n</code></pre>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, samo je element u preseku druge vrste i prve kolone jednak nuli. Ako njega izjedna\u010dimo sa \\(7\\), zbirovi podmatrica \u0107e biti jednaki. Ako zamenimo bilo kojim drugim brojem, zbirovi podmatrica \u0107e se razlikovati.</p>"},{"location":"takprog/2017_2018/kv2/01_mala_matrica/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>Elementi ulazne matrice imaju vrednosti izme\u0111u \\(0\\) i \\(10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(50\\) poena, elementi matrice nisu ve\u0107i od \\(10\\).</li> <li>U test primerima koji vrede \\(20\\) poena, ta\u010dno jedan element matrice je jednak nuli.</li> <li>U test primerima koji vrede \\(30\\) poena nema dodatnih ograni\u010denja. </li> </ul>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/","title":"2 - Trivijalan broj","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Mala Ka\u0107olina je odavno svima nama poznata kao odli\u010dan matemati\u010dar. Kako je lako uspela da pomno\u017ei sve mogu\u0107e parove brojeva manjih od milijardu, re\u0161ila je da sebi malo ote\u017ea igru sa brojevima.</p> <p>Definisa\u0107emo trivijalnost broja \\(x\\)  kao koli\u010dnik zbira njegovih pozitivnih delilaca i njega samog (na primer trivijalnost broja \\(6\\) iznosi \\(\\frac{1 + 2 + 3 + 6}{6} = 2\\)).</p> <p>Za broj \\(x\\) ka\u017eemo da je najtrivijalniji broj u intervalu \\([l,r]\\) (skupu brojeva \\(\\{ l, l+1, \\ldots, r-1, r \\}\\)), ako pripada datom intervalu i njegova trivijalnost je najmanja od trivijalnosti svih brojeva na tom intervalu i ne postoji nijedan drugi broj manji od njega koji pripada intervalu i ima istu trivijalnost. </p> <p>Ka\u0107olina je sebi zadala \\(T\\) pitanja oblika :</p> <ul> <li>Na\u0107i najtrivijalniji broj u intervalu \\([2, A_i]\\)</li> </ul> <p>Da li mo\u017eete odgovoriti na ove upite br\u017ee od Ka\u0107oline (njoj otprilike treba dve sekunde da odgovori na sva pitanja)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Aleksa Plav\u0161i\u0107 Dragan Uro\u0161evi\u0107 Nikola Jovanovi\u0107 i Ivan Sto\u0161i\u0107 <p>Svakako najlak\u0161i na\u010din da se re\u0161i ovaj zadatak jeste da se odredi trivijalnost svakog od brojeva izme\u0111u \\(2\\) i \\(N\\) (\\(N\\) je broj za koji se tra\u017ei odgovor) i nakon toga odredi broj koji ima najmanju trivijalnost. Pri odre\u0111ivanju zbira delilaca koristimo \u010dinjenicu da u paru sa svakim deliocem \\(d_1 &lt; \\sqrt{N}\\) ide i delilac \\(d_2 = \\frac{N}{d_1}\\). Zbog toga je dovoljno samo za brojeve izme\u0111u \\(1\\) i \\(\\sqrt{N}\\) proveravati da li dele broj \\(N\\) i za svaki broj \\(d&lt;\\sqrt{N}\\) koji deli broj \\(n\\) dodati zbiru delilaca vrednost \\(d + \\frac{N}{d}\\), ako je \\(\\sqrt{N}\\) ceo broj onda je i \\(\\sqrt{N}\\) tako\u0111e delilac broja \\(N\\) i treba ga dodati zbiru (ali sa njim u paru ne ide drugi delilac). Prema tome, odre\u0111ivanje zbira svih delilaca za sve brojeve izme\u0111u \\(2\\) i \\(N\\) ima slo\u017eenost \\(O(N\\sqrt{N})\\). Ako to treba da ponovimo \\(T\\) puta (za \\(T\\) razli\u010ditih ulaznih vrednosti), onda je ukupna slo\u017eenost \\(O(TN\\sqrt{N})\\).</p> <p>Gornje re\u0161enje mo\u017eemo profiniti tako \u0161to bi samo jednom ra\u010dunali zbir delilaca za brojeve izme\u0111u \\(2\\) i najve\u0107eg od brojeva \\(A_i\\), nakon toga za svaki pojedina\u010dni \\(A_i\\), odre\u0111ujemo broj sa najmanjom trivijalno\u0161\u0107u, ra\u010dunaju\u0107i koli\u010dnike zbira delilaca i brojeva za odgovaraju\u0107e brojeve.</p> <p>Odre\u0111ivanje zbira delilaca mo\u017eemo ubrzati koriste\u0107i \u010dinjenicu da su svi brojevi \\(d, 2d, 3d, 4d, \\ldots\\) deljivi brojem \\(d\\) i zbog toga zbiru delilaca za te brojeve treba dodati broj \\(d\\). Prema tome za svaku vrednost \\(d=1, 2, 3, \\ldots, N\\) treba zbiru delilaca brojeva \\(d, 2d, 3d, \\ldots, kd\\) (gde je \\(k\\) broj sa osobinom da je \\(kd \\leq n &lt; (k+1)d\\)) dodati broj tj. delilac \\(d\\). Lako zaklju\u010dujemo da za konkretno \\(d\\) treba a\u017eurirati (uve\u0107ati) zbir delilaca za \\(\\frac{N}{d}\\) brojeva, pa je slo\u017eenost odre\u0111ivanja zbira delilaca za brojeve izme\u0111u \\(2\\) i \\(N\\) jednaka \\(O(N + \\frac{N}{2} + \\frac{N}{3} + \\ldots + \\frac{N}{N}) = O(N\\log N)\\).</p> <p>Primetimo da je zbir delilaca za proste brojeve \\(p\\) jednak \\(p+1\\) i trivijalnost prostog broja je jednaka \\(1 + \\frac{1}{p}\\). S druge strane svaki slo\u017een broj \\(N\\) ima osobinu da je zbir delilaca ve\u0107i od \\(N + \\sqrt{N}\\), pa je trivijalnost ve\u0107a od \\(1 + \\frac{1}{\\sqrt{N}}\\). Name\u0107e se da \u0107e najmanju trivijalnost u intervalu od \\(2\\) do \\(N\\) imati najve\u0107i prost broj koji nije ve\u0107i od \\(N\\).  Odre\u0111ivanje tog najve\u0107eg prostog broja mo\u017eemo izvesti tako \u0161to za brojeve \\(N, N-1, N-2, \\ldots\\) proveravamo da li su prosti i postupak prekidamo kada odredimo prvi broj koji jeste prost. Postupak mo\u017eemo profiniti tako \u0161to bi testirali (proveravali) samo brojeve oblika \\(6k+1\\) i \\(6k+5\\) (naravno, izuzetak su \\(2\\) i \\(3\\)).</p> <p>Proveru da li je broj prost \\(N\\) izvodimo proveravavaju\u0107i da li ima delioce me\u0111u brojevima izme\u0111u \\(2\\) i \\(\\sqrt{N}\\). Ako me\u0111u njima ima bar jedan delilac onda broj \\(N\\) nije prost, u suprotnom jeste.</p> <p>Postupak provere da li je broj prost mo\u017eemo ubrzati tako \u0161to bi proveravali da li broj \\(N\\) ima delioce samo me\u0111u prostim brojevima izme\u0111u \\(2\\) i \\(\\sqrt{N}\\). Zbog toga bi za po\u010detak trebalo da odredimo samo proste brojeve izme\u0111u \\(2\\) i \\(\\sqrt{N}\\) (koriste\u0107i na primer Eratostenovo sito), a zatim da testiramo da li je neki broj prost tako \u0161to proveravamo da li je deljiv nekim prostim brojem koje smo prethodno izdvojili.</p> 02_trivijalan_broj.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxi=5000001;\n\nlong long a[maxi];\nlong long s[maxi];\n\nint main()\n{\n\n    for (int i=1; i&lt;maxi; i++)\n        for (int j=i; j&lt;maxi; j+=i)\n            s[j]+=i;\n\n    int t,x;\n\n    cin&gt;&gt;t;\n\n    while(t--)\n    {\n        cin&gt;&gt;x;\n\n        long long ans=2;\n        for (int i=2; i&lt;=x; i++)\n            if (1.0*s[i]/i &lt;1.0*s[ans]/ans) ans=i;\n\n        cout&lt;&lt;ans&lt;&lt;\"\\n\";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan prirodan broj \\(T\\), koji predstavlja broj pitanja koje je Ka\u0107olina zadala.</p> <p>Svaka od narednih \\(T\\) linija sadr\u017ei jedan broj, ta\u010dnije \\(i\\)-ta linija sadr\u017ei broj \\(A_i\\).</p>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od zadatih \\(T\\) upita ispisati najtrivijalniji broj u zadatom intervalu, ta\u010dnije u \\(i\\)-toj liniji ispisati najtrivijalni broj u intervalu [\\(2\\), \\(A_i\\)].</p>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#primer","title":"Primer","text":""},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#ulaz","title":"Ulaz","text":"<pre><code>1\n4\n</code></pre>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Dat je samo jedan upit i potrebno je na\u0107i najtrivijalniji broj u intervalu \\([2, 4]\\).</p> <p>Trivijalnost broja 2 : \\(\\frac{1 + 2}{2} = 1.50\\).</p> <p>Trivijalnost broja 3 : \\(\\frac{1 + 3}{3} = 1.33\\).</p> <p>Trivijalnost broja 4 : \\(\\frac{1+2+4}{4} = 1.75\\).</p> <p>Najmanju trivijalnost ima broj \\(3\\), tako da je on re\u0161enje ovog primera.</p>"},{"location":"takprog/2017_2018/kv2/02_trivijalan_broj/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(2 \\leq A_i \\leq  5 \\cdot 10^6\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena va\u017ei ograni\u010denje \\(2\\leq A_i \\leq 20\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei ograni\u010denje \\(2\\leq A_i \\leq 1000\\).</li> <li>U test primerima vrednim \\(30\\) poena va\u017ei ograni\u010denje \\(2\\leq A_i \\leq 2\\cdot 10^5\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/","title":"3 - Topla voda","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>D\u017earko se upravo vratio ku\u0107i sa zimovanja na Alpima, i, kako to obi\u010daji nala\u017eu, re\u0161io je da sa nekoliko mesta u svojoj ku\u0107i ispusti nagomilanu ledenu vodu. D\u017earkova ku\u0107na vodovodna mre\u017ea se mo\u017ee modelirati kao kolekcija \\(N\\) vodovodnih \u010dvorova, koji su ozna\u010deni brojevima od \\(1\\) do \\(N\\), i koji su povezani sa \\(N-1\\) cevi. U \u010dvoru \\(1\\) nalazi se bojler (ure\u0111aj iz kojeg izlazi topla voda). Na svim ostalim \u010dvorovima nalazi se slavina (ure\u0111aj iz kojeg te\u010de voda).</p> <p>Dodatno va\u017ei da je svaki vodovodni \u010dvor povezan sa bojlerom cevima, bilo direktno, bilo preko nekih drugih \u010dvorova. Kada D\u017earko odvrne slavinu na nekom \u010dvoru, on \u010deka dok iz te slavine ne pote\u010de topla voda. Ovo vreme \u010dekanja, izra\u017eeno u minutima, jednako je broju cevi koje su sadr\u017eale ledenu vodu me\u0111u cevima sa jedinstvenog puta od bojlera do te slavine. Nakon \u0161to zatvori slavinu sve ove cevi do daljnjeg vi\u0161e ne sadr\u017ee ledenu ve\u0107 toplu vodu. D\u017earko je smislio i vama rekao plan, odnosno redosled slavina na kojima planira da ispu\u0161ta vodu. Pomozite D\u017earku tako \u0161to \u0107ete mu za dati niz slavina re\u0107i, za svaku, koliko dugo \u0107e \u010dekati dok iz nje ne pote\u010de topla voda.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Nikola Jovanovi\u0107 Aleksa Plav\u0161i\u0107 <p>Vodovodnu mre\u017eu mo\u017eemo posmatrati kao stablo sa korenom u \u010dvoru u kom se nalazi bojler (\u010dvor \\(1\\)).  Na samom po\u010detku, voda u svim cevima (tj. svim granama stabla) je ledena. U toku izvr\u0161avanja upita markira\u0107emo one grane u kojima voda postane topla. Sada svaki upit mo\u017eemo formulisati kao odgovor na pitanje Koliko ima nemarkiranih grana na putu od korena do \u010dvora \\(x_i\\)? Naravno, na po\u010detku nijedna grana nije markirana.</p> <p>Najjednostavniji na\u010din da odgovorimo na upit je da obi\u0111emo sve grane od \\(x_i\\) do korena, izbrojimo nemarkirane, a zatim ih markiramo. Ovaj pristup u najnepovoljnijem slu\u010daju obilazi celo stablo pri svakom upitu pa je vremenska slo\u017eenost \\(O(MN)\\). </p> <p>Klju\u010dna opservacija koja nas dovodi do boljeg re\u0161enja je da se svaki put od korena do nekog \u010dvora deli na niz (\\(0\\) ili vi\u0161e) markiranih grana, a zatim niz (\\(0\\) ili vi\u0161e) nemarkiranih grana. Drugim re\u010dima, svi markirani \u010dvorovi na nekom takvom putu \u010dine prefiks tog puta. Ovo se lako dokazuje tako \u0161to primetimo da je svaka markirana grana postala markirana pri tra\u017eenju odgovara na neki upit. Samim tim, sve grane od nje do korena su tako\u0111e markirane u istom upitu. Imaju\u0107i ovo svojstvo u vidu, dovoljno je pri svakom upitu obilaziti samo grane od \\(x_i\\) do prve markirane grane na putu do korena. Sve grane na ostatku puta su sigurno ve\u0107 markirane. </p> <p>Ovo re\u0161enje, iako za neke nezgodne upite mo\u017ee obi\u0107i mnogo grana, u toku celog izvr\u0161avanja programa obi\u0111e svaku granu najvi\u0161e jednom (u trenutku kada biva markirana), pa je ukupna vremenska slo\u017eenost \\(O(N+M)\\), \u0161to je u ovom slu\u010daju optimalno.</p>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se ceo broj \\(N\\) koji predstavlja broj \u010dvorova vodovodne mre\u017ee. U \u010dvoru \\(1\\) se nalazi bojler. U narednih \\(N-1\\) linija standardnog ulaza nalaze se po dva cela broja \\(u_i, v_i\\), redni brojevi vodovodnih \u010dvorova koji su direktno povezani jednom cevi. U narednom redu nalazi se \\(M\\), broj slavina koje interesuju D\u017earka. U narednih \\(M\\) linija nalazi se po jedan broj \\(x_i\\) - redni broj slavine.</p>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(M\\) redova ispisati po jedan broj, gore definisano vreme \u010dekanja izra\u017eeno u minutima.</p>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv2/03_topla_voda/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 2\n2 3\n1 4\n3\n2\n3\n4\n</code></pre>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#izlaz","title":"Izlaz","text":"<pre><code>1\n1\n1\n</code></pre>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv2/03_topla_voda/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 4\n4 3\n2 4\n2\n3\n2\n</code></pre>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n1\n</code></pre>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U \\(1\\). primeru, nakon \u0161to D\u017earko pusti vodu sa slavine broj \\(2\\), topla voda \u0107e se nalaziti u cevi koja spaja bojler i slavinu broj \\(2\\) pa \u0107e kad odvrne slavinu \\(3\\) \u010dekati samo jedan minut. Iz istog razloga \u0107e \u010dekati samo jedan minut kada odvrne slavinu \\(4\\).</p> <p>U \\(2\\). primeru, nakon \u0161to D\u017earko odvrne slavinu broj \\(3\\), topla voda \u0107e se nalaziti u cevima \\((1, 4)\\) i \\((4, 3)\\) pa \u0107e kad odvrne slavinu \\(2\\) \u010dekati samo jedan minut, odnosno \u010deka\u0107e samo da topla voda pro\u0111e kroz cev \\((2, 4)\\).</p>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N, M \\leq 300000\\).</li> <li>Garantuje se da \u0107e vodovodna mre\u017ea biti povezana.</li> <li>Za brojeve slavine \\(x_i\\) va\u017ei \\(2 \\leq x_i \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U 35% primera va\u017ei \\(N, M \\leq 1000\\).</li> <li>U 35% primera va\u017ei \\(N, M \\leq 75000\\).</li> <li>U 30% primera va\u017ei \\(N, M \\leq 300000\\).</li> </ul>"},{"location":"takprog/2017_2018/kv2/03_topla_voda/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Sa strane implementacije, re\u0161enje se deli na dva dela: pripremu stabla i odgovaranje na upite. Priprema stabla se svodi na \u010duvanje roditeljskog \u010dvora za svaki \u010dvor, \u0161to nakon u\u010ditavanja grana mo\u017eemo uraditi prostom grafovskom pretragom (DFS/BFS). Pri svakom upitu dolazimo do odgovora pra\u0107enjem niza roditeljskih \u010dvorova po\u010dev\u0161i od \u010dvora \\(x_i\\), pritom vr\u0161e\u0107i markiranje svih pose\u0107enih \u010dvorova.</p> 03_topla_voda.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; e[300005];\nint p[300005];\nbool topla[300005];\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i=1; i&lt;n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &amp;u, &amp;v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    queue&lt;int&gt; q;\n    p[1] = 1;\n    q.push(1);\n    while (!q.empty()) {\n        int x = q.front(); q.pop();\n        for (int y : e[x]) {\n            if (!p[y]) {\n                p[y] = x;\n                q.push(y);\n            }\n        }\n    }\n\n    topla[1] = true;\n\n    int m;\n    scanf(\"%d\", &amp;m);\n    while (m--) {\n        int x, y = 0;\n        scanf(\"%d\", &amp;x);\n        while (!topla[x]) {\n            topla[x] = true;\n            x = p[x];\n            y++;\n        }\n        printf(\"%d\\n\", y);\n    }\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/","title":"4 - D\u017eokeri","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 5000ms 256MB <p>Mali Perica je napravio po\u010detni\u010dku gre\u0161ku: \u0161ifrirao je celokupan sadr\u017eaj svog hard diska koriste\u0107i neki string (sastavljen od malih slova engleske abecede) kao klju\u010d, koji je zatim izgubio! Uspeo je, dodu\u0161e, da prona\u0111e dva stringa, \\(A\\) i \\(B\\), koja su \u201dsli\u010dni\u201d tra\u017eenom. Perica sada \u017eeli da konstrui\u0161e najverovatniju mogu\u0107u \u0161ifru koriste\u0107i ova dva stringa.</p> <p>Peri\u010din cilj je da u\u010dini da ova dva stringa budu potpuno isti. Dozvoljen mu je samo jedan tip poteza: ubacivanje odre\u0111enog broja \u201dd\u017eoker\u201d karaktera izme\u0111u dva susedna karaktera u jednom od ova dva stringa. Na primer, u jednom potezu od stringa <code>abcdef</code> mo\u017eemo napraviti string <code>abc???def</code>, ili <code>abcdef??</code> (tj. dozvoljeno je ubacivati d\u017eokere i na po\u010detak ili kraj stringa). D\u017eoker karakteri se podudaraju sa bilo kojim karakterom!</p> <p>Naravno, ovo bi bio jednostavan zadatak da ne postoje dodatni uslovi: kada se stringovi \\(A\\) i \\(B\\) izjedna\u010de na ovaj na\u010din, obra\u010dunava se \u201dkvalitet\u201d re\u0161enja, na slede\u0107i na\u010din: - Za svaku poziciju na kojoj ne postoji d\u017eoker ni u stringu \\(A\\) ni u stringu \\(B\\), dodaje se 1 poen. - Za svaki potez, oduzima se \\(X\\) poena. - Za svaki d\u017eoker, oduzima se \\(Y\\) poena.</p> <p>Va\u0161 zadatak je da odredite maksimalan kvalitet koji je mogu\u0107e posti\u0107i na ovaj na\u010din.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Petar Veli\u010dkovi\u0107 Petar Veli\u010dkovi\u0107 Slobodan Mitrovi\u0107 Slobodan Mitrovi\u0107 <p>Primetimo najpre da je zadatak za slu\u010daj \\(x = y = 0\\) jednak problemu Najdu\u017ei Zajedni\u010di Podniz (engl. Longest Common Subsequence; skr. LCS). Uz vrlo jednostavnu izmenu, algoritam za LCS mo\u017ee tako\u0111e re\u0161iti varijantu ovog zadatka za slu\u010daj \\(x = 0\\). Dakle, prava te\u017eina zadatka le\u017ei u slu\u010daju kada \\(x \\neq 0\\). U nastavku \u0107emo se najpre ukratko podsetiti algoritma za LCS i pokazati kako se jednostavnom izmenom mo\u017ee iskoristiti da re\u0161i ovaj zadatak za slu\u010daj \\(x = 0\\). Potom \u0107emo opisati kako se taj algoritam mo\u017ee pro\u0161iriti tako da re\u0161i ovaj zadatak u op\u0161tem slu\u010daju, tj. \u010dak i kada \\(x \\neq 0\\).</p> <p>Standardni LCS algoritam defini\u0161e niz \\(dp[i][j]\\) koji predstavlja LCS za stringove \\(A^i\\) i \\(B^j\\), gde \\(A^i\\) (\\(B^j\\)) ozna\u010dava sufiks stringa \\(A\\) (\\(B\\)) od pozicije \\(i\\) (\\(j\\)). Tada, \\(dp[i][j]\\) defini\u0161emo kao: \\(dp[i][j] = \\max\\{dp[i + 1][j], dp[i][j + 1], eq_{i, j}\\}\\), gde u slu\u010daju da \\(A[i] = B[j]\\) imamo \\(eq_{i, j} = dp[i + 1][j + 1] + 1\\), a ina\u010de \\(eq_{i, j} = -\\infty\\).</p> <p>Da bismo re\u0161ili ovaj zadatak u slu\u010daju kada \\(x = 0\\), dovoljno je da defini\u0161emo \\(dp[i][j]\\) na samo malo druga\u010diji na\u010din, naime \\(dp[i][j] = \\max\\{dp[i + 1][j] - y, dp[i][j + 1] - y, eq_{i, j}\\}\\), gde je \\(eq_{i, j}\\) definisano kao i pre.</p> <p>Posmatrajmo sada slu\u010daj \\(x \\neq 0\\). Prvo, u definiciji \\(dp[i][j]\\) imamo, izme\u0111u ostalog, vrednost \\(dp[i + 1][j] - y\\) koja se mo\u017ee intepretirati na slede\u0107i na\u010din: ubacimo d\u017eoker ispod karaktera \\(A[i]\\), \u0161to ima cenu \\(y\\), i prona\u0111imo LCS za \\(A^{i + 1}\\) i \\(B^j\\). Kada \\(x \\neq 0\\), treba li cena i dalje da bude samo \\(y\\) ili ipak treba da bude \\(x + y\\)? To zavisi od toga da li je i ispod \\(A[i - 1]\\) bio d\u017eoker ili nije. Ako je ispod bio d\u017eoker, onda je cena samo \\(y\\) (jer ne po\u010dinjemo novu operaciju), a ako nije bio d\u017eoker onda je cena \\(x + y\\) (jer po\u010dinjemo novu operaciju). Sada je jasno kako pro\u0161iriti algoritam za LCS da re\u0161i ovaj zadatak -- pored indeksa \\(i\\) i \\(j\\), trebalo bi pamtiti jo\u0161 dva indikatora (tj. dve promennjive gde svaka ima vrednost \\(0\\) ili \\(1\\)) koje ozna\u010davaju da li je ispod \\(A[i - 1]\\), tj. iznad \\(B[j - 1]\\), bio umetnut d\u017eoker ili nije.</p>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se \u010detiri cela broja, \\(N\\), \\(M\\), \\(X\\) i \\(Y\\), koji predstavljaju du\u017eine stringova \\(A\\) i \\(B\\), cenu jednog poteza, i cenu jednog d\u017eokera, redom. U drugom redu standardnog ulaza nalazi se string \\(A\\), sastavljen od \\(N\\) malih slova engleske abecede. U tre\u0107em redu standardnog ulaza nalazi se string \\(B\\), sastavljen od \\(M\\) malih slova engleske abecede.</p>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati jedan ceo broj, koji predstavlja maksimalan kvalitet \u0161ifre koji je mogu\u0107e posti\u0107i koriste\u0107i stringove \\(A\\) i \\(B\\) (ovaj broj mo\u017ee biti negativan).</p>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv2/04_dzokeri/#ulaz","title":"Ulaz","text":"<pre><code>5 4 1 1\nabcef\nacde\n</code></pre>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#izlaz","title":"Izlaz","text":"<pre><code>-3\n</code></pre>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv2/04_dzokeri/#ulaz_1","title":"Ulaz","text":"<pre><code>7 7 5 5\nabcdefj\nbefghij\n</code></pre>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#izlaz_1","title":"Izlaz","text":"<pre><code>-41\n</code></pre>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, mo\u017eemo ubaciti jedan d\u017eoker izme\u0111u karaktera <code>c</code> i <code>e</code> u stringu \\(A\\), jedan d\u017eoker izme\u0111u karaktera <code>a</code> i <code>c</code> u stringu \\(B\\), i jedan d\u017eoker na kraj stringa \\(B\\). Ovim dobijamo \u201diste\u201d stringove:</p> <p><code>abc?ef</code></p> <p><code>a?cde?</code></p> <p>Ukupni kvalitet ovog re\u0161enja je \\(3 - 1 \\times 3 - 1 \\times 3 = -3\\) (tri podudaranja bez d\u017eokera, tri poteza, tri d\u017eokera). Nije mogu\u0107e posti\u0107i re\u0161enje sa ve\u0107im kvalitetom.</p> <p>U drugom primeru, jedno od mogu\u0107ih optimalnih re\u0161enja \u0107e uraditi slede\u0107e poteze: - Ubaciti jedan d\u017eoker na po\u010detak stringa \\(B\\); - Ubaciti dva d\u017eokera izme\u0111u karaktera <code>b</code> i <code>e</code> u stringu \\(B\\); - Ubaciti tri d\u017eokera izme\u0111u karaktera <code>f</code> i <code>j</code> u stringu \\(A\\).</p> <p>Ovim dobijamo \u201diste\u201d stringove:</p> <p><code>abcdef???j</code></p> <p><code>?b??efghij</code></p> <p>Ukupni kvalitet ovog re\u0161enja je \\(4 - 5 \\times 3 - 5 \\times 6 = -41\\) (\u010detiri podudaranja bez d\u017eokera, tri poteza, \u0161est d\u017eokera). Nije mogu\u0107e posti\u0107i re\u0161enje sa ve\u0107im kvalitetom.</p>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 1000\\).</li> <li>\\(0 \\leq X, Y \\leq 10^8\\).</li> <li>Stringovi \\(A\\) i \\(B\\) \u0107e sadr\u017eati samo mala slova engleske abecede.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(N, M \\leq 100\\), \\(X, Y \\leq 1000\\).</li> <li>U test primerima vrednim 10 poena va\u017ei\u0107e \\(X = Y = 0\\).</li> <li>U test primerima vrednim 10 poena va\u017ei\u0107e \\(X = 0\\).</li> <li>U test primerima vrednim 20 poena va\u017ei\u0107e \\(X, Y \\leq 1000\\).</li> <li>U test primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv2/04_dzokeri/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Recimo da \u017eelimo da izra\u010dunamo \\(dp[i][j][ind1][ind2]\\), gde su \\(ind1\\) i \\(ind2\\) kao \u0161to je opisano iznad. U smernicama datim ispod, pretpostavljamo da su stringovi \\(A\\) i \\(B\\) indeksirani od \\(0\\). Radi jednostavnosti, neka \\(ret\\) predstavlja vrednost koju \u017eelimo da izra\u010dunamo. Tada imamo</p> <pre><code>Ako ako i == length(A) i j == length(B):\n  ret = 0\nIna\u010de, ako je i == length(A):\n  ret = -x * (1 - ind2) - y * (length(B) - j)\nIna\u010de, ako je j == length(B):\n  ret = -x * (1 - ind1) - y * (length(A) - i)\nIna\u010de:\n  Ako je A[i] == B[j]:\n    ret = max{dp[i][j + 1][0][1] - x * (1 - ind2) - y, dp[i + 1][j][1][0] - x * (1 - ind1) - y, dp[i + 1][j + 1][0][0] + 1}\n  Ina\u010de:\n    ret = max{dp[i][j + 1][0][1] - x * (1 - ind2) - y, dp[i + 1][j][1][0] - x * (1 - ind1) - y}\n</code></pre> 04_dzokeri.cpp<pre><code>/*\n Author: Petar 'PetarV' Velickovic\n Task: Dzokeri \n*/\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#define MAX_N 1005\n#define NEGINF -99999999999999999LL\n\nusing namespace std;\n\ntypedef long long lld;\n\nint n, m;\nlld x, y;\nstring A, B;\n\nlld dn[MAX_N][MAX_N];\nlld rt[MAX_N][MAX_N];\nlld md[MAX_N][MAX_N];\n\nint main(int argc, char **argv)\n{\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n    cin &gt;&gt; A &gt;&gt; B;\n\n    // Simple base case: zero-cost to begin with\n    dn[0][0] = rt[0][0] = md[0][0] = 0LL;\n\n    // Base case: extending an initial wildcard-gap downwards only\n    for (int i=1;i&lt;=n;i++)\n    {\n        dn[i][0] = md[i][0] = -x - i * y;\n        rt[i][0] = NEGINF;\n    }\n\n    // Base case: extending an initial wildcard-gap rightwards only\n    for (int j=1;j&lt;=m;j++)\n    {\n        rt[0][j] = md[0][j] = -x - j * y;\n        dn[0][j] = NEGINF;\n    }\n\n    // Recurrence relation\n    for (int i=1;i&lt;=n;i++)\n    {\n        for (int j=1;j&lt;=m;j++)\n        {\n            dn[i][j] = max(dn[i - 1][j] - y, md[i - 1][j] - x - y);\n            rt[i][j] = max(rt[i][j - 1] - y, md[i][j - 1] - x - y);\n            md[i][j] = max(dn[i][j], rt[i][j]);\n            if (A[i - 1] == B[j - 1])\n            {\n                md[i][j] = max(md[i][j], md[i - 1][j - 1] + 1);\n            }\n        }\n    }\n\n    cout &lt;&lt; md[n][m] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/","title":"5 - Kiosci","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Poznati prodavac magle D\u017eoni Fog je odlu\u010dio da svoj biznis pro\u0161iri u jednom od najve\u0107ih gradova na svetu - Ni\u0161u, jer je \u010duo da se tamo od prodaje magle ba\u0161 lepo \u017eivi. Poznato je da je Ni\u0161 organizovan kao Njujork tj. sastoji se od \\(m\\) paralelnih horizontalnih avenija i \\(m\\) paralelnih vertikalnih bulevara u \u010dijem se preseku nalazi  \\(m^2\\) raskrsnica; ozna\u010dimo raskrsnicu u preseku \\(i\\)-te avenije i \\(j\\)-tog bulevara sa \\((i,j)\\). Kako su rastojanja izme\u0111u susednih avenija i susednih bulevara jednaka \\(1\\) km, jasno je da je rastojanje izme\u0111u raskrsnica \\((a,b)\\) i \\((c,d)\\) jednako \\(|a-c| + |b-d|\\) km. D\u017eoni planira da otvori kioske magle na nekim raskrsnicama i da prodaje maglu na kilo.</p> <p>Me\u0111utim, prodavcima magle nije lako - ukoliko se npr. pojave predstavnici zakona, D\u017eoni mora da hvata maglu i prenosi je iz svih svojih kioska na neko sigurno mesto. Poznato je da je za prenos jednog kilograma magle na rastojanju od \\(1\\) kilometar potreban \\(1\\) minut. Pomozite D\u017eoniju da isplanira svoje vreme tako \u0161to \u0107ete simulirati \\(n\\) upita nekog od slede\u0107a dva tipa:</p> <ul> <li>\\(1\\) \\(x\\) \\(y\\) \\(v\\) - D\u017eoni otvara novi kiosk sa \\(v\\) kilograma magle na raskrsnici \\((x,y)\\);</li> <li>\\(2\\) \\(x\\) \\(y\\) - D\u017eonija zanima koliko bi mu minuta trebalo da prenese maglu iz svih trenutno otvorenih kioska na raskrsnicu \\((x,y)\\).</li> </ul> <p>Ukoliko pomognete D\u017eoniju, dobijate \\(5\\)kg magle!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Ivan Sto\u0161i\u0107 <p>Ozna\u010dimo sa \\((x_i, y_i)\\) koordinate a sa \\(v_i\\) koli\u010dinu magle u \\(i\\)-tom po redu otvorenom kiosku. Jasno je da je za svaki upit tipa 2 sa parametrima \\((x, y)\\) potrebno izra\u010dunati sumu \\(\\sum_{i=1}^k (|x - x_i| + |y - y_i|)\\cdot v_i\\), gde je \\(k\\) trenutni broj izgra\u0111enih kioska. Direktno ra\u010dunanje sume za svaki upit dovodi do re\u0161enja slo\u017eenosti \\(O(n^2)\\) \u0161to je dovoljno samo za prvi podzadatak. Jedno korisno (i, kada se radi sa Menhetn rastojanjima, vrlo standardno) zapa\u017eanje je da se prethodna suma mo\u017ee nezavisno posmatrati po \\(x\\) i \\(y\\) koordinatama; dakle, dovoljno je re\u0161iti problem ra\u010dunanja sume  \\(\\sum_{i=1}^k |x - x_i|\\cdot v_i\\),  primeniti isti algoritam za \\(y\\) koordinate i sabrati dve dobijene vrednosti na kraju.</p> <p>Ukoliko je \\(m\\) dovoljno mala vrednost, mo\u017eemo koristiti pomo\u0107ne nizove \\(vx[]\\) i \\(vy[]\\) du\u017eine \\(m\\) gde je \\(vx[a] =\\) suma vrednosti \\(v_i\\) za sve izgra\u0111ene kioske \u010dija je \\(x\\)-koordinata jednaka \\(a\\) (analogno i za niz \\(vy[]\\)). Prilikom dodavanja novog kioska \\((x_i, y_i, v_i)\\), a\u017euriramo informacije sa \\(vx[x_i] \\leftarrow vx[x_i] + v_i\\) dok prilikom upita tipa 2 \\((x, y)\\), tra\u017eena suma se svodi na \\(\\sum_{i=1}^m |x - i|\\cdot vx[i]\\). Ovim smo dobili algoritam slo\u017eenosti \\(O(nm)\\) koji koristi \\(O(m)\\) memorije, \u0161to re\u0161ava drugi podzadatak. </p> <p>U tre\u0107em podzadatku, nakon u\u010ditavanja svih upita tipa 1, nema vi\u0161e promena; posmatrano po jednoj koordinati, zadatak postaje ekvivalentan \"te\u017einskoj\" verziji zadatka Prodavnice sa prvog kruga kvalifikacija (videti odgovaraju\u0107e re\u0161enje). Sortiranjem upita tipa 1 na po\u010detku i koriste\u0107i binarnu pretragu za upite tipa 2 dobiijamo re\u0161enje slo\u017eenosti \\(O(n \\log n)\\).</p> <p>Motivisani re\u0161enjem drugog podzadatka, neka je \\(A[i]\\) suma vrednosti \\(v\\) za sve kioske sa \\(x\\)-koordinatom \\(i\\), a neka je \\(B[i] = i \\cdot A[i]\\) (na po\u010detku su oba niza popunjena nulama). Tra\u017eena suma (za upit \\((x,y)\\)) se mo\u017ee transformisati kao</p> \\[ \\sum_{i=1}^k |x - x_i|\\cdot v_i = \\sum_{i=1}^m |x - i|\\cdot A[i] = \\sum_{1 \\leq i \\leq x} (x \\cdot A[i] - B[i]) + \\sum_{x &lt; i \\leq m} (B[i] - x \\cdot A[i]) \\] \\[ = 2x \\cdot \\sum_{1 \\leq i \\leq x} A[i] - 2 \\cdot \\sum_{1 \\leq i \\leq x} B[i] - (x \\cdot totalA - totalB) \\] <p>gde su \\(totalA\\) i \\(totalB\\), redom, sume svih elemenata nizova \\(A\\) i \\(B\\). Zadatak se sada svodi na slede\u0107e: prilikom upita tipa 1 \\((x, y, v)\\) treba a\u017eurirati \\(A[x] \\leftarrow A[x] + v\\) i \\(B[x] \\leftarrow B[x] + x \\cdot v\\) (kao i \\(totalA\\) i \\(totalB\\)), dok prilikom upita tipa 2 \\((x, y)\\) treba izra\u010dunati sume \\(\\sum_{1 \\leq i \\leq x} A[i]\\) i \\(\\sum_{1 \\leq i \\leq x} B[i]\\) i ubaciti ih u gornju formulu.</p> <p>Me\u0111utim, ovo je poznati problem koji se najefikasnije re\u0161ava pomo\u0107u Kumulativne tabele ili Segmentnog stabla nad nizovima \\(A\\) i \\(B\\) (i, naravno, odgovaraju\u0107im nizovima za \\(y\\)-koordinate). Koriste\u0107i ove strukture, dobijamo slo\u017eenost \\(O(\\log n)\\) po upitu, tj. ukupno \\(O(n \\log n)\\). Kako ove strukture zahtevaju \\(O(m)\\) memorije, pravolinijska implementacija je dovoljna za prva 4 podzadatka. Da bismo o\u010duvali ovu slo\u017eenost, finalni pozadatak je potrebno raditi 'offline' uz par trikova: u\u010ditati sve koordinate i kompresovati ih na segment \\([1,n]\\) (npr. sortiranjem) uz odgovaraju\u0107e mapiranje - time se memorijska slo\u017eenost svodi na \\(O(n)\\). Memorijsko ograni\u010denje je dozvoljavalo i da se zadatak radi 'online' koriste\u0107i Implicitno segmentno stablo - u tom slu\u010daju je vremenska i memorijska slo\u017eenost algoritma \\(O(n \\log m)\\).</p> 05_kiosci.cpp<pre><code>/* online solution with implicit segment tree */\n\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 250000;\nconst int MAX_LOG_M = 31;\n\nstruct SegmentTree\n{\n    struct node\n    {\n        int left, right;\n        long long sumVal;\n        long long sumProd;\n        node()\n        {\n            left = 0; right = 0;\n            sumVal = 0LL; sumProd = 0LL;\n        }\n    };\n\n    node nodes[MAX_N * MAX_LOG_M];\n    int currNode;\n    int M;\n\n    void init(int m)\n    {\n        M = m;\n        currNode = 1;\n    }\n\n    void update(int nodeNum, int curr_l, int curr_r, int ind, int val)\n    {\n        if (ind &lt; curr_l || ind &gt; curr_r)\n            return;\n        nodes[nodeNum].sumVal += val;\n        nodes[nodeNum].sumProd += (long long)ind * val;\n\n        if (curr_l != curr_r)\n        {\n            int mid = (curr_l + curr_r) / 2;\n\n            if (nodes[nodeNum].left == 0)\n                nodes[nodeNum].left = ++currNode;\n            update(nodes[nodeNum].left, curr_l, mid, ind, val);\n            if (nodes[nodeNum].right == 0)\n                nodes[nodeNum].right = ++currNode;\n            update(nodes[nodeNum].right, mid + 1, curr_r, ind, val);\n        }\n    }\n\n    long long query(int nodeNum, int curr_l, int curr_r, int l, int r, int ind)\n    {\n        if (nodeNum == 0 || r &lt; curr_l || l &gt; curr_r)\n            return 0LL;\n        if (l &lt;= curr_l &amp;&amp; curr_r &lt;= r)\n        {\n            return (nodes[nodeNum].sumVal * ind - nodes[nodeNum].sumProd);\n        }\n\n        int mid = (curr_l + curr_r) / 2;\n        return query(nodes[nodeNum].left, curr_l, mid, l, r, ind) + query(nodes[nodeNum].right, mid + 1, curr_r, l, r, ind);\n    }\n\n    void bulidKiosk(int ind, int val)\n    {\n        update(1, 1, M, ind, val);\n    }\n\n    long long getTotalTime(int ind)\n    {\n        long long sol = query(1, 1, M, 1, ind, ind);\n        sol = sol * 2 - nodes[1].sumVal * ind + nodes[1].sumProd;\n        return sol;\n    }\n};\n\nSegmentTree treex, treey;\n\nint n, m;\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    treex.init(m);\n    treey.init(m);\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int type, x, y, v;\n        scanf(\"%d\", &amp;type);\n        if (type == 1)\n        {\n            scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);\n            treex.bulidKiosk(x, v);\n            treey.bulidKiosk(y, v);\n        }\n        else\n        {\n            scanf(\"%d%d\", &amp;x, &amp;y);\n            long long sol = treex.getTotalTime(x) + treey.getTotalTime(y);\n            printf(\"%lld\\n\", sol);\n        }\n\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(n\\) i \\(m\\), broj upita i broj avenija/bulevara, redom. U narednih \\(n\\) redova nalaze se odgovaraju\u0107i upiti: ili \\(4\\) prirodna broja \\(1\\) \\(x_i\\) \\(y_i\\) \\(v_i\\) (ukoliko je u pitanju upit tipa \\(1\\)) ili \\(3\\) prirodna broja \\(2\\) \\(x_i\\) \\(y_i\\) (ukoliko je u pitanju upit tipa \\(2\\)) \u010dije je zna\u010denje dato u opisu upita.</p>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki upit tipa \\(2\\) ispisati, u posebnom redu i odgovaraju\u0107em redosledu, jedan prirodan broj - odgovor na taj upit.</p>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv2/05_kiosci/#ulaz","title":"Ulaz","text":"<pre><code>5 20\n1 3 7 10\n1 2 2 8\n2 5 3\n1 10 10 3\n2 1 1\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#izlaz","title":"Izlaz","text":"<pre><code>92\n150\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv2/05_kiosci/#ulaz_1","title":"Ulaz","text":"<pre><code>2 1000000000\n1 1 1 10000\n2 1000000000 1000000000\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#izlaz_1","title":"Izlaz","text":"<pre><code>19999999980000\n</code></pre>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru, prvo se otvori kiosk \\(10\\)kg magle na raskrsnici \\((3, 7)\\), zatim se otvara kiosk sa \\(8\\)kg magle na raskrsnici \\((2, 2)\\). Za slede\u0107i upit, treba izra\u010dunati vreme prebacivanja magle iz ova dva kioska na raskrsnicu \\((5, 3)\\). Rastojanje izme\u0111u raskrsnica \\((3, 7)\\) i \\((5, 3)\\) je \\(|5-3| + |3-7| = 6\\), rastojanje izme\u0111u raskrsnica \\((2, 2)\\) i \\((5, 3)\\) je \\(4\\), pa je za ovaj poduhvat potrebno \\(10 \\cdot 6 + 8 \\cdot 4 = 92\\) minuta. U slede\u0107em upitu se otvara kiosk sa \\(3\\)kg magle na raskrsnici \\((10, 10)\\). U poslednjem upitu treba izra\u010dunati vreme prebacivanja magle iz otvorena \\(3\\) kioska na raskrsnicu \\((1,1)\\) \u0161to je \\(80 + 16 + 54 = 150\\) minuta.</p>"},{"location":"takprog/2017_2018/kv2/05_kiosci/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq n \\leq 250.000\\).</li> <li>\\(1 \\leq m \\leq 10^9\\).</li> <li>\\(1 \\leq x_i, y_i \\leq m\\).</li> <li>\\(1 \\leq v_i \\leq 10^4\\).</li> <li>Mogu\u0107e je da se vi\u0161e razli\u010ditih prodavnica otvori na istoj raskrsnici.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima koji vrede \\(10\\) poena va\u017ei\u0107e \\(n \\leq 5.000\\).</li> <li>U test primerima koji vrede \\(20\\) poena va\u017ei\u0107e \\(n \\leq 150.000\\) i \\(m \\leq 10^3\\).</li> <li>U test primerima koji vrede \\(20\\) poena svi upiti tipa \\(1\\) bi\u0107e pre svih upita tipa \\(2\\).</li> <li>U test primerima koji vrede \\(25\\) poena va\u017ei\u0107e \\(m \\leq 300.000\\).</li> <li>U test primerima koji vrede \\(25\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv3/01_zecevi/","title":"1 - Ze\u010devi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 200ms 64MB <p>Anja ima tri zeca, \u010dije su visine prirodni brojevi. Anja obo\u017eava aritmeti\u010dke progresije, i \u017eeli da za ro\u0111endan nabavi jo\u0161 jednog zeca \u010dija je visina prirodan broj, tako da mo\u017ee da pore\u0111a ta \u010detiri zeca a da njihove visine \u010dine aritmeti\u010dku progresiju. Pomozite Anji tako \u0161to \u0107ete joj re\u0107i koje visine da bude novi zec. Ukoliko nije mogu\u0107e nabaviti jednog novog zeca tako da ovo va\u017ei ispi\u0161ite \\(-1\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Du\u0161an Zdravkovi\u0107 <p>U\u010ditamo visine tri zeca i uredimo ih u neopadaju\u0107i redosled. Dobijamo tri broja \\(b_1 \\leq b_2 \\leq b_3\\). Posmatrajmo razlike \\(d_1 = b_2 - b_1\\) i \\(d_2 = b_3 - b_2\\). Ukoliko su ove razlike jednake, mogu\u0107e je na\u0107i re\u0161enje, to je broj \\(b_3 + d_2\\) i on zajedno sa ostala tri \u010dini aritmeti\u010dku progresiju. I broj \\(b_1 - d_1\\) tako\u0111e \u010dini aritmeti\u010dku progresiju sa ostala tri broja ali ovaj broj mo\u017ee biti manji ili jednak nuli, dok prethodno navedeni \\(b_3 + d_2\\) ne mo\u017ee, jer je ve\u0107i ili jednak od \\(b_3\\) koji je prirodan broj. Dalje, ukoliko je \\(d_1 = 2 d_2\\), odnosno, ukoliko je razlika drugog i prvog broja duplo ve\u0107a od razlike tre\u0107eg i drugog broja, mo\u017eemo dodati novi broj izme\u0111u prva dva, a to je broj \\(b_1 + d_2\\), i on sa ostalima \u010dini aritmeti\u010dku progresiju. Ako je pak \\(d_2 = 2 d_1\\) mo\u017eemo dodati broj \\(b_2 + d_1\\) i on \u0107e sa preostala tri \u010diniti aritmeti\u010dku progresiju. Ako nijedan od ovih uslova nije ispunjen, takav broj ne postoji.</p> 01_zecevi.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int a[3], t;\n    cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2];\n    sort(a, a+3);\n    int d1 = a[1] - a[0];\n    int d2 = a[2] - a[1];\n    if (d1 == d2) {\n        t = a[2] + d2;\n    } else if (d1 == 2*d2) {\n        t = a[1] - d2;\n    } else if (d2 == 2*d1) {\n        t = a[1] + d1;\n    } else {\n        t = -1;\n    }\n    cout &lt;&lt; t &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj i jedinoj liniji standardnog ulaza nalaze se tri prirodna broja \\(a_1, a_2, a_3\\), odvojena razmacima - visine ze\u010deva koje Anja trenutno ima.</p>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#opis-izlaza","title":"Opis izlaza","text":"<p>Na prvu liniju standardnog izlaza ispisati visinu novog zeca, ili \\(-1\\) ukoliko nije mogu\u0107e nabaviti takvog zeca. Ukoliko ima vi\u0161e re\u0161enja, \u0161tampati bilo koje.</p>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv3/01_zecevi/#ulaz","title":"Ulaz","text":"<pre><code>3 7 5\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv3/01_zecevi/#ulaz_1","title":"Ulaz","text":"<pre><code>10 6 2\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#izlaz_1","title":"Izlaz","text":"<pre><code>14\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2017_2018/kv3/01_zecevi/#ulaz_2","title":"Ulaz","text":"<pre><code>999999 999997 999998\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#izlaz_2","title":"Izlaz","text":"<pre><code>999996\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#primer-4","title":"Primer 4","text":""},{"location":"takprog/2017_2018/kv3/01_zecevi/#ulaz_3","title":"Ulaz","text":"<pre><code>2 2 3\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#izlaz_3","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom primeru, drugo mogu\u0107e ta\u010dno re\u0161enje je \\(9\\).</p> <p>Visina novog zeca tako\u0111e mora biti prirodan broj.</p> <p>U tre\u0107em primeru, nije mogu\u0107e na\u0107i zeca tako da se zajedno preurede u aritmeti\u010dku progresiju.</p>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq a_1, a_2, a_3 \\leq 10^9\\).</li> <li>U \\(50\\%\\) primera va\u017ei \\(1 \\leq a_1, a_2, a_3 \\leq 1000\\).</li> </ul>"},{"location":"takprog/2017_2018/kv3/01_zecevi/#napomena","title":"Napomena","text":"<p>Za niz brojeva \\(a_1, a_2, \\ldots, a_n\\) ka\u017eemo da \u010dini aritmeti\u010dku progresiju ukoliko postoje brojevi \\(b, c\\) tako da je \\(a_i = b + c \\cdot i\\) za svako \\(i \\in \\{ 1, \\ldots, n \\}\\).</p>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/","title":"2 - Najbli\u017ei neopadaju\u0107i","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>Danici je na zimskom raspustu postalo malo dosadno pa je obe\u0107ala da \u0107e za svaki prirodan broj \\(N\\) koji joj drugari po\u0161alju, prona\u0107i njemu najbli\u017ei ceo broj \u010dije su cifre gledane s leva ka desno pore\u0111ane u neopadaju\u0107em redosledu, a ako ima vi\u0161e takvih brojeva, prona\u0107i \u0107e ih sve i ispisati, o\u010dekivano, u neopadaju\u0107em redosledu.</p> <p>Za \\(m\\)-tocifren prirodan broj \\(N\\) u dekadnom zapisu \\(N=c_{m-1}\\cdot10^{m-1}+c_{m-2}\\cdot10^{m-2}+\\dots+c_{2}\\cdot10^{2}+c_{1}\\cdot10^{1}+c_{0}\\cdot10^{0}\\) ka\u017eemo da je neopadaju\u0107i ako mu broj jedinica \\(c_0\\) nije manji od broja desetica \\(c_1\\), broj desetica \\(c_1\\) nije manji od broja stotina \\(c_2\\), broj stotina \\(c_2\\) nije manji od broja hiljada \\(c_3\\), itd. Drugim re\u010dima prirodan broj je neopadaju\u0107i ako i samo ako za svaki par susednih cifara \\(c_{i}\\) i \\(c_{i-1}\\) va\u017ei \\(c_{i} \\le c_{i-1}\\), pri \u010demu \\(0&lt;i&lt;m\\) i \\(c_{i}\\in\\{0,1,2,3,4,5,6,7,8,9\\}\\).</p> <p>Kako je i njenim drugarima ta igra postala zanimljiva, nakon po\u010detnog zagrevanja sa dvocifrenim i trocifrenim, po\u010deli su da joj \u0161alju sve ve\u0107e i ve\u0107e brojeve. Pomozite maloj Danici da uprkos tome odr\u017ei svoje obe\u0107anje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Ivan Sto\u0161i\u0107 <p>Potrebno je primetiti da provera da li je odre\u0111eni broj neopadaju\u0107i ne zavisi linearno od vrednosti tog broja, ve\u0107 od broja njegovih cifara koji je za prirodne brojeve u dekadnom zapisu proporcionalan \\(\\log_{10}N\\).</p> <p>Idejno najjednostavnije re\u0161enje najverovatnije je da se krene od zadatog broja \\(N\\) i redom proverava da li je neopadaju\u0107i ili ne, tako \u0161to \u0107e se najpre ispitati sam zadati broj \\(N\\), zatim \\(N\\pm1\\), pa \\(N\\pm2\\) i tako dalje.</p> <p>Me\u0111utim, svakako elegantnije re\u0161enje je da se za uneti broj \\(N\\) na efikasan na\u010din prona\u0111e najbli\u017ei neopadaju\u0107i broj ve\u0107i i najbli\u017ei neopadaju\u0107i broj manji od zadatog broja, a potom vrati onaj koji se nalazi na manjoj razlici od \\(N\\), odnosno da se ispi\u0161u oba, ukoliko se ispostavi da su podjednako udaljena.</p> <p>Da bi se odredio najbli\u017ei neopadaju\u0107i broj ve\u0107i od zadatog broja, najpre u nizu cifara unetog broja po\u010dev\u0161i od cifre najve\u0107eg zna\u010daja treba prona\u0107i prvo mesto gde niz postaje opadaju\u0107i, odnosno dve susedne cifre za koje va\u017ei \\(c_{i} &gt; c_{i-1}\\), a zatim sve cifre u opsegu od \\(c_{0}\\) do \\(c_{i-1}\\) promeniti u \\(c_{i}\\). Tako \u0107e na primer broj \\(N=12321\\) biti prepravljen u \\(12333\\), a samim tim i odre\u0111en najbli\u017ei neopadaju\u0107i broj ve\u0107i od zadatog broja.</p> <p>Sli\u010dno tome, kako bi se odredio najbli\u017ei neopadaju\u0107i broj manji od zadatog broja, prvo se na isti na\u010din prona\u0111e monotono neopadaju\u0107i prefiks broja \\(N\\), potom \\(c_{i}\\) umanji za jedan, a cifre u opsegu od \\(c_{0}\\) do \\(c_{i-1}\\) promene u \\(9\\). Za gornji primer \\(N=12321\\) to zna\u010di da \u0107e najbli\u017ei neopadaju\u0107i broj manji od zadatog broja biti \\(12299\\). Treba obratiti pa\u017enju da dekrementiranje poslednje cifre prefiksa mo\u017ee prouzrokovati promenu njegove monotonosti, kao na primer kod \\(N=12345554321\\), pa najbli\u017ei neopadaju\u0107i broj ne\u0107e biti \\(12345549999\\), ni \\(12345499999\\), ve\u0107 \\(12344999999\\). Uzimaju\u0107i i taj slu\u010daj u obzir dolazi se do najbli\u017eeg neopadaju\u0107eg broja koji je manji od zadatog.</p> <p>Uz napomenu da je vremenska slo\u017eenost pronalaska najbli\u017eeg neopadaju\u0107eg broja linearna po du\u017eini niza cifara, odnosno logaritamska po vrednosti zadatog broja \\(N\\), preostaje samo da se proveri koji je od dva neopadaju\u0107a broja bli\u017ei, i da se isti ispi\u0161e, \u010dime je zadatak ura\u0111en u \\(\\mathcal{O}(\\log{N})\\) vremenskoj slo\u017eenosti.</p> 02_najblizi_neopadajuci.cpp<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nll od_stringa(string s) {\n    ll x = 0;\n    for (char c : s) {\n        x = 10 * x + (c - '0');\n    }\n    return x;\n}\n\nstring veci_jednak(string s) {\n    int i = 1;\n    while (i &lt; (int)s.size() &amp;&amp; s[i] &gt;= s[i-1]) {\n        i++;\n    }\n    for (int j=i; j&lt;(int)s.size(); j++) {\n        s[j] = s[i-1];\n    }\n    return s;\n}\n\nstring manji_jednak(string s) {\n    int i = 1;\n    while (i &lt; (int)s.size() &amp;&amp; s[i] &gt;= s[i-1]) {\n        i++;\n    }\n    while (0 &lt; i &amp;&amp; i &lt; (int)s.size() &amp;&amp; s[i] &lt; s[i-1]) {\n        s[i-1]--;\n        i--;\n    }\n    for (int j=i+1; j&lt;(int)s.size(); j++) {\n        s[j] = '9';\n    }\n    return s;\n}\n\nint main() {\n    ll n;\n    cin &gt;&gt; n;\n    ll l = od_stringa(manji_jednak(to_string(n)));\n    ll h = od_stringa(veci_jednak(to_string(n)));\n\n    ll dl = n-l;\n    ll dh = h-n;\n\n    if (dl &lt; dh) {\n        cout &lt;&lt; l &lt;&lt; '\\n';\n    } else if (dh &lt; dl) {\n        cout &lt;&lt; h &lt;&lt; '\\n';\n    } else if (l == h) {\n        cout &lt;&lt; l &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; h &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#opis-ulaza","title":"Opis ulaza","text":"<p>U jedinom redu standardnog ulaza nalazi se zadati prirodan broj \\(N\\) u dekadnom zapisu.</p>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#opis-izlaza","title":"Opis izlaza","text":"<p>U jednom redu standardnog izlaza ispisati najbli\u017ei neopadaju\u0107i ceo broj, odnosno sve takve brojeve odvojene razmakom ukoliko ih ima vi\u0161e od jednog.</p>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#ulaz","title":"Ulaz","text":"<pre><code>53\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#izlaz","title":"Izlaz","text":"<pre><code>55\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#ulaz_1","title":"Ulaz","text":"<pre><code>82\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#izlaz_1","title":"Izlaz","text":"<pre><code>79\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#ulaz_2","title":"Ulaz","text":"<pre><code>105\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#izlaz_2","title":"Izlaz","text":"<pre><code>99 111\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#primer-4","title":"Primer 4","text":""},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#ulaz_3","title":"Ulaz","text":"<pre><code>357\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#izlaz_3","title":"Izlaz","text":"<pre><code>357\n</code></pre>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Najbli\u017ei neopadaju\u0107i broj mo\u017ee biti ve\u0107i od zadatog broja. Najbli\u017ei neopadaju\u0107i broj mo\u017ee biti i manji od zadatog broja. Postoji mogu\u0107nost i da vi\u0161e neopadaju\u0107ih brojeva budu podjednako blizu zadatom broju. Najzad, najbli\u017ei neopadaju\u0107i broj mo\u017ee biti i sam zadati broj.</p>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\le N \\le 10^{18}\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U \\(15\\%\\) test primera va\u017ei ograni\u010denje \\(1 \\le N \\le 10^{2}\\).</li> <li>U \\(30\\%\\) test primera va\u017ei ograni\u010denje \\(1 \\le N \\le 10^{3}\\).</li> <li>U \\(50\\%\\) test primera va\u017ei ograni\u010denje \\(1 \\le N \\le 10^{9}\\).</li> <li>U ostalim test primerima nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv3/02_najblizi_neopadajuci/#napomena","title":"Napomena","text":"<p>Zadati i ispisani brojevi su uvek u dekadnom zapisu bez vode\u0107ih nula.</p>"},{"location":"takprog/2017_2018/kv3/03_struja/","title":"3 - Struja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>Nakon rasprave sa \u010dasa filozofije, malom Stojanu je pala na pamet nova poslovna ideja -- odlu\u010dio je da se bavi kupovinom i prodajom struje. Na osnovu izgubljenog Teslinog izuma je napravio bateriju beskona\u010dnog kapaciteta, tako da sada mo\u017ee da kupuje struju danima kada je jeftina i prodaje je kada je skupa.</p> <p>Pomo\u0107u vremenske ma\u0161ine (tako\u0111e Teslinog izuma), Stojan je saznao kolika \u0107e biti cena struje svakog od narednih \\(N\\) dana (\\(i\\)-tog dana \u0107e kilovat-\u010das ko\u0161tati \\(C_i\\) dinara). Na po\u010detku mu je na raspolaganju \\(M\\) dinara i prazna baterija. Svakog dana on mo\u017ee da kupi koliko god \u017eeli struje (dok god ima novca da je plati) ili proda koliko god \u017eeli (dok god ima dovoljno struje u bateriji). Koli\u010dine kupljene i prodate struje ne moraju biti celi brojevi.</p> <p>Pomozite Stojanu da odlu\u010di kako \u0107e trgovati strujom, tako da mu na kraju poslednjeg dana ostane \u0161to vi\u0161e novca.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Jovanovi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Nikola Jovanovi\u0107 <p>Ako optimalno trgujemo strujom, sigurno \u0107emo svakog dana ili \"\u010dekati\" (bez kupovine i prodaje), ili potro\u0161iti sav novac na struju, ili prodati svu struju koju imamo. Ovo tvr\u0111enje ne\u0107e biti formalno dokazano ovde, ali ideja iza njega je da ako \"razdvojimo\" novac (ili struju) i potro\u0161imo samo deo, potro\u0161en i sa\u010duvan deo se mogu posmatrati nezavisno. Ako potro\u0161en deo novca donosi bolju zaradu od nepotro\u0161enog, bolje je da potro\u0161imo sve (i obrnuto).</p> <p>Sada je potrebno samo odabrati dane kada \u0107emo kupovati i prodavati struju. Optimalan izbor je da kupujemo u lokalnim minimumima cene, odnosno danima kada je struja jeftinija nego \u0161to je bila ju\u010de i nego \u0161to \u0107e biti sutra, i da prodajemo u lokalnim maksimumima (kad je skuplja od susednih dana). Da bismo dokazali da je ovo optimalno, posmatrajmo bilo koji drugi izbor dana. Tada sigurno mo\u017eemo \"pomeriti\" onu kupovinu (ili prodaju) koja nije lokalni minimum (maksimum) na \"susedni\" dan kada je cena povoljnija i zaraditi vi\u0161e.</p> <p>Lokalne minimume i maksimume mo\u017eemo na\u0107i u \\(\\mathcal{O}(N)\\) (za svaki dan gledamo samo dva suseda), tako da se ceo zadatak mo\u017ee re\u0161iti u \\(\\mathcal{O}(N)\\). Obratite pa\u017enju na prvi i poslednji dan -- po\u0161to imaju samo jednog suseda, mo\u017eemo ih ili posmatrati kao specijalne slu\u010dajeve, ili dodati \"ve\u0161ta\u010dke\" elemente za dane \\(0\\) i \\(N+1\\), sa cenama \\(\\infty\\) i \\(-\\infty\\).</p> <p>Ne\u0161to jednostavnije re\u0161enje za implementaciju je slede\u0107e: za svaki dan mo\u017eemo odlu\u010diti da li \u0107emo tog dana kupiti struju i odmah je prodati slede\u0107eg dana. U ovom slu\u010daju dozvoljavamo da isti dan prodamo struju i opet je kupimo po istoj ceni (\u0161to je isto kao da ne uradimo ni\u0161ta). Jasno je da \u0107emo u ovom slu\u010daju kupovati onih dana kada je cena manja nego slede\u0107eg, tako da mo\u017eemo izbe\u0107i \"pam\u0107enje\" minimuma i maksimuma.</p> 03_struja.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    int n;\n    double money;\n    scanf(\"%d %lf\", &amp;n, &amp;money);\n\n    double prev = 1e10;\n    while(n--)\n    {\n    double curr;\n    scanf(\"%lf\", &amp;curr);\n    if(curr &gt; prev)\n        money *= curr / prev;\n    prev = curr;\n    }\n\n    printf(\"%.6f\\n\", money);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv3/03_struja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva cela broja, \\(N\\) i \\(M\\) - broj dana za koje Stojan zna cenu struje i svota novca koja mu jemna raspolaganju na po\u010detku.</p> <p>U drugoj (poslednjoj) liniji nalazi se \\(N\\) brojeva \\(C_1, C_2, \\ldots,C_N\\), gde je \\(C_i\\) cena jednog kilovat-\u010dasa \\(i\\)-tog dana.</p>"},{"location":"takprog/2017_2018/kv3/03_struja/#opis-izlaza","title":"Opis izlaza","text":"<p>Na prvu liniju standardnog izlaza ispisati maksimalnu sumu novca koju Stojan mo\u017ee imati na kraju poslednjeg dana. Garantuje se da ova vrednost ne\u0107e biti ve\u0107a od \\(10^{10}\\).</p>"},{"location":"takprog/2017_2018/kv3/03_struja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv3/03_struja/#ulaz","title":"Ulaz","text":"<pre><code>4 10\n4 10 5 20\n</code></pre>"},{"location":"takprog/2017_2018/kv3/03_struja/#izlaz","title":"Izlaz","text":"<pre><code>100\n</code></pre>"},{"location":"takprog/2017_2018/kv3/03_struja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv3/03_struja/#ulaz_1","title":"Ulaz","text":"<pre><code>3 21\n10 8 3\n</code></pre>"},{"location":"takprog/2017_2018/kv3/03_struja/#izlaz_1","title":"Izlaz","text":"<pre><code>21\n</code></pre>"},{"location":"takprog/2017_2018/kv3/03_struja/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, Stojan mo\u017ee da kupi \\(2.5\\) kilovat-\u010dasova prvog dana, i proda ih drugog dana za \\(25\\) dinara. Tre\u0107eg dana mo\u017ee da kupi pet kilovat-\u010dasova i proda ih \u010detvrtog za \\(100\\) dinara, \u0161to je i optimalno re\u0161enje.</p> <p>U drugom primeru, najbolje je da uop\u0161te ne kupuje struju i sa\u010duva \\(21\\) dinar sa kojim je po\u010deo.</p>"},{"location":"takprog/2017_2018/kv3/03_struja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq M, C_i \\leq 10^6\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U 20% primera va\u017ei \\(1 \\leq N \\leq 20\\).</li> <li>U 30% primera va\u017ei \\(1 \\leq N \\leq 3000\\).</li> <li>U 50% primera va\u017ei \\(1 \\leq N \\leq 10^6\\).</li> </ul>"},{"location":"takprog/2017_2018/kv3/03_struja/#napomena","title":"Napomena","text":"<p>Ako je va\u0161 program ispisao broj \\(a\\), a re\u0161enje komisije je realan broj \\(b\\), va\u0161e re\u0161enje se prihvata kao ta\u010dno pod uslovom da va\u017ei \\(\\frac{|a-b|}{b} \\leq 10^{-6}\\) ili va\u017ei \\(|a-b| \\leq 10^{-6}\\).</p>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/","title":"4 - Plus-minus","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Mikica ja na papiru zapisao jedan niz celih brojeva, koji je za njega bio vrlo bitan. U toku jednog pospremanja svoje sobe, izgubio je papir na kome je bio zapisan taj niz i sada ne mo\u017ee nikako da ga na\u0111e. Ali ostao je papir na kome su zabele\u017eene neke informacije o tom nizu. Te informacije su oblika: zbir elemenata niza od elementa sa indeksom  \\(p\\) (odnosno od elementa na poziciji \\(p\\)) do elementa sa indeksom  \\(k\\) (odnosno elementa na poziciji \\(k\\)) je pozitivan  (ili negativan). Pomozite Mikici da na osnovu tih \u010dinjenica odredi jedan niz koji zadovoljava te \u010dinjenice. Ako takav niz ne postoji (mo\u017ee se desiti da je Mikica pogre\u0161io negde tokom ra\u010dunanja), ispisati odgovaraju\u0107u poruku.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Nikola Jovanovi\u0107 <p>Ozna\u010dimo sa \\(s_k\\) zbir prvih \\(k\\) elemenata niza, tj. \\(s_k = \\sum_{i=1}^k x_k\\) za \\(1 \\leq k\\leq n\\). Zva\u0107emo ove zbirove parcijalne sume. Lako se zaklju\u010duje da je zbir elemenata ed elementa na poziciji \\(i\\) do elementa na poziciji \\(j\\) jednak</p> \\[ x_i + x_{i+1} + ... +x_{j-1} + x_j = s_j - s_{i-1}. \\] <p>Ako je zbir elemanata od elementa na poziciji \\(i\\) do elementa na poziciji \\(j\\) pozitivan, onda je \\(s_j-s_{i-1} &gt; 0\\), odnosno \\(s_{i-1} &lt; s_j\\).  Ako je zbir elemanata od elementa na poziciji \\(i\\) do elementa na poziciji \\(j\\) negativan, onda je \\(s_j-s_{i-1} &lt; 0\\), odnosno \\(s_{j} &lt; s_{i-1}\\). </p> <p>Formira\u0107emo orijentisan graf \\(G=(V,E)\\) u kome \u010dvorovi odgovaraju parcijalnim sumama (mo\u017eemo \u010dvorove numerisati i brojevima izme\u0111u \\(0\\) i \\(n\\)). Za svaku nejednakost oblika \\(s_a &lt; s_b\\) uvodimo ivicu od \u010dvora koji odgovara parcijalnoj sumi \\(s_a\\) do \u010dvora koji odgovara parcijalnoj sumi \\(s_b\\). Ako u tom grafu postoji petlja, onda ne postoji niz koji zadovoljava zadate uslove. Naime, petlja je niz \u010dvorova u kome se prvi i poslednji \u010dvor poklapaju takav da izme\u0111u svaka dva uzastopna postoji ivica. Neka taj niz \u010dine \u010dvorovi</p> \\[ s_{k_1}, s_{k_2}, s_{k_3}, ..., s_{k_c}, s_{k_1}. \\] <p>Tada za parcijalne sume va\u017ei</p> \\[ s_{k_1} &lt; s_{k_2} &lt; s_{k_3} &lt; ..., &lt;s_{k_c} &lt; s_{k_1}  \\] <p>i zbog tranzitivnosti je \\(s_{k_1} &lt; s_{k_1}\\), \u0161to je kontradikcija.</p> <p>Ako u grafu \\(G\\) ne postoji ciklus, \u010dvorovi grafa se mogu pore\u0111ati u niz tako da ako postoji ivica od \u010dvora \\(s_a\\) do \u010dvora \\(s_b\\) onda je \u010dvor \\(s_a\\) stoji u nizu pre \u010dvora \\(s_b\\). Svako takvo re\u0111anje u niz se naziva topolo\u0161ko sortiranje i mo\u017ee se obaviti varijacijom na obilazak grafa u dubinu. Na osnovu tog nabrajanja \u010dvorova, parcijalnim sumama (\u010dvorovima grafa) mo\u017eemo dodeliti cele brojeve, tako da se \u010dvoru \\(s_0\\) dodeli vrednost 0, \u010dvorovima koji se nalaze posle njega u tom nabrajanju redom brojevi \\(1, 2, 3, \\ldots\\) (u skladu sa poretkom u nabrajanju), a \u010dvorovima koji se nalaze pre njega redom brojevi \\(-1, -2, -3, \\ldots\\) (ovaj put sdesna ulevo, u skladu sa nabrajanjem). Lako se uveravamo da \u0107e za svaka dva \u010dvora \\(s_a\\) i \\(s_b\\) va\u017eiti da ako je \\(s_a\\) pre (levo) od \\(s_b\\) u nabrajanju, onda je \\(s_a &lt; s_b\\). Drugim re\u010dima, parcijalnim sumama smo dodelili razli\u010dite cele brojeve i oni zadovoljavaju sve nejednakosti koje su zadate u ulaznim podacima.</p> <p>Na osnovu parcijalnih suma se mogu odrediti elementi niza \\(x_i = s_i - s_{i-1}\\) za \\(1\\leq i \\leq n\\).</p>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi ceo broj \\(T\\) i on predstavlja broj nizova koje je zamislio Mikica. U narednim redovima se nalazi \\(T\\) blokova u kojima su opisani nizovi koje je zamislio Mikica. U prvom redu opisa se nalaze dva cela broja \\(n\\) i \\(m\\). Broj \\(n\\) predstavlja broj elemenata u nizu, a broj \\(m\\) je broj informacija o nizu koje je Mikica zapisao. Svaki od narednih \\(m\\) redova u bloku sadr\u017ei tri cela broja: \\(p\\), \\(k\\) i \\(z\\) (\\(1\\leq p\\leq k\\leq n\\), \\(z\\in\\{-1,1\\}\\)). Ta tri broja ozna\u010davaju da je zbir elemenata niza od elementa na poziciji \\(p\\) do elementa na poziciji \\(k\\) pozitivan (ako je \\(z=1\\)), odnosno negativan (ako je \\(z=-1\\)).</p>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(T\\) nizova iz ulaza treba ispisati odgovor (onim redom u kome se nalaze u ulazu). Ako za neki opis niza ne postoji niz koji odgovara opisu, onda u jednom redu ispisati broj \\(-1\\). Ako za neki opis niza postoji takav niz onda u jednom redu izlaza ispisati broj \\(1\\), a u narednom redu ispisati elemente niza razdvojene razmacima (elementi niza treba da budu celi brojevi \u010dija apsolutna vrednost nije ve\u0107a od \\(10^9\\)).</p>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv3/04_plus_minus/#ulaz","title":"Ulaz","text":"<pre><code>1\n3 2\n1 2 1\n2 3 -1\n</code></pre>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#izlaz","title":"Izlaz","text":"<pre><code>1\n-1 2 -3\n</code></pre>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv3/04_plus_minus/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n6 4\n1 3 1\n1 5 -1\n6 6 -1\n4 6 1\n2 1\n1 2 1\n</code></pre>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n1\n-1 2\n</code></pre>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, sabiranjem odgovaraju\u0107ih elemenata se lako proverava da su oba uslova koje je Mikica zapisao ispunjena.</p>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1\\leq T \\leq 4\\).</li> <li>\\(1\\leq n \\leq 10000\\).</li> <li>\\(1\\leq m \\leq 200000\\).</li> <li>Elementi niza koji je Mikica zapisao su celi brojevi izme\u0111u \\(-10^9\\) i \\(10^9\\).</li> </ul> <p>Test primeri su podeljeni u dve disjunktne grupe:</p> <ul> <li>U 30% test primera va\u017ei \\(1\\leq n \\leq 15\\).</li> <li>U ostalim test primerima nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv3/04_plus_minus/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Dajemo samo pseudokod za topo\u0161ko sortiranje (nabrajanje). Pretpostavljamo da je graf reprezentovan pomo\u0107u vektora/listi suseda svojih \u010dvorova. Rezultat koji vra\u0107a funkcija je \\(0\\), ako graf jeste acikli\u010dan (pored toga je u nizu <code>tops</code> njegovo topolo\u0161ko sortiranje), a \\(1\\), ako je graf ima bar jednu petlju i samim tim ne postoji topolo\u0161ko sortiranje. </p> <pre><code>topsort() {\np = n;\nfor (i = 0; i &lt;= n; i++)\nmark[i] = BEO\nfor (i = 0; i &lt;= n; i++) \nif (mark[i] == BEO)\nif (topsortr(i) != 0) return 1;\nreturn 0;\n}\ntopsortr(i) {\nmark[i] = SIV;\nfor (k = 0; k &lt; susedi[i].size(); k++) {\n  j = susedi[i][k];\n  if (mark[j] == SIV) return 1;\n  if (mark[j] == BEO)\n  if (topsortr(j) != 0) return 1;\n}\ntops[p] = i;\np = p - 1;\nmark[i] = CRN;\nreturn 0;\n}\n</code></pre> 04_plus_minus.cpp<pre><code># include &lt;stdio.h&gt;\n# include &lt;vector&gt;\n# include &lt;algorithm&gt;\n\nusing namespace std;\n\n# define MAXN 30030\n\n# define BEO 0\n# define SIV 1\n# define CRN 2\n\nint n, m, no;\n\nvector&lt;int&gt; susedi[MAXN];\n\nint mark[MAXN];\nint tord[MAXN];\nint s[MAXN], x[MAXN];\n\ncitaj() {\n  int i, j, k, zn;\n  scanf(\"%d%d\", &amp;n, &amp;m);\n  for (k = 0; k &lt;= n; k++)\n    susedi[k].clear();\n  for (k = 1; k &lt;= m; k++) {\n    scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;zn);\n    if (zn &gt; 0)\n      susedi[i-1].push_back(j);\n    else\n      susedi[j].push_back(i-1);\n  }\n}\n\nint topordr(int c1) {\n  int k, c2;\n  mark[c1] = SIV;\n  for (k = 0; k &lt; susedi[c1].size(); k++) {\n    c2 = susedi[c1][k];\n    if (mark[c2] == CRN) continue;\n    if (mark[c2] == SIV) return 1;\n    if (topordr(c2) != 0) return 1;\n  }\n  tord[no--] = c1;\n  mark[c1] = CRN;\n  return 0;\n}\n\nint topord() {\n  int k;\n  for (k = 0; k &lt;= n; k++) mark[k] = BEO;\n  no = n;\n  for (k = 0; k &lt;= n; k++) \n    if (mark[k] == BEO)\n      if (topordr(k)) return 1;\n  return 0;\n}\n\nresi() {\n  int i, j, k;\n  k = 0; \n  while (tord[k] != 0) k++;\n  s[0] = 0;\n  for (i = k-1, j = -1; i &gt;= 0; i--, j--) \n    s[tord[i]] = j; \n  for (i = k+1, j = 1; i &lt;= n; i++, j++) \n    s[tord[i]] = j; \n  for (k = 1; k &lt;= n; k++) \n    x[k] = s[k] - s[k-1];\n}\n\nmain() {\n  int s, t;\n  scanf(\"%d\", &amp;t);\n  for (s = 1; s &lt;= t; s++) {\n    citaj();\n    if (topord() != 0)  \n        printf(\"-1\\n\");\n    else {\n        resi();\n        printf(\"1\\n\");\n        for (int k = 1; k &lt; n; k++)\n            printf(\"%d \", x[k]);\n        printf(\"%d\\n\", x[n]);\n    }    \n  }\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/","title":"5 - Prepisivanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 512MB <p>Godina je \\(3018\\). Takmi\u010denja iz programiranja u Srbiji su nikad ve\u0107a, imamo stotine hiljada takmi\u010dara, i stotine hiljada rundi kvalifikacija, a takmi\u010dari jo\u0161 uvek prepisuju jedni od drugih, i ne po\u0161tuju pravilnik.</p> <p>Komisija je spremna kao i uvek, i unajmila je stotine hiljada \u010dlanova koji \u0107e nadgledati prepisivanje. Svaki \u010dlan Komisije ima zadu\u017eenu rundu od koje \u0107e po\u010deti nadgledanje, i normu koju treba da ispuni - tj. broj razli\u010ditih takmi\u010dara koje treba da uhvati u prepisivanju. \u010clan komisije vr\u0161i nadgledanje u svim rundama po\u010dev od zadate po\u010detne runde, dok god ne ispuni zadatu normu.</p> <p>Za svakog takmi\u010dara su date runde u kojima je prekr\u0161io pravilnik, a vas molimo da pomognete Komisiji i za svakog \u010dlana odgovorite koliko najmanje rundi zaredom treba da posmatra da bi ispunio normu (norma \u0107e uvek biti takva da se mo\u017ee ispuniti).</p> <p>Svaki \u010dlan komisije \u0107e uhvatiti sve takmi\u010dare koji su prepisivali u rundi koju nadgleda. Tako\u0111e, vi\u0161e \u010dlanova komisije mogu uhvatiti istog takmi\u010dara u istoj rundi.</p> <p>Komisija je odlu\u010dila i da vam ote\u017ea posao tako \u0161to \u0107e vam informaciju o zadu\u017eenju svakog \u010dlana dati u zavisnosti od re\u0161enja (minimalnog broja posmatranih rundi) za prethodnog \u010dlana - obratite pa\u017enju na opis ulaza i poja\u0161njenja primera u ovom zadatku.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Tadija \u0160ebez Ivan Sto\u0161i\u0107"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva broja \\(N\\) i \\(R\\) odvojena razmakom - broj takmi\u010dara i broj rundi kvalifikacija. U svakoj od slede\u0107ih \\(N\\) linija se nalazi prvo broj \\(P_i\\) - broj rundi u kojima je \\(i\\)-ti takmi\u010dar prepisivao, pa zatim \\(P_i\\) razli\u010ditih brojeva odvojenih razmakom koji ozna\u010davaju runde u kojima je \\(i\\)-ti takmi\u010dar prepisivao. Zatim, u slede\u0107em redu se nalazi broj \\(K\\) - broj unajmljenih \u010dlanova komisije. U slede\u0107ih \\(K\\) redova se nalaze po dva broja odvojena razmakom - \\(T_i\\) i \\(S_i\\) koji ozna\u010davaju zadu\u017eenje \\(i\\)-tog \u010dlana komisije na slede\u0107i na\u010din:</p> <p>Ako je \\(MP_i\\) minimalan broj rundi koji \\(i\\)-ti \u010dlan komisije treba da posmatra, onda \u0107e \\(Start_i = T_i + MP_{i-1}\\) biti runda u kojoj \\(i\\)-ti \u010dlan treba zapo\u010deti nadgledanje. \\(S_i\\) ozna\u010dava normu \\(i\\)-tog \u010dlana. Uzima se da je \\(MP_0 = 0\\), dok indeksiranje za \u010dlanove komisije po\u010dinje od 1. Obratite pa\u017enju da \\(T_i\\) mo\u017ee biti i negativan broj, ali \u0107e dobijeni \\(Start_i\\) uvek biti od \\(1\\) do \\(R\\).</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(K\\) linija - u svakoj liniji redom brojeve \\(MP_i\\) - koji ozna\u010davaju minimalan broj rundi koje \\(i\\)-ti \u010dlan komisije treba da posmatra.</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#ulaz","title":"Ulaz","text":"<pre><code>6 12\n3 1 2 5\n2 3 4\n3 1 2 7\n2 3 6\n0\n3 3 11 12\n3\n1 2\n0 5\n1 5\n</code></pre>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#izlaz","title":"Izlaz","text":"<pre><code>1\n3\n8\n</code></pre>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#ulaz_1","title":"Ulaz","text":"<pre><code>5 5\n1 2\n1 3\n1 4\n1 5\n2 1 2\n3\n1 5\n-2 3\n-1 2\n</code></pre>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n3\n1\n</code></pre>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, prvi \u010dlan komisije zapo\u010dinje nadgledanje od prve runde, treba da ispuni normu \\(2\\), i odmah u prvoj rundi hvata dva takmi\u010dara (\\(1\\). i \\(3\\).), \u0161to zna\u010di da nadgleda samo \\(1\\) rundu. Drugi \u010dlan komisije po\u010dinje nadgledanje tako\u0111e od prve runde \\((Start_2 = T_2 + MP_1 \\implies Start_2 = 0 + 1 = 1)\\), i potrebno je da uhvati \\(5\\) takmi\u010dara u prepisivanju. Za to je dovoljno da nadgleda \\(3\\) runde (takmi\u010dari \\(1\\) i \\(3\\) prepisuju u prvoj, dok takmi\u010dari \\(2\\), \\(4\\) i \\(6\\) prepisuju u tre\u0107oj rundi). Tre\u0107i \u010dlan komisije zapo\u010dinje nadgledanje od \u010detvrte runde, i potrebno je da uhvati \\(5\\) takmi\u010dara u prepisivanju. Za to je potrebno da nadgleda sve runde do jedanaeste.</p> <p>U drugom primeru, obratite pa\u017enju da \\(T_i\\) mo\u017ee biti negativan broj na ulazu, ali uzimaju\u0107i u obzir re\u0161enja za prethodne \u010dlanove komisije, drugi \u010dlan komisije \u0107e nadgledanje po\u010deti od \\(3\\). runde, dok \u0107e tre\u0107i \u010dlan komisije nadgledanje zapo\u010deti od \\(2\\). runde.</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,R,K \\leq 300 000\\).</li> <li>\\(1 \\leq \\sum_{i=1}^n P_i \\leq 300 000\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(25\\) poena va\u017ei \\(1 \\leq N,R,K,\\sum_{i=1}^n P_i \\leq 10^4\\).</li> <li>U test primerima koji vrede \\(25\\) poena va\u017ei \\(1 \\leq N,R,K,\\sum_{i=1}^n P_i \\leq 10^5\\).</li> <li>U test primerima koji vrede \\(25\\) poena va\u017ei \\(S_i = S_j,  \\forall(i,j | 1 \\leq i,j \\leq K)\\), tj. svi \u010dlanovi komisije imaju istu normu.</li> <li>U test primerima koji vrede \\(25\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#podzadatak-1","title":"Podzadatak 1","text":"<p>Slo\u017eenost \\(O(K\\sum^{N}_{i=1} S_i)\\). Za svaku rundu treba imati listu takmi\u010dara koji su na njoj prepisivali. Svaki upit re\u0161avamo tako \u0161to krenemo od po\u010detne runde i brojimo one takmi\u010dare koje smo prvi put uhvatili.</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#offline-resenje","title":"Offline re\u0161enje","text":"<p>Potrebno nam je segmentno stablo. Da bi re\u0161ili sve upite kojima je po\u010detna runda \\(S\\) za svakog takmi\u010dara koji je prepisivao na nekoj od rundi i\u0455 segmenta \\([S,R]\\) treba da na vrednost prve runde na kojoj \u0107e biti uhva\u0107en dodamo \\(1\\). Da bi efikasno izgradili strukturu treba da re\u0161avamo prvo sve upite sa \\(S=R\\) pa \\(S=R-1\\) itd. Kada je \\(S=R\\) vrednost \\(R\\) u stablu bi\u0107e jednaka broju ljudi koji su prepisivali na toj rundi. Za ostale \\(S\\) nije dovoljno samo postaviti vrednost na broj ljudi koji su prepisivali na toj rundi ve\u0107 moramo i da smanjimo vrednost nekih od slede\u0107ih rundi. Ako je takmi\u010dar \\(X\\) prepisivao na trenutnoj rundi i na nekoj od slede\u0107ih treba da smanjimo vrednost slede\u0107e runde na kojoj je prepisivao. Ovako u svakom koraku imamo opisano segmentno stablo. Upite re\u0161avamo binarnom pretragom po re\u0161enju uz pomo\u0107 segmentnog stabla. Slo\u017eenost ovog algoritma je \\(O(K\\log^2 R)\\).</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#podzadatak-2","title":"Podzadatak 2","text":"<p>Ovaj podzadatak se re\u0161ava tako \u0161to umesto obi\u010dnog segmentnog stabla koristimo persistent segment tree. Tako mo\u017eemo pristupiti prethodnim verzijama segmentnog stabla i posle cele izgradnje. Vremenska slo\u017eenost ostaje \\(O(K\\log^2 R)\\), a memorijska se pove\u0107ava na \\(O((\\sum^{N}_{i=1} S_i)\\log R)\\).</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#podzadatak-3","title":"Podzadatak 3","text":"<p>Ovaj podzadatak zahteva vi\u0161e razmi\u0161ljanja. Potrebno je smanjiti slo\u017eenost Offline re\u0161enja sa \\(O(K\\log^2 R)\\) na \\(O(K\\log R)\\). Primetimo da segmentno stablo ve\u0107 ima izra\u010dunate vrednosti za neke segmente. To mo\u017eemo koristiti umesto binarne pretrage. Zapo\u010dnimo rekurzivni algoritam u korenu stabla. Ako je vrednost levog segmenta ve\u0107a ili jednaka broju takmi\u010dara koje \u010dlan komisije treba da uhvati pomeramo se na levo podstablo, ako ne pomeramo se na desno podstablo i pamtimo da smo uhvatili onoliko takmi\u010dara kolika je bila vrednost levog segmenta. Na kraju ovog algoritma nalazimo se u listu koji predstavlja re\u0161enje upita.</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#podzadatak-4","title":"Podzadatak 4","text":"<p>Ovaj podzadatak se re\u0161ava primenom podzadataka \\(2\\) i \\(3\\), odnosno koristimo persistent segment tree i opisani algoritam na njemu da bi smanjili vremensku slo\u017eenost na \\(O(K\\log R)\\) dok memorijska slo\u017eenost ostaje \\(O((\\sum^{N}_{i=1} S_i)\\log R)\\).</p>"},{"location":"takprog/2017_2018/kv3/05_prepisivanje/#zadaci-za-vezbu","title":"Zadaci za ve\u017ebu","text":"<p>Ovaj trik nije ni\u0161ta novo u takmi\u010darskom programiranju. Postoji dosta zadataka koji se re\u0161avaju na sli\u010dan na\u010din. Korisni mogu biti ovaj (radi se isto kao podzadatak \\(2\\)) i ovaj (zahteva persistent segment tree i trik za smanjenje slo\u017eenosti). </p> 05_prepisivanje.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXNODES 12555333\n#define MAXN 755333\n\nint n,len;\nint p[MAXN],rnd[MAXN],niz[MAXN],tstart[MAXN],tkraj[MAXN];\nvector&lt;int&gt; r[MAXN];\n\nint zadnjiput[MAXN];\n\nint num_nodes;\nint levi_sin[MAXNODES], desni_sin[MAXNODES], uk_suma[MAXNODES];\nint per_time[MAXNODES];\n\nint new_node() {\n    num_nodes++;\n    levi_sin[num_nodes] = -1;\n    desni_sin[num_nodes] = -1;\n    uk_suma[num_nodes] = 0;\n\n    return num_nodes;\n}\n\nvoid ubaci(int last_node, int curr_node, int left, int right, int pos, int value) {\n\n    if (last_node != -1) {\n        levi_sin[curr_node] = levi_sin[last_node];\n        desni_sin[curr_node] = desni_sin[last_node];\n    }\n\n    if (left == right) {\n        uk_suma[curr_node] = value;\n        return;\n    }\n\n    int mid = (left+right)/2;\n    if (pos &lt;= mid) {\n        int nd = new_node();\n        ubaci(levi_sin[curr_node], nd, left, mid, pos, value);\n        levi_sin[curr_node] = nd;\n    } else {\n        int nd = new_node();\n        ubaci(desni_sin[curr_node], nd, mid+1, right, pos, value);\n        desni_sin[curr_node] = nd;\n    }\n\n    uk_suma[curr_node] = (levi_sin[curr_node] != -1 ? uk_suma[levi_sin[curr_node]] : 0) +\n                         (desni_sin[curr_node] != -1 ? uk_suma[desni_sin[curr_node]] : 0);\n}\n\nint query_sum(int curr_node, int left, int right, int sum) {\n    if (left == right) return left;\n\n    int mid = (left+right)/2;\n\n    if (levi_sin[curr_node] == -1) return query_sum(desni_sin[curr_node], mid+1, right, sum);\n    if (desni_sin[curr_node] == -1) return query_sum(levi_sin[curr_node], left, mid, sum);\n\n    if (uk_suma[levi_sin[curr_node]] &gt;= sum) {\n        return query_sum(levi_sin[curr_node], left, mid, sum);\n    } else {\n        return query_sum(desni_sin[curr_node], mid+1, right, sum - uk_suma[levi_sin[curr_node]]);\n    }\n}\n\nvoid init_tree() {\n\n    int nd,tak,last_root;\n\n    for(int i=1; i&lt;=n; i++) {\n        zadnjiput[i] = -1;\n    }\n\n    last_root = -1;\n    for(int i=len; i&gt;=1; i--) {\n        tak = niz[i];\n        if (zadnjiput[tak] != -1) {\n            nd = new_node();\n            ubaci(last_root, nd, 1, len, zadnjiput[tak], 0);\n            last_root = nd;\n        }\n\n        zadnjiput[tak] = i;\n\n        nd = new_node();\n        ubaci(last_root, nd, 1, len, i, 1);\n        last_root = nd;\n\n        per_time[i] = last_root;\n    }\n}\n\nint main() {\n\n    //freopen(\"01.in\", \"r\", stdin);\n    //freopen(\"01.out\", \"w\", stdout);\n\n    int N,R,K,i,j,rj,ti,si,st,zd,tak,last_res;\n\n    scanf(\"%d%d\", &amp;N, &amp;R);\n\n    n = N;\n\n    for(i=1; i&lt;=N; i++) {\n        scanf(\"%d\", &amp;p[i]);\n        for(j=0; j&lt;p[i]; j++) {\n            scanf(\"%d\", &amp;rj);\n            r[rj].push_back(i);\n        }\n    }\n\n    len = 0;\n\n    for(i=1; i&lt;=R; i++) {\n        tstart[i] = len+1;\n        for(j=0; j&lt;r[i].size(); j++) {\n            tak = r[i][j];\n            len++;\n            rnd[len] = i;\n            niz[len] = tak;\n        }\n        tkraj[i] = len;\n    }\n\n    init_tree();\n\n    scanf(\"%d\", &amp;K);\n\n    last_res = 0;\n    for(i=0; i&lt;K; i++) {\n        scanf(\"%d%d\", &amp;ti, &amp;si);\n\n        st = ti+last_res;\n\n        zd = query_sum(per_time[tstart[st]], 1, len, si);\n\n        last_res = rnd[zd]-st+1;\n        printf(\"%d\\n\", last_res);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/","title":"B1 - Pangram","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Moreplovac Brle je u jednoj od svojih pustolovina nabasao na novo, neotkriveno ostrvo. Kada je poku\u0161ao da pri\u0111e ostrvu ugledao je re\u010denicu ispisanu ogromnim slovima u pesku. Na\u017ealost, palmini listovi prekrivaju delove pla\u017ee, pa neki delovi re\u010denice nisu vidljivi. Poznato je da je ispisana re\u010denica savr\u0161en pangram (sadr\u017ei svako slovo engleske abecede ta\u010dno jednom) i sastoji se isklju\u010divo od slova engleske abecede i razmaka. Pritom, ne postoje dva susedna razmaka, i re\u010denica ne po\u010dinje niti se zavr\u0161ava razmakom. Va\u0161 zadatak je da pomognete Brletu da rekonstrui\u0161e ispisanu re\u010denicu, ukoliko je to mogu\u0107e. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107 Dimitrije Erdeljan <p>Ozna\u010dimo broj pojavljivanja karaktera ? u stringu \\(A\\) sa \\(U\\), a skup slova engleske abecede koja se ne pojavljuju u stringu \\(A\\) sa \\(S\\). Jednim prolaskom kroz string mo\u017eemo lako na\u0107i ove vrednosti. Ukoliko se neko slovo pojavljuje vi\u0161e od jednom mo\u017eemo odmah zaklju\u010diti da rekonstrukcija nije mogu\u0107a i prekinuti izvr\u0161avanje programa.</p> <p>Sada znamo da treba zameniti ta\u010dno \\(|S|\\) karaktera ? slovima engleske abecede kako bi dobijena re\u010denica bila savr\u0161en pangram. Kako moramo zameniti sve karaktere ?, sledi da treba zameniti ta\u010dno \\(R=U-|S|\\)  njih razmacima. Pritom, ako va\u017ei  \\(U &lt; |S|\\) nije mogu\u0107e dodati sva nedostaju\u0107a slova, pa je ovo jo\u0161 jedan slu\u010daj u kom zaklju\u010dujemo da rekonstrukcija nije mogu\u0107a.</p> <p>Ostalo je jo\u0161 izvr\u0161iti samu rekonstrukciju tj. rasporediti slova i razmake. Treba imati u vidu da nije svejedno na koji na\u010din ovo radimo. Na primer, ako prvo dodamo svih \\(|S|\\) slova  (tj. zamenimo prvih \\(|S|\\)  karaktera ? slovima) mo\u017eda ne\u0107e biti mogu\u0107e postaviti svih \\(R\\) razmaka (npr. zbog uslova da dva razmaka ne smeju biti susedi). Primetimo da je uvek mogu\u0107e dodati slovo, ali nije uvek mogu\u0107e dodati razmak. Stoga, vr\u0161i\u0107emo rekonstrukciju tako da greedy dodajemo razmake dok ne dodamo svih \\(R\\). Drugim re\u010dima, kre\u0107emo se kroz string \\(A\\) sa leva na desno, i na svakoj poziciji postavljamo razmak ukoliko su svi uslovi ispunjeni: na toj poziciji je karakter ?, nismo na po\u010detku/kraju stringa, nijedan od dva susedna karaktera nije razmak. U suprotnom, dodajemo jedno od nedostaju\u0107ih slova iz skupa \\(S\\). Kada na ovaj na\u010din dodamo svih \\(R\\) razmaka, sve preostale karaktere ? menjamo preostalim nedostaju\u0107im slovima iz skupa \\(S\\) i ispisujemo dobijeni string kao re\u0161enje zadatka. Nije te\u0161ko pokazati da se na ovaj na\u010din mo\u017ee dodati maksimalan broj razmaka, te da ukoliko ovakva procedura nije u stanju da doda svih \\(R\\), do\u0161li smo do tre\u0107eg i poslednjeg slu\u010daja u kom je nemogu\u0107e izvr\u0161iti rekonstrukciju. </p> 01_pangram.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 255\n\nusing namespace std;\n\nint N;\nchar A[MAXN];\nunordered_map&lt;char, int&gt; cnt;\n\nint main() {\n    scanf(\"%d\", &amp;N);\n    scanf(\"%s\", A);\n    for (int i = 0; i &lt; N; i++) {\n        cnt[A[i]]++;\n        if (A[i] &gt;= 'a' &amp;&amp; A[i] &lt;= 'z' &amp;&amp; cnt[A[i]] == 2) {\n            // neko slovo se pojavilo dvaput\n            // nemoguce napraviti pangram\n            printf(\"SAN\\n\");\n            return 0;\n        }\n    }\n    // skupimo slova koja fale\n    vector&lt;char&gt; missing;\n    for (int c = 'a'; c &lt;= 'z'; c++) {\n        if (cnt[c] == 0) {\n            missing.push_back(c);\n        }\n    }\n    // ne mora, naravno\n    reverse(missing.begin(), missing.end()); \n    if (missing.size() &gt; cnt['?']) {\n        // nema dovoljno '?' da dodamo sva slova\n        printf(\"SAN\\n\");\n        return 0;\n    }\n    // koliko razmaka treba dodati?\n    int spaces = cnt['?'] - missing.size();\n    for (int i = 0; i &lt; N; i++) {\n        if (A[i] == '?') {\n            if (i &gt; 0 &amp;&amp; i &lt; N-1 &amp;&amp; spaces &gt; 0 &amp;&amp; A[i-1] != '_' &amp; A[i+1] != '_') {\n                // treba i moze razmak\n                A[i] = '_';\n                spaces--;\n            } else {\n                // ne treba razmaka vise ili ne moze razmaka vise\n                if (missing.empty()) {\n                    // nemoguce staviti dovoljno razmaka\n                    printf(\"SAN\\n\");\n                    return 0;\n                } else {\n                    A[i] = missing.back();\n                    missing.pop_back();\n                }\n            }\n        }\n    }\n    printf(\"%s\\n\", A);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se broj \\(N\\). U drugoj liniji standardnog ulaza nalazi se string \\(A\\) du\u017eine \\(N\\), koji predstavlja ispisanu re\u010denicu iz Brletove perspektive. Pritom va\u017ei: </p> <ul> <li>\\(A\\) se sastoji isklju\u010divo od slova engleske abecede (slova iz skupa \\(\\{a \\dots z\\}\\)), karaktera _ koji ozna\u010davaju razmake, i karaktera \\(?\\) koji ozna\u010davaju palmine listove tj. karaktere (slova ili razmake) koji nisu vidljivi.</li> <li>U \\(A\\) ne postoje dva susedna razmaka, a ni prvi i poslednji karakter \\(A\\) nisu razmaci.</li> </ul>"},{"location":"takprog/2017_2018/okr/01_pangram/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati string \\(B\\), koji predstavlja rekonstruisanu re\u010denicu. Pritom mora da va\u017ei: </p> <ul> <li>\\(B\\) se sastoji isklju\u010divo od slova engleske abecede i karaktera _ koji ozna\u010davaju razmake.</li> <li>U \\(B\\) ne postoje dva susedna razmaka, a ni prvi i poslednji karakter \\(B\\) nisu razmaci.</li> <li>\\(B\\) je savr\u0161en pangram.</li> <li>Mogu\u0107e je dobiti \\(B\\) od \\(A\\) isklju\u010divo nizom zamena karaktera \\(?\\) slovima engleske abecede ili razmacima.</li> </ul> <p>Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje. Ukoliko takvo \\(B\\) ne postoji (tj. rekonstrukcija nije mogu\u0107a) Brle sanja i potrebno je ispisati string <code>SAN</code> (velikim slovima).</p>"},{"location":"takprog/2017_2018/okr/01_pangram/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/okr/01_pangram/#ulaz","title":"Ulaz","text":"<pre><code>29\nabc????ghijklm_nopqrst???xyz?\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/#izlaz","title":"Izlaz","text":"<pre><code>abcdfe_ghijklm_nopqrstu_vxyzw\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/okr/01_pangram/#ulaz_1","title":"Ulaz","text":"<pre><code>28\nabcdefghijklmnopqrstuvwxy???\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/#izlaz_1","title":"Izlaz","text":"<pre><code>SAN\n</code></pre>"},{"location":"takprog/2017_2018/okr/01_pangram/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru mo\u017eemo pretpostaviti da prva serija palminih listova prekriva karaktere \\(dfe\\_\\), druga \\(u\\_v\\), a tre\u0107a \\(w\\). Ovako dobijamo savr\u0161en pangram koji ispunjava sve uslove.</p> <p>U drugom primeru je nemogu\u0107e zameniti tri palmina lista karakterima tako da se dobije savr\u0161en pangram koji ispunjava sve uslove, pa je u pitanju san.</p>"},{"location":"takprog/2017_2018/okr/01_pangram/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 250\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima koji vrede 15 poena va\u017ei \\(1 \\leq N \\leq 26\\).</li> <li>U test primerima koji vrede 15 poena nema palminih listova.</li> <li>U test primerima koji vrede 15 poena postoji najvi\u0161e jedan karakter prekriven palminim listom.</li> <li>U test primerima koji vrede 15 poena cela re\u010denica je prekrivena palminim listovima.</li> <li>U test primerima koji vrede 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/okr/02_matriks/","title":"B2 - Matriks","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Pro\u0161lo je vreme igre, u\u017eivanja i razonode. Pro\u0161lo je vreme malih matrica. Danas su ra\u010dunari neverovatno brzi i mogu izvr\u0161iti i do \\(10^{100}\\) komandi u sekundi. Iz tog razloga komisija vam je spremila jednostavan zadatak sa jednom matricom i mnogo interesantnih upita. </p> <p>U ovom zadatku vam je data matrica \\(A\\) dimenzije \\(n \\times m\\) - matrica ima ta\u010dno \\(n\\) vrsta i ta\u010dno \\(m\\) kolona. Vrste su numerisane brojevima od \\(1\\) do \\(n\\) odozgo nadole a kolone su numerisane brojevima od \\(1\\) do \\(m\\) sleva udesno. Za svako \\(i\\) (\\(1 \\leq i \\leq n\\)) i \\(j\\) (\\(1 \\leq j \\leq m\\)) vrednost na poziciji (\\(i,j\\)) u matrici \\(A\\) (tj. na polju u preseku \\(i\\)-te vrste \\(j\\)-te kolone) je definisana na slede\u0107i na\u010din :</p> \\[A_{i,j} = i \\ \\text{xor} \\ j\\] <p>gde operacija \\(X \\ \\text{xor} \\ Y\\) predstavlja ekskluzivnu disjunkciju brojeva \\(X\\) i \\(Y\\).</p> <p>Potrebno je odgovoriti na \\(q\\) upita oblika: Na\u0107i vrednost \\(\\text{xor}\\)-a svih brojeva u podmatrici matrice \\(A\\) sa gornjim levim temenom \\((x_l,y_l)\\) i donjim desnim temenom \\((x_r,y_r)\\). Podmatrica matrice \\(A\\) sa navedenim ograni\u010denjima obuhvata sve elemente \\(A_{i,j}\\) takve da va\u017ei  \\(x_l \\leq i \\leq x_r\\) , \\(y_l \\leq j \\leq y_r\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Nikola Jovanovi\u0107 Ivan Sto\u0161i\u0107 <p>Po\u0111imo od naivnog re\u0161enja: ako za svaki upit ra\u010dunamo tra\u017eeni \\(\\text{xor}\\) prolaskom kroz celu podmatricu ukupna vremenska slo\u017eenost je \\(\\mathcal{O}(qnm)\\), \u0161to je dovoljno za prvi podzadatak u kom va\u017ei \\(1\\leq n,m,q \\leq 100\\).</p> <p>Ozna\u010dimo vrednost izraza koji treba izra\u010dunati za neku podmatricu sa \\(S\\). U nastavku \u0107emo operaciju  \\(\\text{xor}\\) ozna\u010davati simbolom \\(\\oplus\\). Va\u017ei \\(S = A_{x_ly_l} \\oplus \\ldots\\oplus  A_{x_ry_r} = (x_l \\oplus y_l) \\oplus \\ldots \\oplus (x_r \\oplus y_r)\\). Ozna\u010dimo sada \\(S_x = x_l \\oplus \\ldots \\oplus x_r\\) i \\(S_y = y_l \\oplus \\ldots \\oplus y_r\\). Nezavisnim razmatranjem \u010dlanova po \\(x\\) i po \\(y\\) u izrazu za \\(S\\) dobijamo \\(S = (S_x \\oplus \\ldots \\oplus S_x) \\oplus (S_y \\oplus \\ldots \\oplus S_y)\\) pri \u010demu prva zagrada ima \\(\\Delta y=y_r - y_l + 1\\), a druga \\(\\Delta x=x_r - x_l + 1\\) \u010dlanova (\u0161irina i visina podmatrice). Ovakva reprezentacija sledi iz komutativnosti operacije \\(\\text{xor}\\) i predstavlja osnovu za pobolj\u0161anje na\u0161eg re\u0161enja.</p> <p>Iskoristi\u0107emo poznato svojstvo operacije \\(\\text{xor}\\): za svako \\(a\\) va\u017ei \\(a \\oplus a = 0\\). Iz ovoga sledi da je vrednost izraza \\(a \\oplus \\ldots \\oplus a\\) jednaka \\(a\\) ako imamo neparan broj \u010dlanova, a \\(0\\) u suprotnom. Ako primenimo ovo na dobijenu reprezentaciju \\(S\\) dobijamo da je vrednost prve zagrade jednaka \\(S_x\\)  kada je \\(\\Delta y\\) neparno, a \\(0\\) kada je parno. Na isti na\u010din vrednost druge zagrade je \\(S_y\\) kada je \\(\\Delta x\\) neparno, a \\(0\\) kada je parno. Dakle, ako naivno izra\u010dunamo vrednosti \\(S_x\\) i \\(S_y\\) mo\u017eemo u zavisnosti od parnosti dimenzija podmatrice na\u0107i \\(\\text{xor}\\) svih njenih vrednosti. Ovo nas dovodi do ukupne vremenske slo\u017eenosti od \\(\\mathcal{O}(q(n+m))\\) \u0161to je dovoljno za drugi podzadatak u kom va\u017ei \\(1\\leq n,m \\leq 1000\\).</p> <p>Poku\u0161ajmo da ubrzamo ra\u010dunanje vrednosti \\(S_x\\) i \\(S_y\\). Ako ozna\u010dimo sa \\(P(a) = 1 \\oplus \\ldots \\oplus a\\) vidimo da je \\(S_x = P(x_r) \\oplus P(x_l - 1)\\) i \\(S_y = P(x_r) \\oplus P(x_l - 1)\\). Ovo sledi iz svojstva istaknutog u prethodnom pasusu. Ako unapred izra\u010dunamo sve potrebne vrednosti \\(P\\) mo\u017eemo pri svakom upitu ra\u010dunati \\(S_x\\) i \\(S_y\\) u konstantnom vremenu, tj. re\u0161iti zadatak u ukupnoj vremenskoj slo\u017eenosti od \\(\\mathcal{O}(q)\\). Za \u010duvanje vrednosti  \\(P\\) nam je potreban niz odgovaraju\u0107e du\u017eine, pa je ukupna memorijska slo\u017eenost \\(\\mathcal{O}(m+n)\\), \u0161to je dovoljno za tre\u0107i podzadatak u kom va\u017ei \\(1\\leq n,m \\leq 10^6\\).</p> <p>Da bismo do\u0161li do optimalnog re\u0161enja smanji\u0107emo memorijsku slo\u017eenost bez pogor\u0161avanja vremenske, tj. na\u0107i na\u010din da u konstantnom vremenu izra\u010dunavamo vrednosti \\(P(a)\\). Za ovo treba primetiti jo\u0161 jedno, malo komplikovanije, svojstvo operacije \\(\\text{xor}\\): </p> \\[ P(a) = \\begin{cases} a &amp; \\text{za} ~ a = 4k \\\\ 1 &amp; \\text{za} ~ a = 4k+1 \\\\ a+1 &amp; \\text{za} ~ a = 4k+2 \\\\ 0 &amp; \\text{za} ~ a = 4k+3 \\end{cases} \\] <p>Do ovog svojstva je mogu\u0107e do\u0107i posmatranjem naivno izra\u010dunatih vrednosti \\(P(a)\\) ili direktno iz opservacije da svaka \u010detvorka brojeva \\((4k, 4k+1, 4k+2, 4k+3)\\) u binarnom sistemu ima oblik \\((\\bar{L}00, \\bar{L}01, \\bar{L}10, \\bar{L}11)\\). </p> <p>Sada imamo optimalno re\u0161enje: za svaki upit u konstantnom vremenu ra\u010dunamo vrednosti \\(P(a)\\) potrebne da bi se dobili \\(S_x\\) i \\(S_y\\). Na osnovu njih, u zavisnosti od parnosti dimenzija podmatrice, ra\u010dunamo tra\u017eenu vrednost \\(S\\). </p> 02_matriks.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\n\nusing namespace std;\n\nint n,m,q;\n\nint calc(int x)\n{\n    if (x%4==0) return x;\n    if (x%4==1) return 1;\n    if (x%4==2) return x+1;\n    return 0;\n}\n\nint main()\n{\n\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;\n\n    while(q--)\n    {\n        int xl,yl,xr,yr;\n\n        scanf(\"%d%d%d%d\",&amp;xl,&amp;yl,&amp;xr,&amp;yr);\n\n        int ans=0;\n\n        if ((xr&amp;1)==(xl&amp;1))\n            ans=calc(yr)^calc(yl-1);\n\n        if ((yr&amp;1)==(yl&amp;1))\n            ans^=calc(xr)^calc(xl-1);\n\n        printf(\"%d\\n\",ans);\n    }\n\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/02_matriks/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se brojevi \\(n, m, q\\), broj vrsta matrice \\(A\\), broj kolona matrice \\(A\\) i broj upita na koje je potrebno odgovoriti. Narednih \\(q\\) linija sadr\u017ee po \u010detiri broja, koji predstaljaju redom vrstu gornjeg levog temena podmatrice, kolonu gornjeg levog temena podmatrice, vrstu donjeg desnog temena podmatrice i kolonu donjeg desnog temena podmatrice.</p>"},{"location":"takprog/2017_2018/okr/02_matriks/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardnom izlazu u \\(q\\) redova odgovoriti na upite opisane u tekstu zadatka, ta\u010dnije u \\(i\\)-a liniji standardnog izlaza ispisati re\u0161enje \\(i\\)-tog upita.</p>"},{"location":"takprog/2017_2018/okr/02_matriks/#primer","title":"Primer","text":""},{"location":"takprog/2017_2018/okr/02_matriks/#ulaz","title":"Ulaz","text":"<pre><code>4 5 3\n1 1 3 3\n2 3 4 5\n2 3 2 4\n</code></pre>"},{"location":"takprog/2017_2018/okr/02_matriks/#izlaz","title":"Izlaz","text":"<pre><code>0\n7\n7\n</code></pre>"},{"location":"takprog/2017_2018/okr/02_matriks/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Matrica A je dimenzije \\(4 \\cdot 5\\) i ima oblik:</p> <pre><code>0 3 2 5 4\n3 0 1 6 7\n2 1 0 7 6\n5 6 7 0 1\n</code></pre> <p>Prvi upit zadr\u017ei podmatricu sa gornjim levim temenom (\\(1,1\\)) i donjim desnim (\\(3,3\\)). Re\u0161enje ovog upita je \\(\\text{ xor }\\) svih brojeva u podmatrici, odnosno : </p> \\[ 0 \\text{ xor } 3 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 0 \\text{ xor } 1 \\text{ xor } 2 \\text{ xor } 1 \\text{ xor } 0  = 0 \\] <p>Tre\u0107i upit sadr\u017ei samo dva broja \\(1\\) i \\(6\\), tako da je re\u0161enja za ovaj primer \\(1 \\text{ xor } 6 =7\\) </p>"},{"location":"takprog/2017_2018/okr/02_matriks/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n,m \\leq 10^9\\).</li> <li>\\(1 \\leq q \\leq 10^5\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe.</p> <ul> <li>U primerima vrednim 20 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m,q \\leq 100\\).</li> <li>U primerima vrednim 20 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m \\leq 1000\\).</li> <li>U primerima vrednim 30 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m \\leq 10^6\\).</li> <li>U primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/okr/02_matriks/#napomena","title":"Napomena","text":"<p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>^</code>. Ova operacija \\(x \\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din: prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_i = 0, b_i = 0\\) va\u017ei \\(c_i = 0\\)</li> <li>Za \\(a_i = 0, b_i = 1\\) va\u017ei \\(c_i = 1\\)</li> <li>Za \\(a_i = 1, b_i = 0\\) va\u017ei \\(c_i = 1\\)</li> <li>Za \\(a_i = 1, b_i = 1\\) va\u017ei \\(c_i = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\ y\\).</p>"},{"location":"takprog/2017_2018/okr/03_zalbe/","title":"B3 - \u017dalbe","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Poznato je da se Komisijska komisija za \u017ealbe sastoji od \\(n\\) \u010dlanova koji rade za \\(n\\) stolova numerisanih, s leva udesno, brojevima od \\(1\\) do \\(n\\). Svaki \u010dlan komisije za \u017ealbe poseduje pravednost, \"Ja \\(\\heartsuit\\) Petlja\" \u0161olju i \"Mrzim \u017ealbe\" majicu. Kad god neki takmi\u010dar uobrazi da je o\u0161te\u0107en na takmi\u010denju, on predaje \u017ealbu nekom \u010dlanu komisije i nada se najboljem.</p> <p>Me\u0111utim, \u010dudni su putevi \u017ealbi. Kada neki \u010dlan dobije \u017ealbu, on se zgrozi, baca nov\u010di\u0107 i, ukoliko padne pismo, prosle\u0111uje \u017ealbu nekom \u010dlanu komisije levo od sebe koji nije ve\u0107 dobio ovu \u017ealbu; ukoliko padne glava, prosle\u0111uje \u017ealbu nekom \u010dlanu komisije desno od sebe koji nije ve\u0107 dobio ovu \u017ealbu. \u010clanovi komisije su nave\u017ebani u bacanju nov\u010di\u0107a - \u017ealba na ovaj na\u010din uvek pro\u0111e sve \u010dlanove komisije i, nakon \\(n-1\\) prosle\u0111ivanja, \u010dlan koji poslednji dobije ovu \u017ealbu je baca u kantu za sme\u0107e i \u0161alje mejl \"\u017ealba je odbijena\".</p> <p>Zli takmi\u010dar Be\u017eal Everfor je dobio \"\u017ealba je odbijena\" mejl (tu\u017ena pri\u010da) i on \u017eeli da ispita za\u0161to je do toga do\u0161lo. On je prevarantskim metodama saznao svih \\(n-1\\) rezultata bacanja nov\u010di\u0107a i cilj mu je da na osnovu toga rekonstrui\u0161e redosled prosle\u0111ivanja \u017ealbe tj. da prona\u0111e permutaciju \\((p_1, p_2, \\ldots, p_n)\\) brojeva koja ozna\u010dava da je \u017ealbu prvo dobio \u010dlan \\(p_1\\) koji je prosledio \u010dlanu \\(p_2\\) koji je prosledio \\(\\ldots\\) koji je prosledio \u010dlanu \\(p_n\\). Takva permutacija mora biti u skladu sa bacanjem nov\u010di\u0107a (npr. ako je u \\(i\\)-tom bacanju palo pismo, \u010dlan \\(p_{i+1}\\) mora imati manji redni broj od \u010dlana \\(p_i\\)); nazovimo sve takve permutacije (redoslede) dobrim. </p> <p>Osim \u017ealbi, Be\u017eal mnogo voli leksikografske poretke i konkretan broj \\(k\\). Zato vas je zamolio da mu pomognete u rekonstrukciji redosleda prosle\u0111ivanja \u017ealbi:</p> <ul> <li>Ukoliko prona\u0111ete leksikografski najmanju od svih dobrih permutacija koje po\u010dinju brojem \\(k\\) (tj. za koje va\u017ei \\(p_1 = k\\)) dobijate sve poene na odgovaraju\u0107em test-primeru. </li> <li>Ukoliko prona\u0111ete bilo koju dobru permutaciju koja ne zadovoljava sve gore pomenute uslove dobijate 60% poena na odgovaraju\u0107em test-primeru. (dakle, u ovom slu\u010daju ne treba obra\u0107ati pa\u017enju na broj \\(k\\) i leksikografski poredak ali permutacija i dalje mora biti u skladu sa bacanjem nov\u010di\u0107a).</li> </ul> <p>Ukoliko pomognete Be\u017ealu, dobijate polovinu usvojenih poena sa njegove \u017ealbe!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Andrej Iva\u0161kovi\u0107 <p>Prvi podzadatak se mo\u017ee re\u0161iti jednostavnom analizom slu\u010dajeva: za \\(n \\leq 4\\) posle fiksiranja \\(p_1 = k\\) ostaje nam najvi\u0161e \\(3 \\cdot 2\\) mogu\u0107ih rasporeda koje treba proveriti. Drugi (istovremeno i prvi) podzadatak se mo\u017ee re\u0161iti u slo\u017eenosti \\(O(n! \\cdot n)\\) proveravanjem svih permutacija du\u017eine \\(n\\) za ukupno \\(25\\) poena.</p> <p>Analizirajmo sada kako generisati bilo koju dobru permutaciju, ne obra\u0107aju\u0107i pa\u017enju na broj \\(k\\) i na leksikografski poredak (re\u0161enje za \\(60\\) poena). Jedan od na\u010dina je  slede\u0107i: redom \u0107emo postavljati vrednosti \\(p_1, p_2, \\ldots, p_n\\) tako da se nakon \\(i\\) postavljanja na pozicijama \\(p_1, p_2, \\ldots, p_i\\) nalaze uzastopne vrednosti iz segmenta \\([l, r]\\) za neke \\(l,r\\) (gde je \\(l - r + 1 = i\\)). U \\((i+1)\\)-vom potezu, ukoliko je odgovaraju\u0107i karakter <code>P</code>, dovoljno je postaviti \\(p_{i+1} = l - 1\\), odnosno \\(p_{i+1} = r+1\\) u suprotnom (naredni postavljeni broj je uvek ili trenutni najmanji broj - 1 ili trenutni najve\u0107i broj + 1); na po\u010detku postavljamo \\(p_1 = x\\) (za neki prirodan broj \\(x\\)). Na primer, za ulaz  <code>PPGPGGGPP</code> i npr. \\(x = 1\\), dobijamo </p> \\[ (1) \\rightarrow (1, 0) \\rightarrow (1, 0, -1) \\rightarrow (1, 0, -1, 2) \\rightarrow (1, 0, -1, 2, -2) \\rightarrow (1, 0, -1, 2, -2, 3) \\rightarrow  \\] \\[ (1, 0, -1, 2, -2, 3, 4) \\rightarrow (1, 0, -1, 2, -2, 3, 4, 5) \\rightarrow (1, 0, -1, 2, -2, 3, 4, 5, -3) \\rightarrow \\] \\[ (1, 0, -1, 2, -2, 3, 4, 5, -3, -4). \\] <p>Pomenuti postupak se mo\u017ee implementirati u slo\u017eenosti \\(O(n)\\). Jasno, dobijena \"permutacija\" je u skladu sa bacanjem nov\u010di\u0107a ali dobijeni brojevi nisu nu\u017eno iz segmenta \\([1, n]\\). Ovo mo\u017eemo re\u0161iti na \\(2\\) na\u010dina: \\(1\\)) dodati svim elementima permutacije \\(p\\) apsolutnu vrednost najmanjeg elementa + \\(1\\) ili \\(2\\)) izabrati \\(x\\) kao 1 + broj pojavljivanja karaktera <code>P</code>. Npr. prvi na\u010din primenjen na pomenuti primer daje </p> \\[ (1, 0, -1, 2, -2, 3, 4, 5, -3, -4) + 5 = (6, 5, 4, 7, 3, 8, 9, 10, 2, 1) \\] <p>Dakle, (bar jedna) dobra permutacija uvek postoji. U \u010detvrtom podzadatku se tra\u017ei leksikografski najmanja dobra permutacija (bez uslova za po\u010detni broj \\(k\\)) -- sada je neophodno te\u017eiti da \\(p_1\\) bude najmanje mogu\u0107e, zatim da \\(p_2\\) bude najmanje mogu\u0107e za izabrano \\(p_1\\) itd. Ukoliko na po\u010detku imamo \\(m \\geq 0\\) uzastopnih karaktera <code>P</code>, tada mora biti \\(p_1 = m + 1\\). Zaista, ukoliko bi bilo \\(p_1 &lt; m + 1\\) ne bismo imali dovoljno mesta za pomeranje ulevo; sa druge strane, postoji dobra permutacija koja po\u010dinje sa \\((m + 1, m, m - 1, \\ldots, 2, 1)\\) a zatim neki skok udesno preko \\(m+1\\) (mogu\u0107e je nastaviti, npr. na osnovu konstrukcije za 60%). Nastavljanjem ovog postupka za niz \\((m+2, m+3, \\ldots, n)\\) i preostale karaktera dolazimo do optimalnog re\u0161enja. </p> <p>Nije te\u0161ko do\u0107i do slede\u0107eg algoritma slo\u017eenosti \\(O(n)\\) koji realizuje pomenuti postupak: dodati 've\u0161ta\u010dki' karakter <code>G</code> na po\u010detak stringa; podeliti string na uzastopne podstringove \u010diji je prvi karakter <code>G</code>; u permutaciji \\((1, 2, \\ldots, n)\\) obrnuti redosled uzatopnim elementima koji odgovaraju odgovaraju\u0107im podstringovima i vratiti dobijenu permutaciju. Na primer, PPGPGGGPP \\(\\rightarrow\\) GPPGPGGGPP \\(\\rightarrow\\) GPP|GP|G|G|GPP \\(\\rightarrow\\) 1 2 3 | 4 5 | 6 | 7 | 8 9 10 \\(\\rightarrow\\) 3 2 1 | 5 4 | 6 | 7 | 10 9 8 \\(\\rightarrow\\) (3, 2, 1, 5, 4, 6, 7, 10, 9, 8). Ovaj algoritam osvaja 72 poena.</p> <p>Kona\u010dno, za maksimalan broj poena treba modifikovati prethodni algoritam tako da permutacija uvek po\u010dinje brojem \\(k\\). Neka na po\u010detku stringa ide prvo \\(a \\geq 0\\) 'G'-ova a zatim \\(b \\geq 0\\) 'P'-ova. Uzimaju\u0107i u obzir leksikografsku minimalnost, razlikujemo dva slu\u010daja: 1) Ukoliko je \\(b &lt; k\\) (ima mesta ulevo) tra\u017eena permutacija po\u010dinje sa \\((k, k+1, \\ldots, k + a)\\) a ostatak dobijamo tra\u017eenjem minimalne dobre permutacije preostalog skupa vrednosti \\((\\{1, 2, \\ldots, n\\} \\setminus \\{k, k+1, \\ldots, k + a\\})\\) za preostali niz karaktera; 2) Ukoliko je \\(b \\geq k\\) (nema mesta ulevo) tra\u017eena permutacija po\u010dinje sa \\((k, k+1, \\ldots, k + a - 1, k + a + (b - k + 1))\\) a ostatak dobijamo tra\u017eenjem minimalne dobre permutacije preostalog skupa vrednosti za preostali niz karaktera. Naravno, u oba slu\u010daja za ostatak permutacije koristimo algoritam iz \u010detvrtog podzadatka.</p> <p>Neefikasna implementacija prethodnih algoritama (npr. u \\(O(n^2)\\)) dovoljna je za prva tri podzadatka tj. za oko 40 poena. </p> 03_zalbe.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 200010;\n\nint p[MAX_N], a[MAX_N], blockLen[MAX_N];\nchar s[MAX_N];\nbool mark[MAX_N];\n\nint n, k, bNum;\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    scanf(\"%s\", s + 1);\n\n    // podela stringa s na blokove oblika GPPP...P (uz vestacko 'G' na pocetku)\n    bNum = 0;\n    blockLen[0] = 1;\n    for (int i = 1; i &lt; n; i++)\n    {\n        if (s[i] == 'P')\n            blockLen[bNum]++;\n        else\n            blockLen[++bNum] = 1;\n    }\n\n    int curr = 0;\n    while (curr &lt;= bNum &amp;&amp; blockLen[curr] == 1) curr++;\n    // curr simbola 'G' (ne ukljucujuci vestacki) pa onda PPP.. =&gt; permutacija sigurno krece (k, k+1, ..., k+curr-1)\n    // a naredni korak zavisi od duzine niza PPP... (pomeranje ulevo) - ako nije predugacak, pomeraj na k+curr a inace mora 'desnije'\n    for (int i = 0; i &lt; curr; i++)\n        mark[k + i] = true;\n    if (curr &lt;= bNum)\n    {\n        if (blockLen[curr] &lt;= k)\n            mark[k + curr] = true;\n        else\n            mark[blockLen[curr] + curr] = true;\n        blockLen[curr]--;\n    }\n\n    // ubaciti markirane elemente na pocetak permutacije p[] i napraviti niz a preostalih slobodnih elemenata;\n    int m = 0;\n    int currP = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        if (mark[i])\n            p[++currP] = i;\n        else\n            a[++m] = i;\n    }\n\n    // sada resavamo subtask 4 gde je niz (a[1], a[2], ..., a[m]) pocevsi od bloka curr\n    int pos = 0;\n    for (int i = curr; i &lt;= bNum; i++)\n    {\n        pos = pos + blockLen[i];\n        for (int j = 0; j &lt; blockLen[i]; j++)\n            p[++currP] = a[pos - j];\n    }\n\n    for (int i = 1; i &lt; n; i++)\n        printf(\"%d \", p[i]);\n    printf(\"%d\\n\", p[n]);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/03_zalbe/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se prirodni brojevi \\(n\\) i \\(k\\), odvojeni razmakom. U drugom redu nalazi se \\(n-1\\) karaktera koji su ili 'P' (pismo, ozna\u010dava prosle\u0111ivanje \u017ealbe ulevo) ili 'G' (glava, ozna\u010dava prosle\u0111ivanje \u017ealbe udesno). Izme\u0111u karaktera nema razmaka.</p>"},{"location":"takprog/2017_2018/okr/03_zalbe/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red standardnog izlaza ispisati \\(n\\) razli\u010ditih prirodnih brojeva od \\(1\\) do \\(n\\) - tra\u017eenu permutaciju \\(p\\). Ulazni podaci \u0107e biti takvi da \u0107e re\u0161enje (za maksimalan broj poena) uvek postojati - to re\u0161enje je (jasno) uvek jedinstveno dok je za 60% poena dozvoljeno ispisati bilo koje (ta\u010dno) re\u0161enje.</p>"},{"location":"takprog/2017_2018/okr/03_zalbe/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/okr/03_zalbe/#ulaz","title":"Ulaz","text":"<pre><code>5 2\nGPPG\n</code></pre>"},{"location":"takprog/2017_2018/okr/03_zalbe/#izlaz","title":"Izlaz","text":"<pre><code>2 4 3 1 5\n</code></pre>"},{"location":"takprog/2017_2018/okr/03_zalbe/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/okr/03_zalbe/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3\nPP\n</code></pre>"},{"location":"takprog/2017_2018/okr/03_zalbe/#izlaz_1","title":"Izlaz","text":"<pre><code>3 2 1\n</code></pre>"},{"location":"takprog/2017_2018/okr/03_zalbe/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru je \\(n = 5\\), \\(k = 2\\) a bacanje nov\u010di\u0107a ka\u017ee da je \u017ealba putovala desno-levo-levo-desno. Tra\u017eena leksikografski minimalna permutacija koja po\u010dinje od \\(k\\)-tog \u010dlana je \\((2, 4, 3, 1, 5)\\) tj. \u010dlan \\(2\\) prosle\u0111uje (udesno) \u010dlanu \\(4\\), ovaj prosle\u0111uje (ulevo) \u010dlanu \\(3\\), ovaj prosle\u0111uje (ulevo) \u010dlanu \\(1\\), ovaj prosle\u0111uje (udesno) \u010dlanu \\(5\\). Ovo re\u0161enje osvaja sve poene dok neka od re\u0161enja koja osvajaju \\(60\\%\\) poena mogu biti \\((3, 5, 2, 1, 4)\\) (ne po\u010dinje od \\(k\\)-tog \u010dlana) i \\((2, 5, 4, 1, 3)\\) (nije leksikografski minimalna permutacija koji po\u010dinje brojem \\(k\\)).</p>"},{"location":"takprog/2017_2018/okr/03_zalbe/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq n \\leq 200.000\\).</li> <li>\\(1 \\leq k \\leq n\\).</li> <li>Svih \\(n-1\\) karaktera na ulazu pripadaju skupu \\(\\{'P', 'G'\\}\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima koji vrede \\(10\\) poena va\u017ei\u0107e \\(n \\leq 4\\).</li> <li>U test primerima koji vrede \\(15\\) poena va\u017ei\u0107e \\(n \\leq 10\\).</li> <li>U test primerima koji vrede \\(15\\) poena va\u017ei\u0107e \\(n \\leq 5.000\\).</li> <li>U test primerima koji vrede \\(30\\) poena garantuje se da najmanja leksikografska permutacija koja je saglasna sa rezultatima bacanja nov\u0107i\u0107a po\u010dinje upravo brojem \\(k\\).</li> <li>U test primerima koji vrede \\(30\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/okr/03_zalbe/#napomena","title":"Napomena","text":"<p>Niz \\((a_1, a_2, a_3, \\ldots, a_n)\\) je leksikografski manji od niza  \\((b_1, b_2, b_3, \\ldots, b_n)\\) ako postoji indeks \\(i\\) sa osobinom da je \\(a_1 = b_1, a_2 = b_2, \\ldots, a_{i-1} = b_{i-1}\\) i \\(a_{i} &lt; b_{i}\\).</p>"},{"location":"takprog/2017_2018/okr/04_cik_cak/","title":"A1 - Cik-cak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Mikica se od zavr\u0161etka tre\u0107eg kruga kvalifikacija bavi prou\u010davanjem nizova koje je nazvao cik-cak nizovi. To su nizovi celih brojeva sa slede\u0107im osobinama:</p> <ul> <li>prvi element ima vrednost nula</li> <li>svaki slede\u0107i element je za jedan manji ili za jedan ve\u0107i od prethodnog.</li> </ul> <p>Na primer, cik-cak nizovi su nizovi \\(0, -1, -2, -1, 0, 1, 2, 3, 2, 1\\) ili \\(0, 1, 0, -1, -2, -1, 0, 1, 2, 3\\) a niz \\(0, 1, 2, 3, 1, 2, 1, 0, -1\\) nije cik-cak jer je peti element za dva manji od \u010detvrtog. Prou\u010davaju\u0107i cik-cak nizove, Mikica je sebi postavio zadatak da za zadati prirodni broj \\(n\\) i ceo broj \\(S\\) odredi cik-cak niz koji ima \\(n\\) elemenata, ali takav da je zbir tih \\(n\\) elemenata jednak broju \\(S\\). Zapravo, postavio je sebi zadatak da to bude leksikografski najmanji niz, ali kako jo\u0161 uvek nije uspeo da prona\u0111e postupak za odre\u0111ivanje tog niza bio bi zadovoljan ako prona\u0111e bilo koji cik-cak niz sa \\(n\\) elemenata koji ima zbir elemenata jednak broju \\(S\\).</p> <p>Pomozite Mikici i napi\u0161ite program koji \u0107e za zadate brojeve \\(n\\) i  \\(S\\) odrediti leksikografski najmanji niz sa \\(n\\) elemenata \u010diji je zbir \\(S\\). Ako ne uspete da na\u0111ete leksikografski najmanji, ali zato prona\u0111ete neki drugi niz sa tom osobinom, dobi\u0107ete \\(60\\%\\) predvi\u0111enih poena.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Plav\u0161i\u0107 <p>Primetimo da je najve\u0107i zbir koji mo\u017ee imati cik-cak niz sa \\(n\\) elemenata jednak \\(\\frac{n(n-1)}{2}\\) i posti\u017ee se ako je svaki slede\u0107i element za jedan ve\u0107i od prethodnog, tj. ako niz ima slede\u0107i izgled:</p> \\[ 0, 1, 2, ..., n-1. \\] <p>Tako\u0111e je najmanji zbir koji se mo\u017ee posti\u0107i jednak \\(-\\frac{n(n-1)}{2}\\) i dobija se kada je svaki slede\u0107i element za jedan manji od prethodnog pa su elementi tog niza:</p> \\[ 0, -1, -2, ..., -n+1. \\] <p>Tako\u0111e, primetimo da elementi niza zadr\u017eavaju parnost, pa su tako prvi, tre\u0107i, peti, itd. uvek parni, a drugi, \u010detvrti, \u0161esti, itd. su uvek neparni. Zbog toga sume svih cik-cak nizova sa istim brojem elemenata (neka je broj elemenata \\(n\\)) uvek iste parnosti. Prema tome, ako su vrednost \\(\\frac{n(n-1)}{2}\\) i suma zadata u postavci problema (ozna\u010dimo tu sumu sa \\(S\\)) razli\u010dite parnosti, zadatak nema re\u0161enje. Tako\u0111e, ako je tra\u017eena suma ve\u0107a od najve\u0107e mogu\u0107e ili manja od najmanje mogu\u0107e, zadatak nema re\u0161enje. U ostalim slu\u010dajevima zadatak ima re\u0161enje i potrebno je krenuti od cik cak niza \\(\\(0, 1, 2, 3, ..., n-1\\)\\) \u010dija je suma \\(\\frac{n(n-1)}{2}\\) i smanjivati dok se ne dobije tra\u017eena suma. Primetimo da ako se drugi element dobija smanjivanjem prvog za jedan, dok se svi ostali dobijaju dodavanjem broja 1 na prethodni, onda se ukupna suma smanji za \\(2(n-1)\\). To je zato \u0161to su se svi elementi osim prvog smanjili za dva. Analogno, ako tre\u0107i dobijemo smanjivanjem drugog za 1, a ostale ra\u010dunamo nepromenjeno, zbir \u0107e se smanjiti za \\(2(n-2)\\).  Tako dolazmo do pravilnosti kako ra\u010dunamo elemente niza. Neka je </p> \\[ D = \\frac{n(n-1)}{2} - S. \\] <p>Postavimo da je prvi element jednak nuli (jer je tako i definisan cik-cak niz). Po\u010dev od elementa sa indeksom \\(k=2\\) (elementi su ina\u010de indeksirani po\u010dev od indeksa 1), proveravamo da li je trenutna vrednost \\(D\\) ve\u0107a od ili jednaka \\(2(n-k+1)\\). Ako jeste, onda taj element dobijamo umanjivanjem prethodnog za jedan i istovremeno vrednost \\(D\\) smanjimo za \\(2(n-k+1)\\). U suprotnom, taj element dobijamo uve\u0107avanjem prethodnog za jedan, a vrednost \\(D\\) ostaje neporomenjena. Lako se uveravamo da \u0107e se na ovaj na\u010din uvek dobiti niz \u010dija je suma jednaka tra\u017eenoj. </p> <p>Primetimo da time \u0161to po\u010detne elemente dobijamo smanjivanjem prethodnih (kada god je to mogu\u0107e), obezbe\u0111ujemo da \u0107e biti dobijen leksikografski najmanji cik-cak niz sa zadatom sumom.</p> 04_cik_cak.cpp<pre><code># include &lt;stdio.h&gt;\n\n# define MAXN 50050\n\nint n;\nint a[MAXN];\nlong long s, s1, s2, s3;\n\nmain() {\n    int i, j, k;\n    scanf(\"%d%lld\", &amp;n, &amp;s1);\n    s = (long long)n * (n-1) / 2;\n    if (s1 &gt; s) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    if (s1 &lt; -s) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    if ((s - s1) %2 == 1) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    s2 = (s - s1) / 2;\n    a[0] = 0;\n    for (i = 1, j = n-1; i &lt; n; i++, j--) \n        if (j &lt;= s2) {\n            a[i] = a[i-1] - 1;\n            s2 -= j;\n        } else {\n            a[i] = a[i-1] + 1;\n        }\n    for (i = 0; i &lt; n; i++)\n        printf(\"%d\\n\", a[i]);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalaze prirodan broj \\(n\\) i ceo broj \\(S\\) razdvojeni jednim razmakom</p>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#opis-izlaza","title":"Opis izlaza","text":"<p>Ako ne postoji cik-cak niz sa \\(n\\) elemenata \u010diji je zbir \\(S\\), onda u prvom redu ispisati broj \\(-1\\). Ako postoji cik-cak niz sa tra\u017eenim osobinama, ispisati taj niz tako \u0161to se u svakom od \\(n\\) redova ispisuje po jedan element niza. Ako ste uspeli da odredite leksikografski najmanji, treba njega ispisati, u suprotnom ispisati bilo koji.</p>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/okr/04_cik_cak/#ulaz","title":"Ulaz","text":"<pre><code>7 3\n</code></pre>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#izlaz","title":"Izlaz","text":"<pre><code>0\n-1\n0\n1\n0\n1\n2\n</code></pre>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/okr/04_cik_cak/#ulaz_1","title":"Ulaz","text":"<pre><code>3 100\n</code></pre>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Sabiranjem elemenata (prvi primer) se zaklju\u010duje da je zbir 3. Lako se proverava da ne postoji leksikografski manji sa istim zbirom.</p>"},{"location":"takprog/2017_2018/okr/04_cik_cak/#ogranicenja-i-podzadaci","title":"Ograni\u010denja i podzadaci","text":"<ul> <li>\\(1\\leq n \\leq 50000\\).</li> <li>\\(-10^9 \\leq S \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede \\(20\\) poena broj elemenata u nizovima nije ve\u0107i od \\(20\\).</li> <li>U test primerima koji vrede \\(30\\) poena broj \\(S\\) je izme\u0111u \\(-10\\) i \\(10\\).</li> <li>U test primerima koji vrede \\(50\\) poena nema dodatnih ograni\u010denja. </li> </ul> <p>Napomena</p> <p>Niz \\((a_1, a_2, a_3, \\ldots, a_n)\\) je leksikografski manji od niza  \\((b_1, b_2, b_3, \\ldots, b_n)\\) ako postoji indeks \\(i\\) sa osobinom da je \\(a_1 = b_1, a_2 = b_2, \\ldots, a_{i-1} = b_{i-1}\\) i \\(a_{i} &lt; b_{i}\\).</p>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/","title":"A2 - Velika matrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>Pro\u0161lo je vreme igre, u\u017eivanja i razonode. Pro\u0161lo je vreme malih matrica. Danas su ra\u010dunari neverovatno brzi i mogu izvr\u0161iti i do \\(10^{100}\\) komandi u sekundi. Iz tog razloga komisija vam je spremila jednostavan zadatak sa jednom matricom i mnogo interesantnih upita. </p> <p>U ovom zadatku vam je data matrica dimenzije \\(n \\cdot m\\) - matrica ima ta\u010dno \\(n\\) vrsta i ta\u010dno \\(m\\) kolona. Za svako \\(i\\) (\\(1 \\leq i \\leq n\\)) i \\(j\\) (\\(1 \\leq j \\leq m\\)) vrednost na poziciji (\\(i,j\\)) u matrici \\(A\\) je definisano na slede\u0107i na\u010din:</p> <p>\\(A_{i,j}\\) = (\\(i\\) + \\(j\\)) mod \\(M\\)</p> <p>Operacija \\(X\\) \\(mod\\) \\(M\\) predstavlja ostatak koji daje broj \\(X\\) pri deljenju sa \\(M\\).</p> <p>Potrebno je odgovoriti na \\(q\\) upita oblika : Na\u0107i sumu svih brojeva u podmatrici matrice A sa gornjim levim temenom (\\(x_l,y_l\\)) i donjim desnim temenom(\\(x_r,y_r\\)) po modulu \\(10^9+7\\). Podmatrica matrice A sa navedenim ograni\u010denjima obuhvata sve elemente \\(A_{i,j}\\) takve da va\u017ei  \\(x_l \\leq i \\leq x_r\\) , \\(y_l \\leq j \\leq y_r\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 <p>Za prvi podzadatak re\u0161enje koje ra\u010duna sumu podmatrice element po element tj. re\u0161enje slo\u017eenosti \\(O(nmq)\\) je dovoljno brzo.</p> <p>Za podzadatak gde je \\(M=2\\), ukoliko je visina \\(H\\) ili \u0161irina \\(W\\) podmatrice paran broj, odgovor je \\(\\frac{WH}{2}\\). U suprotnom (ako su oba neparna), re\u0161enje je \\(\\frac{WH + x}{2}\\), gde je \\(x\\) vrednost u gornjem levom uglu matrice. Ovo proisti\u010de iz \u010dinjenice da matrica izgleda kao \u0161ahovska tabla.</p> <p>Za podzadatak gde je \\(n,m \\leq 1000\\), mo\u017eemo izra\u010dunati \\(2D\\) prefiksne sume, odnosno za svako \\(u,v\\) vrednost \\(P_{u,v} = \\sum_{i\\leq u, j \\leq v} A_{i, j}\\). Za ove vrednosti va\u017ei slede\u0107a veza: \\(P_{u,v} = P_{u-1,v} + P_{u,v-1} - P_{u-1,v-1} + A_{u,v}\\). Nakon toga, vrednost u podmatrici \\((x_l, y_l) - (x_r, y_r)\\) nalazimo kao \\(P_{x_r,y_r}+P_{x_l-1,y_l-1}-P_{x_r, y_l-1}-P_{x_l-1,y_r}\\). Vremenska slo\u017eenost je \\(O(nm+q)\\).</p> <p>\u010cetvrti podzadatak se re\u0161ava isto kao poslednji, s tim \u0161to za pojedine matemati\u010dke sume nije neophodno tra\u017eiti formulu slo\u017eenosti \\(O(1)\\) ve\u0107 se mogu izra\u010dunati unapred sve vrednosti u linearnoj slo\u017eenosti po \\(n,m\\).</p> <p>Re\u0161enje za maksimalni broj poena se sastoji od toga da se matrica podeli na tri dela, zatim se svaki od tih delova deli na tri poddela, a za svaki od njih se suma mo\u017ee izra\u010dunati u \\(O(1)\\), pa je ukupna vremenska slo\u017eenost \\(O(1)\\) po upitu odnosno \\(O(q)\\). Ukoliko je matrica pravougaona, prvi deo bi\u0107e jednakokrako-pravougli trougao kome je kateta kra\u0107a ivica (gornja ili leva) a prav ugao mu je u gornjem-levom temenu podmatrice. Sli\u010dno, drugi deo bi\u0107e jednakokrako-pravougli trougao kome je prav ugao u donjem-desnom temenu podmatrice a kateta mu je kra\u0107a ivica (desna ili donja). Tre\u0107i deo je ostatak ove podmatrice koji \u0107e imati oblik paralelograma (ovaj deo mo\u017ee biti prazan). U slu\u010daju da je data podmatrica kvadratna mo\u017eemo uzeti da donji desni trougao ima za \\(1\\) kra\u0107u katetu od gornjeg levog, a tre\u0107i deo (paralelogram u sredini) \u0107e opet biti prazan.</p> <p>Zatim, svaki od ovih delova delimo na poddelove. Svaki od delova \u0107e se sastojati od skupa sporednih dijagonala takvih da su unutar dijagonale svi brojevi jednaki. Kod prvog dela (gornji/levi trougao), ove dijagonale imaju rastu\u0107e du\u017eine, kod drugog dela (donji/desni trougao) one imaju opadaju\u0107e du\u017eine, a kod tre\u0107eg (srednjeg) dela one imaju jednake du\u017eine. Svaki od delova delimo na tri poddela: Srednji od ovih poddelova se sastoji maksimalnog broja poddijagonala koje redom uzimaju vrednosti \\(0, 1, 2, \\ldots, M-1\\), dok su ostala dva dela levi i desni ostaci. Za ra\u010dunanje sume unutar svakog od ovih poddelova mo\u017eemo koristiti slede\u0107e identitete:</p> <ul> <li>\\(\\sum_{i=1}^n i = \\frac{n(n+1)}{2}\\)</li> <li>\\(\\sum_{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6}\\)</li> </ul> <p>Neke od posledica koje su korisne pri ra\u010dunanju suma su:</p> <ul> <li>\\(\\sum_{i=1}^n (a+i)(b+i) = abn + \\frac{n(n+1)(2n+1)}{6} + \\frac{(a+b)n(n+1)}{2}\\)</li> <li>\\(\\sum_{i=1}^n (a+i)(b-i) = abn - \\frac{n(n+1)(2n+1)}{6} + \\frac{(b-a)n(n+1)}{2}\\)</li> </ul> 05_velika_matrica.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst long long mo=1e9+7;\n\nint n,m;\nlong long mod;\nint q;\n\nlong long gcd(long long x, long long y)\n{\n    if (x&lt;0) x*=-1;\n    if (y&lt;0) y*=-1;\n    if (x==0 || y==0) return max(x,y);\n    if (x%y==0) return y;\n    return gcd(y,x%y);\n}\n\npair&lt;long long,pair&lt;int,int&gt; &gt; calc(int x, int y)\n{\n    long long tot=0;\n\n    //kratim po y\n    tot=x*(y/mod);\n    tot%=mo;\n    y%=mod;\n\n    // kratim po x\n    tot+=y*(x/mod);\n    tot%=mo;\n    x%=mod;// sada x&lt;mod &amp;&amp; y&lt;mod\n    return {tot,{x,y}};\n}\n\nlong long mul(long long n, long long x, long long k)\n{\n    long long first=k*n;\n    first%=mo;\n    first*=x;\n    first%=mo;\n\n   return first;\n}\n\nlong long sumDOWN(long long n, long long x, long long k)//sum (n+i) *(x-i) (i=0...k-1) po modulu 10^9+7\n{\n    long long ans=0;\n    long long first=mul(n,x,k);\n\n    long long p=6;\n\n    long long second=(k-1)/gcd(k-1,p);\n    p/=gcd(k-1,p);\n\n    long long third=k/gcd(k,p);\n    p/=gcd(k,p);\n\n    long long fourth=(3*n-3*x+2*k-1);\n    long long fifth=fourth;\n    fourth=fifth/gcd(fifth,p);\n    p/=gcd(fifth,p);//sada je p sigurno 1\n\n    long long sixth=mul(second,third,fourth);\n\n    ans=(first-sixth+mo)%mo;\n\n    return ans;\n}\n\nlong long sumUP(long long n, long long x, long long k) //sum (n+i)*(x+i) (i=0...k-1)  po modulu 10^9+7\n{\n    long long ans=0;\n\n    long long first= mul(n,x,k);\n\n    long long p=6;\n\n    long long second=(k-1)/gcd(k-1,p);\n    p/=gcd(k-1,p);\n\n    long long third=k/gcd(k,p);\n    p/=gcd(k,p);\n\n    long long fourth=(3*n+3*x+2*k-1);\n    long long fifth=fourth;\n    fourth=fifth/gcd(fifth,p);\n    p/=gcd(fifth,p);//sada je p sigurno 1\n\n    long long sixth=mul(second,third,fourth);\n\n    ans=(first+sixth)%mo;\n\n  return ans;\n}\n\nlong long sumLine(long long n, long long x, long long k) // sum (n+i)*x  i=0...k-1 po modulu 10^9+7\n{\n  long long ans=0;\n\n  long long first=mul(n,x,k);\n\n  long long second=k-1;\n  long long third=k;\n\n  if (second%2==0) second/=2; else third/=2;\n\n  long long fourth=mul(second,third,x);\n\n  ans=(fourth+first)%mo;\n\n  return ans;\n}\nlong long finish(int xl, int yl,int xr, int yr)\n{\n    if (xl&gt;xr || yl&gt;yr) return 0;\n    long long ans=0;\n\n    long long dx=(xr-xl)+1;\n    long long dy=(yr-yl)+1;\n    long long dz=min(dx,dy)-1;\n\n    long long currentTop=(xl+yl)%mod;\n    long long rest=mod-currentTop;\n\n    if (rest&gt;=dz)\n         ans=sumUP(currentTop,1,dz);\n     else\n     {\n        ans=sumUP(currentTop,1,rest);\n        ans+=sumUP(0,rest+1, dz-rest);\n     }\n\n    currentTop+=dz;\n    currentTop%=mod;\n    ans%=mo;\n\n    long long dp=max(dx,dy)-dz;\n    rest=mod-currentTop;\n\n    if (rest&gt;=dp)\n            ans+=sumLine(currentTop,min(dx,dy),dp);\n    else\n    {\n       ans+=sumLine(currentTop,min(dx,dy),rest);\n       ans+=sumLine(0,min(dx,dy),dp-rest);\n    }\n\n    currentTop+=dp;\n    currentTop%=mod;\n    ans%=mo;\n\n    rest=mod-currentTop;\n\n    if (rest&gt;=dz)\n         ans+=sumDOWN(currentTop,dz,dz);\n     else\n     {\n        ans+=sumDOWN(currentTop,dz,rest);\n        ans+=sumDOWN(0,dz-rest, dz-rest);\n     }\n\n    ans%=mo;\n\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d%lld\",&amp;n,&amp;m,&amp;mod);\n    scanf(\"%d\",&amp;q);\n\n    long long val=(1ll*(mod-1)*mod)/2;\n    val%=mo;\n\n    while(q--)\n    {\n        int xl,yl,xr,yr;\n        scanf(\"%d%d%d%d\",&amp;xl,&amp;yl,&amp;xr,&amp;yr);\n        long long ans=0;\n        pair&lt;long long,pair&lt;int,int&gt; &gt; rest = calc(xr-xl+1,yr-yl+1);\n        ans=(val*rest.first)%mo;\n        ans+=finish(xr-rest.second.first+1,yr-rest.second.second+1, xr, yr);\n        ans%=mo;\n        printf(\"%lld\\n\",ans);\n    }\n\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se brojevi \\(n\\), \\(m\\), \\(M\\) -- broj vrsta matrice \\(A\\), broj kolona matrice \\(A\\) i modul \\(M\\) opisan u tekstu zadatka, redom. Druga linija standardnog ulaza sadr\u017ei broj \\(q\\), broj upita na koje je potrebno odgovoriti. Narednih \\(q\\) linija sadr\u017ee po \u010detiri broja, koji predstaljaju, redom, vrstu gornjeg levog temena podmatrice, kolonu gornjeg levog temena podmatrice, vrstu donjeg desnog temena podmatrice i kolonu donjeg desnog temena podmatrice.</p>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardnom izlazu u \\(q\\) redova odgovoriti na upite opisane u tekstu zadatka, ta\u010dnije u \\(i\\)-toj liniji standardnog izlaza ispisati sumu tra\u017eene podmatrice po modulu \\(10^9+7\\) iz \\(i\\)-tog upita.</p>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#primer","title":"Primer","text":""},{"location":"takprog/2017_2018/okr/05_velika_matrica/#ulaz","title":"Ulaz","text":"<pre><code>5 4 3\n3\n1 2 4 3\n2 3 4 4\n3 3 3 3\n</code></pre>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#izlaz","title":"Izlaz","text":"<pre><code>7\n6\n0\n</code></pre>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Matrica je dimenzija \\(5 \\cdot 4\\), \\(M=3\\). Matrica izgleda:</p> <pre><code>2 0 1 2\n0 1 2 0\n1 2 0 1\n2 0 1 2\n0 1 2 0\n</code></pre> <p>U prvom upitu, gornje levo teme podmatrice ima koordinate (\\(1,2\\)), dok donje desno teme ima koordinate (\\(4,3\\)). Re\u0161enje ovog upita je: $$ (0 + 1 + 1 +2 +2 + 0 + 0 +1 ) \\ \\text{ mod } \\ (10^9+7) = 7 \\ \\text{ mod } \\ (10^9+7) = 7. $$</p> <p>U tre\u0107em upitu jedini broj se nalazi na polju (\\(3,3\\)) i on ima vrednost \\(0\\). Re\u0161enje ovog upita je \\(0 \\ \\text{ mod } \\ 10^9+7 = 0\\).</p>"},{"location":"takprog/2017_2018/okr/05_velika_matrica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n,m,M \\leq 10^9\\).</li> <li>\\(1 \\leq q \\leq 2\\cdot 10^5\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U primerima vrednim 10 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m,q \\leq 100\\).</li> <li>U primerima vrednim 10 poena va\u017ei\u0107e ograni\u010denje \\(M=2\\).</li> <li>U primerima vrednim 10 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m \\leq 1000\\).</li> <li>U primerima vrednim 30 poena va\u017ei\u0107e ograni\u010denje \\(1\\leq n,m,M \\leq 10^6\\).</li> <li>U primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/okr/06_formula/","title":"A3 - Formula","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mra\u010dnoj Komisiji ponovo ponestaje vremena! Potrebno je objaviti kona\u010dne rezultate Galakti\u010dkih kvalifikacija za takmi\u010denje iz hiperprogramiranja. Ovo takmi\u010denje se sastoji od \\(N\\) rundi, a za kona\u010dan skor svakog takmi\u010dara se uzima \\(K\\)-ta vrednost u sortiranom nizu skorova koje je ostvario na svim rundama. Na primer, ako je \\(K=1\\), kona\u010dan rezultat je najmanja od svih vrednosti.</p> <p>Me\u0111utim, Mra\u010dna Komisija i dalje koristi prastaru Inteligentnu aplikaciju za bodovanje, kod koje se za ra\u010dunanje kona\u010dnog rezultata mogu koristiti mala slova engleske abecede i dvoargumentne funkcije \\(\\min\\) i \\(\\max\\) (minimum i maksimum dva broja), koje se pi\u0161u \\((x,y)\\) i \\([x,y]\\), redom. Va\u0161 zadatak je da prona\u0111ete formulu koja ta\u010dno nalazi kona\u010dan skor za proizvoljne (ne nu\u017eno sortirane) skorove u pojedina\u010dnim rundama.  Argumenti ovih funkcija \\(x,y\\) se odvajaju zarezom i mogu biti bilo koje formule. Mogu\u0107e je proizvoljno ugnje\u017edavati formule. Rezultat \\(i\\)-te runde je ozna\u010den \\(i\\)-tim malim slovom engleskog alfabeta.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Nikola Spasi\u0107 <p>Posmatrajmo sve \\(K\\)-elementne podskupove skupa simbola \\(x_1, \\ldots, x_n\\), gde je \\(x_i\\) \\(i\\)-to slovo engleske abecede. U svakoj zameni simbola konkretnim vrednostima, svaki od ovih podskupova \u0107e imati maksimalni element. Primetimo da vrednost tog maksimalnog elementa ne mo\u017ee biti manja od \\(K\\)-te vrednosti po veli\u010dini od svih \\(N\\) vrednosti. \u0160tavi\u0161e, ta\u010dno jedan od tih podskupova \u0107e sadr\u017eati \\(K\\)-ti element po veli\u010dini od svih kao svoj maksimum, i to onaj podskup koji sadr\u017ei najmanjih \\(K\\) elemenata. Dakle, ovaj maksimum \u0107e biti ujedno i minimalni maksimum po svim \\(K\\)-elementnim podskupovima.</p> <p>Re\u0161enje je, dakle, na\u0107i maksimum za sve \\(K\\)-elementne podskupove a zatim minimum svih tih vrednosti. Izra\u010dunajmo du\u017einu formule u zavisnosti od \\(K, N\\). Postoji \\(\\binom{N}{K}\\) \\(K\\)-elementnih podskupova. Zapis maksimuma za svakog od njih \u0107e se sastojati od \\(4K-3\\) karaktera. Zatim, neophodno je izra\u010dunati minimum svih ovih vrednosti za \u0161ta je potrebno jo\u0161 \\(3(\\binom{N}{K}-1)\\) karaktera. Dakle, ukupan broj karaktera je \\((4K-3)\\binom{N}{K} + 3(\\binom{N}{K}-1)\\). Ovaj izraz se mo\u017ee uprostiti i iznosi \\(4K\\binom{N}{K} - 3\\). \"Najgori\" slu\u010daj je \\(N=12, K=6\\) ili \\(N=12, K=7\\) i tada je broj karaktera \\(22173\\), \u0161to je svakako manje od \\(30000\\).</p>"},{"location":"takprog/2017_2018/okr/06_formula/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se prirodni brojevi \\(N\\) i \\(K\\), redom, odvojeni razmakom.</p>"},{"location":"takprog/2017_2018/okr/06_formula/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedini red standardnog izlaza ispisati tra\u017eenu formulu. Ukoliko ima vi\u0161e re\u0161enja, \u0161tampati bilo koje. Ispisana formula ne sme imati vi\u0161e od 30000 karaktera i ne sme sadr\u017eati razmake niti bilo koje karaktere osim prvih \\(N\\) malih slova engleske abecede, obi\u010dnih i uglastih zagrada i zareza.</p>"},{"location":"takprog/2017_2018/okr/06_formula/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/okr/06_formula/#ulaz","title":"Ulaz","text":"<pre><code>2 2\n</code></pre>"},{"location":"takprog/2017_2018/okr/06_formula/#izlaz","title":"Izlaz","text":"<pre><code>[a,b]\n</code></pre>"},{"location":"takprog/2017_2018/okr/06_formula/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2017_2018/okr/06_formula/#ulaz_1","title":"Ulaz","text":"<pre><code>3 2\n</code></pre>"},{"location":"takprog/2017_2018/okr/06_formula/#izlaz_1","title":"Izlaz","text":"<pre><code>[[(a,b),(b,c)],(c,a)]\n</code></pre>"},{"location":"takprog/2017_2018/okr/06_formula/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru tra\u017ei se drugi, odnosno najve\u0107i skor. Jasno je da je ova vrednost upravo jednaka maksimumu skorova prve i druge runde. U drugom primeru kako god da zamenimo vrednosti simbola \\(a,b,c\\) brojevima dobi\u0107e se srednji broj po vrednosti.</p>"},{"location":"takprog/2017_2018/okr/06_formula/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 12\\).</li> <li>\\(1 \\leq K \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima koji vrede 20 poena va\u017ei \\(K=1\\) ili \\(K=N\\).</li> <li>U test primerima koji vrede 25 poena va\u017ei \\(K = 2\\).</li> <li>U test primerima koji vrede 55 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/okr/06_formula/#napomena","title":"Napomena","text":"<p>Prvih dvanaest slova engleske abecede su: <code>abcdefghijkl</code>.</p>"},{"location":"takprog/2017_2018/okr/06_formula/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Svi \\(K\\)-elementni podskupovi nekog skupa mogu se generisati rekurzivnom funkcijom ili u jeziku C++ funkcijom <code>next_permutation</code> primenjenom na niz koji se sastoji od \\(N-K\\) nula i \\(K\\) jedinica, tim redom.</p> 06_formula.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, k;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;string&gt; terms;\n    int a[20] = {0};\n\n    for (int i=n-k; i&lt;n; i++) {\n        a[i] = 1;\n    }\n\n    do {\n        string s(k-1, '[');\n\n        int j = 0;\n\n        for (int i=0; i&lt;n; i++) {\n            if (a[i]) {\n                if (!j) {\n                    j = 1;\n                    s += 'a' + i;\n                } else {\n                    s += ',';\n                    s += 'a' + i;\n                    s += ']';\n                }\n            }\n        }\n        terms.push_back(s);\n    } while (next_permutation(a, a+n));\n\n    string p(terms.size() - 1, '(');\n\n    int j = 0;\n\n    for (string q : terms) {\n        if (!j) {\n            j = 1;\n            p += q;\n        } else {\n            p += ',';\n            p += q;\n            p += ')';\n        }\n    }\n\n    cout &lt;&lt; p &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/01_pacovi/","title":"1 - Pacovi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 256MB <p>Bila jednom jedna beskona\u010dna usmerena prava linija. Ona je bila poplo\u010dana stringovima koji su svi bili isti, isto orijentisani (u istom smeru kao prava) i bili su jednaki stringu \\(A\\). Me\u0111utim, beskona\u010dno (i to neprebrojivo) mnogo pacova je napalo pravu i pojelo sve plo\u010dice, pa je sad ostala samo gola prava. Vi na raspolaganju imate beskona\u010dno (ali prebrojivo) mnogo kopija svakog od \\(M\\) vrsta stringova, kojima treba poplo\u010dati ovu pravu. Va\u0161 zadatak je poplo\u010date pravu tako da ona izgleda isto kao ranije. Obratite pa\u017enju na to da ova prava nema ni po\u010detak ni kraj niti su pozicije na pravoj indeksirane na bilo koji na\u010din (videti primere za obja\u0161njenje). Kako biste majstorima olak\u0161ali posao, va\u0161 zadatak je da napravite jednu plo\u010dicu konkatenacijom (nadovezivanjem) nekih od datih stringova, tako da se tom jednom plo\u010dicom mo\u017ee izvr\u0161iti poplo\u010davanje. Nije dozvoljeno okretati ove stringove (a ni celu plo\u010dicu) naopa\u010dke. Pomozite majstorima tako \u0161to \u0107ete im re\u0107i koliko je najmanje stringova potrebno da se napravi plo\u010dica kojom mo\u017ee da se popravi \u0161teta koju su naneli pacovi. Ukoliko ovo nije mogu\u0107e, va\u0161 odgovor treba da bude broj \\(-1\\) (omiljeni broj svakog pacova).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksa Plav\u0161i\u0107 <p>Re\u0161enje zadatka se okvirno mo\u017ee podeliti na dve faze: U prvoj, identifikujemo na kojim pozicijama se nalaze stringovi iz niza \\(B\\) u stringu \\(A\\), gde \\(A\\) posmatramo kao cikli\u010dan string. U drugoj, proveravamo koliko najmanje stringova iz \\(B\\) nam treba da bismo napravili string ekvivalentan stringu \\(A\\).</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, A[\\ldots], M, L[\\ldots], B[\\ldots][\\ldots])\\)</li> </ul> <p>koja treba da na\u0111e broj opisan u tekstu zadatka. \\(N\\) ozna\u010dava du\u017einu stringa \\(A\\) (koji je indeksiran od \\(1\\)). \\(M\\) ozna\u010dava broj stringova u nizu stringova \\(B\\). \\(L\\) je niz du\u017eine \\(M\\) gde je \\(L[i]\\) du\u017eina stringa \\(B[i]\\). \\(B\\) je niz nizova karaktera. Va\u0161a funkcija treba da vrati jedan ceo broj - odgovor na pitanje postavljeno u tekstu zadatka, ili \\(-1\\) ako formiranje plo\u010dice nije mogu\u0107e. Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#primer-1","title":"Primer 1","text":"<p>Neka je \\(A = baabaa, B = \\{a, b, c\\}\\). Mogu\u0107e je formirati plo\u010dicu \\(aba\\) pomo\u0107u dva stringa \\(a\\) i jednog stringa \\(b\\). Ovom plo\u010dicom dobija se poplo\u010davanje koje je jednako poplo\u010davanju koje se dobija stringom \\(baabaa\\):</p> <pre><code>...baabaabaabaa...\n.....abaabaabaaba...\n</code></pre> <p>Re\u0161enje ovog primera je \\(3\\), jer smo za formiranje plo\u010dice \\(aba\\) iskoristili \\(3\\) stringa.</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#primer-2","title":"Primer 2","text":"<p>Neka je \\(A = bca, B = \\{ab, bc, ca\\}\\). Mogu\u0107e je formirati plo\u010dicu \\(abcabc\\) redom pomo\u0107u stringova \\(ab, ca, bc\\). Lako se uo\u010dava da se i ovom plo\u010dicom dobija poplo\u010davanje jednako poplo\u010davanju stringom \\(bca\\):</p> <pre><code>...bcabcabcabca...\n.....abcabcabcabc...\n</code></pre>"},{"location":"takprog/2017_2018/sio/01_pacovi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N \\leq 500\\).</li> <li>\\(M \\leq 100.000\\).</li> <li>\\(1 \\leq L_i \\leq N\\).</li> <li>\\(\\sum_{i=1}^{M} L_i \\leq 1.000.000\\).</li> <li>Svi stringovi se sastoje samo od malih slova engleske abecede.</li> </ul>"},{"location":"takprog/2017_2018/sio/01_pacovi/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak \\(1\\) [\\(4\\) poena]: String \\(A\\) sadr\u017ei samo slova \\(a\\).</li> <li>Podzadatak \\(2\\) [\\(33\\) poena]: \\(N, M \\leq 100\\).</li> <li>Podzadatak \\(3\\) [\\(11\\) poena]: \\(M \\leq 1000\\).</li> <li>Podzadatak \\(4\\) [\\(52\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/sio/01_pacovi/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>pacovi.cpp</code> ili <code>pacovi.pas</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>U zavisnosti od programskog jezika koji koristite, va\u0161a funkcija mora biti slede\u0107eg oblika:</p> Jezik Deklaracija funkcije C++ <code>int Resi(int N, char* A, int M, int* L, char** B);</code> Pascal <code>function Resi(N : Longint; var A : Array of Char; M : Longint; var L : Array of Longint; var B : NizStringova) : Longint;</code> <p>Za <code>Pascal</code>, <code>NizStringova</code> je tip koji je definisan kao <code>Array of Array of Char</code>. Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \"template\" fajlovi <code>code.cpp</code> i <code>code.pas</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi <code>grader.cpp</code>, <code>grader.pas</code> koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu string \\(A\\),</li> <li>U narednom redu broj \\(M\\)</li> <li>U narednih \\(M\\) redova po jedan string, \\(B_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa njen rezultat. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#prva-faza-trazenje-stringova","title":"Prva faza - tra\u017eenje stringova","text":"<p>Jedan od efikasnijih na\u010dina da se ovo uradi jeste da se skup stringova iz \\(B\\) predstavi u obliku Trie strukture podataka. Zatim, za svaku polaznu poziciju \\(i\\) u stringu \\(A\\) kre\u0107emo se unapred nizom slova \\(A_i, A_{i+1}, \\ldots A_j\\). Ako \"izletimo\" iz stabla Trie prekidamo i nastavljamo sa narednom vredno\u0161\u0107u \\(i\\). Ina\u010de, ako se nalazimo u \u010dvoru koji odgovara nekom stringu iz \\(B\\) pamtimo da je \\(A_i, \\ldots, A_j \\in B\\). Ovaj deo radi u vremenskoj slo\u017eenosti \\(O(N^2 + \\sum L_i)\\).</p>"},{"location":"takprog/2017_2018/sio/01_pacovi/#druga-faza-nalazenje-minimalnog-broja-stringova","title":"Druga faza - nala\u017eenje minimalnog broja stringova","text":"<p>Pretpostavimo da je string \\(A\\) aperiodi\u010dan. Ukoliko nije, nalazimo njegovu najmanju periodu. Primetimo da se prava mo\u017ee poplo\u010dati na ekvivalentan na\u010din poplo\u010davanju stringom \\(A\\) ako i samo ako postoji neki niz stringova \\(S_1, S_2, \\ldots S_k\\) iz \\(B\\) koji pokrivaju pozicije \\([x_1, x_2-1], [x_2, x_3-1], \\ldots, [x_{k-1}, x_k-1]\\) gde je \\(x_k = x_1\\). Stoga, pravimo graf sa \\(N\\) \u010dvorova i stavljamo granu \\((i, j)\\) ukoliko je \\(A_i, \\ldots, A_{j-1} \\in B\\), a zatim tra\u017eimo najkra\u0107i ciklus u grafu. U slu\u010daju da \\(A\\) nije aperiodi\u010dan, u obzir dolazi svaki put koji vodi od \u010dvora \\(i\\) do \u010dvora \\(j\\) gde va\u017ei \\(d | i-j\\), gde je \\(d\\) du\u017eina najkra\u0107e periode. Nala\u017eenje najkra\u0107eg puta odnosno ciklusa u ovom grafu je najjednostavnije uraditi Flojd-Var\u0161alovim algoritmom, u svega 4 linije koda. Ovaj deo radi u vremenskoj slo\u017eenosti \\(O(N^3)\\).</p> 01_pacovi.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXNODES = 1000005;\nconst int MAXN = 505;\n\nstruct node {\n    int p[26];\n    int c;\n} d[MAXNODES];\nint z;\n\nint f[MAXN][MAXN];\n\nint Resi(int n, char* a, int m, int* l, char** b) {\n    // nadji najmanju periodu stringa i promeni n\n    a++;\n    for (int i=1; i&lt;=n; i++) {\n        if (n % i)\n            continue;\n        bool ok = true;\n        for (int j=0; j&lt;n; j++)\n            if (a[j] != a[j % i]) {\n                ok = false;\n                break;\n            }\n        if (ok) {\n            n = i;\n            break;\n        }\n    }\n\n    // napravi trie\n    for (int i=1; i&lt;=m; i++) {\n\n        int r = 0;\n\n        for (int j=1; j&lt;=l[i]; j++) {\n            int x = b[i][j] - 'a';\n\n            if (!d[r].p[x])\n                d[r].p[x] = ++z;\n\n            r = d[r].p[x];\n        }\n\n        d[r].c = 1;\n    }\n\n    memset(f, 11, sizeof(f));\n\n    // nadji grane\n    for (int i=0; i&lt;n; i++) {\n        int r = 0;\n        for (int j=0;; j++) {\n            int x = a[(i+j) % n] - 'a';\n            if (d[r].p[x])\n                r = d[r].p[x];\n            else\n                break;\n\n            if (d[r].c)\n                f[i][(i+j+1) % n] = 1;\n        }\n    }\n\n    for (int j=0; j&lt;n; j++)\n        for (int i=0; i&lt;n; i++)\n            for (int k=0; k&lt;n; k++)\n                f[i][k] = min(f[i][k], f[i][j] + f[j][k]);\n\n    int sol = 123123123;\n    for (int i=0; i&lt;n; i++)\n        sol = min(sol, f[i][i]);\n\n    if (sol &gt; n)\n        sol = -1;\n    return sol;\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/02_imanje/","title":"2 - Imanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje - - <p>Deda Vido, poljoprivrednik iz sela u okolini Novog Pazara, ve\u0107 du\u017ei niz godina odr\u017eava svoje imanje. Imanje se mo\u017ee predstaviti kao matrica dimenzija \\(N \\times M\\), gde jedno polje u matrici ozna\u010dava \\(1\\) metar kvadratni imanja. Vidovo zemlji\u0161te je malo mo\u010dvarno, tako da svako polje u matrici mo\u017ee sadr\u017eati zemlju ili vodu. Svi povezani delovi vode prave jedno jezero na imanju. Dva polja su povezana ako dele jednu stranicu u matrici. Primetimo da deda Vidovo imanje trenutno mo\u017ee sadr\u017eati vi\u0161e odvojenih jezera.</p> <p>Danas u goste dolazi njegov unuk Lale koji mnogo voli da peca. Lale je prili\u010dno nesta\u0161an i nikada se ne zadr\u017eava dugo na jednom jezeru. Kada obi\u0111e sva jezera on se ponovo vra\u0107a u grad i ostavlja svog dedu usamljenog. </p> <p>Deda Vido silno \u017eeli da zadr\u017ei unuka \u0161to du\u017ee na selu, tako da je nabavio dovoljno materijala da najvi\u0161e \\(K\\) metara kvadratnih (\\(K\\) polja matrice) promeni iz vode u zemlju. Na ovaj na\u010din on bi pregradio neka od postoje\u0107ih jezera i od jednog jezera dobio vi\u0161e njih.</p> <p>Va\u0161 je zadatak da pomognete deda Vidu da rasporedi materijal tako da maksimizuje broj dobijenih jezera.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Nikola Spasi\u0107 <p>Kao i ve\u0107ina drugih output only problema, ovaj zadatak zahteva detaljniju analizu prilo\u017eenih fajlova i testiranje razli\u010ditih re\u0161enja na datim test primerima. Re\u0161enje ne mora biti preterano vremenski i memorijski efikasno, jedino je va\u017eno da se program izvr\u0161i u nekom doglednom vremenu kako bi mogle da se testiraju i druge strategije. Osnovna ideja algoritma koji je koristila komisija je maksimizovanje broja jezera farbanjem jednog jezera (jedne povezane komponente vode) poput \u0161ahovske table. Na taj na\u010din od jednog jezera veli\u010dine \\(X\\), dobi\u0107emo otprilike \\(\\frac{X}{2}\\) jezera, sa pribli\u017eno toliko utro\u0161enog materijala. Po\u0161to je o\u010digledno da ne\u0107emo mo\u0107i da prekrijemo sva jezera na ovaj na\u010din, ne\u0107emo imati dovoljno materijala, moramo na neki na\u010din da odredimo koja jezera su najoptimalnija za prekrivanje. Za re\u0161avanje ovog podzadatka mo\u017eemo koristiti dinami\u010dko programiranje i problem ranca. Ranac bi imao ukupnu zapreminu \\(K\\), predmeti su u ovom slu\u010daju ekvivalentni jezerima, te\u017eine predmeta bi bile jednake broju polja koja moramo transformisati iz vode u zemlju da bi dobili \u0161ahovsku tablu, dok bi zara\u0111eni novac bio ekvivalentan broju jezera koja smo dobili pregra\u0111ivanjem velike komponente. Nakon biranja nekih optimalnih komponenti i njihovog farbanja, pro\u0107i\u0107emo kroz sva ofarbana jezera jo\u0161 jednom i ukloniti polja koja su vi\u0161kom promenjena. Mo\u017ee se desiti da neko polje nema potrebe pretvarati u zemlju, zato \u0161to je recimo ve\u0107 okru\u017eeno zemljom i uni\u0161tili smo jedno jezero, na taj na\u010din malo ru\u0161imo izgled \u0161ahovske table ali je jasno da broj jezera ne smanjujemo i dobijamo dodatni materijal koji mo\u017eemo iskoristiti.</p> <p>Postavlja se pitanje \u0161ta dodatno mo\u017eemo odraditi sa preostalim materijalom, koji nismo iskoristili u prvom bojenju ili smo dodatno uklonili. Naravno i njega je potrebno raspodeliti na odre\u0111ena mesta. Strategija kojom smo se vodili u ovom slu\u010daju je, pregra\u0111ivanje nekog od trenutnih jezera na dva jezera gde bi veli\u010dina drugog jezera bila \\(1 \\times 1\\). Ovde mo\u017eemo zapamtiti za svako polje vode koliko je potrebno dodavanja zemlje da bi se ono ogradilo (taj broj mo\u017ee i\u0107i od \\(1\\) do \\(4\\)). U svakom potezu \u0107emo birati jezero kome nedostaje najmanje polja da bude ogra\u0111eno(trebalo bi da se mo\u017ee lako pokazati da \u0107e uvek postojati vodeno polje kome ne\u0107e nedostajati vi\u0161e od \\(2\\) polja zemlje). </p> <p>U prilo\u017eenim materijalima imate jo\u0161 nekoliko strategija re\u0161avanja ovog problema, treba obratiti pa\u017enju na strategiju koja koristi BFS u odre\u0111ivanju optimalnog re\u0161enja. Ona je imala najbolje rezultate na nekim od primera, ali je poprili\u010dno spora i na re\u0161enje se treba \u010dekati i do \\(10\\) minuta.</p> <p>Slo\u017eenost opisanog algoritma je \\(O(k \\times BrojJezera)\\).</p>"},{"location":"takprog/2017_2018/sio/02_imanje/#napomena","title":"Napomena","text":"<p>Ovo je zadatak sa poznatim ulazom (output-only zadatak). Vama su dati ulazni fajlovi (<code>01.in</code>, <code>02.in</code>, <code>03.in</code>, <code>04.in</code>, <code>05.in</code>), dok vi treba da po\u0161aljete samo odgovaraju\u0107e izlazne fajlove za njih (<code>01.out</code>, <code>02.out</code>, <code>03.out</code>, <code>04.out</code>,  <code>05.out</code>).</p>"},{"location":"takprog/2017_2018/sio/02_imanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaznih fajlova nalaze se tri prorodna broja  \\(N\\), \\(M\\) i \\(K\\), du\u017eina imanja, \u0161irina imanja, broj metara kvadratnih koje mo\u017eemo promeniti iz vode u zemlju. U svakom od narednih \\(N\\) redova nalazi se po \\(M\\) karaktera. Svaki karakter u matrici mo\u017ee predstavljati zemlju ili vodu. Ako je karakter u preseku \\(i\\)-te vrste i \\(j\\)-te kolone <code>x</code> (bez navodnika) onda se na tom polju nalazi zemlja, u suportnom, karakter u preseku \\(i\\)-te vrste i \\(j\\)-te kolone je <code>.</code> (bez navodnika) i ozna\u010dava vodu.</p>"},{"location":"takprog/2017_2018/sio/02_imanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Svaki va\u0161 izlazni fajl treba da sadr\u017ei matricu dimenzija \\(N \\times M\\). Svako polje u matrici mo\u017ee biti <code>x</code> (zemlja), <code>.</code> (voda), <code>o</code> (polje na kome se nalazila voda i sada je promenjeno u zemlji\u0161te).</p>"},{"location":"takprog/2017_2018/sio/02_imanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2017_2018/sio/02_imanje/#ulaz","title":"Ulaz","text":"<pre><code>4 8 3\n.x...x..\n.x.x.x..\n.x...xxx\n.xxxxx..\n</code></pre>"},{"location":"takprog/2017_2018/sio/02_imanje/#izlaz","title":"Izlaz","text":"<pre><code>.x...x..\n.xoxox..\nox...xxx\n.xxxxx..\n</code></pre>"},{"location":"takprog/2017_2018/sio/02_imanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Imanje je dimenzija  \\(4 \\times 8\\). Mo\u017eemo promeniti najvi\u0161e \\(3\\) polja na kojima se nalazi voda u polja na kojima se nalazi zemlja. U po\u010detnom trenutku na imanju se nalazi \\(4\\) jezera. Promenili smo polja sa koordinatama \\((3, 1), (2, 3), (2, 5)\\). Nakon navedenog pregra\u0111ivanja na imanju se nalazi \\(6\\) jezera.</p>"},{"location":"takprog/2017_2018/sio/02_imanje/#napomena-1","title":"Napomena 1","text":"<ul> <li>Svi fajlovi moraju biti u opisanom formatu, u fajlovima se ne sme nalaziti nijedan karakter osim <code>x</code>, <code>.</code> i <code>o</code>.</li> <li>U matrici se ne sme nalaziti vi\u0161e od \\(K\\) karaktera <code>o</code>. </li> <li>Svaki karakter <code>o</code> mora nalaziti na polju gde se prethodno nalazio karakter <code>.</code>.</li> <li>Ako se na nekom polju u finalnoj matrici nalazi karakter <code>x</code> ili karakter <code>.</code>, onda se na tom polju morao nalaziti isti karakter i u po\u010detnoj matrici.</li> </ul>"},{"location":"takprog/2017_2018/sio/02_imanje/#bodovanje","title":"Bodovanje","text":"<p>Dato vam je pet ulaznih fajlova.</p> <ul> <li>Prvi primer (<code>01.in</code>) vredi \\(10\\) poena.</li> <li>Drugi primer (<code>02.in</code>) vredi \\(20\\) poena.</li> <li>Tre\u0107i primer (<code>03.in</code>) vredi \\(20\\) poena. </li> <li>\u010cetvrti primer (<code>04.in</code>) vredi \\(25\\) poena.</li> <li>Peti primer (<code>05.in</code>) vredi \\(25\\) poena.</li> </ul> <p>Va\u0161a re\u0161enja se boduju u odnosu na re\u0161enje komisije. Re\u0161enje komisije \u0107e nositi \\(100\\) poena. Za svaki procenat za koji va\u0161e re\u0161enje bude gore od komisijskog gubite \\(10\\) poena sve do \\(0\\) poena (to zna\u010di da re\u0161enja koja budu gora od komisijskog za vi\u0161e od \\(10\\)% nose \\(0\\) poena). Ako va\u0161e re\u0161enje za odre\u0111en unos bude bolje od komisijskog dobi\u0107ete \\(100\\) poena.</p> <p>Rezultati komisije redom po fajlovima, u odnosu na koje se ra\u010duna skor, su:</p> <ul> <li>Prvi fajl \\(18\\) jezera.</li> <li>Drugi fajl \\(1091\\) jezero.</li> <li>Tre\u0107i fajl \\(1009\\) jezera.</li> <li>\u010cetvrti fajl \\(14566\\) jezera.</li> <li>Peti fajl \\(46103\\) jezera.</li> </ul>"},{"location":"takprog/2017_2018/sio/02_imanje/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Prvi deo bojenja jezera poput \u0161ahovske table mo\u017eemo uraditi jednostavno kori\u0161\u0107enjem zakonitosti da sva polja na \u0161ahovskoj tabli iste boje daju ujedno i isti ostatak pri deljenju sa dva njihovih koordinata - \\((i+j) mod 2\\). Va\u017eno je probati bojenje i parnih i neparnih polja i na neki na\u010din izabrati bolju od opcija. Deo sa dinami\u010dkim programiranjem i rancem mo\u017ee biti vrlo memorijiski zahtevan, tako da se mora osmisliti pa\u017eljivo algoritam za uklanjanje jedne koordinate iz dinami\u010dke matrice. Ideja koju smo koristili je ra\u010dunanje niza parova \\(DP[i]\\), koji bi davao informaciju o maksimalnom rezultatu koji mo\u017eemo dobiti ako smo ofarbali ne vi\u0161e od \\(i\\) polja i iz kog stanja smo do\u0161li do ove pozicije. Druga vrednost nam poma\u017ee oko dalje rekonstrukcije jezera za bojenje. Za poslednji deo i farbanje jezera mo\u017ee se koristiti neka od struktura koja bi pamtila polja sa ta\u010dno \\(i\\) potrebnih ogra\u0111ivanja, koja bi mogla lako da bri\u0161e brojeve iz skupa i da ih ponovo ubacuje u drugi skup. Detanje implementacije mo\u017eete videti u prilo\u017eenim kodovima.</p> <p>Voleli bismo da \u010dujemo i va\u0161e ideje za ovaj zadatak, tako da budite slobodni i napi\u0161ite ako vas je zainteresovao.</p> 02_imanje.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n\n//ranac po sahovnicama, onda greedy ograditi one koje ima najmanje da se ograde\n// officijalno resenje komisije(tj mene :P)\n\nconst int ma=2e3+3;\n\n#define pb push_back\n\nint n,m,k;\nint a[ma][ma],ob[ma][ma];\nstring s;\nint comp;\nint b[ma][ma];\nint total,neparne;\nvector&lt;pair&lt;pair&lt;int,int&gt;, int &gt; &gt;v;\npair&lt;int,int&gt; dp[1000002],pre[1000002];\nmap&lt;pair&lt;int,int&gt;, pair&lt;int,int&gt; &gt; mp;\nint k1;\nint koji[1000002];\nset&lt;pair&lt;int,int&gt; &gt; st[10];\nint cnt[ma][ma];\nint broj[1000002];\n\nint in_range(int x, int y)\n{\n    if (x&gt;n || x&lt;=0 || y&gt;m || y&lt;=0) return 0;\n    return 1;\n}\nvoid dfs(int x, int y)\n{\n    if (a[x][y]) return;\n    ob[x][y]=comp;\n    broj[comp]++;\n    total++;\n    if ((x+y)%2) neparne++;\n    if (in_range(x-1,y) &amp;&amp; !ob[x-1][y]) dfs(x-1,y);\n    if (in_range(x+1,y) &amp;&amp; !ob[x+1][y]) dfs(x+1,y);\n    if (in_range(x,y-1) &amp;&amp; !ob[x][y-1]) dfs(x,y-1);\n    if (in_range(x,y+1) &amp;&amp; !ob[x][y+1]) dfs(x,y+1);\n    return ;\n}\nvoid ocisti()\n{\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n        {\n            a[i][j]=b[i][j];\n            ob[i][j]=0;\n        }\n\n    comp=0;\n    k=k1;\n}\n\nvoid ispisi()\n{\n    freopen(\"imanje-04.out\",\"w\",stdout);\n    for (int i=1; i&lt;=n; i++)\n    {\n        for (int j=1; j&lt;=m; j++)\n            if (a[i][j]==2) printf(\"o\");\n            else if (a[i][j]==1) printf(\"x\");\n            else\n                printf(\".\");\n        printf(\"\\n\");\n\n    }\n\n    fclose(stdout);\n}\n\nint okolo(int x, int y)\n{\n    if (x&gt;1 &amp;&amp; !a[x-1][y]) return 1;\n    if (x&lt;n &amp;&amp; !a[x+1][y]) return 1;\n    if (y&gt;1 &amp;&amp; !a[x][y-1]) return 1;\n    if (y&lt;m &amp;&amp; !a[x][y+1]) return 1;\n    return 0;\n}\nvoid update(int x, int y)\n{\n    st[cnt[x][y]].erase( {x,y});\n    cnt[x][y]++;\n    st[cnt[x][y]].insert( {x,y});\n    return;\n}\nvoid ogradi(int xi, int yi)\n{\n    if (cnt[xi][yi]==3) return;\n    a[xi][yi]=2;\n    k--;\n\n    st[cnt[xi][yi]].erase( {xi,yi});\n\n    if (!a[xi][yi-1]) update(xi,yi-1);\n    if (!a[xi][yi+1]) update(xi,yi+1);\n    if (!a[xi-1][yi]) update(xi-1,yi);\n    if (!a[xi+1][yi]) update(xi+1,yi);\n\n    return;\n}\n\nint main()\n{\n\n    freopen(\"imanje-04.in\",\"r\",stdin);\n    scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k);\n    k1=k;\n\n\n       for (int i=1; i&lt;=n; i++)\n    {\n        cin&gt;&gt;s;\n        for (int j=1; j&lt;=m; j++)\n            if (s[j-1]=='.') b[i][j]=0;\n            else\n                b[i][j]=1;\n    }\n\n    fclose(stdin);\n\n    ocisti();\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n            if (ob[i][j]==0 &amp;&amp; !a[i][j])\n            {\n                comp++;\n                total=0;\n                neparne=0;\n                dfs(i,j);\n                if (neparne&gt;0 &amp;&amp; total-neparne&gt;0)\n                {\n                    if (total-neparne&gt;neparne)\n                    {\n                        v.pb( {{total-neparne,neparne},comp});\n                        koji[comp]=1;\n                    }\n                    else\n                    {\n                        v.pb( {{neparne,total-neparne},comp});\n                    }\n                }\n            }\n\n\n    for (auto j:v)\n    {\n        for (int i=k; i&gt;0; i--)\n        {\n\n            int cmp = j.second;\n            int prepreke = j.first.second;\n            int dodaje  = j.first.first;\n            if (prepreke &gt;0 &amp;&amp; prepreke&lt;=i &amp;&amp; dp[i].first&lt;dp[i-prepreke].first+dodaje)\n            {\n                dp[i]= {dp[i-prepreke].first+dodaje,cmp};\n                mp[dp[i]]=dp[i-prepreke];\n            }\n        }\n    }\n\n\n    int x=k;\n    int count=0;\n\n    while(dp[x].second!=0)\n    {\n        for (int i=1; i&lt;=n; i++)\n            for (int j=1; j&lt;=m; j++)\n                if (dp[x].second== ob[i][j] &amp;&amp; a[i][j]==0 &amp;&amp; (i+j)%2==koji[dp[x].second])\n                {\n                    a[i][j]=2;\n                    broj[ob[i][j]]--;\n                    count++;\n                }\n\n        dp[x]=mp[dp[x]];\n\n    }\n\n    k-=count;\n\n    for (int i=1; i&lt;=n; i++)\n    {\n        a[i][0]=1;\n        a[i][m+1]=1;\n    }\n\n    for (int i=1; i&lt;=m; i++)\n    {\n        a[0][i]=1;\n        a[n+1][i]=1;\n    }\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n        {\n            broj[ob[i][j]]=0;\n            ob[i][j]=0;\n\n        }\n\n    comp=0;\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n            if (!ob[i][j] &amp;&amp; a[i][j]==0)\n            {\n                comp++;\n                dfs(i,j);\n            }\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n            if (a[i][j]==2 &amp;&amp; min(1,a[i-1][j])+min(1,a[i+1][j])+min(1,a[i][j-1])+min(1,a[i][j+1])&gt;=2)\n            {\n                a[i][j]=0;\n                broj[ob[i][j]]++;\n                k++;\n            }\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n            if (!a[i][j] &amp;&amp; broj[ob[i][j]]&gt;2)\n            {\n                st[min(1,a[i-1][j])+min(1,a[i+1][j])+min(1,a[i][j-1])+min(1,a[i][j+1])].insert( {i,j});\n                cnt[i][j]=min(1,a[i-1][j])+min(1,a[i+1][j])+min(1,a[i][j-1])+min(1,a[i][j+1]);\n            }\n\n    while(k&gt;0)\n    {\n        int p=0;\n        if (st[3].size()) p=3;\n        else if (st[2].size()) p=2;\n        else if (st[1].size()) p=1;\n\n        if (p==1 &amp;&amp; k&lt;=2) break;\n        if (p==2 &amp;&amp; k==1) break;\n        if (p)\n        {\n            pair&lt;int,int&gt; node = *st[p].begin();\n            st[p].erase(st[p].begin());\n            int xi=node.first;\n            int yi=node.second;\n\n            if (p==3)\n            {\n                if (!a[xi][yi-1] &amp;&amp; cnt[xi][yi-1]==3) continue;\n                if (!a[xi][yi+1] &amp;&amp; cnt[xi][yi+1]==3) continue;\n                if (!a[xi-1][yi] &amp;&amp; cnt[xi-1][yi]==3) continue;\n                if (!a[xi+1][yi] &amp;&amp; cnt[xi+1][yi]==3) continue;\n            }\n\n            if (!a[xi][yi-1]) ogradi(xi,yi-1);\n            if (!a[xi][yi+1]) ogradi(xi,yi+1);\n            if (!a[xi-1][yi]) ogradi(xi-1,yi);\n            if (!a[xi+1][yi]) ogradi(xi+1,yi);\n        } else\n            k--;\n    }\n\n    ispisi();\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/03_popis/","title":"3 - Popis","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 512MB <p>Ena radi u poznatom supermarketu koji je dobio ime po jednoj komutativnoj binarnoj operaciji na skupu realnih brojeva. Nedavno je supermarket obijen pa je potrebno izvr\u0161iti popis robe. Supermarket se mo\u017ee predstaviti kao matrica sa \\(N\\) redova i \\(M\\) kolona. Redovi i kolone su indeksirani od \\(1\\). U supermarketu se prodaje \\(V\\) vrsta robe, koje ozna\u010davamo brojevima od \\(1\\) do \\(V\\). Ena je dobila zadatak da tokom nekih od narednih \\(Q\\) dana popi\u0161e neku pravougaonu podmatricu. Njoj je \u0161ef dao spisak \\(B\\) od \\(V\\) brojeva, gde \\(B_i\\) ozna\u010dava da artikal pod rednim brojem \\(i\\) treba u podmatrici da se na\u0111e ta\u010dno \\(B_i\\) puta. Enin zadatak je da za neku podmatricu odredi koliko vrsta artikala postoji tako da se taj artikal nalazi u toj podmatrici ta\u010dno \\(B_i\\) puta, odnosno, koliko razli\u010ditih vrednosti \\(i\\) postoji tako da se broj \\(i\\) pojavljuje ta\u010dno \\(B_i\\) puta u podmatrici. Me\u0111utim, tu nije kraj Eninim mukama! Zli duhovi s vremena na vreme vade artikle sa nekih mesta u matrici i stavljaju neke druge artikle (tokom tih dana Ena ne mora da popisuje robu). Ena ima puno obaveza pa je ovaj zadatak poverila vama.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Dragan Uro\u0161evi\u0107 Ivan Sto\u0161i\u0107 i Aleksa Plav\u0161i\u0107 <p>Razmislimo prvo kako bismo re\u0161ili zadatak u slu\u010daju da nije data matrica ve\u0107 niz vrednosti i da nema izmena niza, pa \u0107emo ovo re\u0161enje uop\u0161titi. Jasno je da se name\u0107e Mo-ov algoritam kao potencijalno re\u0161enje. Vrlo jednostavno mo\u017eemo odr\u017eavati za svako \\(i, 1 \\leq i \\leq V\\) broj \\(C_i\\) - koliko puta se vrednost \\(i\\) javlja u trenutnom prozoru i tako\u0111e za koliko razli\u010ditih vrednosti \\(i\\) va\u017ei da su jednake \\(C_i, B_i\\), neka je taj broj \\(Z\\). U \\(1\\)-dimenzionoj varijanti vremenska slo\u017eenost bi bila \\(O(N \\sqrt{N} + Q)\\).</p>"},{"location":"takprog/2017_2018/sio/03_popis/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, M, Q, V, A[\\ldots][\\ldots], B[\\ldots], X1[\\ldots], Y1[\\ldots], X2[\\ldots], Y2[\\ldots], O[\\ldots])\\)</li> </ul> <p>koja treba da obradi sve upite i da smesti re\u0161enja upita u niz \\(O\\). Matrica \\(A\\) sadr\u017ei brojeve od \\(1\\) do \\(V\\) i opisuje po\u010detno stanje supermarketa. Nizovi \\(X1, Y1, X2, Y2\\) opisuju upite. Ukoliko je \\(Y2[i] = -1\\), tog dana je zli duh u\u0161ao u supermarket i promenio artikal na poziciji \\((X1[i], Y1[i])\\) u artikal sa rednim brojem \\(X2[i]\\). U suprotnom, ako je \\(Y2[i] \\neq -1\\), tog dana Ena treba da popi\u0161e robu. Ako postoji \\(T\\) upita koji ozna\u010davaju da se roba popisuje, odgovore na ove upite upi\u0161ite u istom redosledu u niz \\(O\\) na pozicijama od \\(1\\) do \\(T\\). Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2017_2018/sio/03_popis/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N = 3, M = 4, Q = 3, V = 4\\), niz \\(B = [1, 2, 3, 4]\\), a matrica \\(A\\) je: <pre><code>1 2 3 2\n2 3 1 3\n3 1 1 4\n</code></pre></p> <p>Prvog dana, Ena treba da popi\u0161e podmatricu od polja \\((1,2)\\) do polja \\((3,4)\\), odnosno, podmatricu koja se sastoji od poslednje tri kolone. Ena vidi da se artikal \\(1\\) nalazi tri puta, artikal \\(2\\) se nalazi dva puta, artikal \\(3\\) se nalazi \\(3\\) puta i artikal \\(4\\) se nalazi jednom u ovoj podmatrici. Od svih njih artikli \\(2, 3\\) se nalaze ispravan broj puta - artikal \\(2\\) treba da se javi \\(B_2 = 2\\) puta, a artikal \\(3\\) treba \\(B_3 = 3\\) puta, pa je odgovor \\(2\\). Drugog dana, zli duh menja artikal u donjem desnom uglu matrice u artikal \\(2\\), pa \u0107e slede\u0107eg dana samo jedan artikal (sa rednim brojem \\(3\\)) da se na\u0111e ispravan broj puta.</p>"},{"location":"takprog/2017_2018/sio/03_popis/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N, M \\leq 840\\).</li> <li>\\(Q \\leq 10000\\).</li> <li>\\(V \\leq 100000\\).</li> <li>\\(1 \\leq A_{i, j} \\leq V\\).</li> <li>\\(0 \\leq B_i \\leq N \\cdot M\\).</li> <li>U upitima kod kojih je \\(Y_2 = -1\\) va\u017ei \\(1 \\leq X_1 \\leq N, 1 \\leq Y_1 \\leq M, 1 \\leq X_2 \\leq V\\).</li> <li>U ostalim upitima va\u017ei \\(1 \\leq X_1 \\leq X_2 \\leq N, 1 \\leq Y_1 \\leq Y_2 \\leq M\\).</li> </ul>"},{"location":"takprog/2017_2018/sio/03_popis/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak \\(1\\) [\\(7\\) poena]: \\(N, M, Q, V \\leq 100\\).</li> <li>Podzadatak \\(2\\) [\\(12\\) poena]: \\(V \\leq 100\\), nema zlih duhova.</li> <li>Podzadatak \\(3\\) [\\(15\\) poena]: \\(V \\leq 50\\).</li> <li>Podzadatak \\(4\\) [\\(17\\) poena]: \\(Q \\leq 400\\).</li> <li>Podzadatak \\(5\\) [\\(21\\) poen]: \\(N, M \\leq 400\\).</li> <li>Podzadatak \\(6\\) [\\(28\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/sio/03_popis/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>popis.cpp</code> ili <code>popis.pas</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>U zavisnosti od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> Jezik Deklaracija funkcije C++ <code>void Resi(int N, int M, int Q, int V, int** A, int* B, int* X1, int* Y1, int* X2, int* Y2, int* O);</code> Pascal <code>procedure Resi(N, M, Q, V : Longint; var A : Matrica; var B, X1, Y1, X2, Y2, O : Array of Longint);</code> <p>Za <code>Pascal</code>, <code>Matrica</code> je tip koji je definisan kao <code>Array[1..1000, 1..1000] of Longint</code>. Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p>"},{"location":"takprog/2017_2018/sio/03_popis/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \"template\" fajlovi <code>code.cpp</code> i <code>code.pas</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi <code>grader.cpp</code>, <code>grader.pas</code> koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, M, Q, V\\),</li> <li>U narednih \\(N\\) redova po \\(M\\) brojeva, elemente matrice \\(A\\),</li> <li>U narednom redu \\(V\\) brojeva, elemente niza \\(B\\),</li> <li>U narednih \\(Q\\) redova 4 ili 5 brojeva:</li> <li> <ul> <li>Prvi broj je tip upita (1 - popis, 2 - zli duh)</li> </ul> </li> <li> <ul> <li>U slu\u010daju popisa preostala 4 broja su \\(X1, Y1, X2, Y2\\).</li> </ul> </li> <li> <ul> <li>U slu\u010daju zlog duha 3 broja, \\(X, Y, Z\\), \\((X, Y)\\) je pozicija u matrici a \\(Z\\) je nova vrednost.</li> </ul> </li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa brojeve \\(O[1], \\ldots, O[T]\\), svaki u posebnom redu, gde je \\(T\\) broj \"popis\" upita. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2017_2018/sio/03_popis/#generalizacija-u-vise-dimenzija-i-izmene","title":"Generalizacija u vi\u0161e dimenzija i izmene","text":"<p>Posmatrajmo 5-dimenzioni prostor, gde 4 dimenzije odgovaraju pozicijama \\((x_1, y_1, x_2, y_2)\\) prozora dok poslednja dimenzija odgovara rednom broju upita. Posmatrajmo koliko nam elementarnih koraka treba da od ta\u010dke \\((x_1, y_1, x_2, y_2, t)\\) do\u0111emo do ta\u010dke \\((x_1', y_1', x_2', y_2', t')\\). Kroz prostorne dimenzije se kre\u0107emo tako \u0161to pove\u0107avamo ili smanjujemo vrednosti \\(x_1, y_1, x_2, y_2\\). Da bismo jednu od njih promenili za ta\u010dno jedan, treba nam onoliko vremena kolika je \u0161irina prozora u drugoj dimenziji (toliko vrednosti biva uba\u010deno tj. izba\u010deno). Kretanje kroz vreme je jednostavnije, ukoliko je pozicija prozora fiksna, samo posmatramo da li vrednost koja se menja u trenutku \\(t\\) upada u prozor. Ako ne upada, samo je promenimo u matrici a ako upada dodatno a\u017euriramo vrednosti \\(C_i, Z\\). Sada, izdelimo ceo ovaj prostor na blokove, koji u prostornoj dimenziji imaju \u0161irinu \\(\\frac{D}{N}\\) a u vremenskoj \\(D\\). Unutar jednog bloka mogu\u0107e je do\u0107i od bilo koje do bilo koje druge ta\u010dke u ne vi\u0161e od \\(5D\\) elementarnih koraka. Od jednog bloka do susednog bloka mogu\u0107e je do\u0107i u \\(D\\) elementarnih koraka. Najzad, rasporedimo upite u blokove i re\u0161avamo upite iz jednog bloka, pa iz nekog od susednih blokova, i tako dalje. Ukupan broj elementarnih koraka potreban da se re\u0161e svi upiti je ne ve\u0107i od \\(DW + 5DQ\\), gde je \\(W = \\frac{N^4Q}{(\\frac{D}{N})^4 D} = \\frac{N^8Q}{D^5}\\) broj blokova. Sada, na\u0111imo najbolju veli\u010dinu bloka. Ovo se mo\u017ee uraditi prostim isprobavanjem razli\u010ditih vrednosti \\(D\\) ali se dobra procena mo\u017ee na\u0107i matemati\u010dki. Na\u0111imo izvod izraza \\(DW + 5DQ\\) po \\(D\\). On iznosi \\(5Q - \\frac{4N^8 Q}{D^5}\\). Ako ga izjedna\u010dimo sa nulom i re\u0161imo po \\(D\\), dobi\u0107emo vrednost koja minimizuje vreme izvr\u0161enja. Rezultat je \\(D \\approx 0.956 N^\\frac{8}{5}\\), odnosno, za \\(N=840, D \\approx 45600\\). Po\u0161to je \\(Q \\leq 10000\\) ovo zna\u010di da ne moramo da delimo u blokove po vremenskoj dimenziji, dok u prostornoj delimo na blokove \u0161irine \\(\\approx 54\\), najbli\u017ei delilac broja \\(840\\) je \\(56\\). Vremenska slo\u017eenost re\u0161enja je \\(O(Q N^\\frac{8}{5})\\).</p> 03_popis.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 840;\nconst int MAXQ = 10000;\nconst int MAXV = 100000;\n\nconst int PRAVOUGAONIK = 1;\nconst int IZMENA = 2;\n\nconst int D = 60; // velicina bloka\nconst int K = 14;\n\nint n, m, q, v;\n\nint a[MAXN][MAXN];\nint a_orig[MAXN][MAXN];\n\nint b[MAXV];\n\nstruct upit {\n    int t, x1, y1, x2, y2, val, old;\n};\n\n// Mo prerequisites\n\nint mo;\n\ninline void add(int vr) {\n    if (!b[vr]) {\n        mo--;\n    }\n    b[vr]--;\n    if (!b[vr]) {\n        mo++;\n    }\n}\n\ninline void rem(int vr) {\n    if (!b[vr]) {\n        mo--;\n    }\n    b[vr]++;\n    if (!b[vr]) {\n        mo++;\n    }\n}\n\n// Mo tracker\n\nint xl=0, xr=-1, yl=0, yr=-1, t=-1;\n\nupit u[MAXQ];\n\nvoid adjust_t(int tt) {\n    while (t &lt; tt) {\n        // vidi sta se desava u t+1\n        t++;\n        if (u[t].t == PRAVOUGAONIK)\n            continue;\n\n        if (xl &lt;= u[t].x1 &amp;&amp; u[t].x1 &lt;= xr &amp;&amp;\n            yl &lt;= u[t].y1 &amp;&amp; u[t].y1 &lt;= yr)\n        {\n            rem(u[t].old);\n            add(u[t].val);\n        }\n\n        a[u[t].x1][u[t].y1] = u[t].val;\n    }\n\n    while (t &gt; tt) {\n\n        if (u[t].t == PRAVOUGAONIK) {\n            t--;\n            continue;\n        }\n\n        if (xl &lt;= u[t].x1 &amp;&amp; u[t].x1 &lt;= xr &amp;&amp;\n            yl &lt;= u[t].y1 &amp;&amp; u[t].y1 &lt;= yr)\n        {\n            add(u[t].old);\n            rem(u[t].val);\n        }\n\n        a[u[t].x1][u[t].y1] = u[t].old;\n        t--;\n    }\n}\n\nvoid adjust_x(int lt, int rt) {\n    while (xl &gt; lt) {\n        xl--;\n        for (int j=yl; j&lt;=yr; j++) {\n            add(a[xl][j]);\n        }\n    }\n    while (xr &lt; rt) {\n        xr++;\n        for (int j=yl; j&lt;=yr; j++) {\n            add(a[xr][j]);\n        }\n    }\n    while (xl &lt; lt) {\n        for (int j=yl; j&lt;=yr; j++) {\n            rem(a[xl][j]);\n        }\n        xl++;\n    }\n    while (xr &gt; rt) {\n        for (int j=yl; j&lt;=yr; j++) {\n            rem(a[xr][j]);\n        }\n        xr--;\n    }\n}\n\nvoid adjust_y(int lt, int rt) {\n    while (yl &gt; lt) {\n        yl--;\n        for (int j=xl; j&lt;=xr; j++) {\n            add(a[j][yl]);\n        }\n    }\n    while (yr &lt; rt) {\n        yr++;\n        for (int j=xl; j&lt;=xr; j++) {\n            add(a[j][yr]);\n        }\n    }\n    while (yl &lt; lt) {\n        for (int j=xl; j&lt;=xr; j++) {\n            rem(a[j][yl]);\n        }\n        yl++;\n    }\n    while (yr &gt; rt) {\n        for (int j=xl; j&lt;=xr; j++) {\n            rem(a[j][yr]);\n        }\n        yr--;\n    }\n}\n\nint seqn(int i) {\n    int sz[5] = {K*K*K*K, K*K*K, K*K, K, 1};\n    int h[5] = {0, K, K, K, K};\n    int a[5] = {\n        i / (MAXN * D),\n        u[i].x1 / D,\n        u[i].y1 / D,\n        u[i].x2 / D,\n        u[i].y2 / D\n    };\n\n    int x = 0;\n    for (int i=0; i&lt;5; i++) {\n        if (a[i] % 2) {\n            for (int j=i+1; j&lt;5; j++) {\n                a[j] = h[j] - 1 - a[j];\n            }\n        }\n        x += a[i] * sz[i];\n    }\n\n    return x;\n}\n\nbool cmprbupit(int i, int j) {\n    return seqn(i) &lt; seqn(j);\n}\n\nvoid Resi(int n, int m, int q, int v, int** a, int* b,\n    int* x1, int* y1, int* x2, int* y2, int* o)\n{\n    // ucitavanje\n    ::n = n;\n    ::m = m;\n    ::q = q;\n    ::v = v;\n\n    for (int i=1; i&lt;=v; i++) {\n        mo += !b[i];\n        ::b[i-1] = b[i];\n    }\n\n    for (int i=1; i&lt;=n; i++)\n        for (int j=1; j&lt;=m; j++)\n            ::a[i-1][j-1] = a_orig[i-1][j-1] = a[i][j] - 1;\n\n    for (int i=1; i&lt;=q; i++) {\n        if (y2[i] != -1) {\n            u[i-1] = {PRAVOUGAONIK, x1[i]-1, y1[i]-1, x2[i]-1, y2[i]-1,      -1, -1};\n        } else {\n            u[i-1] = {      IZMENA, x1[i]-1, y1[i]-1,      -1,      -1, x2[i]-1, -1};\n        }\n    }\n\n    // vidi za svaku izmenu koja vrednost je bila pre izmene\n    for (int i=0; i&lt;q; i++) {\n        if (u[i].t == IZMENA) {\n            u[i].old = ::a[u[i].x1][u[i].y1];\n            ::a[u[i].x1][u[i].y1] = u[i].val;\n        }\n    }\n\n    // vrati na vreme 0\n    memcpy(::a, a_orig, sizeof(::a));\n\n    // sortiraj i resi\n    vector&lt;int&gt; qs;\n    for (int i=0; i&lt;q; i++)\n        if (u[i].t == PRAVOUGAONIK)\n            qs.push_back(i);\n\n    sort(qs.begin(), qs.end(), cmprbupit);\n\n    for (int i : qs) {\n        adjust_x(u[i].x1, u[i].x2);\n        adjust_y(u[i].y1, u[i].y2);\n        adjust_t(i);\n        u[i].val = mo;\n    }\n\n    int outv = 0;\n    for (int i=0; i&lt;q; i++) {\n        if (u[i].t == PRAVOUGAONIK) {\n            o[++outv] = u[i].val;\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/04_bombonice/","title":"4 - Bombonice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 512MB <p>Mala Duca mnogo voli da jede bombonice. Ona je od svoje mame dobila beskona\u010dno bombonica i sada \u017eeli da ih rasporedi u kutije. Uzela je \\(N\\) praznih kutija, napisala na njima brojeve od \\(1\\) do \\(N\\), i postavila ih redom u krug oko sebe. Kutiji sa rednim brojem \\(N\\) susedne kutije su sa rednim brojevima \\(N-1\\) i \\(1\\). </p> <p>Sada \u0107e stavljati bombonice u kutije na slede\u0107i na\u010din: Izabra\u0107e dva broja, \\(P\\) i \\(K\\), i onda \u0107e u kutiju broj \\(P\\) dodati ta\u010dno \\(K^2\\) bombinca (zato \u0161to voli brojeve koji su potpuni kvadrati), zatim \u0107e u slede\u0107u kutiju redom u krugu dodati \\((K-1)^2\\) bombonica, zatim u slede\u0107u \\((K-2)^2\\), itd. redom dok ne pro\u0111e \\(K\\) kutija i u poslednju stavi jednu (\\(1^2\\)) bombonicu.  Ovakav postupak, po\u010dev od ponovnog izbora novih brojeva \\(P\\) i \\(K\\), \u0107e potencijalno ponavljati vi\u0161e puta, sve dok joj ne dosadi.</p> <p>Duca \u017eeli da odr\u017eava odre\u0111eni balans bombonica u nekim kutijama, tako da \u0107e se povremeno zapitati koliko je ukupno bombonica ubacila u nekih \\(T\\) uzastopnih kutija, po\u010dev od kutije broj \\(X\\). Kako to mo\u017ee biti jako veliki broj za ra\u010dunanje, moli vas za pomo\u0107 da joj svaki put odgovorite na ovakvo pitanje, i za uzvrat \u0107e vam dati nekoliko bombonica. Ukoliko svi odgovori budu ta\u010dni, pomo\u0107i \u0107e vam i da osvojite neki poen na takmi\u010denju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksa Plav\u0161i\u0107 <p>Lako se zaklju\u010duje da se pri dodavanju bombonica, one dodaju u kutije \\(P, P+1, P+2, ..., P+K-1\\). Za nijansu je jednostavniji slu\u010daja kada je  \\(P+K-1\\leq N\\). Ako uvedemo o\u0455naku \\(R=P+K\\), onda \u0107e u kutiju broj \\(I\\) (\\(P\\leq I\\leq P+K-1=R-1\\)) biti dodato \\((R-I)^2\\) bombonica, Ako uzmemo u obzir da je \\((R-I)^2 = R^2 - 2R\\times I + I^2\\), to broj dodatih kuglica mo\u017eemo ba\u0161 posmatrati kao tri zasebna sabirka (koji \u0107e formirati tokom trajanja tri zasebna zbira). Da bi efikasno mogli da efikasno a\u017euriramo zbirove (po pojedina\u010dnim kutijama) i efikasno odre\u0111uejmo zbirove blokova uzastopnih kutija, formiramo tri segmentna stabla. Jedno koje zbraja fiksni sabirak u operaciji dodavanja (\\(R^2\\)), drugo koje broji koliko smo puta sadr\u017eaj \\(I\\)-te kutije uve\u0107ali za \\(I\\) (u gornjem primeru to je \\(-2R\\)) i tre\u0107e koje broji koliko smo puta sadr\u017eaj \\(I\\)-te kutuje uve\u0107ali za \\(I^2\\) (u gornjem primeru to je \\(1\\)). Ako ta segemntna stabla formiramo na taj na\u010din, onda \u0107emo kasnije mo\u0107i efikasno da prebrojimo ukupan broj bombonica u blokovima uzastopnih kutija. </p> <p>Ako je  \\(P+K-1&gt; N\\), onda dodavanje bombonica razdvajamo u dva dodavanja: u prvom dodavanju je \\(P1=P\\) \\(K1=N-P+1\\), a u drugom je \\(P2 = 1\\) i \\(K2=K-K1\\).</p> <p>Sli\u010dno se prebrajanje bombonica razdvaja na dva slu\u010daja. Ako je \\(X+T-1\\leq N\\), onda je dovoljan jedno sabiranje po segmentnom stablu za blok (interval) \\(X,X+T-1]\\). Ako je \\(X+T-1.&gt;N\\), onda su potrebna dva upita/zbira: \u0455a intervale \\(X, N]\\) i \\([1,T-(N+1-X)]\\).</p> 04_bombonice.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 3555333\n#define mmod 1000000007\n\nint n;\nlong long bombonice[MAXN];\n\nint bigrand() {\n    return (rand() &lt;&lt; 15) | (rand());\n}\n\nvoid fmod(long long &amp;x) {\n    if (x&gt;=mmod) x%=mmod;\n    if (x&lt;0) x = ((x%mmod) + mmod) % mmod;\n}\n\nvoid PocetakBF(int N) {\n    n = N;\n    for(int i=0; i&lt;=N; i++) bombonice[i] = 0;\n}\n\nvoid DodajBomboniceBF(int P, int K) {\n    for(long long k = K; k&gt;0; k--) {\n        bombonice[P] += k*k;\n        fmod(bombonice[P]);\n        P++;\n        if (P&gt;n) P=1;\n    }\n}\n\nint PrebrojiBF(int X, int T) {\n    long long s = 0;\n    for(int i=0; i&lt;T; i++) {\n        s += bombonice[X];\n        fmod(s);\n        X++;\n        if (X&gt;n) X=1;\n    }\n    return s;\n}\n\nlong long sum[MAXN], lazy0[MAXN], lazy1[MAXN], lazy2[MAXN];\nlong long part_sum0[MAXN], part_sum1[MAXN], part_sum2[MAXN];\n\nvoid Pocetak(int N) {\n    n = N;\n\n    part_sum0[0] = 0;\n    part_sum1[0] = 0;\n    part_sum2[0] = 0;\n    for(long long i=1; i&lt;=N; i++) {\n        part_sum0[i] = part_sum0[i-1] + 1;   fmod(part_sum0[i]);\n        part_sum1[i] = part_sum1[i-1] + i;   fmod(part_sum1[i]);\n        part_sum2[i] = part_sum2[i-1] + i*i; fmod(part_sum2[i]);\n    }\n\n    int m = min(MAXN,5*N);\n    for(long long i=0; i&lt;m; i++) {\n        sum[i] = 0;\n        lazy0[i] = 0;\n        lazy1[i] = 0;\n        lazy2[i] = 0;\n    }\n}\n\nlong long lazypartsum(int l, int r, long long s2, long long s1, long long s0) {\n    long long s = 0;\n    fmod(s2); fmod(s1); fmod(s0);\n    s += s2*(part_sum2[r] - part_sum2[l-1]); fmod(s);\n    s += s1*(part_sum1[r] - part_sum1[l-1]); fmod(s);\n    s += s0*(part_sum0[r] - part_sum0[l-1]); fmod(s);\n    return s;\n}\n\nvoid addseg(int x, int l, int r, int L, int R, long long s2, long long s1, long long s0) {\n\n    if (r &lt; L) return;\n    if (l &gt; R) return;\n\n    if (l &gt;= L &amp;&amp; r &lt;= R) {\n\n        lazy2[x] += s2; fmod(lazy2[x]);\n        lazy1[x] += s1; fmod(lazy1[x]);\n        lazy0[x] += s0; fmod(lazy0[x]);\n\n        sum[x] += lazypartsum(l,r,s2,s1,s0); fmod(sum[x]);\n\n        /*sum[x] += s2*(part_sum2[r] - part_sum2[l-1]); fmod(sum[x]);\n        sum[x] += s1*(part_sum1[r] - part_sum1[l-1]); fmod(sum[x]);\n        sum[x] += s0*(part_sum0[r] - part_sum0[l-1]); fmod(sum[x]);*/\n\n        //printf(\"add %d %d %d (%d %d)   %lld %lld %lld    -&gt; %lld\\n\", x,l,r,L,R,s2,s1,s0,sum[x]);\n\n    } else {\n        int m = (l+r)/2;\n        addseg(x*2,l,m, L,R, s2,s1,s0);\n        addseg(x*2+1,m+1,r, L,R, s2,s1,s0);\n        sum[x] = sum[x*2] + sum[x*2+1];\n        fmod(sum[x]);\n        sum[x] += lazypartsum(l,r,lazy2[x],lazy1[x],lazy0[x]);\n        fmod(sum[x]);\n        //printf(\"trsum %d (%d %d) -&gt; %lld\\n\", x,l,r, sum[x]);\n    }\n}\n\nlong long sumseg(int x, int l, int r, int L, int R, long long s2, long long s1, long long s0) {\n\n    if (r &lt; L) return 0;\n    if (l &gt; R) return 0;\n\n    if (l &gt;= L &amp;&amp; r &lt;= R) {\n\n        long long res = sum[x] + lazypartsum(l,r,s2,s1,s0);\n        fmod(res);\n\n        /*res += s2*(part_sum2[r] - part_sum2[l-1]); fmod(res);\n        res += s1*(part_sum1[r] - part_sum1[l-1]); fmod(res);\n        res += s0*(part_sum0[r] - part_sum0[l-1]); fmod(res);*/\n\n        return res;\n\n    } else {\n\n        int m = (l+r)/2;\n        long long res = sumseg(x*2,l,m, L,R, s2+lazy2[x],s1+lazy1[x],s0+lazy0[x]);\n        res += sumseg(x*2+1,m+1,r, L,R, s2+lazy2[x],s1+lazy1[x],s0+lazy0[x]);\n        fmod(res);\n\n        return res;\n    }\n}\n\nvoid DodajBombonice(int P, int K) {\n    if (P+K-1 &gt; n) {\n        long long R = P+K;\n        addseg(1,1,n, P,n, 1, -2LL*R,R*R);\n\n        DodajBombonice(1, K-(n-P+1));\n    } else {\n        long long R = P+K;\n        addseg(1,1,n, P,R-1, 1,-2LL*R,R*R);\n    }\n}\n\nint Prebroji(int X, int T) {\n    if (X+T-1 &gt; n) {\n        long long sum = Prebroji(X, n-X+1);\n        sum += Prebroji(1, T-(n-X+1));\n        fmod(sum);\n        return sum;\n    } else {\n        long long sum = sumseg(1,1,n, X,X+T-1, 0,0,0);\n        return sum;\n    }\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/04_bombonice/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate slede\u0107e funkcije:</p> <ul> <li>\\(Pocetak(N)\\)</li> </ul> <p>koja se poziva ta\u010dno jednom na po\u010detku izvr\u0161avanja programa, i saop\u0161tava da Duca ima \\(N\\) kutija postavljenih u krug.</p> <ul> <li>\\(DodajBombonice(P,K)\\)</li> </ul> <p>koja ozna\u010dava da Duca dodaje bombonice u \\(K\\) kutija, po\u010dev od kutije broj \\(P\\), na na\u010din koji je opisan u zadatku.</p> <ul> <li>\\(Prebroji(X,T)\\)</li> </ul> <p>koja treba da vrati koliko se trenutno ukupno bombonica nalazi u \\(T\\) uzastpnih kutija, po\u010dev od kutije broj \\(X\\). Po\u0161to ovaj broj mo\u017ee biti veliki, vratiti ostatak pri deljenju broja bombonica sa \\(10^9 + 7 = 1000000007\\).</p>"},{"location":"takprog/2017_2018/sio/04_bombonice/#primer-1","title":"Primer 1","text":"Pozivi funkcija Obja\u0161njenje Pocetak(7) Imamo 7 kutija koje su na po\u010detku prazne. Broj bombonica u njima mo\u017eemo predstaviti kao niz indeksiran od 1:  [0,0,0,0,0,0,0] DodajBombonice(2,3) Dodajemo \\(9=3^2\\) bombonica u drugu kutiju, \\(4=2^2\\) bombonica u tre\u0107u kutiju i \\(1=1^2\\) bombonicu u \u010detvrtu kutiju. Sada je stanje: [0,9,4,1,0,0,0] DodajBombonice(4,2) Dodajemo \\(4\\) bombonice u \u010detvrtu i \\(1\\) bombonicu u petu kutiju. Trenutno stanje: [0,9,4,5,1,0,0] DodajBombonice(5,4) Dodajemo \\(16\\) bombonica u petu, zatim \\(9\\) u \u0161estu, \\(4\\) u sedmu, i \\(1\\) u prvu kutiju. Trenutno stanje: [1,9,4,5,17,9,4] Prebroji(1,5) Brojimo koliko ima bombonica u 5 uzastopnih kutija po\u010dev od prve. [1,9,4,5,17,9,4] Ovaj poziv funkcije treba da vrati rezultat 36. Prebroji(5,1) Brojimo koliko ima bombonica u 1 uzastopnoj kutiji po\u010dev od pete. [1,9,4,5,17,9,4] Ovaj poziv funkcije treba da vrati rezultat 17. DodajBombonice(7,2) Dodajemo \\(4\\) bombonice u sedmu i \\(1\\) bombonicu u prvu kutiju. Dobijamo stanje: [2,9,4,5,17,9,8] Prebroji(6,4) Brojimo koliko ima bombonica u \\(3\\) uzastopne kutije po\u010dev od \u0161este. [2,9,4,5,17,9,8]Ovaj poziv funkcije treba da vrati rezultat 28."},{"location":"takprog/2017_2018/sio/04_bombonice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Neka je \\(Q\\) ukupan broj poziva funkcija \\(DodajBombonice\\) i \\(Prebroji\\).</li> <li>\\(1 \\leq N, Q \\leq 250000\\)</li> <li>\\(1 \\leq P,K,X,T \\leq N\\)</li> </ul>"},{"location":"takprog/2017_2018/sio/04_bombonice/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [11 poena]: \\(N, Q \\leq 1000\\).</li> <li>Podzadatak 2 [18 poena]: \\(K \\leq 3\\).</li> <li>Podzadatak 3 [19 poena]: \\(T \\leq 3\\).</li> <li>Podzadatak 4 [20 poena]: Prvo \u0107e se izvr\u0161avati samo pozivi funkcije \\(DodajBombonice\\), potom nakon njih samo pozivi funkcije \\(Prebroji\\)</li> <li>Podzadatak 5 [32 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/sio/04_bombonice/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>bombonice.cpp</code> ili <code>bombonice.pas</code>, koji implementira pomenute funkcije. Osim tra\u017eenih funkcija, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>U zavisnosti od programskog jezika koji koristite, va\u0161e funkcije/procedure moraju biti slede\u0107eg oblika:</p> Jezik Deklaracija funkcije C++ <code>void Pocetak(int N);</code> <code>void DodajBombonice(int P, int K);</code> <code>int Prebroji(int X, int T);</code> Pascal <code>procedure Pocetak(N: longint);</code> <code>procedure DodajBombonice(P,K : longint);</code> <code>function Prebroji(N,T : longint) : longint;</code>"},{"location":"takprog/2017_2018/sio/04_bombonice/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \"template\" fajlovi <code>code.cpp</code> i <code>code.pas</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi <code>grader.cpp</code>, <code>grader.pas</code> koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu u\u010ditava brojeve \\(N\\) i \\(Q\\)</li> <li>Poziva funkciju \\(Pocetak(N)\\)</li> <li>U narednih \\(Q\\) redova \u010dita po 3 broja</li> <li> <ul> <li>Prvi broj je tip upita (1 - dodavanje bombonica, 2 - prebrojavanje)</li> </ul> </li> <li> <ul> <li>U prvom slu\u010daju, preostala dva broja su \\(P\\) i \\(K\\), i poziva se funkcija \\(DodajBombonice(P,K)\\)</li> </ul> </li> <li> <ul> <li>U drugom slu\u010daju, preostala dva broja su \\(X\\) i \\(T\\), i poziva se funkcija \\(Prebroji(X,T)\\), i ispisuje se njen rezultat, svaki u posebnom redu.</li> </ul> </li> </ul> <p>Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2017_2018/sio/05_vocnjak/","title":"5 - Vo\u0107njak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Petar ima ogroman vo\u0107njak \u0161ljiva koji je idealno organizovao tako da su \u0161ljive pore\u0111ane u \\(N\\) redova (vrsta) i \\(N\\) kolona. Visine svih stabala su pozitivni celi brojevi. Ne postoje dva stabla iste visine. Pri tome je stabla tako oblikovao tako da za svaku vrstu va\u017ei da visine stabala sleva nadesno obrazuju rastu\u0107i ili opadaju\u0107i niz (mogu postojati vrste pore\u0111ane u rastu\u0107em, ali isto tako i vrste pore\u0111ane u opadaju\u0107em poretku, na potpuno slu\u010dajan na\u010din pore\u0111ane). Sli\u010dno za svaku kolonu va\u017ei da visine stabala od prvog prema poslednjem obrazuju rastu\u0107i ili opadaju\u0107i niz (mogu postojati kolone u kojima su pore\u0111ane u rastu\u0107em poretku i kolone u kojima su pore\u0111ane u opadaju\u0107em poretku, ali poredak vama nije poznat). Vrste su numerisane brojevima od \\(1\\) do \\(N\\), a kolone brojevima od \\(1\\) do \\(N\\). Na raspolaganju imate funkciju (kasnije \u0107e biti detaljno opisana) kojom mo\u017eete dobiti visinu stabla koje se nalazi u odre\u0111enoj vrsti i koloni (zva\u0107emo tu funkciju upit). Potrebno je da sa \u0161to manje upita odredite da li u vo\u0107njaku postoji stablo zadate visine i poziciju tog stabla, ako postoji (redni broj vrste i redni broj kolone). Zato \u0107e biti zadat prirodan broj \\(K\\). Ako va\u0161 program u ne vi\u0161e od \\(K\\) upita odgovori ta\u010dno smatra se da je va\u0161 program korektno re\u0161io taj test primer, u suprotnom, smatra se da je re\u0161enje primera neta\u010dno.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dragan Uro\u0161evi\u0107 Bhuvnesh Jain Nikola Spasi\u0107 <p>Mo\u017eete pro\u010ditati editorijal na engleskom (CodeChef je koristio na\u0161 zadatak za Challenge rundu): Link</p> 05_vocnjak.cpp<pre><code># include &lt;stdio.h&gt;\n# include \"code.h\"\n\n# define MAXN 1010\nint smv[MAXN], smk[MAXN];\nint npv, npk;\nint a[MAXN][MAXN];\n\n\n\nvoid Nadji(int i1, int j1, int i2, int j2, int vv, int *ii, int *jj) {\n    int i, j;\n    if (smv[i1] == 1) {\n        if (smk[j2] == 1) {\n            i = i1; j = j2;\n            while (i &lt;= i2) {\n//              printf(\"cc %d %d\\n\", i, j);\n                if (a[i][j] == 0)\n                    a[i][j] = DajVisinu(i, j);\n                if (a[i][j] == vv) {\n                    *ii = i; *jj = j; return;\n                }\n                if (vv &lt; a[i][j]) {\n                    j--;\n                    if (j &lt; j1) return; // j &lt; j1\n                } else {\n                    if (j &lt; j2) j++;\n                    if (++i &gt; i2) return;\n                }\n            }                       \n        } else {\n            i = i2; j = j2;\n            while (i &gt;= i1) {\n//              printf(\"cc %d %d\\n\", i, j);\n                if (a[i][j] == 0)\n                    a[i][j] = DajVisinu(i, j);\n                if (a[i][j] == vv) {\n                    *ii = i; *jj = j; return;\n                }\n                if (vv &lt; a[i][j]) {\n                    j--;    \n                    if (j &lt; j1) return; // j &lt; j1\n                } else {\n                    if (j &lt; j2) j++;\n                    if (--i &lt; i1) return;\n                }\n            }                       \n        }\n    } else {\n        if (smk[j2] == 1) {\n            i = i1; j = j1;\n            while (i &lt;= i2) {\n//              printf(\"cc %d %d\\n\", i, j);\n                if (a[i][j] == 0)\n                if (a[i][j] == 0)\n                    a[i][j] = DajVisinu(i, j);\n                if (a[i][j] == vv) {\n                    *ii = i; *jj = j; return;\n                }\n                if (vv &lt; a[i][j]) {\n                    j++; \n                    if (j &gt; j2) return;\n                } else {\n                    if (j &gt; j1) j--;\n                    if (++i &gt; i2) return;\n                }\n            }                       \n        } else {\n            i = i2; j = j1;\n            while (i &gt;= i1) {\n//              printf(\"cc %d %d\\n\", i, j);\n                if (a[i][j] == 0)\n                    a[i][j] = DajVisinu(i, j);\n                if (a[i][j] == vv) {\n                    *ii = i; *jj = j; return;\n                }\n                if (vv &lt; a[i][j]) {\n                    j++;\n                    if (j &gt; j2) return; \n                } else {\n                    if (j &gt; j1) j--;\n                    if (--i &lt; 1) return;\n                }\n            }                       \n        }\n    }\n}\n\n\n\n\n\nvoid Resi2x2AA(int n, int i1, int j1, int vv, int *ii, int *jj) {\n    int i, j;\n    int radi[2][2] = {{1,1},{1,1}};\n//  printf(\"Ovde %d %d %d %d\\n\", i1, j1, a[i1-1][j1-1], a[i1][j1]);\n    if (vv &gt; a[i1-1][j1-1]) {\n        radi[0][0] = 0;\n    } else {\n        radi[0][1] = radi[1][0] = 0;\n    }\n    if (vv &gt; a[i1][j1]) {\n        radi[1][1] = 0;\n    } else {\n        radi[0][1] = radi[1][0] = 0;\n    }\n//  printf(\"%d\\n\", radi[0][1]);\n    if (radi[0][0]) {\n        Nadji(1, 1, i1-1, j1-1, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[0][1]) {\n        Nadji(1, j1, i1-1, n, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[1][0]) {\n        Nadji(i1, 1, n, j1-1, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[1][1]) {\n        Nadji(i1, j1, n, n, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }   \n}\n\n\nvoid Resi2x2BB(int n, int i1, int j1, int vv, int *ii, int *jj) {\n    int i, j;\n    int radi[2][2] = {{1,1},{1,1}};\n//  printf(\"Ovde %d %d %d %d\\n\", i1, j1, a[i1-1][j1-1], a[i1][j1]);\n    if (vv &lt; a[i1-1][j1-1]) {\n        radi[0][0] = 0;\n    } else {\n        radi[0][1] = radi[1][0] = 0;\n    }\n    if (vv &lt; a[i1][j1]) {\n        radi[1][1] = 0;\n    } else {\n        radi[0][1] = radi[1][0] = 0;\n    }\n//  printf(\"%d\\n\", radi[0][1]);\n    if (radi[0][0]) {\n        Nadji(1, 1, i1-1, j1-1, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[0][1]) {\n        Nadji(1, j1, i1-1, n, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[1][0]) {\n        Nadji(i1, 1, n, j1-1, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }\n    if (radi[1][1]) {\n        Nadji(i1, j1, n, n, vv, ii, jj);\n        if ((*ii != 0) &amp;&amp; (*jj != 0)) return;\n    }   \n}\n\n\n\n\nvoid Resi2x2(int n, int vv, int *ii, int *jj) {\n    int i, j, i1, j1, i2, j2;\n    i1 = 1; j1 = 1;\n    *ii = *jj = 0;\n    while (smv[i1] == smv[1]) i1++;\n    while (smk[j1] == smk[1]) j1++;\n    a[i1-1][j1-1] = DajVisinu(i1-1, j1-1);  \n    a[i1-1][j1] = DajVisinu(i1-1, j1);  \n    a[i1][j1-1] = DajVisinu(i1, j1-1);  \n    a[i1][j1] = DajVisinu(i1, j1);  \n    if (a[i1-1][j1-1] == vv) {\n        *ii = i1-1; *jj = j1-1; return; \n    }\n    if (a[i1-1][j1] == vv) {\n        *ii = i1-1; *jj = j1; return; \n    }\n    if (a[i1][j1-1] == vv) {\n        *ii = i1; *jj = j1-1; return; \n    }\n    if (a[i1][j1] == vv) {\n        *ii = i1; *jj = j1; return; \n    }\n    if ((smv[1] == 1) &amp;&amp; (smk[1] == 1)) {\n        Resi2x2AA(n, i1, j1, vv, ii, jj);\n        return; \n    }\n    if ((smv[1] == -1) &amp;&amp; (smk[1] == -1)) {\n        Resi2x2BB(n, i1, j1, vv, ii, jj);\n        return; \n    }\n\n}\n\n\nvoid ResiV(int n, int vv, int *ii, int *jj) {\n\n    int nadjen = 0;\n    int i, j, i1, i2;\n    i2 = 1;\n    *ii = *jj = 0;\n    while (i2 &lt;= n) {\n        i1 = i2;\n        while ((i2 &lt;= n) &amp;&amp; (smv[i2] == smv[i1])) i2++;\n//      printf(\"AA %d %d %d\\n\", i1, i2, vv);\n        if (smk[1] == 1) {\n            if (smv[i1] == -1) {\n                a[i2-1][1] = DajVisinu(i2-1, 1);\n                if (vv &lt;= a[i2-1][1]) {\n                    nadjen = 1; break;\n                }\n            } else {\n                a[i2-1][n] = DajVisinu(i2-1, n);\n                if (vv &lt;= a[i2-1][n]) {\n                    nadjen = 1; break;\n                }\n            }\n        } else {\n            if (smv[i1] == -1) {\n                a[i2-1][n] = DajVisinu(i2-1, n);\n                if (vv &gt;= a[i2-1][n]) {\n                    nadjen = 1; break;\n                }\n            } else {\n                a[i2-1][1] = DajVisinu(i2-1, 1);\n                if (vv &gt;= a[i2-1][1]) {\n                    nadjen = 1; break;\n                }\n            }\n        }\n    }\n//  printf(\"BB %d %d\\n\", i2, a[i2-1][n]);\n    if (!nadjen) {\n        *ii = *jj = 0;\n        return;\n    }\n    i2--;\n    Nadji(i1, 1, i2, n, vv, ii, jj);\n\n\n}\n\nvoid ResiK(int n, int vv, int *ii, int *jj) {\n    int nadjen = 0;\n    int i, j, j1, j2;\n    j2 = 1;\n    *ii = *jj = 0;\n    while (j2 &lt;= n) {\n        j1 = j2;\n        while ((j2 &lt;= n) &amp;&amp; (smk[j2] == smk[j1])) j2++;\n//      printf(\"AA %d %d %d\\n\", j1, j2, vv);\n        if (smv[1] == 1) {\n            if (smk[j1] == -1) {\n                a[1][j2-1] = DajVisinu(1, j2-1);\n                if (vv &lt;= a[1][j2-1]) {\n                    nadjen = 1; break;\n                }\n            } else {\n                a[n][j2-1] = DajVisinu(n, j2-1);\n                if (vv &lt;= a[n][j2-1]) {\n                    nadjen = 1; break;\n                }\n            }\n        } else {\n            if (smk[j1] == -1) {\n                a[n][j2-1] = DajVisinu(n, j2-1);\n                if (vv &gt;= a[n][j2-1]) {\n                    nadjen = 1; break;\n                }\n            } else {\n                a[1][j2-1] = DajVisinu(1, j2-1);\n                if (vv &gt;= a[1][j2-1]) {\n                    nadjen = 1; break;\n                }\n            }\n        }\n    }\n//  printf(\"BB %d %d\\n\", j2, a[n][j2-1]);\n    if (!nadjen) {\n        *ii = *jj = 0;\n        return;\n    }\n    j2--;\n    Nadji(1, j1, n, j2, vv, ii, jj);\n}\n\n\nvoid Resi(int n, int k, int vv, int *ii, int *jj) {\n    int i, j;\n    a[1][1] = DajVisinu(1, 1);\n    a[1][2] = DajVisinu(1, 2);\n    if (a[1][1] &lt; a[1][2]) smv[1] = 1; else smv[1] = -1;\n    for (i = 2; i &lt; n; i++) {\n        a[i][i] = DajVisinu(i, i);\n        a[i][i+1] = DajVisinu(i, i+1);\n        if (a[i][i] &lt; a[i][i+1]) smv[i] = 1; else smv[i] = -1;\n        if (a[i-1][i] &lt; a[i][i]) smk[i] = 1; else smk[i] = -1;\n    }\n    a[n][n] = DajVisinu(n, n);\n    a[n][1] = DajVisinu(n, 1);\n    if (a[n][1] &lt; a[n][n])  smv[n] = 1; else smv[n] = -1;\n    if (a[1][1] &lt; a[n][1])  smk[1] = 1; else smk[1] = -1;\n    if (a[n-1][n] &lt; a[n][n]) smk[n] = 1; else smk[n] = -1;\n    npv = npk = 1;\n    for (i = 2; i &lt;= n; i++) {\n        if (smv[i-1] != smv[i]) npv++;\n        if (smk[i-1] != smk[i]) npk++;\n    }   \n\n//  printf(\"%d %d\\n\", npv, npk);\n\n    if (npv == 1) {\n        ResiK(n, vv, ii, jj);\n        return;\n    }\n    if (npk == 1) {\n        ResiV(n, vv, ii, jj);\n        return;\n    }\n    Resi2x2(n, vv, ii, jj);\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, K, V, I, J)\\)</li> </ul> <p>koja treba da odredi da li se u vo\u0107njaku sa \\(N\\) vrsta i \\(N\\) kolona nalazi stablo visine \\(V\\) i ako se nalazi odredi redni broj vrste i redni broj kolone u kome se nalazi stablo visine \\(V\\). Ako stablo ne postoji, onda vrednosti za redni broj vrste i redni broj kolone treba da budu 0. \\(K\\) je predvi\u0111eni broj upita.</p> <p>Na raspolaganju imate funkciju </p> <ul> <li>\\(DajVisinu(I, J)\\)</li> </ul> <p>koja treba da vrati visinu stabla koje se nalazi u vrsti \\(I\\) i kooni \\(J\\). Ako koordinate \\(I\\) i \\(J\\) nisu u dozvoljenim granicama, funkcija vra\u0107a vrednost \\(-1\\).</p>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N = 4, K = 16, V = 9\\), a matrica sa visinama stabala:</p> <pre><code>3 6 10 15\n5 9 13 18\n31 27 23 20\n45 28 32 25\n</code></pre> <p>Ako je  prvi upit bio za polje \\((2, 4)\\) odgovor bi bio \\(18\\). Ako je drugi upit za polje \\((2,1)\\) odgovor bi bio \\(5\\). Kona\u010dno, ako je tre\u0107i upit za polje \\((2,2)\\) odgovor bi bio 9, pa bi va\u0161a funkcija mogla da vrati re\u0161enje \\(I=2\\), \\(J=2\\).</p>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N \\leq 1000\\).</li> <li>\\(K \\leq 10000\\).</li> <li>Visine stabala si izme\u0111u \\(1\\) i \\(100.000.000\\).</li> </ul>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [8 poena]: \\(N \\leq 100\\), \\(K = N \\times N\\).</li> <li>Podzadatak 2 [14 poena]: \\(N \\leq 1.000\\), \\(K = 10.000\\).</li> <li>Podzadatak 3 [24 poena]: \\(N \\leq 1.000\\), \\(K = 6.000\\).</li> <li>Podzadatak 4 [54 poena]: \\(N \\leq 1.000\\), \\(K = 4.000\\).</li> </ul>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>vocnjak.cpp</code> ili <code>vocnjak.pas</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>U zavisnosti od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> Jezik Deklaracija funkcije C++ <code>void Resi(int N, int K, int V, int *I, int *J);</code> Pascal <code>procedure Resi(N, K, V: longint; var I, J: longint);</code> <p>U zavisnosti od programskog jezika koji koristite,  va\u0161a funkcija/procedura mo\u017ee koristiti fuknciju:</p> Jezik Deklaracija funkcije C++ <code>int DajVisinu(int I, int J);</code> Pascal <code>function DajVisinu(I, J: longint): longint;</code>"},{"location":"takprog/2017_2018/sio/05_vocnjak/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \"template\" fajlovi <code>code.cpp</code> i <code>code.pas</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi <code>grader.cpp</code>, <code>grader.pas</code> koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, K, V\\),</li> <li>U narednih \\(N\\) redova po \\(N\\) brojeva, brojevi koji predstavljaju visine stabala po redovima u vo\u0107njaku.</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa brojeve \\(I\\), \\(J\\) i \\(T\\). \\(I, J\\) su redni broj vrste i kolone koje je vratila va\u0161a funkcija, a \\(T\\) je broj poziva funkcije \\(DajVisinu\\). Kodove ovih programa mo\u017eete menjati po potrebi, ali \u0107e za testiranje biti kori\u0161\u0107ena originalna verzija ovih programa.</p>"},{"location":"takprog/2017_2018/sio/06_taman/","title":"6 - Taman","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>U drevnom podrumu Komisije za \u017ealbe, nalazi se \\(N\\) gomila takmi\u010darskih \u017ealbi pore\u0111anih u niz - na \\(i\\)-toj gomili se nalazi \\(a_i\\) \u017ealbi. Do\u0161lo je vreme da se i te \u017ealbe odbiju pa je Glavni Arhivator \u0110or\u0111e Kavurmov dobio zadatak da podeli gomile \u010dlanovima komisije. Kavurmov planira da podeli ove gomile \u017ealbi u  hrpe (ve\u0107e gomile) - uzastopne podnizove gomila \u017ealbi pri \u010demu \u0107e svaka gomila \u017ealbi pripadati ta\u010dno jednoj hrpi (podnizu).</p> <p>Me\u0111utim, to nije trivijalan posao jer veli\u010dine hrpi moraju biti taman (akcenat na drugo 'a') tj. ni prevelike ni premale. Preciznije, za svaku hrpu mora va\u017eiti da njena veli\u010dina (broj gomila \u017ealbi u njoj, tj. du\u017eina podniza) nije manja od najmanje gomile koja joj pripada (jer to nema smisla) i da nije ve\u0107a od najve\u0107e gomile koja joj pripada (jer je to bezveze).  Kako Arhivator ne voli da radi, on je odlu\u010dio da sedi i razmi\u0161lja na koliko na\u010dina mo\u017ee podeliti dati niz gomila na hrpe. Zapravo, odlu\u010dio je samo da sedi a razmi\u0161ljanje prepu\u0161ta vama - kao nagradu, prosledi\u0107e va\u0161u \u017ealbu nekome ko ih zapravo \u010dita pre odbijanja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Bhuvnesh Jain Ivan Sto\u0161i\u0107 <p>Mo\u017eete pro\u010ditati editorijal na engleskom (CodeChef je koristio na\u0161 zadatak za Challenge rundu): Link</p> 06_taman.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 500005;\nconst int MOD = 1000000007;\n\nint s[MAX_N];\nint index_left[MAX_N];\nint L[MAX_N];\nint R[MAX_N];\nint d[MAX_N];\nint preff_sum[MAX_N];\n\nint sum(int l, int r)\n{\n    if (l == 0)\n        return preff_sum[r];\n    else\n        return (preff_sum[r] - preff_sum[l - 1]) % MOD;\n}\n\nint TamanPodela(int N, int a[])\n{\n    // index_left[i] = najveci indeks j &lt;= i takav da je a[j..i] taman podniz ili &lt;= 0 ako takvo j ne postoji\n    // dovoljno je samo proveravati uslov (i - j + 1) &gt;= min[j..i]\n    // koristimo dequeue gde odrzavamo strogo rastuce vrednosti\n    int l = 1, r = 0;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        while (l &lt;= r &amp;&amp; a[i] &lt;= a[s[r]]) r--;\n        s[++r] = i;\n        if (l &lt; r &amp;&amp; min(s[l], i - a[s[l]] + 1) &lt;= min(s[l + 1], i - a[s[l + 1]] + 1)) l++;\n        index_left[i] = min(s[l], i - a[s[l]] + 1);\n    }\n\n    // L[i] - najveci indeks j &lt; i tako da je a[j] &gt; a[i]\n    for (int i = 1; i &lt;= N; i++)\n    {\n        int curr = i - 1;\n        while (curr != 0 &amp;&amp; a[curr] &lt;= a[i])\n            curr = L[curr];\n        L[i] = curr;\n    }\n    // R[i] - najmanji indeks j &gt; i tako da je a[j] &gt;= a[i]\n    for (int i = N; i &gt;= 1; i--)\n    {\n        int curr = i + 1;\n        while (curr &lt;= N &amp;&amp; a[curr] &lt; a[i])\n            curr = R[curr];\n        R[i] = curr;\n    }\n\n    // d[i] = optimalno resenje za podniz a[1..i]\n    for (int i = 1; i &lt;= N; i++) d[i] = 0;\n    d[0] = 1;\n    preff_sum[0] = 1;\n    int currSum = 0;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        currSum = (currSum + d[i]) % MOD;\n        // dodati d[l..r] trenutnoj sumi\n        int r = i - 1;\n        int l = max(i - a[i], L[i]);\n        currSum = (currSum + sum(l, r)) % MOD;\n\n        // unapred oduzeti d[curr] odgovarajucim d[]-ovima\n        int curr = l;\n        while (curr + a[i] + 1 &lt; R[i] &amp;&amp; curr &lt; i)\n        {\n            d[curr + a[i] + 1] = (d[curr + a[i] + 1] - d[curr]) % MOD;\n            curr++;\n        }\n        if (curr + a[i] + 1 &gt;= R[i])\n            d[R[i]] = (d[R[i]] - sum(curr, r)) % MOD;\n\n        // izracunati d[i]\n        if (index_left[i] &lt;= 0)\n            d[i] = 0;\n        else\n            d[i] = (currSum - sum(index_left[i], i - 1)) % MOD;\n\n        if (d[i] &lt; 0) d[i] = (d[i] + MOD) % MOD;\n        preff_sum[i] = (preff_sum[i - 1] + d[i]) % MOD;\n    }\n\n    return d[N];\n}\n</code></pre>"},{"location":"takprog/2017_2018/sio/06_taman/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(TamanPodela(N, a[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) - broj gomila \u017ealbi dok je \\(a\\) niz koji opisuje gomile \u017ealbi: \\(i\\)-ta gomila sadr\u017ei \\(a_i\\) \u017ealbi. Niz \\(a\\) je indeksiran od 1. Ova funkcija mora da vrati jedan ceo broj -- tra\u017eeni broj podela po modulu \\(1.000.000.007\\) \\((10^9 + 7)\\). Obratiti pa\u017enju da re\u0161enje mora biti u segmentu \\([0, 10^9 + 6]\\).</p>"},{"location":"takprog/2017_2018/sio/06_taman/#primer","title":"Primer","text":"<p>Neka je \\(N = 7\\) i \\(a = [1, 6, 2, 3, 4, 3, 4]\\). Tada je niz od ovih 7 gomila \u017ealbi mogu\u0107e podeliti na hrpe na slede\u0107ih \\(6\\) na\u010dina: | 1 | 6 2 3 4 3 4 |, | 1 6 2 | 3 4 3 4 |, | 1 6 2 3 | 4 3 4 |, | 1 | 6 2 | 3 4 3 4 |,  | 1 | 6 2 3 | 4 3 4 |, | 1 6 | 2 3 | 4 3 4 |; dakle, u ovom slu\u010daju va\u0161a funkcija mora vratiti broj \\(6\\) \\(mod\\) \\((10^9 + 7)\\) \\(=\\) \\(6\\). Obraditi pa\u017enju da npr. podela | 1 6 | 2 3 4 3 4 | nije validna jer je veli\u010dina (du\u017eina) desne hrpe \\(5\\) \u0161to je ve\u0107e od najve\u0107e gomile koja joj pripada (\\(4\\)); tako\u0111e, podela | 1 6 2 | 3 4 | 3 4 | nije validna jer je veli\u010dina poslednje dve hrpe \\(2\\) \u0161to je manje od najmanjih gomila koje im pripadaju (u oba slu\u010daja \\(3\\)).</p>"},{"location":"takprog/2017_2018/sio/06_taman/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 500.000\\)</li> <li>Za svako \\(i = \\overline{1,N}\\) va\u017ei \\(1 \\leq a_i \\leq N\\)</li> </ul>"},{"location":"takprog/2017_2018/sio/06_taman/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak \\(1\\) [\\(9\\) poena]: \\(N \\leq 1.000\\).</li> <li>Podzadatak \\(2\\) [\\(10\\) poena]: \\(N \\leq 100.000\\), \\(a_i \\leq 500\\).</li> <li>Podzadatak \\(3\\) [\\(12\\) poena]: U nizu \\(a\\) postoje ta\u010dno 2 razli\u010dite vrednosti.</li> <li>Podzadatak \\(4\\) [\\(24\\) poena]: Za svaki paran indeks \\(i\\) va\u017ei \\(a_i = N\\).</li> <li>Podzadatak \\(5\\) [\\(45\\) poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2017_2018/sio/06_taman/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>taman.cpp</code> ili <code>taman.pas</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>U zavisnosti od programskog jezika koji koristite, va\u0161a funkcija/procedura mora biti slede\u0107eg oblika:</p> Jezik Deklaracija funkcije C++ <code>int TamanPodela(int N, int a[]);</code> Pascal <code>function TamanPodela(N : longint; var a : array of longint) : longint;</code> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p>"},{"location":"takprog/2017_2018/sio/06_taman/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111eni su vam \"template\" fajlovi <code>code.cpp</code> i <code>code.pas</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e su vam obezbe\u0111eni programi <code>grader.cpp</code>, <code>grader.pas</code> koji slu\u017ee da lak\u0161e testirate kodove. Ovi programi u\u010ditavaju sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\),</li> <li>U narednom redu \\(N\\) brojeva, elemente niza \\(a\\)</li> </ul> <p>a zatim pozivaju va\u0161u funkciju sa u\u010ditanim parametrima i, na kraju, vrednost koju va\u0161a funkcija vra\u0107a ispisuju na standardni izlaz. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/","title":"B1 - Hakerisanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mladi haker \u017dak je odlu\u010dio da po svaku cenu do\u0111e do \u0161ifre naloga svoga profesora. Otkrio je da je ta \u0161ifra ta\u010dno jednaka odgovoru na \\(Q\\) upita nad profesorovim nizom. Profesorov niz \\(A_{i}\\) ima \\(N\\) elemenata, a upiti su tipa \\(L\\) \\(R\\). Odgovor na upit je vrednost bitovske konjunkcije elemenata niza izme\u0111u indeksa \\(L\\) i \\(R\\) (uklju\u010duju\u0107i i njih). Pomozite \u017daku da otkrije \u0161ifru.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Mom\u010dilo Topalovi\u0107"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se brojevi \\(N\\), du\u017eina niza i \\(Q\\) najve\u0107i broj upita nad nizom. U drugom redu nalazi se niz od \\(N\\) elemenata. U narednih \\(Q\\) redova nalaze se upiti opisanog formata.</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(Q\\) upita ispisati vrednost bitovske konjunkcije elemenata izme\u0111u indeksa \\(L\\) i \\(R\\).</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#primer","title":"Primer","text":""},{"location":"takprog/2018_2019/drz/01_hakerisanje/#ulaz","title":"Ulaz","text":"<pre><code>5 4\n1 5 4 3 2\n1 3\n4 5\n2 5\n2 3\n</code></pre>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#izlaz","title":"Izlaz","text":"<pre><code>0\n2\n0\n4\n</code></pre>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Odgovor na prvi upit je: \\(1 \\ \\text{and} \\ 5 \\ \\text{and} \\ 4 = 0\\). Odgovor na drugi upit je: \\(3 \\ \\text{and} \\ 2 = 2\\). Odgovor na tre\u0107i upit je: \\(5 \\ \\text{and} \\ 4 \\ \\text{and} \\ 3 \\ \\text{and} \\ 2 = 0\\). Odgovor na \u010detvrti upit je: \\(5 \\ \\text{and} \\ 4 = 4\\).</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq Q, N \\leq 2 \\cdot 10^5\\)</li> <li>\\(0 \\leq A_{i} \\leq 10^6\\)</li> </ul> <p>Postoje tri podzadatka:</p> <ul> <li>Podzadatak 1 [15 poena]: \\(N, Q \\leq 10^3\\).</li> <li>Podzadatak 2 [33 poena]: \\(A_{i} \\leq 1\\).</li> <li>Podzadatak 3 [52 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#napomena","title":"Napomena","text":"<p>Operator konjunkcije u Pascal-u je ozna\u010den sa <code>and</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>&amp;</code>. Ova operacija \\(x\\ \\text{and} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{and} \\  y\\).</p> <p>Bitovska konjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{and} \\ x_{2}  \\ \\text{and} \\  ...  \\ \\text{and} \\  x_{n} = (...(((x_{1}  \\ \\text{and} \\  x_{2})  \\ \\text{and} \\  x_{3}) \\ \\text{and} \\ x_{4})...)  \\ \\text{and} \\  x_{n}\\).</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#podzadatak-1","title":"Podzadatak 1","text":"<p>U prvom podzadatku, za svaki upit pro\u0111emo kroz podniz za koji se tra\u017ei odgovor i izvr\u0161imo bitovsku konjunkciju svih elemenata. Vremenska slo\u017eenost je \\(O(NQ)\\).</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#podzadatak-2","title":"Podzadatak 2","text":"<p>U drugom podzadatku u nizu su samo jedinice i nule.  Primetimo da je odgovor na upit ili \\(0\\) ili \\(1\\). U ovom podzadatku napravimo prefiksne sume, tj. proverimo koliko puta se pojavljuje \\(1\\) do nekog indeksa \\(i\\). Neka je ovaj broj \\(p_{i}\\). Uslov da odgovor bude \\(1\\) je da izme\u0111u indeksa \\(l\\) i \\(r\\) budu sve jedinice, tj. da va\u017ei \\(p_{r}-p_{l-1}=r-l+1\\). Vremenska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2018_2019/drz/01_hakerisanje/#podzadatak-3-kompletno-resenje","title":"Podzadatak 3  (kompletno re\u0161enje)","text":"<p>Za kompletno re\u0161enje neophodno je da zamislimo na\u0161e brojeve u binarnom sistemu i da primetimo da bitove ovde mo\u017eemo da posmatramo nezavisno. Sada radimo sli\u010dan postupak kao i u prethodnom podzadatku, za svaki bit \\(k\\), na\u0111emo u koliko brojeva do indeksa \\(i\\) je on \\(1\\). Neka je ovaj broj \\(p_{k,i}\\). Da bi taj bit bio \\(1\\) kada izvr\u0161imo konjunkciju svih elemenata, potrebno je da va\u017ei \\(p_{k,r}-p_{k,l-1}=r-l+1\\). Tada je odgovor na upit od \\(l\\) do \\(r\\) jednak \\(\\sum 2^k\\), za sve \\(k\\) za koje va\u017ei \\(p_{k,r}-p_{k,l-1}=r-l+1\\). Vremenska slo\u017eenost je \\(O(N\\log A_{i})\\).</p> 01_hakerisanje.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define MAXN 1000010\n#define MAXB 21\nint n,q,x,a[MAXN];\nint pref[MAXB][MAXN];\nint main()\n{\n    scanf(\"%d %d\",&amp;n,&amp;q);\n    int l,r,m,k;\n    bool p;\n    for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]);\n    for(int i=1;i&lt;=n;i++) {\n        for(int j=0;j&lt;MAXB;j++) {\n            pref[j][i]=pref[j][i-1];\n            if(a[i]&amp;(1&lt;&lt;j)) pref[j][i]++;\n        }\n    }\n    while(q--) {\n        scanf(\"%d %d\",&amp;l,&amp;r);\n        m=r-l+1;\n        int res=0;\n        for(int j=0;j&lt;MAXB;j++) {\n            if(pref[j][r]-pref[j][l-1]==r-l+1) res+=(1&lt;&lt;j);\n        }\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/","title":"B2 - Poljoprivrednik","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Miloranka, nova mlada nada \u0160ljivograda, tek \u0161to je nau\u010dila da u\u010ditava nizove, a ve\u0107 je dobila zadatak od svog profesora Rastislava. Zadatak glasi:</p> <p>Data su tri broja \\(N\\), \\(K\\) i \\(X\\). Prona\u0107i jedan niz \\(A\\) koji ima \\(N\\) \u010dlanova, svi \u010dlanovi su prirodni brojevi manji od \\(10^6\\) i u kojem postoji ta\u010dno \\(K\\) parova indeksa (\\(i, j\\)) sa svojstvom: </p> <ul> <li>\\(1\\leq i&lt;j\\leq N\\)</li> <li>\\(|A_i - A_j|\\geq X\\). </li> </ul> <p>Po\u0161to je Rastislav poljoprivrednik i bavi se programiranjem jedino kada nije sezona \u0161ljiva, mogu\u0107e da je pogre\u0161io i dao takva tri broja da ne postoji nijedan niz \\(A\\) koji ispunjava tra\u017eene uslove. U tom slu\u010daju ispisati \\(-1\\). Pomozite Miloranki da re\u0161i profesorov zadatak.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Dimitrije Erdeljan Aleksa Milisavljevi\u0107"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj i jedinoj liniji standardnog ulaza nalaze se tri cela broja \\(N\\), \\(K\\) i \\(X\\), opisana u tekstu zadatka.</p>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati \\(N\\) prirodnih brojeva, \u010dlanove niza \\(A\\) koji ispunjava tra\u017eena svojstva. U slu\u010daju da takav niz ne postoji ispisati \\(-1\\).</p>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#ulaz","title":"Ulaz","text":"<pre><code>3 2 5\n</code></pre>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#izlaz","title":"Izlaz","text":"<pre><code>1 8 2\n</code></pre>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Niz \\(A={1, 8, 2}\\), ima \\(N=3\\) \u010dlana, i \\(K=2\\) para indeksa, (\\(1, 2\\)) i (\\(2, 3\\)), ispunjavaju svojstvo iz zadatka:</p> <ul> <li>\\(|A_1 - A_2| = 7 \\geq 5 = X\\) </li> <li>\\(|A_2 - A_3| = 6 \\geq 5 = X\\)</li> </ul>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 1000\\)</li> <li>\\(2 \\leq X \\leq 1000\\)</li> <li>\\(0 \\leq K \\leq \\frac{N\\cdot (N-1)}{2}\\)</li> </ul> <p>Postoje tri podzadatka:</p> <ul> <li>Podzadatak 1 [21 poen]: \\(K=3\\).</li> <li>Podzadatak 2 [22 poena]: \\(N=K\\).</li> <li>Podzadatak 3 [57 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#analiza","title":"Analiza","text":"<p>Podeli\u0107emo zadatak na dva slu\u010daja:</p> <ul> <li>kada \\(K \\geq N\\), i</li> <li>kada \\(K &lt; N\\).</li> </ul> <p>U slu\u010daju u kom je \\(K \\geq N\\), zadatak mo\u017eemo svesti na re\u0161avanje zadatka za \\(N-1\\) i \\(K - (N-1)\\) tako \u0161to odaberemo prvi element niza (npr. postavimo ga na \\(1\\)), konstrui\u0161emo niz sa \\(N-1\\) elemenata gde imamo \\(K - (N-1)\\) parova na rastojanju ve\u0107em od \\(X\\), i \"pomerimo\" taj niz tako da je na rastojanju ve\u0107em od \\(X\\) od prvog elementa (tj. na sve elemente dodamo \\(X\\)).</p> <p>U slu\u010daju kada \\(K &lt; N\\), zadatak mo\u017eemo re\u0161iti na slede\u0107i na\u010din:</p> <ul> <li>postavimo prvi element na \\(1\\),</li> <li>postavimo \\(K\\) elemenata na \\(X\\), i</li> <li>ostale elemente stavimo izme\u0111u ova dva (na primer, na \\(2\\)).</li> </ul>"},{"location":"takprog/2018_2019/drz/02_poljoprivrednik/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Da bi zadatak re\u0161ili u \\(\\mathcal{O}(N)\\) umesto \\(\\mathcal{O}(N^2)\\), mo\u017eemo eliminisati korak u kom pomeramo celo re\u0161enje tako \u0161to tokom izvr\u0161avanja programa pamtimo poziciju od koje po\u010dinju elementi koje jo\u0161 nismo postavili, i dodamo je na sve elemente koje postavimo od tog abattoirs na dalje.</p> 02_poljoprivrednik.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n,k,x;\nint rez[1001];\n\nvoid solve(int n, int k, int x, int poz)\n{\n    if (k &lt; n)\n    {\n        rez[n--] = poz;\n        for (int i=1; i &lt;= k; i++)\n            rez[n--] = poz + x;\n\n        while(n)\n            rez[n--] = poz + x / 2;\n    }\n    else\n    {\n        rez[n--] = poz;\n        solve(n, k - n, x, poz + x);\n    }\n}\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;\n\n    solve(n, k, x, 1);\n\n    for (int i=1; i &lt;= n; i++)\n        cout&lt;&lt;rez[i]&lt;&lt;\" \";\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/drz/03_miniranje/","title":"B3 - Miniranje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 128MB <p>Mali Danilo treba da se na\u0111e sa svojim najboljim drugom, ali zbog silnih radova u gradu to mu predstavlja problem. Sre\u0107om, Danilo uvek nosi par mina sa sobom koje mo\u017ee da iskoristi da stigne do svog druga.</p> <p>Stanje grada se mo\u017ee opisati matricom, gde je svako polje slobodno ili blokirano radovima. U svakom trenutku Danilo mo\u017ee da pre\u0111e sa polja na kom se nalazi na susedna slobodna polja, gde su susedna polja u matrici ona polja koja su neposredno iznad, ispod, levo ili desno od trenutnog polja.</p> <p>Danilo sme da postavi minu samo na polje koje mu je dosti\u017eno.  Nakon eksplozije prve mine, pod uslovom da mu je ostalo jo\u0161 mina, Danilo mo\u017ee da postavi slede\u0107u minu na sva polja do koja su mu tada dosti\u017ena (mogu\u0107e je da se skup dosti\u017enih polja pro\u0161irio nakon eksplozije prve mine).</p> <p>Ali Danilo je zaboravio snagu svojih mina. Pomozite mu da na\u0111e minimalnu snagu mina \\(K\\) koja mu je potrebna da bi stigao do svog druga.</p> <p>Snaga mina odre\u0111uje veli\u010dinu njene eksplozije. Mina snage \\(K\\) osloba\u0111a sva polja u pravougaoniku veli\u010dine \\((2K+1)*(2K+1)\\), sa centrom u istom polju gde je mina postavljena.</p> <p>Na primer, ako se postavi mina u sredini leve matrice snage \\(K = 1\\), polja koja je eksplozija obuhvatila su ozna\u010dena sa <code>O</code> i ta polja \u0107e na dalje biti prohodna.</p> <pre><code>X....      X....\nXXXXX      XOOOX\nX..X. ---&gt; XOOO. \n...X.      .OOO.\nXX..X      XX..X\n</code></pre> <p>Na\u0111i minimalnu potrebnu snagu mina, \\(K\\), da bi bilo mogu\u0107e da Danilo postavi mine na neki na\u010din tako da stigne do svog druga.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Nenad Bauk Dimitrije Erdeljan Du\u0161an Zdravkovi\u0107"},{"location":"takprog/2018_2019/drz/03_miniranje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se dva broja \\(N\\), koji predstavlja du\u017eine stranice matrice, i \\(M\\), broj mina koji je Danilo poneo sa sobom. Narednih \\(N\\) redova predstavlja stanje grada.</p> <p>Slobodna polja su ozna\u010dena karakterom <code>.</code> , a blokirana polja sa <code>X</code>. Danilo se nalazi na polju ozna\u010denim sa <code>A</code>, a njegov drug na polju ozna\u010denim sa <code>B</code>. Ta dva polja su slobodna.</p>"},{"location":"takprog/2018_2019/drz/03_miniranje/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati prirodan broj \\(K\\) koji predstavlja minimalnu ja\u010dinu mina potrebnu da Danilo stigne do njegovog druga. Ako nije potrebno koristiti mine uop\u0161te, ispisati -1.</p>"},{"location":"takprog/2018_2019/drz/03_miniranje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/drz/03_miniranje/#ulaz","title":"Ulaz","text":"<pre><code>6 1\nA.XX..\n..XX..\nXXXX..\n..XX..\n..XX..\n..XX.B\n</code></pre>"},{"location":"takprog/2018_2019/drz/03_miniranje/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2018_2019/drz/03_miniranje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/drz/03_miniranje/#ulaz_1","title":"Ulaz","text":"<pre><code>7 2\nAXXXXXX\nXXXXXXX\nXXXXXXX\nXXXXXXX\nXXXXXXX\nXXXXXXX\nXXXXXXB\n</code></pre>"},{"location":"takprog/2018_2019/drz/03_miniranje/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2018_2019/drz/03_miniranje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, Danilo mo\u017ee da postavi minu na polje \\((2,2)\\) ili \\((2,1)\\) ja\u010dine \\(K = 2\\) da bi napravio put do svog druga.</p> <p>U drugom primeru, Danilo mo\u017ee samo da stavi minu na svoju poziciju. Stanje matrice nakon prve eksplozije minom snage \\(K = 3\\) na polje \\((1,1)\\):</p> <pre><code>....XXX\n....XXX\n....XXX\n....XXX\nXXXXXXX\nXXXXXXX\nXXXXXXB\n</code></pre> <p>Sad Danilo jedino mo\u017ee da postavi svoju poslednju minu na polje \\((4,4)\\) da bi otvorio put do svog druga.</p>"},{"location":"takprog/2018_2019/drz/03_miniranje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 500\\)</li> <li>\\(1 \\leq M \\leq 2\\)</li> </ul> <p>Postoje tri podzadatka:</p> <ul> <li>Podzadatak 1 [31 poena]: \\(M = 1\\).</li> <li>Podzadatak 2 [32 poena]: \\(N \\leq 50\\).</li> <li>Podzadatak 3 [37 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/drz/03_miniranje/#napomena","title":"Napomena","text":"<p>Danilo i njegov drug su otporni na eksplozije.</p>"},{"location":"takprog/2018_2019/drz/03_miniranje/#analiza","title":"Analiza","text":"<p>Ako je minama snage \\(K\\) mogu\u0107e do\u0107i do cilja, o\u010dito je mogu\u0107e na isti na\u010din i sa snagom \\(K+1\\). Samim tim, minimalno \\(K\\) mo\u017eemo na\u0107i binarnom pretragom \"po re\u0161enju\". Za ovo nam je potreban algoritam kojim \u0107emo odrediti da li, za fiksno \\(K\\), mo\u017eemo sti\u0107i od polaznog do ciljnog polja.</p> <p>Ako postavimo minu na neko polje i time oslobodimo kvadrat dimenzija \\(2K+1 \\times 2K+1\\), nakon \u0161to iza\u0111emo iz tog kvadrata nema razloga da se vra\u0107amo u njega (u suprotnom, mo\u017eemo \"presko\u010diti\" deo puta od izlaska do povratka). Zbog ovoga, mine mo\u017eemo posmatrati kao \"teleport\" ure\u0111aje, koji omogu\u0107avaju da se prebacimo na proizvoljno polje na rastojanju ne ve\u0107em od \\(K\\) (koje mo\u017ee biti i zauzeto).</p> <p>Dakle, na\u0161 put od polaznog do ciljnog polja \u0107e imati slede\u0107i oblik:</p> <ul> <li>kre\u0107emo se slobodnim poljima do mesta gde postavljamo prvu minu,</li> <li>\"presko\u010dimo\" na polje, mo\u017eda zauzeto, na rastojanju ne ve\u0107em od \\(K\\),</li> <li>dalje se kre\u0107emo slobodnim poljima do mesta za drugu minu,</li> <li>opet \"presko\u010dimo\", i</li> <li>kre\u0107emo se do cilja slobodnim poljima.</li> </ul> <p>Polja do kojih mo\u017eemo sti\u0107i u prvom koraku mo\u017eemo na\u0107i pretragom u dubinu ili \u0161irinu od po\u010detnog polja. Zatim markiramo sva polja na rastojanju ne ve\u0107em od \\(K\\) od nekog od prona\u0111enih, i pokrenemo novu pretragu od svih markiranih polja (za tre\u0107i korak). Ovu proceduru ponovimo jo\u0161 jednom za drugu minu i kretanje posle nje. Ako je na kraju ovaj algoritam na\u0161ao put do cilja, mogu\u0107e je do\u0107i do cilja sa minama snage \\(K\\).</p> <p>Ukupna slo\u017eenost jedne provere (za fiksno \\(K\\)) je \\(\\mathcal{O}(N^2)\\) (tri pretrage i dva prolaska kroz matricu), a kako nam za binarnu pretragu treba \\(\\log{N}\\) provera, slo\u017eenost algoritma je \\(\\mathcal{O}(N^2 \\log{N})\\).</p>"},{"location":"takprog/2018_2019/drz/03_miniranje/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Pri implementaciji algoritma, treba voditi ra\u010duna o koraku gde markiramo sva polja na rastojanju ne ve\u0107em od \\(K\\) od skupa polja do kojih ve\u0107 imamo put. Ovo ne mo\u017eemo raditi tako \u0161to za svako svakog polje do kog znamo put obele\u017eimo njegovo okru\u017eenje, jer je slo\u017eenost ovoga \\(\\mathcal{O}(N^2 K^2)\\), tj. u najgorem slu\u010daju (za \\(K=N\\)) \\(\\mathcal{O}(N^4)\\).</p> <p>Ovaj deo programa je mogu\u0107e implementirati na vi\u0161e na\u010dina. Jedna mogu\u0107nost je da pokrenemo pretragu u \u0161irinu od svih polja do kojih imamo put (paralelno), koju prekidamo kada do\u0111emo na rastojanje \\(K\\) (obratite pa\u017enju da ova pretraga ne uzima u obzir \"blokiranost\" polja i da rastojanje moramo gledati odvojeno za vertikalno i horizontalno kretanje).</p> <p>Druga mogu\u0107nost je da izra\u010dunamo matricu prefiksnih suma na matrici \"da li imamo put do ovog polja\" (gde polja imaju vrednost \\(1\\) ako imamo put do njih, a ina\u010de \\(0\\)). Pomo\u0107u ove matrice mo\u017eemo u \\(\\mathcal{O}(1)\\) odrediti koliko polja do kojih imamo put postoji u kvadratu \\(2K+1 \\times 2K+1\\) centriranom na proizvoljnom polju, tj. da li je do njega mogu\u0107e \"sko\u010diti\".</p> 03_miniranje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 1010;\nconst short INF = 10000;\n\ntypedef pair&lt;short,short&gt; pii;\n\nint N, M;\n\nvector&lt;vector&lt;bool&gt; &gt; A(MAXN, vector&lt;bool&gt;(MAXN, 1));\nvector&lt;vector&lt;bool&gt; &gt; EMPTY(MAXN, vector&lt;bool&gt;(MAXN, 1));\n\nint AI,AJ,BI,BJ;\n\nvector&lt;pii&gt; BASIC_NEIGHBOURS = {{0,-1}, {0,1}, {-1,0}, {1,0}};\nvector&lt;pii&gt; BOMB_NEIGHBOURS = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\nbool foundB = false;\n\nvector&lt;pii &gt; GetAllAdjacentCells(vector&lt;vector&lt;bool&gt; &gt; &amp;mat, vector&lt;pii&gt; &amp;sources, vector&lt;pii&gt; &amp;neigh, short max_dist)\n{\n    foundB = false;\n    vector&lt;vector&lt;short&gt; &gt; visited(MAXN, vector&lt;short&gt;(MAXN, INF));\n    vector&lt;pii&gt; neighbours;\n\n    queue&lt;pii&gt; Q;\n    queue&lt;short&gt; COST;\n\n    for (pii source: sources)\n    {\n        // cout &lt;&lt; \"Source \" &lt;&lt; source.first &lt;&lt; ' ' &lt;&lt; source.second &lt;&lt; endl;\n        Q.push(source);\n        COST.push(0);\n    }\n\n    while (!Q.empty())\n    {\n        pii x = Q.front();\n        Q.pop();\n\n        short cur_cost = COST.front();\n        COST.pop();\n\n        short cur_i = x.first, cur_j = x.second;\n\n        // cout &lt;&lt; \"Cur: \" &lt;&lt; cur_i &lt;&lt; ' ' &lt;&lt; cur_j &lt;&lt; endl;\n\n        if ((cur_cost &gt; 0 &amp;&amp; mat[cur_i][cur_j]) || cur_cost &gt;= visited[cur_i][cur_j] || cur_cost &gt; max_dist)\n            continue;\n\n        // cout &lt;&lt; \"PASSED\" &lt;&lt; endl;\n\n        visited[cur_i][cur_j] = cur_cost;\n        neighbours.push_back(make_pair(cur_i, cur_j));\n\n        for (auto delta : neigh)\n        {\n            // int ti = cur_i + delta.first, tj = cur_j + delta.second;\n            Q.push(make_pair(cur_i + delta.first, cur_j + delta.second));            \n            COST.push(cur_cost + 1);\n        }\n\n        foundB = (visited[BI][BJ] &lt; INF);\n    }\n\n    return neighbours;\n}\n\nvoid printA(vector&lt;vector&lt;int&gt; &gt; &amp;mat, string fname)\n{\n    ofstream f;\n    f.open(fname);\n\n    for (int i = 0; i &lt;= N+1;i++)\n    {\n        for (int j = 0; j &lt;= N+1;j++)\n        {   \n            char c;\n            if (mat[i][j] == 0)\n                c = '.';\n            if (mat[i][j] == 1)\n                c = 'X';\n            if (mat[i][j] == 2)\n                c = ',';\n\n            f &lt;&lt; c;\n        }\n        f &lt;&lt; endl;\n    }\n    f.close();\n}\n\ninline bool ValidInds(int i, int j)\n{\n    return (1 &lt;= i) &amp;&amp; (i &lt;= N) &amp;&amp; (1 &lt;= j) &amp;&amp; (j &lt;= N);\n}\n\nint ExplodeMine(vector&lt;vector&lt;int&gt; &gt; &amp;arr, int i, int j, int K)\n{\n    assert(K &gt;= 0);\n\n    for (int ti = max(1, i - K); ti &lt;= min(N, i + K); ti++)\n    for (int tj = max(1, j - K); tj &lt;= min(N, j + K); tj++)\n        arr[ti][tj] = 0;\n}\nvector&lt;pii&gt; adj_A;\n\nbool solve(short K)\n{\n\n    // Get all cells after first explosion.\n    vector&lt;pii&gt; cur_adj = GetAllAdjacentCells(EMPTY, adj_A, BOMB_NEIGHBOURS, K);\n    cur_adj = GetAllAdjacentCells(A, cur_adj, BASIC_NEIGHBOURS, INF);\n\n    if (M == 2)\n    {\n        cur_adj = GetAllAdjacentCells(EMPTY, cur_adj, BOMB_NEIGHBOURS, K);\n        cur_adj = GetAllAdjacentCells(A, cur_adj, BASIC_NEIGHBOURS, INF);\n    }\n\n    return foundB;\n}\n\nshort bin()\n{\n    short lo = 0, hi = N;\n\n    while (lo &lt; hi)\n    {\n        short mid = (lo + hi) / 2;\n\n        if (solve(mid))\n            hi = mid;\n        else\n            lo = mid + 1;\n    }\n\n    return lo;    \n}\n\n\nint main()\n{\n    // Read input.\n    cin &gt;&gt; N &gt;&gt; M;\n    string s;\n    char c;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        cin &gt;&gt; s;\n\n        for (int j = 1; j &lt;= N; j++)\n        {\n            c = s[j - 1];\n\n            if (c == 'A')\n            {\n                AI = i; AJ = j;\n                A[i][j] = 0;\n            }\n            else if (c == 'B')\n            {\n                BI = i; BJ = j;\n                A[i][j] = 0;\n            }\n            else if (c == 'X')\n                A[i][j] = 1;\n            else\n                A[i][j] = 0;\n\n            // Fill empty matrix.\n            EMPTY[i][j] = 0;\n\n        }\n    }\n\n    // First find all adjacent cells from A without any mines.\n    vector&lt;pii&gt; A_as_source  = {{AI, AJ}};\n    adj_A = GetAllAdjacentCells(A, A_as_source, BASIC_NEIGHBOURS, INF);\n\n    if (foundB)\n    {\n        // No need for any mines.\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        return 0;\n    }\n\n\n    // printA(A);\n\n    cout &lt;&lt; bin() &lt;&lt; endl;\n\n\n\n}\n</code></pre>"},{"location":"takprog/2018_2019/drz/04_nz/","title":"A1 - Nz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Niz koji nastane kada se iz nekog niza obri\u0161u neki elementi se zove nz. Za dati niz \\(A\\) i broj \\(K\\) na\u0107i leksikografsko najmanji nz koji se dobija brisanjem ta\u010dno \\(K\\) elemenata niza \\(A\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Marko Savi\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2018_2019/drz/04_nz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji nalaze se dva cela broja. Prvi broj, \\(N\\), predstavlja du\u017einu niza \\(A\\), a drugi broj je broj \\(K\\). U narednoj liniji se nalazi \\(N\\) celih brojeva koji predstavljaju elemente niza \\(A\\).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(N-K\\) celih brojeva koji predstavljaju tra\u017eeni nz.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/drz/04_nz/#ulaz","title":"Ulaz","text":"<pre><code>4 1\n4 8 6 3 \n</code></pre>"},{"location":"takprog/2018_2019/drz/04_nz/#izlaz","title":"Izlaz","text":"<pre><code>4 6 3 \n</code></pre>"},{"location":"takprog/2018_2019/drz/04_nz/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Brisanjem jednog elementa mogu se dobiti nzovi <code>8 6 3</code>, <code>4 6 3</code>, <code>4 8 3</code> i <code>4 8 6</code>. Nz <code>4 6 3</code> je leksikografski manji od svih ostalih.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/drz/04_nz/#ulaz_1","title":"Ulaz","text":"<pre><code>8 3\n6 0 3 1 4 2 1 7 \n</code></pre>"},{"location":"takprog/2018_2019/drz/04_nz/#izlaz_1","title":"Izlaz","text":"<pre><code>0 1 2 1 7 \n</code></pre>"},{"location":"takprog/2018_2019/drz/04_nz/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq A_i \\leq 10^9\\)</li> <li>\\(0 \\leq K \\leq N-1\\)</li> </ul> <p>Postoji pet podzadatka:</p> <ul> <li>Podzadatak 1 [19 poena]: \\(N \\leq 400\\) i \\(K = 1\\)</li> <li>Podzadatak 2 [24 poena]: \\(N \\leq 200.000\\) i \\(A_i \\in \\{0, 1\\}\\)</li> <li>Podzadatak 3 [18 poena]: \\(N \\leq 400\\)</li> <li>Podzadatak 4 [18 poena]: \\(N \\leq 200.000\\) i \\(A_i \\leq 100\\)</li> <li>Podzadatak 5 [21 poena]: \\(N \\leq 500.000\\)</li> </ul>"},{"location":"takprog/2018_2019/drz/04_nz/#napomena","title":"Napomena","text":"<p>Ka\u017eemo da je niz \\(P\\) leksikografski manji od niza \\(Q\\) iste du\u017eine ako va\u017ei da je \\(P_i &lt; Q_i\\) za najmanje \\(i\\) za koje je \\(P_i \\neq Q_i\\).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#potproblem-1","title":"Potproblem 1","text":"<p>U prvom potproblemu je potrebno obrisati ta\u010dno jedan broj. Ako krenemo kroz niz sa leva na desno, jasno je da prvi put kada va\u017ei uslov \\(A[i] &gt; A[i+1]\\) treba obrisati \\(A[i]\\), jer se u suprotnom sigurno dobija leksikografski ve\u0107i nz. Ako uslov nikada nije zadovoljen, bri\u0161emo poslednji element niza.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#potproblem-2","title":"Potproblem 2","text":"<p>U drugom potproblemu u nizu su samo jedinice i nule. Ukoliko u nizu ima barem \\(N-K\\) nula finalni nz \u0107e biti sastavljen isklju\u010divo od njih, pa bri\u0161emo sve jedinice i vi\u0161ak nula. </p> <p>U suprotnom, \u017eelimo da zadr\u017eimo sve nule i onoliko jedinica koliko je neophodno (neka je taj broj \\(N_1\\)). Optimalno je zadr\u017eati poslednjih \\(N_1\\) jedinica u nizu, i finalni nz mo\u017eemo odrediti prolaskom kroz niz sa desna na levo. Kao \u0161to je pomenuto, svaka nula na koju nai\u0111emo mora da bude deo nza, kao i prvih \\(N_1\\) jedinica na koje nai\u0111emo (ostale jedinice bri\u0161emo).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#potproblem-3","title":"Potproblem 3","text":"<p>Tre\u0107i potproblem se mo\u017ee re\u0161iti na dva na\u010dina.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#prvi-nacin","title":"Prvi na\u010din","text":"<p>Koristi\u0107emo dinami\u010dko programiranje. Neka je \\(S(l, c)\\) leksikografski najmanji nz koji se mo\u017ee dobiti brisanjem ta\u010dno \\(c\\) elemenata po\u010dev\u0161i od prefiksa originalnog niza du\u017eine \\(l\\). Ra\u010dunamo kompletnu DP tabelu koriste\u0107i rekurentnu vezu \\(S(l, c) = \\min(S(l-1, c-1), S(l-1, c) + a[l-1])\\), i re\u0161enje nalazimo polaze\u0107i od \\(S(N, K)\\) i prate\u0107i put kroz tabelu unazad. </p> <p>Ra\u010dunanje tabele vr\u0161imo u \\(\\mathcal{O}(N^3)\\), po\u0161to je za leksikografsko pore\u0111enje dva podniza naivno potrebno \\(\\mathcal{O}(N)\\). Svakako, ovo je dovoljno dobro za tre\u0107i potproblem.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#drugi-nacin","title":"Drugi na\u010din","text":"<p>Ovaj na\u010din, za razliku od prvog, predstavlja korak ka kompletnom re\u0161enju, i re\u0161enja za preostala dva podzadatka \u0107e se bazirati na njemu. </p> <p>Nazovimo nz tra\u017een u zadatku kratko optimalan nz i defini\u0161imo najlevlji optimalan nz kao optimalan nz dobijem zadr\u017eavanjem elemenata na indeksima \\(I = \\{i_0, i_1, \\dots, i_{N-K-1}\\}\\) takvim da ne postoji drugi optimalan nz \u010diji su indeksi \\(J = \\{j_0, j_1, \\dots, j_{N-K-1}\\}\\) takvi da je niz \\(J\\) leksikografski manji od \\(I\\). Drugim re\u010dima, najlevlji optimalan nz je onaj \u010diji su zadr\u017eani elementi \\,\\,\u0161to levlje'' u originalnom nizu.</p> <p>Najlevlji optimalan nz mo\u017eemo odrediti na slede\u0107i na\u010din (niz indeksiramo od nule): \\(i_{-1} = -1\\), \\(i_r =\\) \\(LRMQ(i_{r-1} + 1, K+r)\\), gde \\(LRMQ(a, b)\\) predstavlja indeks najlevljeg od svih minimalnih elemenata u intervalu \\([a, b]\\).</p> <p>Levi kraj intervala sledi iz toga da mora va\u017eiti \\(i_r &gt; i_{r-1}\\), a desni iz toga da ne smemo odabrati indeks \\(i_r\\) takav da do kraja niza nema dovoljno brojeva da se formira ceo nz (odatle \\(K+r = N - (N - K) + r\\)). Korektnost ovakvog pohlepnog pristupa sledi direktno iz definicije leksikografskog pore\u0111enja.</p> <p>Koriste\u0107i ovo, uz naivnu implementaciju \\(LRMQ\\) koja prolazi kroz ceo interval, mo\u017eemo u ukupnoj slo\u017eenosti od \\(\\mathcal{O}(N^2)\\) odrediti optimalan nz. Ovo je dovoljno samo za tre\u0107i potproblem. Za naredna dva potproblema koristimo istu ideju uz bolje na\u010dine za ra\u010dunanje \\(LRMQ\\).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#potproblem-4","title":"Potproblem 4","text":"<p>U \u010detvrtom potproblemu sve vrednosti u nizu su u intervalu \\([0, 100]\\). Ovo dodatno ograni\u010denje nam omogu\u0107ava da re\u0161imo \\(LRMQ\\) u \\(\\mathcal{O}(M)\\) (gde je \\(M\\) maksimalni element u nizu). Ovo mo\u017eemo uraditi na vi\u0161e na\u010dina. </p> <p>Jedan od na\u010dina je izgradnja prefiksnih suma koje \u010duvaju broj pojavljivanja svake vrednosti u \\([0, M]\\). Konkretno gradimo matricu \\(pre\\) dimenzija \\(N\\times M\\), gde je \\(pre(l, v)\\) broj pojavljivanja vrednosti \\(v\\) u prefiksu niza du\u017eine \\(l\\), i ra\u010duna se kao \\(pre(l, v) = pre(l-1, v) + (A[l-1] == v)\\).</p> <p>Sada \\(LRQM\\) na nekom intervalu re\u0161avamo tako \u0161to na\u0111emo minimalnu vrednost oduzimanjem odgovaraju\u0107ih vrednosti iz matrice \\(pre\\), a zatim prona\u0111emo njeno prvo pojavljivanje linearnom pretragom. Budu\u0107i da u narednom pozivu \\(LRMQ\\) kre\u0107emo od \\(i_r+1\\) linearna pretraga ne uti\u010de na slo\u017eenost i ukupna slo\u017eenost je \\(\\mathcal{O}(NM)\\).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#potproblem-5-kompletno-resenje","title":"Potproblem 5 (kompletno re\u0161enje)","text":"<p>Naravno, u poslednjem potproblemu ovaj pristup re\u0161avanja \\(LRMQ\\) ne funkcioni\u0161e. Postoje barem tri na\u010dina da se ovo re\u0161i i u pitanju su poznate metode za \\(RMQ\\) problem (Range Minimum Query).</p>"},{"location":"takprog/2018_2019/drz/04_nz/#prvi-nacin_1","title":"Prvi na\u010din","text":"<p>Mo\u017eemo izgraditi segmentno stablo za minimume nad nizom, uz pa\u017eljivo tretiranje jednakih vrednosti tako da se uvek preferira levlja. Ovime dobijamo \\(LRMQ\\) upite u \\(\\mathcal{O}(\\log N)\\), sama izgradnja stabla je \\(\\mathcal{O}(N\\log N)\\), pa je ukupna slo\u017eenost \\(\\mathcal{O}(N\\log N)\\). Ovo je dovoljno za maksimalan broj poena.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#drugi-nacin_1","title":"Drugi na\u010din","text":"<p>Kad god nema izmena niza, umesto segmentnog stabla se mo\u017ee koristiti sparse table Sparse table je jednostavniji za implementaciju i daje odgovore na upite u konstantnom vremenu (\\(\\mathcal{O}(1)\\)). Kako je slo\u017eenost izgradnje ista kao u slu\u010daju segmentnog stabla i u ovom slu\u010daju dominira (\\(\\mathcal{O}(N \\log N)\\)), kori\u0161\u0107enje ove strukture ne dovodi do ubrzanja (na nivou slo\u017eenosti), ali predstavlja alternativan na\u010din za re\u0161avanje zadatka.</p>"},{"location":"takprog/2018_2019/drz/04_nz/#treci-nacin","title":"Tre\u0107i na\u010din","text":"<p>Iako su \\(\\mathcal{O}(N\\log N)\\) re\u0161enja dovoljno dobra za svih \\(100\\) poena, zadatak je mogu\u0107e re\u0161iti i linearno, u slo\u017eenosti \\(\\mathcal{O}(n)\\). Ako primetimo da intervali za koje \u017eelimo \\(LRMQ\\) nisu ugnje\u017edeni, tj. da su nizovi levih i desnih granica neopadaju\u0107i, mo\u017eemo primeniti sliding window, tj. two pointers tehniku.</p> <p>U op\u0161tem slu\u010daju, sliding window RMQ re\u0161avamo kre\u0107u\u0107i se kroz niz sa leva na desno, pritom odr\u017eavaju\u0107i interval koji nas interesuje. U svakom koraku potencijalno pomeramo granice tog intervala udesno, i \u017eelimo da u svakom momentu u \\(\\mathcal{O}(1)\\) imamo minimum na tom intervalu.</p> <p>U ovu svrhu odr\u017eavamo ,\\,listu kandidata'' (najzgodnije implementiranu kao deque). Klju\u010dna opservacija koju koristimo je da postoje elementi koji od nekog momenta nikada ne mogu biti minimalni u intervalu (konkretno, takvi elementi \\(A[i]\\), da unutar intervala postoji indeks \\(j\\) takav da je \\(i &lt; j\\) i \\(A[i] &gt; A[j]\\)). Va\u017eno je da stoji znak \\(&gt;\\) a ne \\(\\geq\\) jer tra\u017eimo najlevlji minimum.</p> <p>Sa ovom opservacijom listu kandidata pri dodavanju novog elementa u interval (pomeranje desne granice) a\u017euriramo tako \u0161to izbacujemo elemente sa kraja liste dokle god su ve\u0107i od novog elementa, a zatim taj novi element dodajemo na kraj. Pri izbacivanju elemenata iz intervala (pomeranje leve granice) prosto izbacujemo adekvatan broj elemenata sa po\u010detka liste.</p> <p>Rezultat ovoga je da je lista kandidata sortirana neopadaju\u0107e i da je minimalni element u trenutnom intervalu uvek na po\u010detku liste, pa mu mo\u017eemo pristupiti u konstantnom vremenu, i re\u0161iti ceo zadatak u \\(\\mathcal{O}(n)\\).</p> 04_nz.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nint n, k;\nint a[500005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; k;\n    k = n-k;\n    for (int i=0; i&lt;n; i++)\n        cin &gt;&gt; a[i];\n\n    set&lt;pair&lt;int, int&gt;&gt; ms;\n    set&lt;int&gt; zivi;\n\n    for (int i=0; i&lt;n; i++) {\n        ms.insert({a[i], i});\n        zivi.insert(i);\n        if (n-i-1 &lt; k) {\n            auto it = *ms.begin();\n            auto it2 = zivi.find(it.second);\n            cout &lt;&lt; it.first &lt;&lt; ' ';\n            while (1) {\n                int t = *it2;\n                ms.erase({a[t], t});\n                if (it2 == zivi.begin()) {\n                    zivi.erase(t);\n                    break;\n                } else {\n                    auto it3 = prev(it2);\n                    zivi.erase(it2);\n                    it2 = it3;\n                }\n            }\n        }\n    }\n    cout &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2018_2019/drz/05_vizaard/","title":"A2 - Vizaard","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Odavno se zna za misti\u010dna svojstva nizova kojima je i bitovska konjunkcija svih elemenata ve\u0107a od nule i bitovska ekskluzivna disjunkcija ve\u0107a od nule. \u010carobnjak Vizaard je dobio jedan ovakav niz sa \\(N\\) elemenata. Da bi on dobio misti\u010dna svojstva, Vizaard na svakom od njegovih elemenata mo\u017ee da primeni jednu od slede\u0107e dve operacije:</p> <ul> <li>Ukoliko je \\(A_{i} &gt; 0\\), mo\u017ee da smanji vrednost elementu sa indeksom \\(i\\). Ovom operacijom vrednost \\(i\\)-tog elementa se pretvara u \\(A_{i}-1\\).</li> <li>Mo\u017ee da pove\u0107a vrednost elementu sa indeksom \\(i\\). Ovom operacijom vrednost \\(i\\)-tog elementa se pretvara u \\(A_{i}+1\\).</li> </ul> <p>Vizaarda interesuje koliko najmanje operacija mora da primeni tako da niz dobije misti\u010dna svojstva, tj. da mu bitovska konjunkcija svih elemenata bude ve\u0107a od nule i da mu bitovska ekskluzivna disjunkcija svih elemenata bude ve\u0107a od nule.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Milisavljevi\u0107 Vladimir Milenkovi\u0107 Mom\u010dilo Topalovi\u0107"},{"location":"takprog/2018_2019/drz/05_vizaard/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji nalazi se jedan broj \\(N\\), du\u017eina niza. U narednoj liniji nalazi se niz od \\(N\\) elemenata.</p>"},{"location":"takprog/2018_2019/drz/05_vizaard/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati najmanji broj operacija potrebnih da i bitovska konjunkcija i bitovska ekskluzivna disjunkcija svih elemenata bude ve\u0107a od \\(0\\).</p>"},{"location":"takprog/2018_2019/drz/05_vizaard/#primer","title":"Primer","text":""},{"location":"takprog/2018_2019/drz/05_vizaard/#ulaz","title":"Ulaz","text":"<pre><code>4\n5 2 3 3\n</code></pre>"},{"location":"takprog/2018_2019/drz/05_vizaard/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2018_2019/drz/05_vizaard/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Primetimo da je \\(5 \\ \\text{and} \\ 2 \\ \\text{and} \\ 3 \\ \\text{and} \\ 3  = 0\\). Me\u0111utim primetimo da ukoliko drugi element smanjimo za jedan, dobijamo niz \\([5,1, 3, 3]\\), za koji va\u017ei \\(5 \\ \\text{and} \\ 1 \\ \\text{and} \\ 3 \\ \\text{and} \\ 3  = 1\\) i \\(5 \\ \\text{xor} \\ 1 \\ \\text{xor} \\ 3 \\ \\text{xor} \\ 3  = 4\\).</p>"},{"location":"takprog/2018_2019/drz/05_vizaard/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 5 \\cdot 10^5\\)</li> <li>\\(0 \\leq A_{i} \\leq 10^{18}\\)</li> </ul> <p>Postoje \u010detiri podzadatka:</p> <ul> <li>Podzadatak 1 [14 poena]: \\(N, A_{i} \\leq 16\\).</li> <li>Podzadatak 2 [20 poena]: \\(N \\leq 10^3\\), \\(A_{i} \\leq 10^9\\).</li> <li>Podzadatak 3 [29 poena]: \\(N \\leq 3\\cdot 10^4\\), \\(A_{i} \\leq 10^9\\).</li> <li>Podzadatak 4 [37 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/drz/05_vizaard/#napomena","title":"Napomena","text":"<p>Operator konjunkcije u Pascal-u je ozna\u010den sa <code>and</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>&amp;</code>. Ova operacija \\(x\\ \\text{and} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{and} \\  y\\).</p> <p>Bitovska konjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{and} \\ x_{2}  \\ \\text{and} \\  ...  \\ \\text{and} \\  x_{n} = (...(((x_{1}  \\ \\text{and} \\  x_{2})  \\ \\text{and} \\  x_{3}) \\ \\text{and} \\ x_{4})...)  \\ \\text{and} \\  x_{n}\\).</p> <p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\  y\\).</p> <p>Bitovska ekskluzivna disjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{xor} \\ x_{2}  \\ \\text{xor} \\  ...  \\ \\text{xor} \\  x_{n} = (...(((x_{1}  \\ \\text{xor} \\  x_{2})  \\ \\text{xor} \\  x_{3}) \\ \\text{xor} \\ x_{4})...)  \\ \\text{xor} \\  x_{n}\\).</p>"},{"location":"takprog/2018_2019/drz/05_vizaard/#analiza","title":"Analiza","text":"<p>Na po\u010detku, konstatujmo da ni u jednom optimalnom re\u0161enju ne\u0107emo primenjivati oba tipa operacija na isti broj \u2013 ili \u0107emo samo pove\u0107avati, ili samo smanjivati taj broj. </p> <p>Primetimo da, ukoliko \u017eelimo da je and svih elemanata ve\u0107i od 0, mora postojati jedna pozicija na kojoj svi brojevi imaju binarnu cifru 1. Ukoliko fiksiramo tu poziciju t, mo\u017eemo izra\u010dunati za svaki broj u konstantnom vremenu najmanji broj dodavanja broj 1 na njega tako da u tom broju cifra na poziciji t postane 1. Tako\u0111e, mo\u017eemo izra\u010dunati i najmanji broj oduzimanja potreban za istu stvar. Optimalno nam je da izaberemo onu opciju za koju treba manje operacija, ali je tako\u0111e korisno da sa\u010duvamo da li je za neki broj bilo mogu\u0107e da uzmemo bilo koju opciju (ukoliko je broj dodavanja i oduzimanja isti).</p> <p>Kako smo ispunili prvi uslov (za fiksno t), prva slede\u0107a stvar koju treba proveriti je da li je xor svih ovako dobijenih brojeva 0 \u2013 ako jeste, na\u0161li smo najmanji broj operacija za izabranu poziciju. Ukoliko nije, a postojala je druga opcija za neki broj, iskoristi\u0107emo nju i ona \u0107e promeniti xor, tako da nije potrebno dodatnih operacija, ukoliko nije postojala, treba\u0107e nam jo\u0161 2 ili 1 operacija, u zavisnosti od toga da li je t izabrana pozicija najdesnija ili nije.</p> <p>Uradiv\u0161i ovo za svako t od 0 do 60 (maksimalni broj bitova), sve \u0161to nam je preostalo je da uzmemo minimum dobijenih brojeva operacija.</p> <p>Vremenska slo\u017eenost: \\(O(NlogMAX)\\), gde je MAX maksimalan broj u ulazu (10^18).</p> 05_vizaard.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 600000\nusing namespace std;\nlong long n;\nlong long a[maxn];\nlong long b[maxn];\nlong long r=-1;\nint main()\n{\n    scanf(\"%lld\",&amp;n);\n    for(long long i=0;i&lt;n;i++) scanf(\"%lld\",&amp;a[i]);\n    long long s=0;\n    long long mask=0;\n    for(long long i=0;i&lt;60;i++) { //fiksiramo bit\n        s=0;\n        if(i!=0) {\n            for(long long j=0;j&lt;n;j++) {\n                if((a[j]&amp;(1ll&lt;&lt;i))==0) {\n                    if(a[j]&lt;(1ll&lt;&lt;i)) {\n                        s+=((1ll&lt;&lt;i)-a[j]);\n                        b[j]=a[j]+((1ll&lt;&lt;i)-a[j]);\n                    }\n                    else {\n                        if((a[j]&amp;mask)+1ll&lt;((1ll&lt;&lt;i)-(a[j]&amp;mask))) {\n                            s+=((a[j]&amp;mask)+1ll);\n                            b[j]=a[j]-((a[j]&amp;mask)+1ll);\n                        }\n                        else {\n                            s+=((1ll&lt;&lt;i)-(a[j]&amp;mask));\n                            b[j]=a[j]+((1ll&lt;&lt;i)-(a[j]&amp;mask));\n                        }\n                    }\n                }\n                else b[j]=a[j];\n                if(s&gt;r) break;\n            }\n            long long x=0;\n            for(int j=0;j&lt;n;j++) x^=b[j];\n            s+=(x==0);\n        }\n        else {\n            bool fixable=false;\n            s=0;\n            for(int j=0;j&lt;n;j++) {\n                if((a[j]&amp;1ll) == 0) {\n                    s++;\n                    b[j]=a[j]+1ll;\n                    if(a[j]&gt;0) fixable=true;\n                }\n                else b[j]=a[j];\n            }\n            if(!fixable) {\n                long long x=0;\n                for(int j=0;j&lt;n;j++) x^=b[j];\n                if(x==0) s+=2ll;\n            }\n        }\n        if(r==-1 || s&lt;r) r=s;\n        mask=(mask&lt;&lt;1ll)+1ll;\n    }\n    printf(\"%lld\",r);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/drz/06_pariz/","title":"A3 - Pariz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Pariz je poznat po brojnim atrakcijama i znamenitostima koje se mogu videti u tom gradu. U poslednjoj predizbornoj kampanji, gradski oci Pariza su izgradili nove, lepe i moderne, pe\u0161a\u010dke puteve izme\u0111u atrakcija. Kako bi dalje finansirali svoju kampanju, smislili su i na\u010din kako mogu prevariti nesmotrene gra\u0111ane i turiste - pe\u0161a\u010dke puteve su napravili jednosmernim, i svakome ko se kre\u0107e u suprotnom smeru bi\u0107e napisana kazna. Za svaku atrakciju u gradu, napravljen je ta\u010dno jedan pe\u0161a\u010dki put koji vodi do nje.</p> <p>Ana \u0107e ove godine prvi put i\u0107i u Pariz, i sa svime ovime je dobro upoznata. Ona jako \u017eeli da isplanira svoj obilazak i da uop\u0161te ne gubi vreme tamo. Na internetu je istra\u017eila apsolutno sve atrakcije, i svakoj je dodelila ocenu koliko joj se svi\u0111a. Ipak, po\u0161to atrakcija ima mnogo, a Ana mora i da spakuje stvari, moli vas da joj pomognete u planiranju obilaska. </p> <p>Ana vam daje novu mapu Pariza gde su upisani svi pe\u0161a\u010dki putevi, od koje do koje atrakcije vode, i koliko vremena traje pe\u0161a\u010denje tim putem. Tako\u0111e \u0107e vam dati svoje ocene atrakcija, i ukupno vreme koje \u0107e provesti u Parizu. Va\u0161 zadatak je da joj ka\u017eete kolika je najve\u0107a ukupna lepota atrakcija koje ona mo\u017ee da obi\u0111e (ukupna lepota je suma ocena svake atrakcije koju obi\u0111e), tako da se Ana kre\u0107e samo novim pe\u0161a\u010dkim putevima. Ana svoj obilazak mo\u017ee po\u010deti od bilo koje atrakcije.</p> <p>Imajte u vidu da Ana kada obilazi atrakcije ne gubi ni malo vremena razgledaju\u0107i, njoj je dovoljno samo da se slika za Instagram i da ide dalje. Upravo zato, mogu\u0107e je da neke atrakcije obi\u0111e i po vi\u0161e puta, a da su joj i dalje isto lepe kao \u0161to su joj bile i na po\u010detku (odnosno, ukoliko vi\u0161e puta obi\u0111e istu atrakciju, svaki put \u0107e se njena ocena dodati na ukupnu lepotu puta).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2018_2019/drz/06_pariz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji se nalaze dva prirodna broja \\(N\\) i \\(T\\) - broj atrakcija, i vreme koje \u0107e Ana provesti u Parizu. U drugoj liniji se nalazi \\(N\\) prirodnih brojeva - ocene koje je Ana dala atrakcijama. U tre\u0107oj liniji se nalazi \\(N\\) prirodnih brojeva - niz \\(X_i\\). U \u010detvrtoj liniji se nalazi \\(N\\) prirodnih brojeva - niz \\(D_i\\). Nizovi \\(X\\) i \\(D\\) opisuju jednosmerne pe\u0161a\u010dke puteve - put koji vodi do atrakcije \\(i\\) po\u010dinje od atrakcije \\(X_i\\), i potrebno je \\(D_i\\) vremena da se prepe\u0161a\u010di. Atrakcije su indeksirane brojevima od \\(1\\) do \\(N\\).</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi i jedini red izlaza ispisati jedan broj - najve\u0107u ukupnu lepotu atrakcija koje Ana mo\u017ee da obi\u0111e.</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/drz/06_pariz/#ulaz","title":"Ulaz","text":"<pre><code>5 7\n7 3 1 4 8\n4 3 5 2 1\n3 2 4 1 7\n</code></pre>"},{"location":"takprog/2018_2019/drz/06_pariz/#izlaz","title":"Izlaz","text":"<pre><code>16\n</code></pre>"},{"location":"takprog/2018_2019/drz/06_pariz/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U ovom primeru postoji \\(5\\) atrakcija, a pe\u0161a\u010dki putevi koji postoje su \\(4 \\rightarrow 1\\) du\u017eine \\(3\\), \\(3 \\rightarrow 2\\) du\u017eine \\(2\\), \\(5 \\rightarrow 3\\) du\u017eine \\(4\\), \\(2 \\rightarrow 4\\) du\u017eine \\(1\\) i \\(1 \\rightarrow 5\\) du\u017eine \\(7\\). Vreme kojie \u0107e Ana provesti u Parizu je \\(7\\), i za to vreme najve\u0107a ukupna lepota atrakcija koje mo\u017ee da obi\u0111e je \\(16\\) ako ide putem: \\(5 \\rightarrow 3 \\rightarrow 2 \\rightarrow 4\\).</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/drz/06_pariz/#ulaz_1","title":"Ulaz","text":"<pre><code>6 200\n1 1 1 1 1 100\n3 1 2 5 4 5\n1 1 1 10 10 1\n</code></pre>"},{"location":"takprog/2018_2019/drz/06_pariz/#izlaz_1","title":"Izlaz","text":"<pre><code>201\n</code></pre>"},{"location":"takprog/2018_2019/drz/06_pariz/#objasnjenje-primera_1","title":"Obja\u0161njenje primera","text":"<p>Da bi ovde postigla najve\u0107u lepotu, Ana \u0107e se vrteti u krug izme\u0111u par atrakcija. Jedna mogu\u0107nost je da krene od \\(2\\), a put bi bio \\(2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 2 \\rightarrow \\ldots \\rightarrow 1\\)</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 10^5\\)</li> <li>\\(1 \\leq T \\leq 10^{12}\\)</li> <li>\\(1 \\leq A_i \\leq 10^6\\)</li> <li>\\(1 \\leq D_i \\leq 10^6\\)</li> </ul> <p>Postoje \u010detiri podzadatka:</p> <ul> <li>Podzadatak 1 [22 poena]: \\(N, T \\leq 1000\\).</li> <li>Podzadatak 2 [17 poena]: \\(N \\leq 1000\\), i \\(T \\leq 10^{12}\\).</li> <li>Podzadatak 3 [14 poena]: \\(D_i = 1\\) za svako \\(i\\), odnosno vreme potrebno da se svaki put prepe\u0161a\u010di je \\(1\\).</li> <li>Podzadatak 4 [23 poena]: Niz \\(X\\) je permutacija brojeva od \\(1\\) do \\(N\\), odnosno iz svake atrakcije kre\u0107e ta\u010dno jedan put.</li> <li>Podzadatak 5 [24 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/drz/06_pariz/#analiza","title":"Analiza","text":""},{"location":"takprog/2018_2019/drz/06_pariz/#potproblem-1","title":"Potproblem 1","text":"<p>Pravolinijsko re\u0161enje se dobija tako \u0161to se svaka atrakcija posmatra kao poslednja na turi koju je obi\u0161la Ana. Ako je fiksirana poslednja atrakcija, onda se kompletna tura dobija tako \u0161to se krene poslednje atrakcije i 'vra\u0107a unazad' pomeraju\u0107i se svaki put do atrakcije od koje vodi jedini put do atrakcije u kojoj se trenutno nalazimo. Naravno, tokom pomeranja se sabiraju lepote atrakcija koje je Ana posetila. Postupak se prekida u trenutka kada bi se narednim korakom vra\u0107anja prema\u0161ilo ukupno vreme koje Ana ima na raspolaganju.</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#potproblem-2","title":"Potproblem 2","text":"<p>Re\u0161enje se dobija uz malu doradu re\u0161enja za potproblem 1. Polaze\u0107i od atrakcije \\(A\\) i vra\u0107aju\u0107i se du\u017e puta koji vodi do trenutne atrakcije, pre ili kasnije \u0107emo zatvoriti petlju. Mo\u017ee se odrediti vreme da se obi\u0111u sve atrakcije na petlji, a zatim i koliko puta se ta petlja mo\u017ee obi\u0107i a da se ne prema\u0161i vreme \\(T\\). Na kraju ako je ostalo vremena treba zapo\u010deti jo\u0161 jedan prolaz kroz petlju i zaustaviti se u trenutku kada vreme prema\u0161i vreme \\(T\\). Naravno, tokom postupka je odre\u0111ivana suma lepota atrakcija koje su obi\u0111ene.</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#potproblem-3","title":"Potproblem 3","text":"<p>Ovaj potproblem se mo\u017ee re\u0161iti kao i potproblem 2, pri \u010demu ne kre\u0107emo svaki put od atrakcije koja je na kraju ture, ve\u0107 koristimo rezultate od prethodnog obilaska. </p>"},{"location":"takprog/2018_2019/drz/06_pariz/#potproblem-4","title":"Potproblem 4","text":"<p>Ako je niz \\(X\\) permutacija brojeva od \\(1\\) do \\(N\\), onda svi putevi obrazuju kolekciju petlji (ciklusa). Za svaku petlju je dovoljno odrediti \u010dvor od koga treba krenuti kako bi se dobila maksimalna suma lepota atrakcija koje su pose\u0107ene. To se mo\u017ee obaviti i linearnom vremenu (linearnom po broju atrakcija na petlji), kori\u0161\u0107enjem dva pokaziva\u010da (indeksa): jedan za po\u010detak ture, a drugi za kraj ture.</p>"},{"location":"takprog/2018_2019/drz/06_pariz/#potproblem-5","title":"Potproblem 5","text":"<p>Maksimalni broj poena se dobija tako \u0161to se za svaku atrakciju \\(A\\) odredi suma lepota atrakcija (kao i vreme potrebno da se obi\u0111u te atrakcije) na turi koja se zavr\u0161ava na atrakcija \\(A\\) i \u010dija je du\u017eina \\(2^I\\) (\\(I=0, 1, 2, ... \\lfloor \\log T\\rfloor\\)). Du\u017eina ture je jednaka broju atrakcija na turi. To se mo\u017ee obaviti u slo\u017eenosti \\(O(N \\times \\log T)\\). Naime, ako znamo sume atrakcija za ture du\u017eine \\(2^{I-1}\\), onda sumu za turu du\u017eine \\(2^I\\) koja se zavr\u0161ava na atrakciji \\(A\\) dobijamo tako \u0161to nadove\u017eemo dve ture du\u017eine \\(2^{I-1}\\): turu koja se zavr\u0161ava na atrakciji \\(A\\) i turu koja se zavr\u0161ava u \u010dvoru od koga vodi put do po\u010detka ture du\u017eine \\(2^{I-1}\\) koja se zavr\u0161ava na atrakciji \\(A\\). </p> <p>Kada smo  odredili opisane sume tura, onda je potrebno za svaku atrakciju odrediti turu maksimalne du\u017eine koja se zavr\u0161ava u toj atrakciji. To obavljamo tako \u0161to kombinujemo ture odre\u0111ene u prethodnom pasusu. Po\u010dinjemo sa turom du\u017eine \\(2^{\\lfloor\\log T\\rfloor}\\). Ako je vreme potrebno za njen obilazak ve\u0107e od dozvoljenog prepolovimo du\u017einu (tj. podelimo sa 2). Ako vreme nije ve\u0107e, dodajemo tu turu na kompletnu turu, pomeramo se na atrakciju na kojoj ta tura po\u010dinje (ta\u010dnije na atrakciju koja prethodi atrakciji na kojoj ta tura po\u010dinje) i nastavljamo sa turom dvostruko kra\u0107om od one koja je dodata. </p> 06_pariz.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 111555\n#define MAXDEPTH 45\n\nlong long a[MAXN], x[MAXN], d[MAXN];\nlong long uka[MAXN][MAXDEPTH], ukd[MAXN][MAXDEPTH], sled[MAXN][MAXDEPTH], last[MAXN][MAXDEPTH];\n\nint main() {\n\n    int n;\n    long long t;\n\n    scanf(\"%d%lld\", &amp;n, &amp;t);\n\n    for(int i=0; i&lt;n; i++) {\n        for(int stp=1; stp&lt;MAXDEPTH; stp++) {\n            ukd[i][stp] = -1;\n        }\n    }\n\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%lld\", &amp;a[i]);\n        uka[i][0] = a[i];\n        ukd[i][0] = 0;\n    }\n\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%lld\", &amp;x[i]);\n        x[i]--;\n        sled[i][0] = x[i];\n        last[i][0] = i;\n    }\n\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%lld\", &amp;d[i]);\n    }\n\n    for(int stp=1; stp &lt; MAXDEPTH; stp++) {\n        for(int i=0; i&lt;n; i++) {\n\n            int j = sled[i][stp-1];\n            sled[i][stp] = sled[j][stp-1];\n            last[i][stp] = last[j][stp-1];\n\n            if (ukd[i][stp-1] == -1 || ukd[j][stp-1] == -1) continue;\n\n            long long td = ukd[i][stp-1] + ukd[j][stp-1] + d[ last[i][stp-1] ];\n            long long ta = uka[i][stp-1] + uka[j][stp-1];\n            if (td &lt;= t) {\n                ukd[i][stp] = td;\n                uka[i][stp] = ta;\n            }\n        }\n    }\n\n    long long res = 0;\n    for(int i=0; i&lt;n; i++) {\n        int stp = MAXDEPTH - 1;\n        int tr = i;\n        long long td = 0;\n        long long ta = 0;\n        while(stp &gt;= 0) {\n            while(stp &gt;= 0 &amp;&amp; (ukd[tr][stp] == -1 || td + ukd[tr][stp]&gt; t)) stp--;\n            if (stp &lt; 0) break;  \n\n            ta += uka[tr][stp];\n            td += ukd[tr][stp]+d[last[tr][stp]];\n            tr = sled[tr][stp];\n\n            stp--;\n        }\n\n\n        res = max(res,ta);\n    }\n\n    printf(\"%lld\\n\", res);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/","title":"1 - Pile\u0107a krilca","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Kineski restoran ima u ponudi samo pile\u0107a krilca. Prava vrednost jednog pile\u0107eg krilca je \\(X\\) Juana, ali da se gosti restorana ne bi optere\u0107ivali matematikom, vlasnici su napravili jelovnik u kome je za razli\u010dite koli\u010dine krilaca napisana njihova cena zaokru\u017eena na najbli\u017ei ceo broj. Preciznije, svaka stavka u jelovniku je oblika \"\\(K\\) krilaca ko\u0161ta \\(round(K\\cdot X)\\) Juana\", gde je \\(K\\) prirodan broj, a \\(round\\) je funkcija koja dati realan broj zaokru\u017euje na najbli\u017ei ceo broj. Va\u0161 zadatak je da utvrdite kolika je najmanja mogu\u0107a prava vrednost jednog pile\u0107eg krilca, tj. minimalno \\(X\\) za koje va\u017ee sve stavke u jelovniku.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Marko Savi\u0107 Marko Savi\u0107 Aleksa Milisavljevi\u0107 <p>Sa \\(R\\) ozna\u010dimo realnu cenu jednog krilca, koju \u017eelimo da izra\u010dunamo.</p> <p>Ako u \\(i\\)-toj stavci menija pi\u0161e da \\(K_i\\) krilaca ko\u0161ta \\(C_i\\) Juana, to zna\u010di da \\(K_i\\) krilaca realno ne mogu ko\u0161tati manje od \\(C_i-0.5\\) Juana. Svaka manja realna cena za \\(K_i\\) krilaca zaokru\u017eena na najbli\u017ei ceo broj ne bi dala \\(C_i\\) kao rezultat zaokru\u017eivanja. Iz toga zaklju\u010dujemo da je \\(K_i R \\geq C_i-0.5\\), odnosno \\(R \\geq (C_i-0.5)/K_i\\).</p> <p>Sada je potrebno pro\u0107i kroz sve stavke u meniju i za svaku na\u0107i ovo donje ograni\u010denje za cenu. Jasno je da najmanja mogu\u0107a realna cena za jedno krilce ne sme biti manja od svakog tako dobijenog donjeg ograni\u010denja, \u0161to zna\u010di da ne sme biti manja od njihovog maksimuma. Po\u0161to nam se u zadatku garantuje da su cene u meniju formirane ispravno, to zna\u010di da je najmanja mogu\u0107a realna cena jednog krilca jednaka upravo tom maksimumu.</p> \\[ R=\\max_{i\\in\\{1,2,\\ldots,n\\}}(C_i-0.5/K_i) \\] 01_krilca.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n//100p\nint main()\n{\n    int n;\n    scanf(\"%d\",&amp;n);\n    double k,c;\n    double m;\n    for(int i=0;i&lt;n;i++) {\n        scanf(\"%lf %lf\",&amp;k,&amp;c);\n        if(i==0) m=(c-0.5)/k;\n        else m=fmax(m,(c-0.5)/k);\n    }\n    printf(\"%.6lf\",m);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se broj \\(N\\), ukupan broj stavki u jelovniku. U svakoj od narednih \\(N\\) linija je navedena po jedna stavka iz jelovnika, predstavljena sa dva prirodna broja, \\(K\\) i \\(C\\), \u0161to zna\u010di da je za \\(K\\) pile\u0107ih krilaca potrebno platiti \\(C\\) Juana. Redosled navo\u0111enja stavki mo\u017ee biti proizvoljan.</p>"},{"location":"takprog/2018_2019/kv1/01_krilca/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinu liniju standardnog izlaza ispisati jedan realan broj, najmanju mogu\u0107u pravu vrednost jednog pile\u0107eg krilca.</p>"},{"location":"takprog/2018_2019/kv1/01_krilca/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv1/01_krilca/#ulaz","title":"Ulaz","text":"<pre><code>1\n5 5\n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/#izlaz","title":"Izlaz","text":"<pre><code>0.9\n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv1/01_krilca/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n5 7\n4 6\n2 3 \n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/#izlaz_1","title":"Izlaz","text":"<pre><code>1.375\n</code></pre>"},{"location":"takprog/2018_2019/kv1/01_krilca/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako bi u prvom primeru jedno krilce vredelo ta\u010dno 0.9 Juana, pet krilaca bi vredela 4.5 Juana, \u0161to je kad se zaokru\u017ei na najbli\u017ei ceo broj jednako 5 Juana. Ako bi vrednost jednog krilca bila manja od 0.9 Juana, tada bi vrednost pet krilaca bila strogo manja od 4.5 Juana, a to zaokru\u017eeno na najbli\u017ei ceo broj ne mo\u017ee biti ve\u0107e od 4. Zato je tra\u017eena minimalna vrednost jednaka 0.9.</p>"},{"location":"takprog/2018_2019/kv1/01_krilca/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 100\\)</li> <li>\\(1 \\leq K \\leq 100\\)</li> <li>\\(0 \\leq C \\leq 10000\\)</li> </ul> <p>U svim test primerima ta\u010dan rezultat \u0107e biti pozitivan broj. Garantuje se da \u0107e ulazni podaci biti takvi da re\u0161enje postoji.</p>"},{"location":"takprog/2018_2019/kv1/01_krilca/#napomene","title":"Napomene","text":"<ul> <li>Da bi se rezultat priznao kao ta\u010dan, apsolutna gre\u0161ka mora biti manja od \\(10^{-4}\\).</li> <li>Brojevi jednako udaljeni od dva uzastopna cela broja se zaokru\u017euju na prvi ve\u0107i ceo broj (na primer, 3.5 se zaokru\u017euje na 4, a 6.5 se zaokru\u017euje na 7).</li> </ul>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/","title":"2 - Lep niz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Aleksa je za ro\u0111endan od svoje mame dobio niz od \\(N\\) celih brojeva. Tako\u0111e, od tate je dobio \\(C\\) tokena za aktivaciju \u010darobne mo\u0107i. Aleksa mo\u017ee iskoristiti \u010darobnu mo\u0107 tako da pove\u0107a ta\u010dno jedan broj u nizu za 1, i to ga ko\u0161ta 1 token. On mo\u017ee koristiti mo\u0107 proizvoljno mnogo puta na svakom elementu niza, ali sveukupno ne mo\u017ee iskoristiti mo\u0107 vi\u0161e od \\(C\\) puta.</p> <p>Neka je lepota niza definisana kao suma \\(K\\)-tih stepena svih brojeva u nizu.</p> <p>Aleksa zna da \u0107e ga drugari iz odeljenja ceniti onoliko koliko je lep niz koji on ima. Pomozite Aleksi da maksimizuje lepotu njegovog niza, kao i da izra\u010duna najmanji broj \u010darobnih mo\u0107i koje mora da iskoristi kako bi dostigao tu vrednost lepote niza. </p> <p>Napomena: u ovom zadatku, podrazumevati da je \\(0^0 = 0\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milenkovi\u0107 Vladimir Milenkovi\u0107 Aleksa Milisavljevi\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza dati su celi brojevi \\(N\\), \\(C\\), i \\(K\\), redom. U slede\u0107oj liniji je dato \\(N\\) celih brojeva, razdvojenih razmakom, koji predstavljaju elemente niza.</p>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvoj liniji standardnog izlaza treba ispisati dva cela broja, gde prvi predstavlja maksimalnu dosti\u017enu vrednost lepote niza, a drugi minimalan broj mo\u0107i koje se moraju iskoristiti kako bi se dostigla ta vrednost.</p>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv1/02_lep_niz/#ulaz","title":"Ulaz","text":"<pre><code>3 1 2\n-5 3 -4\n</code></pre>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#izlaz","title":"Izlaz","text":"<pre><code>57 1\n</code></pre>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv1/02_lep_niz/#ulaz_1","title":"Ulaz","text":"<pre><code>3 0 0\n0 0 0\n</code></pre>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#izlaz_1","title":"Izlaz","text":"<pre><code>0 0\n</code></pre>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru, optimalno je da pove\u0107amo broj 3 na 4, Re\u0161enje je \\(25 + 16 + 16 = 57\\).</p> <p>U drugom test primeru, \\(C = 0\\), te ne mo\u017eemo menjati nijedan element niza. Re\u0161enje je \\(0 + 0 + 0 = 0\\). (videti napomenu)</p>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim podzadacima:</p> <ul> <li>\\(1 \\leq N \\leq 100.000\\)</li> <li>\\(0 \\leq C \\leq 1.000.000.000\\)</li> <li>Svi elementi niza su po apsolutnoj vrednosti manji ili jednaki \\(100.000\\)</li> <li>\\(0 \\leq K \\leq 2\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena: \\(N \\leq 5\\), \\(C \\leq 5\\)</li> <li>U test primerima vrednim 36 poena: \\(N \\leq 1000\\), \\(C \\leq 1000\\)</li> <li>U test primerima vrednim 34 poena:  Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#napomena","title":"Napomena","text":"<p>U ovom zadatku, podrazumevati da je \\(0^0 = 0\\). Ostali stepeni se pona\u0161aju uobi\u010dajeno.</p>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#analiza","title":"Analiza","text":"<p>Zadatak re\u0161avamo razmatranjem vrednosti \\(K\\):</p> <ul> <li>Ako je \\(K=0\\), vrednost svakog stepena \u0107e biti 1, osim vrednosti \\(0^0\\). U tom slu\u010daju treba da prebrojimo koliko ima 0 u nizu i svaku koju mo\u017eemo pove\u0107amo za 1.</li> <li>Ukoliko je \\(K=1\\), lepota niza je suma njegovih elemenata. Tada je svejedno koji \u0107emo element pove\u0107ati, pa samo primenimo svih \\(C\\) operacija na bilo koji element.</li> <li>Ukoliko je \\(K=2\\) i ukoliko budemo primenjivali ijednu operaciju, primeni\u0107emo svih \\(C\\) operacija na najve\u0107i. To va\u017ei, jer pretpostavimo da smo ukupno primenili \\(D\\) operacija i to \\(D_i\\) na element \\(A_i\\) i neka najve\u0107i ima vrednost \\(a\\) tada je kona\u010dna suma: </li> </ul> \\[ \\sum_{i=1}^n (A_i + D_i)^2 = \\sum_{i = 1}^{n} (A_i^2 + 2 \\cdot A_i \\cdot D_i + D_i^2) =  \\] \\[ \\sum_{i = 1}^{n} (A_i^2 + 2 \\cdot A_i \\cdot D_i) +\\sum_{i = 1}^{n} D_i^2 \\leq \\sum_{i = 1}^{n} (A_i^2 + 2 \\cdot a \\cdot D_i) + \\sum_{i = 1}^{n} D_i^2 = \\] \\[ \\sum_{i = 1}^{n} A_i^2 + 2 \\cdot a \\cdot D + \\sum_{i = 1}^{n} D_i^2 \\leq \\sum_{i = 1}^{n} A_i^2 + 2 \\cdot a \\cdot D + D^2, \\] <p>\u0161to je ta\u010dno jednako lepoti niz, kada bi na najve\u0107i dodali \\(D\\). Dakle ukoliko primenjujemo neke operacije, svakako ih primenjujemo na najve\u0107i. Me\u0111utim, primetimo da se tada lepota promenila za \\(2 \\cdot a \\cdot D + D^2\\) \u0161to maksimum dosti\u017ee ili za \\(D=0\\) ili za \\(D=C\\), pa ako budemo primenjivali neku operaciju, primeni\u0107emo svih \\(C\\) na najve\u0107i.</p>"},{"location":"takprog/2018_2019/kv1/02_lep_niz/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Primetimo da, ukoliko je \\(K=2\\), dovoljno je da proverimo da li pove\u0107avanjem najve\u0107eg elementa za \\(C\\), pove\u0107avamo njegovu apsolutnu vrednost, ukoliko je pove\u0107avamo, primeni\u0107emo svih \\(C\\) operacija na njega, u suprotnom, ne\u0107emo primeniti ni jednu operaciju. Primetimo da, ukoliko apsolutna vrednost ostaje ista, ne\u0107emo primeniti ni jednu operaciju, jer te\u017eimo da minimizujemo broj operacija.</p> 02_lep_niz.cpp<pre><code>/*\nVladimir VladaMG98 Milenkovic\nProblem: Dodavanje u kutije\nKvalifikacije 2018/19, prvi krug, drugi zadatak\n*/\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAXN = 100010;\nlong long pw(int a, int b){\n    long long ret = 1;\n    while(b--) ret *= a;\n    return ret;\n}\nint arr[MAXN];\nint n, c, k;\nlong long soln(){\n    long long sol = 0;\n    for(int i = 1; i &lt;= n; i++){\n        sol += pw(arr[i], k);\n    }\n    return sol;\n}\nint main(){\n    scanf(\"%d %d %d\", &amp;n, &amp;c, &amp;k);\n    for(int i = 1; i &lt;= n; i++){\n        scanf(\"%d\", &amp;arr[i]);\n    }\n    if(k == 0){\n        //I should change as many zeros I can to ones\n        int operations_made = 0;\n        int n_zeros = 0;\n        for(int i = 1; i &lt;= n; i++){\n            if(arr[i] == 0) n_zeros++;\n        }\n        operations_made = min(n_zeros, c);\n        int zeros_left = n_zeros - operations_made;\n        int answer = n - zeros_left;\n        printf(\"%d %d\\n\", answer, operations_made);\n    } else if(k == 1){\n        long long ans = soln();\n        printf(\"%lld %d\\n\", ans + c, c);\n    } else if(k == 2){\n        int mx = arr[1]; int ind_mx = 1;\n        for(int i = 2; i &lt;= n; i++){\n            if(arr[i] &gt; mx){\n                mx = arr[i];\n                ind_mx = i;\n            }\n        }\n        int operations;\n        if(abs(mx + c) &gt; abs(mx)){\n            arr[ind_mx] += c;\n            operations = c;\n        } else operations = 0;\n        printf(\"%lld %d\\n\", soln(), operations);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/","title":"3 - Deljenje niza","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 498ms 64MB <p>Perica ima niz od \\(N\\) pozitivnih brojeva i poku\u0161ao je da ga u potpunosti podeli na dva niza uzastopnih brojeva, tako da ta dva niza imaju istu sumu brojeva.</p> <p>Kako to nije uspeo da uradi, malo se iznervirao i odlu\u010dio da uni\u0161ti jedan deo niza (neki uzastopni podniz unutar niza). Nakon uni\u0161tavanja podniza, niz se ponovo spaja. Tako\u0111e, Perica ne sme da uni\u0161ti ceo niz. Da li mo\u017eete da mu pomognete da nakon uni\u0161tenja nekog podniza ostvari svoju prvobitnu zamisao, tako \u0161to \u0107ete da ispi\u0161ete indekse po\u010detka i kraja tog podniza ili -1 ako nema re\u0161enja za Pericu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milovanovi\u0107 Marko Savi\u0107"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se broj \\(N\\), du\u017eina niza. U drugoj liniji nalazi se \\(N\\) pozitivnih brojeva, koji predstavljaju elemente niza. Garantuje se da dati niz nije mogu\u0107e podeliti na dva niza uzastopnih brojeva koji imaju istu sumu.</p>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji ispisati dva broja - indeks po\u010detka i kraja podniza koji uni\u0161tavamo. Indeksi po\u010dinju od 1. Ukoliko takav podniz ne postoji, ispisati -1. Ukoliko postoji vi\u0161e takvih podnizova, ispisati bilo koji.</p>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#ulaz","title":"Ulaz","text":"<pre><code>7\n7 5 9 1 3 9 6\n</code></pre>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#izlaz","title":"Izlaz","text":"<pre><code>3 4\n</code></pre>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 10 100\n</code></pre>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako u prvom primeru uni\u0161timo podniz od 3. do 4. elementa, ostaje nam 7 5 3 9 6, \u0161to mo\u017eemo podeliti na [7,5,3] i [9,6]. Koji god podniz da uni\u0161timo u drugom primeru, nije mogu\u0107e podeliti niz na dva dela sa istom sumom.</p>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq A_i \\leq 10^9\\) </li> <li>\\(1 \\leq N \\leq 8000\\) </li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:  </p> <ul> <li>U test primerima vrednim 15 poena: \\(N \\leq 80\\) </li> <li>U test primerima vrednim 25 poena: \\(N \\leq 400\\) </li> <li>U  test primerima vrednim 25 poena: \\(N \\leq 2000\\) </li> <li>U test primerima vrednim 35 poena: \\(N \\leq 8000\\)</li> </ul>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#analiza","title":"Analiza","text":"<p>Jedna od klju\u010dnih stavki u zadatku jeste garancija da bez izbacivanja, odnosno uni\u0161tenja nekog uzastopnog podniza nije mogu\u0107e podeliti zadati niz tako da su mu podzbirovi nekog prefiksa i ostatka niza jednaki. Tako\u0111e, postavka zadatka uslovljava da su svi \u010dlanovi ulaznog niza strogo pozitivni, \u0161to uz pa\u017eljivo re\u0161avanje pojednostavljuje kompleksnost kori\u0161\u0107enog algoritma pretrage.</p> <p>Najpre, neka je zbir svih \u010dlanova zadatog niza \\(z\\), a zbir \u010dlanova nekog njegovog prefiksa (odnosno sufiksa) \\(p\\). Neophodno je odrediti neki neprazan podniz ulaznog niza koji ne obuhvata prefiks (odnosno sufiks), takav da ako zbir njegovih \u010dlanova ozna\u010dimo sa \\(s\\), mora biti zadovoljen uslov \\(z = p + s + p = 2p + s\\). Drugim re\u010dima, zbir \u010dlanova podniza koji se uni\u0161tava \\(0&lt;s&lt;z\\), mora biti jednak ukupnoj sumi svih \u010dlanova izvornog niza umanjenoj za dvostruku vrednost prefiksa, \\(s=z-2p\\).</p> <p>Sada je potrebno izvr\u0161iti pretragu po svim prefiksima (odnosno sufiksima) i svim uzastopnim podnizovima ulaznog niza i proveriti da li je mogu\u0107e zadovoljiti malopre\u0111a\u0161nju jednakost. Ukoliko bi ta pretraga naivno bila izvr\u0161ena kroz tri nezavisne petlje (prva po prefiksima niza, a druga i tre\u0107a po levoj i desnoj granici podniza za uni\u0161tenje), dobila bi se kubna vremenska slo\u017eenost \\(\\mathcal{O}(N^3)\\) po du\u017eini niza. Me\u0111utim, uz ne\u0161to ve\u0161tiju pretragu po levoj i desnoj granici uzastopnog podniza tu slo\u017eenost mogu\u0107e je i umanjiti.</p>"},{"location":"takprog/2018_2019/kv1/03_deljenje_niza/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Naime, na po\u010detku iteracije po prefiksima (odnosno sufiksima) inicijalizovati levu i desnu granicu na prvi susedni \u010dlan prefiksa (odnosno sufiksa). U svakoj iteraciji neophodno je ispitati da li je vrednost izraza \\(z - 2p - s\\) ve\u0107a, manja ili jednaka nuli, te ako je ve\u0107a, pomerati desnu granicu, a ukoliko je manja, pomerati levu. Pretraga se zavr\u0161ava ili kada izraz poprimi vrednost nula nakon \u010dega sledi ispis utvr\u0111enih granica podniza, ili kada leva i desna granica do\u0111u do kraja izvornog niza, kada se prelazi na slede\u0107i prefiks (odnosno sufiks). Po\u0161to prilikom napredovanja granica mora biti zadovoljen i uslov da indeks leve granice nije vi\u0161i od indeksa desne, to je ukupna slo\u017eenost ove unutra\u0161nje petlje linearna \\(\\mathcal{O}(N)\\) po du\u017eini niza. Kako je neophodno pretragu uraditi za sve prefikse i sufikse izvornog niza (zbog asimetrije pretrage), to je ukupna slo\u017eenost ovog algoritma kvadratna \\(\\mathcal{O}(N^2)\\), \u0161to se i zahtevalo za maksimalan broj poena u ovom zadatku.</p> 03_deljenje_niza.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define MAXN 8005\nusing namespace std;\n//100p\nint n;\nint a[MAXN];\nint main()\n{\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]);\n    long long total_sum=0,s=0;\n    for(int i=0;i&lt;n;i++) total_sum+=a[i];\n    for(int i=0;i&lt;n;i++) {\n        s+=a[i];\n        long long cs=0;\n        int l=i+1,r=i+1;\n        cs=a[i+1];\n        while(l&lt;n &amp;&amp; r&lt;n) {\n            while(r&lt;n &amp;&amp; (r&lt;l || total_sum-cs-s&gt;s)) {\n                r++;\n                cs+=a[r];\n            }\n            if(total_sum-cs-s==s) {\n                printf(\"%d %d\",l+1,r+1);\n                return 0;\n            }\n            cs-=a[l];\n            l++;\n        }\n    }\n    s=0;\n    reverse(a,a+n);\n    for(int i=0;i&lt;n;i++) {\n        s+=a[i];\n        long long cs=0;\n        int l=i+1,r=i+1;\n        cs=a[i+1];\n        while(l&lt;n &amp;&amp; r&lt;n) {\n            while(r&lt;n &amp;&amp; (r&lt;l || total_sum-cs-s&gt;s)) {\n                r++;\n                cs+=a[r];\n            }\n            if(total_sum-cs-s==s) {\n                printf(\"%d %d\",n-r,n-l);\n                return 0;\n            }\n            cs-=a[l];\n            l++;\n        }\n    }\n    printf(\"-1\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/04_postar/","title":"4 - Po\u0161tar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 128MB <p>Kao i obi\u010dno, ovaj zadatak se odnosi na jednu \u010dudnu situaciju -- potrebno je isplanirati isporuke za svemirskog po\u0161tara u 2318. godini. U po\u0161ti, koja se nalazi na planeti sa koordinatama \\((0,0)\\), se nalazi \\(N\\) paketa koje treba dostaviti na razli\u010dite planete, \u010dije su koordinate date (svemir je dvodimenzionalan, koordinate \\(i\\)-te planete su \\((X_i,Y_i)\\)).</p> <p>Svemirski po\u0161tar se mora pridr\u017eavati slede\u0107ih pravila:</p> <ul> <li>Paketi se raznose dva po dva - kada krene iz po\u0161te, po\u0161tar mora   da ode do jedne planete i isporu\u010di paket, zatim od nje direktno do   druge, i nakon toga da se vrati u po\u0161tu (gde \u0107e preuzeti naredna dva   paketa, ako ih jo\u0161 ima).</li> <li>Izme\u0111u planeta (ukljju\u010duju\u0107i i planetu na kojoj je po\u0161ta) se mora kretati pravom linijom (najkra\u0107im putem).</li> <li>Putanja kojom se po\u0161tar kre\u0107e (izlomljena linija koja spaja planete)   ne sme se\u0107i samu sebe.</li> </ul> <p>Va\u0161 zadatak je da prona\u0111ete put koji po\u0161tuje ova tri pravila, takav da mu je ukupna du\u017eina minimalna.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Aleksa Milisavljevi\u0107 Slobodan Mitrovi\u0107"},{"location":"takprog/2018_2019/kv1/04_postar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se jedan prirodan broj \\(N\\) - broj planeta na koje treba odneti pakete. U narednih \\(N\\) linija se nalaze po dva broja \\(X_i\\) i \\(Y_i\\) - koordinate \\(i\\)-te planete.</p>"},{"location":"takprog/2018_2019/kv1/04_postar/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji ispisati jedan realan broj - ukupnu du\u017einu najkra\u0107eg puta koji po\u0161tuje sva pravila. Re\u0161enje \u0107e biti prihva\u0107eno ako se razlikuje od ta\u010dnog za najvi\u0161e \\(10^{-6}\\) (kao relativna ili apsolutna gre\u0161ka).</p>"},{"location":"takprog/2018_2019/kv1/04_postar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv1/04_postar/#ulaz","title":"Ulaz","text":"<pre><code>4\n-1 1\n-1 4\n1 1\n1 4\n</code></pre>"},{"location":"takprog/2018_2019/kv1/04_postar/#izlaz","title":"Izlaz","text":"<pre><code>17.07463838\n</code></pre>"},{"location":"takprog/2018_2019/kv1/04_postar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Najkra\u0107i put koji zadovoljava sva tri pravila je slede\u0107i: \\((0,0) \\rightarrow (-1,1) \\rightarrow (-1,4) \\rightarrow (0,0) \\rightarrow (1, 4) \\rightarrow (1, 1) \\rightarrow (0,0)\\). Kad ne bi bilo tre\u0107eg pravila, po\u0161tar bi mogao da prvo dostavi pakete prvoj i tre\u0107oj, a zatim drugoj i \u010detvrtoj planeti, ali ta putanja nije dozvoljena jer se putevi od po\u0161te do druge planete i od prve do tre\u0107e seku.</p>"},{"location":"takprog/2018_2019/kv1/04_postar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N\\) je parno.</li> <li>Za sve \\(i\\), \\(-10^6 \\leq X_i, Y_i \\leq 10^6\\).</li> <li>Nijedne dve planete (uklju\u010duju\u0107i po\u0161tu) se ne nalaze na istoj poziciji.</li> <li>Nijedne tri planete (uklju\u010duju\u0107i po\u0161tu) nisu kolinearne.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N \\leq 8\\) i za sve \\(i\\) va\u017ei \\(Y_i &gt; 0\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\) i za sve \\(i\\) va\u017ei \\(Y_i &gt; 0\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 500\\) i za sve \\(i\\) va\u017ei \\(Y_i &gt; 0\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 500\\).</li> </ul>"},{"location":"takprog/2018_2019/kv1/04_postar/#analiza","title":"Analiza","text":"<p>Zadatak re\u0161avamo dinami\u010dkim programiranjem.</p> <p>Re\u0161imo prvo zadatak u slu\u010daju da su sve koordinate \\(Y_i\\) pozitivne. Prvo sortiramo ta\u010dke po uglu u odnosu na poziciju po\u0161te. Neka je \\(dp[l][r]\\) najmanja du\u017eina puta, koju po\u0161tar mora da pre\u0111e, da bi obi\u0161ao sve planere u intervalu \\([l,r]\\), ukoliko je to mogu\u0107e i \\(inf\\) u suprotnom.  Neka smo povezali \\(l\\) sa nekom \\(m\\) takvom da je \\(l&lt;m&lt;r\\), to je  \\(dp[l][r] = min_{l&lt;m&lt;r}(dp[l][m]+dp[m+1][r])\\). Druga opcija je da pove\u017eemo planetu \\(l\\) sa \\(r\\). Dovoljno je da proverimo da li du\u017e koja ih spaja se\u010de du\u017e izme\u0111u po\u0161te i neke druge planete. To mo\u017eemo da uradimo u \\(O(N)\\). Ukoliko ne se\u010de, imamo jo\u0161 jednog kandidata za re\u0161enje, pa je onda \\(dp[l][r]=min(dp[l][r],dist(l,r)+dp[l+1][r-1])\\), gde je \\(dist(l,r)\\) rastojanje izme\u0111u planete sa indeksom \\(l\\) i planete sa indeksom \\(r\\). Rezultat je u \\(dp[1][N]\\), a vremenska slo\u017eenost algoritma je \\(O(N^3)\\).</p> <p>Sada mo\u017eemo re\u0161enje da uop\u0161timo na slu\u010daj da koordinate \\(Y_i\\) nisu pozitivne. Primetimo da kako god povezali planete, uvek mo\u017eemo da nacrtamo jednu polupravu iz \\((0,0)\\), koja ne se\u010de ni jednu putanju. Ovo va\u017ei zato \u0161to se putanje me\u0111usobno ne seku. \"Luk\" koji pravi jedan obilazak dve planete mo\u017ee da bude sadr\u017ean u nekom drugom i da sadr\u017ei neki drugi, ali ne mogu da se seku. Sada sortiramo ta\u010dke po uglu. Ako pretpostavimo da smo povukli tu polupravu negde izme\u0111u \\(i\\) i \\(i+1\\) planete, mo\u017eemo da posmatramo niz koji je cikli\u010dno pomeren ulevo za \\(i\\) mesta i da ponovimo dinami\u010dko kao u prethodnom delu. Ovo re\u0161enje radi u slo\u017eenosti \\(O(N^4)\\). </p> <p>Me\u0111utim mo\u017eemo da primetimo da veliki deo tog dinami\u010dkog mi izra\u010dunavamo vi\u0161e puta. Mo\u017eemo da dupliramo sortirani niz, tj. cikli\u010dno ga ponovimo drugi put i ponovo izra\u010dunamo \\(dp[l][r]\\). Primetimo da je sada u \\(dp[i][i+N]\\) upravo re\u0161enje koje se dobija kada bi poluprava bila izme\u0111u planeta \\(i-1\\) i \\(i\\). Pa je krajnji rezultat \\(min_{1 \\leq i \\leq N}(dp[i][i+N])\\). Vremenska slo\u017eenost \\(O(N^3)\\), memorijska slo\u017eenost \\(O(N^2)\\).</p> 04_postar.cpp<pre><code>#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n\nstruct point\n{\n    long long x, y;\n} ;\npoint operator-(point a, point b) { return {a.x - b.x, a.y - b.y}; }\n// (z-component of) cross product\nlong long operator*(point a, point b) { return a.x*b.y - a.y*b.x; }\nconst point ORIGIN = {0, 0};\n\n// we need sorting by polar angle\nbool operator&lt;(point a, point b)\n{\n    // int s_a = (a.y &gt; 0) || (a.y == 0 &amp;&amp; a.x &lt; 0);\n    // int s_b = (b.y &gt; 0) || (b.y == 0 &amp;&amp; b.x &lt; 0);\n    // if(s_a == s_b)\n    //     return a * b &gt; 0;\n    // else return s_a;\n    return std::atan2(a.y, a.x) &lt; std::atan2(b.y, b.x);\n}\n\nconst int N = 1000;\npoint pts[2 * N];\nbool ok[N][N];\ndouble dp[2 * N][2 * N];\nint n;\n\nlong long sgn(long long x) { return x &lt; 0 ? -1 : 1; }\n\nbool diff_side(point a, point b, point x, point y)\n{\n//    printf(\"%lld %lld\\n\", (b-a)*(x-a), (b-a)*(y-a));\n    return sgn((b-a) * (x-a)) != sgn((b-a) * (y-a));\n}\n\nbool intersect(point a, point b, point x, point y)\n{\n//    printf(\"%d%d\\n\", diff_side(a, b, x, y), diff_side(x, y, a, b));\n    return diff_side(a, b, x, y) &amp;&amp; diff_side(x, y, a, b);\n}\n\nbool check_ok(int i, int j)\n{\n    if((j - i) % 2 == 0)\n        return false;\n\n    for(int k = 0; k &lt; n; k++)\n        if(k != i &amp;&amp; k != j)\n        {\n//            printf(\"%d %d %d -&gt; %d\\n\", i, j, k, intersect(pts[i], pts[j], pts[k], ORIGIN));\n            if(intersect(pts[i], pts[j], pts[k], ORIGIN))\n                return false;\n        }\n\n    return true;\n}\n\nbool is_ok(int i, int j)\n{\n    if(j - i &gt;= n) return false; // angle more than full circle\n    if((pts[j] - pts[i]) * (ORIGIN - pts[i]) &lt; 0)\n        return false; // angle more than half-circle\n    return ok[i % n][j % n];\n}\n\nlong long sqr(long long x) { return x * x; }\ndouble dist(int i, int j)\n{\n    return std::sqrt(sqr(pts[i].x - pts[j].x) + sqr(pts[i].y - pts[j].y));\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%lld %lld\", &amp;pts[i].x, &amp;pts[i].y);\n\n    std::sort(pts, pts + n);\n//    for(int i = 0; i &lt; n; i++) fprintf(stderr, \"(%lld, %lld)\\n\", pts[i].x, pts[i].y);\n    for(int i = 0; i &lt; n; i++)\n        pts[i + n] = pts[i];\n\n    // simple O(N^3) precomputation (complexity is dominated by the DP\n    // anyway, no need for a quadratic algorithm here)\n    for(int i = 0; i &lt; n; i++)\n        for(int j = i + 1; j &lt; n; j++)\n            ok[i][j] = ok[j][i] = check_ok(i, j);\n\n    for(int delta = 0; delta &lt; 2 * n; delta++)\n        for(int i = 0; i &lt; 2 * n; i++)\n        {\n            int j = i + delta;\n            if(j &gt;= 2 * n) continue;\n\n            dp[i][j] = INFINITY;\n\n            if(is_ok(i, j))\n                dp[i][j] = dp[i + 1][j - 1] + dist(i, j);\n            for(int k = i + 1; k &lt; j; k++)\n                dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\n            // if(is_ok(i,j) &amp;&amp; dp[i][j] == dp[i+1][j-1] + dist(i,j))\n            //     printf(\"%d %d -&gt; outer\\n\", i, j);\n            // else for(int k = i + 1; k &lt; j; k++)\n            //          if(dp[i][j] == dp[i][k] + dp[k+1][j])\n            //          {printf(\"%d %d -&gt; %d\\n\", i, j, k); break;}\n        }\n\n    double res = INFINITY;\n    for(int i = 0; i &lt; n; i++)\n        res = std::min(res, dp[i][i + n - 1]);\n\n    // for(int i = 0; i &lt; 2 * n; i++)\n    //     for(int j = 0; j &lt; 2 * n; j++)\n    //         printf(\"%10.2lf%c\", dp[i][j], j == 2*n-1 ? '\\n' : ' ');\n    // for(int i = 0; i &lt; n; i++) printf(\"%10.2lf\\n\", dp[i][i+n-1]);\n\n    for(int i = 0; i &lt; n; i++)\n        res += std::sqrt(sqr(pts[i].x) + sqr(pts[i].y));\n\n    // for(int i = 0; i &lt; n; i++)\n    //     for(int j = 0; j &lt;= n; j++)\n    //         printf(\"%c\", j == n ? '\\n' : ok[i][j] ? '+' : '.');\n\n    // double ss = 0;\n    // for(int i = 0; i &lt; n; i++)\n    //     ss += std::sqrt(sqr(pts[i].x) + sqr(pts[i].y));\n    // for(int i = 1; i &lt;= 3; i++)\n    //     printf(\"%d -&gt; %.8lf\\n\", i, ss+dist(0, i) + dist(i == 1 ? 2 : 1, i == 3 ? 2 : 3));\n\n    printf(\"%.8lf\\n\", res);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/05_dodela/","title":"5 - Dodela vrednosti","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 512MB <p>Jaca je pametna maca i za vas ima veoma jednostavan zadatak. Ona \u0107e vam dati prirodne brojeve \\(N\\) i \\(Q\\), nakon \u010dega vi treba da napravite niz \\(a = [1,2,\\ldots,N]\\) (niz se indeksira od \\(1\\)) i da izvr\u0161ite \\(Q\\) njenih naredbi. Svaka naredba ima jedan od slede\u0107a dva oblika:</p> <ul> <li>\\(1\\) \\(u\\) \\(v\\) \\(l\\) - Za svako \\(i \\in \\{0,1,\\ldots,l-1\\}\\) (tim redom), izvr\u0161iti naredbu dodele \\(a_{u+i} \\leftarrow a_{v+i}\\) (\\(a_{u+i}\\) dobija vrednost koju u tom trenutku ima \\(a_{v+i}\\))</li> <li>\\(2\\) \\(x\\) - Recite Jaci trenutnu vrednost \\(a_x\\)</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Vladimir Milenkovi\u0107 <p>Odr\u017eavajmo u svakom trenutku graf sa slede\u0107im osobinama:</p> <ul> <li>Postoje tri vrste \u010dvorova, \"unutra\u0161nji\", \"listovi\" i jedan specijalan \"prazan\" \u010dvor. Unutra\u0161nji \u010dvorovi imaju ta\u010dno dve izlazne grane, koje \u0107emo zvati \"levom\" i \"desnom\". Listovi nemaju izlazne grane i \u010duvaju jednu celobrojnu vrednost, koju \u0107emo zvati \"labela\".</li> <li>Graf je \"nepromenljiv\", odnosno, nije mogu\u0107e izmeniti osobine postoje\u0107ih \u010dvorova. Mogu\u0107e je samo dodavati nove \u010dvorove.</li> <li>Svaki \u010dvor \u010duva veli\u010dinu iz njega dosti\u017enog dela grafa. Za listove, ova veli\u010dina iznosi \\(1\\). Za unutra\u0161nje \u010dvorove, ova veli\u010dina jednaka je zbiru veli\u010dina \u010dvorova do kojih se sti\u017ee pomo\u0107u leve i desne grane. Za prazan \u010dvor ova veli\u010dina je \\(0\\).</li> <li>Analogno defini\u0161emo dosti\u017eni niz labela za neki \u010dvor. Za listove, to je niz od jednog elementa - njegova labela. Za unutra\u0161nje \u010dvorove niz se dobija konkatenacijom nizova levog i desnog \u010dvora. Za prazan \u010dvor je prazan niz.</li> </ul> <p>Pored grafa, odr\u017eavajmo i pokaziva\u010d \\(R\\) na \u010dvor \u010diji \u0107e dosti\u017eni niz labela biti jednak trenutnoj vrednosti niza \\(a\\). Upite tipa \\(2\\) re\u0161avamo veoma jednostavno, kre\u0107emo iz \u010dvora \\(R\\) i spu\u0161tamo se levo ili desno u zavisnosti od toga kom elementu niza \u017eelimo da pristupimo, sve dok ne do\u0111emo do lista. </p> <p>Upite prvog tipa re\u0161avamo pomo\u0107u slede\u0107ih operacija nad grafom:</p> <ul> <li><code>seci(x, s)</code>, vra\u0107a dva pokaziva\u010da na \u010dvorove, gde je prvi \u010dvor takav da je njegov dosti\u017eni niz jednak prefiksu dosti\u017enog niza za \u010dvor \\(x\\) du\u017eine \\(s\\), a dosti\u017eni niz drugog \u010dvora je jednak ostatku dosti\u017enog niza za \u010dvor \\(x\\).</li> <li><code>spoji(x, y)</code> vra\u0107a \u010dvor \u010diji je dosti\u017eni niz jednak konkatenaciji dosti\u017enih nizova za \u010dvorove \\(x\\) i \\(y\\). Ova operacija se mo\u017ee izvesti na dva na\u010dina o \u010demu \u0107e biti vi\u0161e re\u010di kasnije.</li> <li><code>pomnozi(x, k)</code> vra\u0107a \u010dvor \u010diji je dosti\u017eni niz jednak konkatenaciji \\(k\\) dosti\u017enih nizova za \u010dvor \\(x\\). </li> </ul> <p>Na\u0161 cilj je da sve tri operacije rade brzo. Ta\u010dnije, sve tri operacije radi\u0107e u slo\u017eenosti linearnoj po dubini grafa po\u010dev od datog \u010dvora ili \u010dvorova, zato \u0107e nama biti cilj da se ova dubina ne pove\u0107ava previ\u0161e u toku rada.</p> <p>Slede skice mogu\u0107ih realizacija ove tri operacije:</p> <ul> <li><code>seci(x, s)</code>, ukoliko je \\(s\\) manje od veli\u010dine levog \u010dvora od \\(x\\), pravimo kopiju \\(y\\) \u010dvora \\(x\\) \u010diji levi \u010dvor se\u010demo rekurzivno. Prvi \u010dvor rezultata rekurzivnog poziva vratimo kao prvi \u010dvor, dok drugi \u010dvor rezultata rekurzivnog poziva zaka\u010dimo kao levi \u010dvor \u010dvora \\(y\\) i kao drugi \u010dvor vratimo upravo \\(y\\). U suprotnom, analogno se\u010demo desni \u010dvor.</li> <li><code>spoji(x, y)</code>, nasumi\u010dno izaberemo jedan od ta dva \u010dvora (recimo da je to \u010dvor \\(x\\)), napravimo njegovu kopiju \\(z\\), rekurzivno spojimo desni \u010dvor \u010dvora \\(z\\) i \u010dvor \\(y\\) i rezultat zaka\u010dimo kao desni \u010dvor \\(z\\), zatim vratimo \\(z\\).</li> <li><code>pomnozi(x, k)</code>, kako \u0107e va\u017eiti \\(k \\leq n &lt; 2^{20}\\), napravimo \u010dvorove \\(y_0, y_1, \\ldots, y_{19}\\), gde je \\(y_0\\) kopija \u010dvora \\(x\\), a za \\(i &gt; 0\\) je \\(y_i\\) \u010dvor koji se dobija \"prostim\" (nerekurzivnim) spajanjem \u010dvora \\(y_{i-1}\\) sa samim sobom. Ta\u010dnije, \u010dvoru \\(y_i\\) \u0107e i leva i desna grana pokazivati na \u010dvor \\(y_{i-1}\\). Sada je jasno da je niz \u010dvora \\(y_i\\) jednak konkatenaciji \\(2^i\\) nizova \u010dvora \\(x\\). Zatim samo izaberemo stepene dvojke u binarnom zapisu broja \\(k\\) i ponovo prostim spajanjem napravimo rezultuju\u0107i \u010dvor, vode\u0107i ra\u010duna da spajamo od manjih ka ve\u0107im stepenima.</li> </ul> <p>Sada, zadatak re\u0161avamo na slede\u0107i na\u010din. Graf inicijalizujemo kao binarno stablo \u010diji listovi redom imaju labele od \\(1\\) do \\(N\\) i \\(R\\) postavljamo za koren tog stabla. U ve\u0107ini slu\u010dajeva samo se\u010demo delove niza za \u010dvor \\(R\\) i sastavljamo ih u nekom drugom redosledu. Jedini nezgodan slu\u010daj jeste taj kada je \\(u &gt; v\\) i \\(l &gt; u-v\\). Tada se jedno par\u010de originalnog niza cikli\u010dno ponavlja odre\u0111en broj puta, i tu nam je potrebna efikasna operacija <code>pomnozi</code>.</p> <p>Jedna mogu\u0107a optimizacija jeste da, kada broj \u010dvorova prebaci neku unapred zadatu granicu (recimo par miliona), izra\u010dunamo ceo dosti\u017ean niz iz \u010dvora \\(R\\), obri\u0161emo sve \u010dvorove i \"po\u010dnemo ispo\u010detka\" sa tim nizom.</p> <p>Vremenska i memorijska slo\u017eenost: \\(N + Q \\log N\\).</p> 05_dodela.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int MAX_LOG = 20;\nconst int MAX_NODES = 10000000;\nconst int CRITICAL_NODES = 5000000;\n\nbool odluka() {\n    static unsigned x = 0;\n    x += 1111111111;\n    return x &lt; 0x80000000u;\n}\n\nstruct cvor {\n    int l, r, s;\n} a[MAX_NODES]; int z; // a[0] = {0, 0, 0}\n\nint kopija(int c) {\n    a[++z] = a[c];\n    return z;\n}\n\nvoid fixs(int x) {\n    if (a[x].l == -1)\n        a[x].s = 1;\n    else\n        a[x].s = a[a[x].l].s + a[a[x].r].s;\n}\n\npair&lt;int, int&gt; seci(int x, int s) {\n    if (!x)\n        return {0, 0};\n    if (!s)\n        return {0, x};\n    if (a[x].l == -1)\n        return {s ? x : 0, s ? 0 : x};\n    int y = kopija(x), p = a[a[x].l].s;\n    if (s &lt;= p) {\n        auto w = seci(a[y].l, s);\n        a[y].l = w.second;\n        fixs(y);\n        return {w.first, y};\n    } else {\n        auto w = seci(a[y].r, s - p);\n        a[y].r = w.first;\n        fixs(y);\n        return {y, w.second};\n    }\n}\n\nint spoji(int x, int y) {\n    if (!x) return y;\n    if (!y) return x;\n    if (a[x].l == -1 &amp;&amp; a[y].l == -1) {\n        int z = kopija(0);\n        a[z] = {x, y, 2};\n        return z;\n    }\n    bool levo = odluka();\n    if (a[x].l == -1)\n        levo = false;\n    else if (a[y].l == -1)\n        levo = true;\n    if (levo) {\n        int z = kopija(x);\n        a[z].r = spoji(a[z].r, y);\n        fixs(z);\n        return z;\n    } else {\n        int z = kopija(y);\n        a[z].l = spoji(x, a[z].l);\n        fixs(z);\n        return z;\n    }\n}\n\nint trazi(int x, int s) {\n    if (a[x].l == -1)\n        return a[x].r;\n    int p = a[a[x].l].s;\n    if (s &lt; p)\n        return trazi(a[x].l, s);\n    else\n        return trazi(a[x].r, s-p);  \n}\n\nint spoji_spolja(int x, int y) {\n    int z = kopija(0);\n    a[z] = {x, y, a[x].s + a[y].s};\n    return z;\n}\n\nint dupliraj(int x) {\n    return spoji_spolja(x, x);\n}\n\nint pomnozi(int x, int k) {\n    if (!k) return 0;\n    int y[MAX_LOG];\n    y[0] = x;\n    for (int i=1; i&lt;MAX_LOG; i++)\n        y[i] = dupliraj(y[i-1]);\n    int z = -2;\n    for (int i=0; i&lt;MAX_LOG; i++) {\n        if (k &amp; (1 &lt;&lt; i)) {\n            if (z == -2)\n                z = y[i];\n            else\n                z = spoji_spolja(z, y[i]);\n        }\n    }\n    return z;\n}\n\nint napravi(int l, int r, basic_string&lt;int&gt;&amp; v) {\n    if (l == r) {\n        int z = kopija(0);\n        a[z] = {-1, v[l], 1};\n        return z;\n    } else {\n        int m = (l+r) &gt;&gt; 1;\n        return spoji_spolja(napravi(l, m, v), napravi(m+1, r, v));\n    }\n}\n\nvoid procitaj_rek(int x, basic_string&lt;int&gt;&amp; v) {\n    if (!x) return;\n    if (a[x].l == -1) {\n        v += a[x].r;\n        return;\n    }\n    procitaj_rek(a[x].l, v);\n    procitaj_rek(a[x].r, v);\n}\n\nvoid stampaj(int x) {\n    basic_string&lt;int&gt; v;\n    procitaj_rek(x, v);\n    for (int x : v)\n        cerr &lt;&lt; x &lt;&lt; ' ';\n    cerr &lt;&lt; '\\n';\n}\n\nbasic_string&lt;int&gt; seci(int x, basic_string&lt;int&gt; v) {\n    basic_string&lt;int&gt; r;\n    for (int s : v) {\n        auto p = seci(x, s);\n        r += p.first;\n        x = p.second;\n    }\n    return r;\n}\n\nint spoji(basic_string&lt;int&gt; v) {\n    int x = 0;\n    for (int y : v)\n        x = spoji(x, y);\n    return x;\n}\n\nint osvezi(int x) {\n    basic_string&lt;int&gt; v;\n    procitaj_rek(x, v);\n    memset(a, 0, (z + 1) * sizeof(cvor));\n    z = 0;\n    return napravi(0, v.size()-1, v);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    int x;\n    {\n        basic_string&lt;int&gt; a(n, 0);\n        iota(a.begin(), a.end(), 1);\n        x = napravi(0, n-1, a);\n    }\n    for (int _q=0; _q &lt; q; _q++) {\n        int t;\n        cin &gt;&gt; t;\n        if (t == 1) {\n            int u, v, l;\n            cin &gt;&gt; u &gt;&gt; v &gt;&gt; l;\n            u--, v--;\n            if (u &lt; v) {\n                if (v-u &gt;= l) {\n                    auto p = seci(x, {u, l, v-u-l, l, n-v-l});\n                    x = spoji({p[0], p[3], p[2], p[3], p[4]});\n                } else {\n                    auto p = seci(x, {u, v-u, u+l-v, v-u, n-v-l});\n                    x = spoji({p[0], p[2], p[3], p[3], p[4]});\n                }\n            } else if (u &gt; v) {\n                if (u-v &gt;= l) {\n                    auto p = seci(x, {v, l, u-v-l, l, n-u-l});\n                    x = spoji({p[0], p[1], p[2], p[1], p[4]});\n                } else {\n                    int kol = l / (u - v);\n                    int ost = l % (u - v);\n                    auto p = seci(x, {v, ost, u-v-ost, l, n-u-l});\n                    int ponovljeno = pomnozi(spoji(p[1], p[2]), 1 + kol);\n                    x = spoji({p[0], ponovljeno, p[2], p[4]});\n                }\n            }\n        } else {\n            int u;\n            cin &gt;&gt; u;\n            cout &lt;&lt; trazi(x, u-1) &lt;&lt; '\\n';\n        }\n        if (z &gt; CRITICAL_NODES)\n            x = osvezi(x);\n    }\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv1/05_dodela/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se prirodni brojevi \\(N\\) - veli\u010dina niza i \\(Q\\) - broj upita. Narednih \\(Q\\) linija mogu biti oblika \\(1\\) \\(u\\) \\(v\\) \\(l\\) ili \\(2\\) \\(x\\). U prvom slu\u010daju va\u017ei \\(u,v \\geq 1\\) i \\(u+l-1,v+l-1\\leq N\\), a u drugom \\(1 \\leq x \\leq N\\).</p>"},{"location":"takprog/2018_2019/kv1/05_dodela/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki upit tipa \\(2\\) u poseban red standardnog izlaza ispisati tra\u017eeni broj.</p>"},{"location":"takprog/2018_2019/kv1/05_dodela/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv1/05_dodela/#ulaz","title":"Ulaz","text":"<pre><code>6 4\n1 1 5 1\n2 1\n1 3 1 4\n2 6\n</code></pre>"},{"location":"takprog/2018_2019/kv1/05_dodela/#izlaz","title":"Izlaz","text":"<pre><code>5\n2\n</code></pre>"},{"location":"takprog/2018_2019/kv1/05_dodela/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Nakon prve izmene niz \u0107e izgledati ovako: \\([5,2,3,4,5,6]\\), u drugom upitu Jaca nam tra\u017ei da joj ka\u017eemo \\(a_1\\), \u0161to iznosi \\(5\\). Nakon druge izmene (tre\u0107i upit) niz \u0107e izgledati ovako: \\([5,2,5,2,5,2]\\). U \u010detvrtom upitu Jaca nas pita za \\(a_6\\), \u0161to iznosi \\(2\\).</p>"},{"location":"takprog/2018_2019/kv1/05_dodela/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N \\leq 1.000.000, Q \\leq 100.000\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 10 poena: \\(N, Q \\leq 5.000\\)</li> <li>U test primerima vrednim 30 poena: Svi upiti tipa \\(2\\) se nalaze posle svih upita tipa \\(1\\)</li> <li>U test primerima vrednim 30 poena: U upitima tipa \\(1\\) va\u017ei \\(|u-v| \\geq l\\)</li> <li>U test primerima vrednim 30 poena: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/","title":"1 - Nadovezivanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 128MB <p>Ove godine, Komisija je odlu\u010dila da svim takmi\u010darima pokloni ne\u0161to lepo, tako da ste na poklon dobili tri broja \\(A\\), \\(B\\) i \\(C\\). Iznena\u0111eni ovim pre svega korisnim poklonom, odlu\u010dili ste da vam je i jedan broj dovoljan, tako da \u0107ete ova tri broja spojiti u jedan nadovezivanjem (na primer, ako ste dobili brojeve \\(50\\), \\(2\\) i \\(7\\), mo\u017eete ih spojiti u \\(7502\\)).</p> <p>Naravno, postoji vi\u0161e na\u010dina da spojite tri broja, i odlu\u010dili ste da odaberete onaj koji \u0107e vam dati najve\u0107i broj. Va\u0161 zadatak je da napi\u0161ete program koji \u0107e, za data tri broja, prona\u0107i najve\u0107i broj koji je mogu\u0107e dobiti njihovim nadovezivanjem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dimitrije Erdeljan Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se tri cela broja \\(A\\), \\(B\\) i \\(C\\): brojevi koje ste dobili na poklon.</p>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji ispisati najve\u0107i broj koji je mogu\u0107e dobiti nadovezivanjem data tri broja.</p>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#ulaz","title":"Ulaz","text":"<pre><code>15 9 12\n</code></pre>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#izlaz","title":"Izlaz","text":"<pre><code>91512\n</code></pre>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#ulaz_1","title":"Ulaz","text":"<pre><code>10 102 10\n</code></pre>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#izlaz_1","title":"Izlaz","text":"<pre><code>1021010\n</code></pre>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Brojevi koje mo\u017eemo dobiti spajanjem \\(15\\), \\(9\\) i \\(12\\) u prvom primeru su: \\(15|9|12\\), \\(15|12|9\\), \\(9|15|12\\), \\(9|12|15\\), \\(12|15|9\\) i \\(12|9|15\\). Najve\u0107i od ovih brojeva je \\(91512\\).</p> <p>U drugom primeru mo\u017eemo dobiti \\(10|10|102\\), \\(10|102|10\\) i \\(102|10|10\\), tako da je re\u0161enje \\(1021010\\).</p>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq A, B, C\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(A, B &lt; 10\\) i \\(C &lt; 100\\).</li> <li>U test primerima vrednim 40 poena: \\(A, B, C \\leq 1000\\).</li> <li>U test primerima vrednim 20 poena: \\(A, B, C \\leq 10^9\\).</li> <li>U test primerima vrednim 20 poena: \\(A, B, C \\leq 10^{18}\\).</li> </ul>"},{"location":"takprog/2018_2019/kv2/01_nadovezivanje/#analiza","title":"Analiza","text":"<p>Zadatak re\u0161avamo jednostavnom proverom slu\u010dajeva, napravimo svih 6 permutacija i proverimo koja ima najve\u0107u vrednost. Primetimo da su brojevi preveliki da bi stali u tip <code>int</code> u C++, ali mo\u017eemo koristiti tip <code>long long</code>. Me\u0111utim, najpogodnije je da brojeve u\u010ditamo kao <code>string</code>. Tada se operacija spajanja tri broja u nekom redosledu svodi na konkateniranje stringova. U C++ konkateniranje dva stringa <code>A</code> i <code>B</code> realizujemo sa <code>A+B</code>. Funkcija <code>max</code> u C++ vra\u0107a leksikografski ve\u0107i string, ako su joj argumenti stringovi. U na\u0161em slu\u010daju, po\u0161to \u0107e svih 6 permutacija (<code>A+B+C</code>, <code>A+C+B</code>, <code>B+A+C</code>, <code>B+C+A</code>, <code>C+A+B</code> i <code>C+B+A</code>) imati istu du\u017einu, leksikografski najve\u0107a permutacija je i najve\u0107i broj koji mo\u017eemo dobiti pri spajanju brojeva \\(A\\), \\(B\\) i \\(C\\).</p> 01_nadovezivanje.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string a, b, c;\n    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    std::string res = a + b + c;\n    res = std::max(res, a + c + b);\n    res = std::max(res, b + a + c);\n    res = std::max(res, b + c + a);\n    res = std::max(res, c + a + b);\n    res = std::max(res, c + b + a);\n\n    std::cout &lt;&lt; res &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/","title":"2 - Dobri pravougaonici","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Ozlogla\u0161eni gospodar svih glodara, \u0106rle, namerava da pokori ceo svet. Me\u0111utim, dobar deo Perine farme \u0107e da poslu\u017ei za sada.</p> <p>Perinu farmu mo\u017eemo predstaviti kao matricu \\(M\\) dimenzije \\(N \\times N\\) gde polje \\(M_{ij}\\) sadr\u017ei jedan broj -- sortu jabuke koju Pera uzgaja na tom polju. Poznato je da Pera obele\u017eava sorte nekim brojevima izme\u0111i \\(1\\) i \\(K\\).</p> <p>\u010cudni su putevi pacovski, te \u0106rletova regularna vojska mo\u017ee da pokori jedino pogodne teritorije. Ka\u017eemo da je teritorija pogodna ako je pravougaonog oblika, sadr\u017ei samo jednu sortu jabuke i ta sorta se nalazi samo u okviru te teritorije.</p> <p>Unajmljivanje elitnih \u0161takora ko\u0161ta previ\u0161e, te \u0106rleta zanima koliko pogodnih teritorija ima Perina farma (ni on sam ne zna za\u0161to). Po\u0161to je \u0106rle previ\u0161e zauzet jedenjem sira, zamolio vas je da to odredite umesto njega.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Mom\u010dilo Topalovi\u0107 Vladimir Milenkovi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(K\\) - dimenzija Perine farme, i broj sorti jabuka koje Pera poznaje. U \\((i+1)\\)-voj liniji (\\(1 \\leq i \\leq N\\)) standardnog ulaza nalazi se \\(N\\) brojeva odvojenih razmacima koji predstavljaju \\(i\\)-tu vrstu Perine farme (\\(j\\)-ti broj predstavlja \\(M_{ij}\\)). </p>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu standardnog izlaza ispisati jedan broj - broj pogodnih teritorija koje Perina farma sadr\u017ei.</p>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#ulaz","title":"Ulaz","text":"<pre><code>5 10\n3 2 2 1 4\n3 2 2 7 4\n8 2 2 1 3\n8 8 9 9 9\n8 8 1 5 1\n</code></pre>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#izlaz","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Pogodne teritorije su one teritorije koje sadr\u017ee brojeve 2, 4, 5, 7 i 9.</p>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei:</p> <ul> <li>\\(1 \\leq N \\leq 2000\\).</li> <li>\\(1 \\leq K \\leq 10^6\\).</li> <li>\\(1 \\leq M_{ij} \\leq K\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N \\leq 20\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\), \\(K \\leq .100\\)</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\).</li> <li>U test primerima vrednim 20 poena: \\(K = 2\\).</li> <li>U test primerima vrednim 20 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#analiza","title":"Analiza","text":"<p>Primetimo da je \\(K &lt;= 1000000\\), pa ukoliko mi mo\u017eemo da u \\(O(1)\\) proverimo da li su svi brojevi jednaki nekom broju u istom pravougaoniku, mi mo\u017eemo re\u0161iti zadatak u \\(O(K)\\), \u0161to je slo\u017eenost koja je dovoljno dobra. Ukoliko posmatramo sve vrednosti koje su jednake nekom broju \\(A\\), jedini kandidat za dobar pravougaonik koji sadr\u017ei samo brojeve \\(A\\) je najmanji pravougaonik koji sadr\u017ei sve njih (ukoliko bi bio neki ve\u0107i, sigurno bi postojao broj koji nije jednak tom broju, ukoliko bi bio neki manji, postojao bi broj jednak tom broju koji nije u njemu). Sada, provera da li je taj pravouganik dobar je ekvivalentna proveri da li je povr\u0161ina tog pravougaonika jednaka broju pojavljivanja broja \\(A\\) u matrici (zato \u0161to svako pojavljivanje tog broja mora biti u tom pravougaoniku).</p>"},{"location":"takprog/2018_2019/kv2/02_dobri_pravougaonici/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Prvo, \u017eelimo da unapred izra\u010dunamo, za svaki broj, koji je njegov odgovoraju\u0107i pravougaonik. On \u0107e se prostirati od najmanjeg reda u kom postoji taj broj do najve\u0107eg, i od najmanje kolone u kojoj postoji taj broj, do najve\u0107e. Tako\u0111e, mo\u017eemo izra\u010dunati i broj pojavljivanja svakog broja. Onda, jednom petljom, idemo po svih brojevima od \\(1\\) do \\(K\\) i proveravamo da li je kandidat pravouganik dobar, u \\(O(1)\\).</p> <p>\u0160to se ti\u010de slo\u017eenosti, treba nam \\(O(N^2)\\) za preprocesiranje, i \\(O(K)\\) za sve provere, tako da je ukupna slo\u017eenost \\(O(N^2 + K)\\).</p> 02_dobri_pravougaonici.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAXK = 1000010;\nint min_x[MAXK], min_y[MAXK], max_x[MAXK], max_y[MAXK];\nint cnt[MAXK];\nint main(){\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    assert(n &lt;= 5000);\n    assert(k &lt;= 1000000);\n    m = n;\n    for(int i = 1; i &lt;= k; i++){\n        min_x[i] = INT_MAX;\n        min_y[i] = INT_MAX;\n        max_x[i] = INT_MIN;\n        max_y[i] = INT_MIN;\n    }\n    for(int i = 1; i &lt;= n; i++){\n        for(int j = 1; j &lt;= m; j++){\n            int value;\n            cin &gt;&gt; value;\n            assert(1 &lt;= value);\n            assert(value &lt;= k);\n            cnt[value] += 1;\n            min_x[value] = min(min_x[value], i);\n            max_x[value] = max(max_x[value], i);\n            min_y[value] = min(min_y[value], j);\n            max_y[value] = max(max_y[value], j);\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i &lt;= k; i++){\n        if(cnt[i] == 0) continue;\n        if((max_x[i] - min_x[i] + 1) * (max_y[i] - min_y[i] + 1) == cnt[i]){\n            ans += 1;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv2/03_rokada/","title":"3 - Rokada","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Perica voli da igra \u0161ah, ali \u010desto gubi stvari i zaboravlja pravila. Roditelji su mu zbog toga kupili mnogo garnitura i tabli za \u0161ah, me\u0111utim on ih je sve izgubio, osim topova koji su mu omiljene figure pa ih zbog toga dr\u017ei u posebnoj fioci.</p> <p>Perica je odlu\u010dio da se igra i poku\u0161ao da se seti pravila \u0161aha, za po\u010detak se\u0107a se da je postojala tabla pa je zbog toga na kartonu nacrtao tablu sa \\(N\\) vrsta i \\(M\\) kolona. Odlu\u010dio je da svako polje ili ostavi prazno ili da u njega stavi ta\u010dno jednu od \u0161est vrsta igra\u010daka kojih najvi\u0161e ima, naime ili auti\u0107 ili kockicu na kojoj je napisan neki od brojeva 0 do 4.</p> <p>Na\u017ealost, jedini deo \u0161aha kog se Perica se\u0107a, sem pomenutih, je na\u010din na koji se pomera top, to mu je ipak omiljena figura (za one koji ni to ne znaju, top se u jednom potezu mo\u017ee pomeriti na neko drugo polje u svojoj koloni ili vrsti). Zato je odlu\u010dio da postavi izvestan broj topova na prazna polja svoje table i pomera ih, naravno bez podizanja sa table, pa top ne mo\u017ee da pre\u0111e preko polja na kom se ve\u0107 nalazi neka igra\u010dka. Dok je to \u010dinio shvatio je da igra nije previ\u0161e zanimljiva ako je na tabli previ\u0161e topova, jer se \u010desto nalaze jedan drugome na putu, a ni ako je na tabli premalo topova jer u tom slu\u010daju nema \u010dime da se igra, pa je uveo slede\u0107a pravila:</p> <ol> <li>Ni jedan top se ne sme nalaziti na polju na koje drugi top mo\u017ee da do\u0111e u jednom potezu.</li> <li>Ukoliko je na nekom polju kockica sa brojem \\(K\\), na njemu susednim poljima mora da se nalazi ta\u010dno \\(K\\) topova. (Polja su susedna ako dele stranicu, dakle svako polje ima najvi\u0161e \u010detiri susedna polja.)</li> <li>Za svako polje koje je na po\u010detku igre bilo prazno mora na tabli postojati top koji u najvi\u0161e jednom potezu mo\u017ee da do\u0111e na to polje.</li> </ol> <p>Perica je brzo primetio da pre nego \u0161to po\u010dne da se igra mora prvo da prona\u0111e po\u010detnu postavku topova, ukoliko takva uop\u0161te postoji, a koja po\u0161tuje navedena pravila za njegovu tablu. Va\u0161 zadatak je da pomognete Perici da po\u010dne da se igra tako \u0161to \u0107ete za zadatu po\u010detnu tablu prona\u0107i postavku topova koja po\u0161tuje sva zadata pravila, ili zaklju\u010diti da takva tabla ne postoji.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161ko Obradovi\u0107 Nikola Spasi\u0107 Dragan Urosevi\u0107 Mom\u010dilo Topalovi\u0107"},{"location":"takprog/2018_2019/kv2/03_rokada/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalaze se dva cela broja, \\(N\\) - broj vrsta i \\(M\\) - broj kolona table. U svakoj od narednih \\(N\\) linija ulaza nalazi se po \\(M\\) znakova ('.', '#', '0', '1', '2', '3' ili '4'), koji ozna\u010davaju da se u odgovaraju\u0107em polju  '.' - ne nalazi ni\u0161ta (prazno je) '#' - nalazi auti\u0107 '0', '1', '2', '3' ili '4' - nalazi kockica koja pokazuje odgovaraju\u0107i broj.</p>"},{"location":"takprog/2018_2019/kv2/03_rokada/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko tra\u017eena konfiguracija ne postoji ispisati \\(-1\\), dok ukoliko postoji potrebno je ispisati matricu dimenzija ulazne matrice, \u010dija su polja ista kao odgovaraju\u0107a polja u ulaznoj matrici, s tim da se prazno polje, '.', mo\u017ee zameniti sa 'C' ukoliko na to polje treba staviti topa u postavci.</p>"},{"location":"takprog/2018_2019/kv2/03_rokada/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv2/03_rokada/#ulaz","title":"Ulaz","text":"<pre><code>5 6\n.#01.1\n2.....\n0.....\n......\n#...2.\n</code></pre>"},{"location":"takprog/2018_2019/kv2/03_rokada/#izlaz","title":"Izlaz","text":"<pre><code>C#01C1\n2C....\n0.....\n..C...\n#..C2C\n</code></pre>"},{"location":"takprog/2018_2019/kv2/03_rokada/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv2/03_rokada/#ulaz_1","title":"Ulaz","text":"<pre><code>2 2\n0.\n.2\n</code></pre>"},{"location":"takprog/2018_2019/kv2/03_rokada/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2018_2019/kv2/03_rokada/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim primerima va\u017ei \\(1 \\leq N, M \\leq 10\\).</p> <ul> <li>U test primerima vrednim 10 poena: Sva polja su prazna na po\u010detku.</li> <li>U test primerima vrednim 20 poena: \\(1 \\leq N, M \\leq 2\\).</li> <li>U test primerima vrednim 30 poena: \\(1 \\leq N, M \\leq 5\\).</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv2/03_rokada/#analiza","title":"Analiza","text":"<p>Ovaj problem se mo\u017ee re\u0161iti primenom bektreka (backtracking). Ali da bi se bektrek ubrzao (tj. bio efikasniji), na po\u010detku se uradi preprocesiranje u kome se za svako polje na kome se nala\u0455i kockica odredi koliko u njegovom susedstvu ima slobodnih polja ili polja na koja je ve\u0107 postavljen top i ako se taj broj poklapa sa brojem na kockici, onda se i na preostala slobodna polja postave topovi. Pri postavljanju topova markiraju se sva slobodna polja do kojih mo\u017ee sti\u0107i taj top (to \u0107e nam kasnije omogu\u0107iti efikasnu proveru da li do svakog slobodnog polja mo\u017ee sti\u0107i neki top). Nakon toga se proveri da li postoji polje na kome se nalazi kockica takvo da je broj susednih polja koja su slobodna ili se na njima nalazi top manji od broja na kockici. Ako takvo polje postoji onda nije mogu\u0107e rasporediti topove na tu tablu tako da zadovoljavaju sva ograni\u010denja, ispisuje broj \\(-1\\) i prekida izvr\u0161avanje programa.</p> <p>Posle ove pripremne faze zapo\u010dinje se raspore\u0111ivanje preostalih topova. To se izvodi tako \u0161to se obra\u0111uje jedno po jedno polje table (na primer, vrsta po vrsta). Obrada narednog polja se obavlja pozivom funkcije, koja kao argumente dobija vrstu i kolonu u kojoj se nalazi to polje, a kao rezultat vra\u0107a informaciju da li je ostatak table uspe\u0161no obra\u0111en/popunjen. Ako je polje koje trenutno obra\u0111ujemo zauzeto ili se na njega ne mo\u017ee postaviti top zato \u0161to bi onda oko neke kockice bilo previ\u0161e topova, prelazi se na slede\u0107e polje (tj. poziva funkcija za obradu slede\u0107eg polja). U suprotnom se za to polje probaju dve varijante. Prva varijanta je da se na to polje postavi top, markiraju polja do kojih mo\u017ee sti\u0107i taj top i nastavi sa obradom slede\u0107eg polja na tabli. Ta obrada se obavlja tako \u0161to se rekurzivno poziva funkcija za obradu polja koja kao argumente dobija koordinate (vrstu i kolonu) polja koje se obra\u0111uje. Ako je ostatak table uspe\u0161no popunjen, druga varijanta se ne razmatra ve\u0107 se prekida izvr\u0161avanje i vra\u0107a informacija da je uspe\u0161no popunjena tabla. U suprotnom, ako ostatak table nije uspe\u0161no popunjen, razmatra se druga varijanta, u kojoj se na to polje ne raspore\u0111uje top, ve\u0107 se prelazi na naredno polje table, tj. rekurzivno poziva  funkcija za re\u0161avanje slede\u0107eg polja. Ako se re\u0161avanje ostatka table uspe\u0161no zavr\u0161i, onda funkcija vra\u0107a informaciju da je ostatak table uspe\u0161no re\u0161en, u suprotnom, vra\u0107a informaciju da ostatak table nije uspe\u0161no re\u0161en. </p> <p>Kada se obrade sva polja table, tj. pozove funkcija za obradu polja koje se nalai vrsti broj \\(M+1\\) i koloni broj \\(1\\), proverava se da li je popunjavanje korektno/ispravno: broj topova oko svake kockice se poklapa sa brojem na kockici i do svakog slobodnog polja mo\u017ee sti\u0107i neki od topova. Ako je popunjavanje table ispravno funkcija vra\u0107a informaciju da je tabla popunjena ispravno, u suprotnom, vra\u0107a informaciju da tabla nije uspe\u0161no popunjena.  Da bi se dodtno ubrzao postupak, mo\u017ee se pri svakom pozivu funkcije za obradu polja proveravati da li postoji kockica takva da je zbir broja postavljenih topova na susednim poljima i broja slobodnih susednih polja manji od broja na kockici. Ako takva kockica postoji, nije mogu\u0107e rasporediti topove prema zahtevima, pa se prekida obrada tog polja i vra\u0107a nazad (tj. na obradu prethodnog polja).</p> 03_rokada.cpp<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define maxd 12\nusing namespace std;\nint N,M;\nstruct slog{\n  char G[maxd][maxd];\n}game;\nchar A[maxd][maxd],B[maxd][maxd],C[maxd][maxd];\nbool imaresenja;\n\nvoid ispisiresenje(){\n  for (int i=1; i&lt;=N; i++){\n    for (int j=1; j&lt;=M; j++)\n      cout&lt;&lt;A[i][j];\n    cout &lt;&lt; endl;\n  }\n}\nint brojpoljaoko(int r, int c, char z){\n  return (A[r-1][c]==z and B[r-1][c]!='x')+(A[r+1][c]==z and B[r+1][c]!='x')+(A[r][c-1]==z and B[r][c-1]!='x')+(A[r][c+1]==z and B[r][c+1]!='x');\n}\nvoid blokiraj(){                   /// obelezavanje polja oko stubova na kojima ne moze biti svetiljka\n  for (int i=1; i&lt;=N; i++)\n    for (int j=1; j&lt;=M; j++)\n      if (A[i][j]&gt;='0' and A[i][j]&lt;='4')\n       if (brojpoljaoko(i,j,'C')==A[i][j]-48){\n        if (A[i-1][j]=='.') B[i-1][j]='x';\n        if (A[i+1][j]=='.') B[i+1][j]='x';\n        if (A[i][j-1]=='.') B[i][j-1]='x';\n        if (A[i][j+1]=='.') B[i][j+1]='x';\n      }\n}\nvoid osvetli(int r, int c){\n  int x;\n  x=r-1; while (A[x][c]=='.' or A[x][c]=='!') {A[x][c]='!';x--;}\n  x=r+1; while (A[x][c]=='.' or A[x][c]=='!') {A[x][c]='!';x++;}\n  x=c-1; while (A[r][x]=='.' or A[r][x]=='!') {A[r][x]='!';x--;}\n  x=c+1; while (A[r][x]=='.' or A[r][x]=='!') {A[r][x]='!';x++;}\n}\nvoid upisisvetiljkeokopolja(int r, int c){\n  if (A[r-1][c]=='.' and B[r-1][c]!='x') {A[r-1][c]='C';osvetli(r-1,c);}\n  if (A[r+1][c]=='.' and B[r+1][c]!='x') {A[r+1][c]='C';osvetli(r+1,c);}\n  if (A[r][c-1]=='.' and B[r][c-1]!='x') {A[r][c-1]='C';osvetli(r,c-1);}\n  if (A[r][c+1]=='.' and B[r][c+1]!='x') {A[r][c+1]='C';osvetli(r,c+1);}\n}\nbool sigurica(){ /// dovodjenje pocetnog stanja u bolju poziciju za backtracking\n  blokiraj();\n  bool bilopromene=false;\n  for (int i=1; i&lt;=N; i++)\n    for (int j=1; j&lt;=M; j++)\n      if (A[i][j]&gt;='1' and A[i][j]&lt;='4') {\n        int btacaka=brojpoljaoko(i,j,'.');\n        int bsvetiljki=brojpoljaoko(i,j,'C');\n        if (btacaka&gt;0 and btacaka+bsvetiljki==A[i][j]-48){\n          upisisvetiljkeokopolja(i,j);\n          bilopromene=true;\n        }\n      }\n  return bilopromene;\n}\nbool uslovok(int r, int c){\n  int x=0;\n  x+=(A[r][c+1]=='C');\n  x+=(A[r][c-1]=='C');\n  x+=(A[r+1][c]=='C');\n  x+=(A[r-1][c]=='C');\n  return x==A[r][c]-48;\n}\nbool svejeok(){\n  for (int r=1; r&lt;=N; r++)\n    for (int c=1; c&lt;=M; c++){\n      if (A[r][c]&gt;='0' and A[r][c]&lt;='4')\n        if (!uslovok(r,c))\n          return false; /// provera broja svetiljki koje su zapisane na stubu\n    }\n  memcpy(C,A,sizeof(C));\n  for (int r=1; r&lt;=N; r++)\n    for (int c=1; c&lt;=M; c++)\n      if (A[r][c]=='C'){\n        int x=r-1; while (A[x][c]=='.' or A[x][c]=='!'){C[x][c]='!';x--;}  /// markiranje osvetljenih polja\n            x=r+1; while (A[x][c]=='.' or A[x][c]=='!'){C[x][c]='!';x++;}\n            x=c-1; while (A[r][x]=='.' or A[r][x]=='!'){C[r][x]='!';x--;}\n            x=c+1; while (A[r][x]=='.' or A[r][x]=='!'){C[r][x]='!';x++;}\n      }\n  for (int r=1; r&lt;=N; r++)  /// provera da li je sve osvetljeno\n    for (int c=1; c&lt;=M; c++)\n      if (C[r][c]=='.') return false;\n  for (int r=1; r&lt;=N; r++)\n    for (int c=1; c&lt;=M; c++)\n      if (A[r][c]=='!') A[r][c]='.';\n  return true;\n}\nvoid solve(int r, int c){\n  if (r==N+1){\n    if (svejeok()) imaresenja=true;\n    return;\n  }\n  if (A[r][c]!='.' or A[r][c]=='.' and B[r][c]=='x'){\n    if (c==M) solve(r+1,1);\n    else solve(r,c+1);\n    if (imaresenja) return;\n  }\n  else {\n    /// postavljam svetiljku na ovo polje\n    A[r][c]='C';\n    char D[maxd][maxd];\n    char E[maxd][maxd];\n    memcpy(D,A,sizeof(D));\n    memcpy(E,B,sizeof(E));\n    osvetli(r,c);\n    while (sigurica());\n    if (c==M) solve(r+1,1);\n    else solve(r,c+1);\n    if (imaresenja) return;\n    memcpy(A,D,sizeof(A));\n    memcpy(B,E,sizeof(B));\n    A[r][c]='.';\n    /// ne postavljam svetiljku na ovo polje\n    if (c==M) solve(r+1,1);\n    else solve(r,c+1);\n    if (imaresenja) return;\n  }\n}\nbool protivurecnost(){\n  for (int i=1; i&lt;=N; i++)\n    for (int j=1; j&lt;=M; j++)\n      if (A[i][j]&gt;='0' and A[i][j]&lt;='4')\n        if (brojpoljaoko(i,j,'.')+brojpoljaoko(i,j,'C')&lt;A[i][j]-48)\n          return true;\n  return false;\n}\nint main(){\n//  freopen(\"svetla.dummy.02.in\",\"r\",stdin);\n//  freopen(\"lightsout.txt\",\"w\",stdout);\n  cin&gt;&gt;N&gt;&gt;M;\n  for (int i=1; i&lt;=N; i++)\n    for (int j=1; j&lt;=M; j++)\n      cin&gt;&gt;A[i][j];\n  memcpy(B,A,sizeof(B));\n\n  while (sigurica());\n\n  if (protivurecnost()){cout &lt;&lt; -1 &lt;&lt; endl;return 0;}\n\n  solve(1,1);\n\n  if (imaresenja) ispisiresenje();\n  else cout &lt;&lt; -1 &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv2/04_bojenje/","title":"4 - Bojenje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Tom je bio nevaljao, i za kaznu je dobio zadu\u017eenje da ofarba zid. Zid se mo\u017ee predstaviti kao matrica sa \\(N\\) vrsta i \\(M\\) kolona. Tom ima jako \u010dudnu \u010detku kojom mo\u017ee u \\(i\\)-toj vrsti da ofarba ili prvih \\(A_i\\) kolona ili poslednjih \\(M-A_i\\) kolona. Tomu je svaka kolona dosadna onoliko koliko iznosi proizvod broja ofarbanih i neofarbanih polja u toj koloni. Ukupna dosadnost zida je jednaka zbiru dosadnosti svih kolona. Pomozite Tomu i izra\u010dunajte najmanju mogu\u0107u dosadnost zida nakon bojenja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Filip \u0106osovi\u0107 Dimitrije Erdeljan Marko Savi\u0107"},{"location":"takprog/2018_2019/kv2/04_bojenje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze dva cela broja, \\(N\\) i \\(M\\), koja predstavljaju broj vrsta i broj kolona, U narednih \\(N\\) linija se nalazi po jedan ceo broj, \\(A_i\\), koji predstavlja granicu za farbanje \\(i\\)-te vrste (\\(0 \\leq A_i \\leq M\\)).</p>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza se nalazi jedan ceo broj koji predstavlja minimalnu dosadnost zida nakon farbanja.</p>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv2/04_bojenje/#ulaz","title":"Ulaz","text":"<pre><code>2 3\n1\n2\n</code></pre>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv2/04_bojenje/#ulaz_1","title":"Ulaz","text":"<pre><code>4 4\n2 \n1 \n4 \n1\n</code></pre>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru je najbolje ofarbati obe vrste sa desne strane i onda bi ukupna dosadnost bila \\(2 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 2 = 1\\). <pre><code>.##\n..#\n</code></pre></p> <p>U drugom primeru je najbolje prvu, drugu i \u010detvrtu vrstu ofarbati sa leve strane, a tre\u0107u sa desne (po\u0161to je \\(A_3 = M\\) ona \u0107e onda ostati neofarbana). <pre><code>##..\n#...\n....\n#...\n</code></pre> Ukupna dosadnost je \\(1 \\cdot 3 + 3 \\cdot 1 + 4 \\cdot 0 + 4 \\cdot 0 = 6\\).</p>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>U test primerima vrednim 10 poena: \\(n \\leq 15\\) i \\(m \\leq 15\\).</li> <li>U test primerima vrednim 15 poena: \\(n \\leq 100\\) i \\(m \\leq 100\\).</li> <li>U test primerima vrednim 20 poena: \\(n \\leq 600\\) i \\(m \\leq 600\\).</li> <li>U test primerima vrednim 20 poena: \\(n \\leq 10000\\) i \\(m \\leq 10000\\).</li> <li>U test primerima vrednim 35 poena: \\(n \\leq 100000\\) i \\(m \\leq 10000\\).</li> </ul>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#analiza","title":"Analiza","text":"<p>Dokaza\u0107emo da optimalno re\u0161enje sigurno ima slede\u0107i oblik: broj belih polja u koloni opada do neke ta\u010dke, a zatim raste do kraja, ili raste do neke ta\u010dke pa opada do kraja. Ovo zna\u010di da, ako sortiramo redove po poziciji gde im se menja boja, prvih \\(K\\) redova bojimo belo-crno, a ostale crno-belo.</p> <p>Da bi dokaz bio jednostavniji, umesto da biramo boje za redove, bira\u0107emo funkciju \\(f\\), gde je \\(f(i)\\) broj belih polja u koloni izme\u0111u \"promena\" \\(i-1\\) i \\(i\\). Za validna bojenja zida va\u017ee slede\u0107e osobine \\(f\\), i obrnuto, ako osobine va\u017ee mo\u017eemo napraviti bojenje:</p> <ul> <li>\\(f(0) + f(n) = n\\) (svi redovi promene boju)</li> <li>Za svako \\(i\\), \\(|f(i) - f(i-1)| = 1\\) (svaki put se menja ta\u010dno jedan   red)</li> </ul> <p>Dokaz ovoga ostavljamo \u010ditaocu.</p> <p>Prvo, sigurno postoji ta\u010dno jedan \"trenutak\" (deo zida izme\u0111u dve promene) kada imamo po \\(\\frac{N}{2}\\) crnih i belih polja (za neparno \\(N\\), sli\u010dnim argumentom dokazujemo da se ta\u010dno jednom broj menja sa \"vi\u0161e belih\" na \"vi\u0161e crnih\"), tj. postoji ta\u010dno jedno \\(x\\) za koje \\(f(x) = \\frac{n}{2}\\). Kada ovo ne bi bilo ta\u010dno, mogli bismo da pobolj\u0161amo re\u0161enje:</p> <ul> <li>Na\u0111emo \\(x\\) takvo da je \\(f(x) = \\frac{n}{2}\\) i \\(f(x-1) = f(x+1) =   \\frac{n}{2} + 1\\) (ili sli\u010dno za \\(-1\\)) -- ako ne postoji, mo\u017eemo   odabrati neki interval izme\u0111u dve ta\u010dke gde \\(f(i) = \\frac{n}{2}\\) i   \"obrnuti\" ih (postaviti \\(f(i) = n - f(i)\\)) tako da se ne promeni   vrednost re\u0161enja.</li> <li>Postavimo \\(f(x) = \\frac{n}{2} - 2\\).</li> </ul> <p>Bez gubitka op\u0161tosti pretpostavi\u0107emo da \\(f(0) &lt; \\frac{n}{2}\\) (po\u010dinjemo sa manje belih nego crnih polja). Na sli\u010dan na\u010din mo\u017eemo dokazati da na intervalu od \\(0\\) to ta\u010dke gde imamo isti broj crnih i belih polja funkcija \\(f\\) opada do neke ta\u010dke pa raste, a od te ta\u010dke raste pa opada.</p> <p>Dakle, optimalno \\(f\\) mora imati oblik \"opada, pa raste, pa opada\". Sada \u0107emo dokazati da ne mo\u017eemo imati oba opadaju\u0107a dela: ako postoje, mo\u017eemo smanjiti \\(f(0)\\) za \\(2\\) i pove\u0107ati \\(f(n)\\) za \\(2\\) i dobiti bolje re\u0161enje.</p> <p>Sada smo dokazali da je optimalno re\u0161enje ili da broj belih polja raste do neke ta\u010dke pa opada do kraja, ili obrnuto. Kako za svaki izbor broja belih polja na po\u010detku postoji ta\u010dno jedna ta\u010dka gde mo\u017eemo pre\u0107i sa rastu\u0107eg na opadaju\u0107e, ili sa opadaju\u0107eg na rastu\u0107e (kada su sva polja iste boje), imamo \\(\\mathcal{O}(n)\\) opcija koje treba proveriti.</p> <p>Sada jo\u0161 ostaje da na\u0111emo na\u010din da izra\u010dunamo koliko bojenje vredi, ako je dat broj belih polja \\(K\\) na po\u010detku, i znamo da taj broj opada prvih \\(x\\) kolona a zatim raste do \\(N-K\\).</p>"},{"location":"takprog/2018_2019/kv2/04_bojenje/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Izra\u010duna\u0107emo samo vrednost bojenja od po\u010detka do kolone \\(x\\). Od te kolone do kraja metod je identi\u010dan.</p> <p>Vrednost koju treba izra\u010dunati je:</p> \\[ \\sum_{i = 0}^{x} (A_i - A_{i-1}) \\cdot (K - i) = K \\sum_{i=0}^x(A_i - A_{i-1}) - \\sum_{i=0}^x i \\cdot (A_i - A_{i-1}) \\] <p>Da bismo ovo ra\u010dunali u konstantnom vremenu, na po\u010detku programa je dovoljno da izra\u010dunamo nizove prefiksnih suma koje nam daju ove dve \"male\" sume za svako \\(x\\).</p> 04_bojenje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int MAXN=int(2e5+50);\n\nlong long n,m,a[MAXN],s[MAXN],s2[MAXN],ps[MAXN],ps2[MAXN],pm[MAXN],p[MAXN],qs[MAXN],qs2[MAXN],qm[MAXN],q[MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i=0; i&lt;n; i++)\n        cin &gt;&gt; a[i];\n\n    sort(a,a+n);\n\n    a[n]=m;\n    s[0]=a[0];\n    ps[0]=s[0];\n    ps2[0]=0LL;\n    pm[0]=0LL;\n    p[0]=0LL;\n    for (int i=1; i&lt;=n; i++)\n    {\n        s[i]=a[i]-a[i-1];\n        ps[i]=ps[i-1]+s[i];\n        ps2[i]=ps2[i-1]+ps[i-1];\n        pm[i]=pm[i-1]+2*ps2[i-1]+ps[i-1];\n        p[i]=n*ps2[i]-pm[i];\n    }\n\n    s2[0]=s[n];\n    qs[0]=s2[0];\n    qs2[0]=0LL;\n    qm[0]=0LL;\n    q[0]=0LL;\n    for (int i=1; i&lt;=n; i++)\n    {\n        s2[i]=s[n-i];\n        qs[i]=qs[i-1]+s2[i];\n        qs2[i]=qs2[i-1]+qs[i-1];\n        qm[i]=qm[i-1]+2*qs2[i-1]+qs[i-1];\n        q[i]=n*qs2[i]-qm[i];\n    }\n\n\n    long long rez=-1;\n    for (int i=0; i&lt;=n; i++)\n        if (p[i]+q[n-i]&lt;rez || rez==-1)\n            rez=p[i]+q[n-i];\n\n    printf(\"%lld\\n\",rez);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/","title":"5 - Vrednost dodele","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1600ms 1024MB <p>Maca Jaca ima za vas slede\u0107i zadatak: Da\u0107e vam brojeve \\(N, M\\) a zatim niz \\(B = [B_1, B_2, \\ldots, B_M]\\), za svaki element va\u017ei \\(1 \\leq B_i \\leq M\\) (vrednosti brojeva mogu da se ponavljaju). Va\u0161 zadatak je da formirate niz \\(A = [1, 2, \\ldots, N]\\) (niz se indeksira od \\(1\\)), a da zatim, za svako \\(i\\) iz niza \\([0, 1, \\ldots, N-M]\\) (u rastu\u0107em redosledu) uradite slede\u0107u operaciju: <pre><code>for (int j=1; j&lt;=M; j++)\n  A[i + B[j]] = A[i + j]\n</code></pre> Drugim re\u010dima, da za svako \\(j\\) po\u010dev od \\(1\\) do \\(M\\) (u rastu\u0107em redosledu), vrednost u \\(A_{i+j}\\) upi\u0161ete u element \\(A_{i + B_j}\\). Za kraj, Jaca \u0107e vam dati ceo broj \\(C\\). Va\u0161 zadatak je da izra\u010dunate vrednost \\(X = \\sum_{i=1}^{N}(C^i \\times A_i)\\) po modulu \\(998244353\\) nakon svih operacija.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Nikola Spasi\u0107 Nikola Spasi\u0107 Aleksa Milisavljevi\u0107 <p>Ozna\u010dimo skup \\(\\{1, 2, \\ldots, N\\}\\) sa \\([[N]]\\). Posmatrajmo dodele vrednosti za \\(i = 0\\) i defini\u0161imo dve funkcije </p> <ul> <li>\\(f : [[N]] \\rightarrow [[N]]\\), takva da je \\(a'_j = f(a_j)\\), gde je \\(a'_j\\) vrednost na poziciji \\(j\\) u nizu \\(A\\) nakon izvr\u0161avanja dodela vrednosti za \\(i = 0\\) a \\(a_j\\) je ta vrednost pre izvr\u0161avanja dodela.</li> <li>\\(g : [[N]] \\rightarrow [[N]], g(N) := 1; g(x) := x + 1, x \\neq N\\) cikli\u010dno pomeranje za jedno mesto ulevo.</li> </ul> <p>Sada \u0107emo operaciju koju treba izvr\u0161iti na nizu \\(A\\) (za svako \\(i \\in \\{0, 1, \\ldots, N-M \\}\\) i za svako \\(j \\in \\{0, 1, \\ldots, M-1\\}\\)) ozna\u010diti sa \\(z\\), gde je \\(z : [[N]] \\rightarrow [[N]]\\). Ozna\u010dimo sa \\(z_i : [[N]] \\rightarrow [[N]]\\) operaciju na nizu \\(A\\) koja odgovara izvr\u0161avanju unutra\u0161nje for-petlje (po \\(j\\)) za dato fiksno \\(i\\). Jasno je da va\u017ei: \\(z = z_{N-M} \\circ z_{N-M-1} \\circ \\ldots \\circ z_0\\). Klju\u010dna ideja je to \u0161to \\(z_i\\) mo\u017eemo zapisati u obliku \\(z_i = g^{-i} \\circ f \\circ g^i\\). Ovo va\u017ei zato \u0161to preslikavanjem \\(g^i\\) \"rotiramo\" niz u takvu poziciju da element koji je bio na poziciji \\(i\\) je sada na poziciji \\(0\\). Nakon toga primenjujemo dodelu vrednosti sa \\(f\\) i ponovo rotiramo niz u kontra smeru za \\(i\\) mesta.</p> <p>Ako zatim pro\u0161irimo izraz za \\(z\\) i skratimo susedne parove \\(\\ldots g^{i} \\circ g^{-(i-1)} \\ldots\\) ostaje nam \\(z = g^{-(N-M)} \\circ (f \\circ g)^{N-M} \\circ f\\), odnosno, kra\u0107e \\(z = g^{-k} \\circ (g \\circ f)^k\\), gde smo uveli oznaku \\(k := N-M+1\\). Kako se \\(g^{-k}\\) lako ra\u010duna kao desna rotacija za \\(k\\) mesta, ako uvedemo oznaku \\(h := g \\circ f\\) ostaje nam da izra\u010dunamo \\(k\\)-ti  stepen ove funkcije.</p> <p>Da bismo za svako \\(i\\) prona\u0161li vrednost \\(h^k(i)\\) konstrui\u0161emo graf sa \u010dvorovima \\(\\{1 \\ldots N\\}\\) i usmerenim granama \\(\\{x \\rightarrow h(x), x \\in [[N]]\\}\\). Kako je usmeren, kona\u010dan i iz svakog \u010dvora izlazi ta\u010dno jedna grana, komponente povezanosti (posmatraju\u0107i graf kao neusmeren) izgledaju kao ciklusi sa stablima \u010diji je ta\u010dno jedan \u010dvor deo ciklusa (primetiti da kako je mogu\u0107e da \\(h(i) = i\\) postoji mogu\u0107nost da ciklus sadr\u017ei samo jedan \u010dvor). Usmerenje grana u ciklusu mora biti takvo da je ciklus i u usmerenom grafu, dok usmerenje grana u stablima mora biti takvo da je ulazni \u010dvor bli\u017ei ciklusu od izlaznog.</p> <p>Obilaze\u0107i svaku komponentu povezanosti (posmatraju\u0107i graf kao neusmeren) u njoj pronalazimo ciklus za \u010diji svaki \u010dvor nalazimo \\(h^k(i)\\) kao \\(c((id(i) + k) \\mod d)\\) gde je \\(d\\) du\u017eina ciklusa koji sadr\u017ei \u010dvor \\(i\\), \\(idx(x)\\) daje redni broj \u010dvora \\(x\\) u ciklusu dok \\(c(x)\\) ozna\u010dava \\(x\\)-ti \u010dvor na tom ciklusu. Za \"po\u010detak\" ciklusa mo\u017eemo izabrati proizvoljan \u010dvor. Zatim dfs obilaskom, kroz stabla povezana sa tim ciklusom, unazad (suprotno usmerenju grana) za svaki \u010dvor \\(i\\) \u010diji je otac u stablu obilaska \\(o_i\\) ra\u010dunamo \\(h^k(i)\\) ili kao prethodnika \u010dvora \\(h^k(o_i)\\) u ciklusu ukoliko je \\(i\\) na rastojanju od ciklusa manjem od \\(k\\) ili kao sina \u010dvora \\(h^k(o(i))\\) u stablu obilaska u \u010dijem podstablu se nalazi \u010dvor \\(i\\). Ovog sina mo\u017eemo na\u0107i tako \u0161to odr\u017eavamo niz koji odgovara steku \u010dvorova tokom dfs-a i uzimanjem \\(k\\)-tog prethodnika trenutnog \u010dvora.</p> <p>Na kraju potrebno je samo izra\u010dunati tra\u017eenu vrednost, znaju\u0107i vrednosti niza \\(A\\) nakon svih dodela vrednosti.</p> <ul> <li>Vremenska slo\u017eenost algoritma \\(O(n)\\)</li> <li>Prostorna slo\u017eenost algoritma \\(O(n)\\)</li> </ul> 05_vrednost_dodele.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ldb long double\n#define mt make_tuple\nconst int N=100050;\nconst int L=25;\nconst int mod=998244353;\nconst int inf=1e9+7;\nint n,m,b[N],c,sol,bsol;\nvoid input()\n{\n    scanf(\"%i %i\",&amp;n,&amp;m);\n    for(int i=1;i&lt;=m;i++) scanf(\"%i\",&amp;b[i]);\n    scanf(\"%i\",&amp;c);\n    c%=mod;\n    if(c&lt;0) c+=mod;\n}\nvoid output()\n{\n    printf(\"%i\\n\",sol);\n}\nint par[N][L],a[N],mx[N];\nvoid Solve()\n{\n    for(int i=1;i&lt;=m;i++) a[i]=i;\n    for(int j=1;j&lt;=m;j++)\n        a[b[j]]=a[j];\n    for(int i=1;i&lt;=m;i++) par[i-1][0]=a[i];\n    par[m][0]=-1;\n    for(int j=1;j&lt;L;j++) for(int i=0;i&lt;=m;i++)\n    {\n        if(par[i][j-1]==-1) par[i][j]=-1;\n        else par[i][j]=par[par[i][j-1]][j-1];\n    }\n    for(int i=0;i&lt;=m;i++)\n    {\n        if(par[i][L-1]!=-1) mx[i]=inf;\n        else\n        {\n            mx[i]=0;\n            int u=i;\n            for(int j=L-1;~j;j--) if(par[u][j]!=-1) u=par[u][j],mx[i]+=1&lt;&lt;j;\n            mx[i]++;\n        }\n    }\n    sol=0;\n    int mul=c;\n    int zero=0;\n    for(int i=1;i&lt;=n;i++)\n    {\n        int pos;\n        if(zero!=-1) zero=par[zero][0];\n        if(i+m&gt;n)\n        {\n            int po=n-m+1;\n            pos=i-(n-m+1);\n            if(mx[pos]&gt;po)\n            {\n                for(int k=0;k&lt;L;k++) if((po&gt;&gt;k)&amp;1) pos=par[pos][k];\n            }\n            else\n            {\n                pos=po-mx[pos]+m+1;\n            }\n        }\n        else\n        {\n            int po=i;\n            pos=0;\n            if(mx[pos]&gt;po)\n            {\n                pos=zero;\n                //for(int k=0;k&lt;L;k++) if((po&gt;&gt;k)&amp;1) pos=par[pos][k];\n            }\n            else\n            {\n                pos=po-mx[pos]+m+1;\n            }\n        }\n        sol+=(ll)mul*pos%mod;\n        if(sol&gt;=mod) sol-=mod;\n        mul=(ll)mul*c%mod;\n        //printf(\"%i \",pos);\n    }\n    //printf(\"\\n\");\n}\nvoid Run()\n{\n    input();\n    Solve();\n    output();\n}\n\nint main()\n{\n    Run();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva prirodna broja \\(N\\) i \\(M\\). U narednom redu se nalaze brojevi \\(B_1, B_2, \\ldots, B_M\\), odvojeni razmakom. U naredom redu nalazi se jedan ceo broj \\(C\\).</p>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinu liniju standardnog izlaza ispi\u0161ite tra\u017eeni broj \\(X\\) (\\(0 \\leq X &lt; 998244353\\)).</p>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#ulaz","title":"Ulaz","text":"<pre><code>14 6\n6 4 3 3 2 1\n-1\n</code></pre>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#izlaz","title":"Izlaz","text":"<pre><code>16\n</code></pre>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Niz \\(A\\) \u0107e nakon svih operacija izgledati ovako: <pre><code>1 5 1 5 1 5 1 5 1 5 2 2 5 1\n</code></pre></p>"},{"location":"takprog/2018_2019/kv2/05_vrednost_dodele/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei: \\(M \\leq N, -10^9 \\leq C \\leq 10^9\\)</p> <ul> <li>U test primerima vrednim 10 poena: \\(N, M \\leq 10000\\).</li> <li>U test primerima vrednim 60 poena: \\(N \\leq 500.000, M \\leq 100.000\\).</li> <li>U test primerima vrednim 30 poena: \\(N \\leq 20.000.000, M \\leq 100.000\\).</li> </ul>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/","title":"1 - Vorp spejs","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 400ms 64MB <p>Nakon \u0161to su ti prsti, masni od Smokija, skliznuli sa upravlja\u010da i nehotice pritisnuli dugme na kome je pisalo \"vorp-spid\", tvoj svemirski brod, Milenijumski Soko \u0160tark, na\u0161ao se izgubljen u vorp-spejsu. Ljuljanje broda uzrokovano jakim gravitacionim talasima ubrzo je u\u010dinilo da dobije\u0161 morsku bolest. Ne \u017eele\u0107i da polusvareni Smoki zavr\u0161i na komandama tvog broda, pritiska\u0161 dugme sa natpisom \"Tutanj!\", koje te u najkra\u0107em mogu\u0107em vremenu odvodi do izlaza iz vorp-spejsa, a to je vorm-hol \u010diji se drugi kraj nalazi u tvom wc-u na planeti Zemlji.</p> <p>Par decenija ranije, u 2019. godini, evo tebe kako programira\u0161 svoj budu\u0107i svemirski brod. Poznavaju\u0107i svoj slab stomak, predvi\u0111a\u0161 situaciju u kojoj \u0107e\u0161 hitno morati da napusti\u0161 vorp-spejs, te \u017eeli\u0161 da napi\u0161e\u0161 program koji \u0107e tvoj broj odvesti do izlaza u \u0161to kra\u0107em vremenu.</p> <p>Vorp-spejs ima oblik tabele dimenzija \\(D_x \\times D_y\\) (\\(D_x\\) je broj kolona, a \\(D_y\\) je broj vrsta). Na jednom od polja vorp-spejsa se nalazi tvoj brod, i na jednom od polja se nalazi izlaz (brod i izlaz mogu biti i na istom polju). U jednoj jedinici vremena tvoj brod mo\u017ee da pre\u0111e na neko od susedna \u010detiri polja vorp-spejsa (gore, dole, levo ili desno). Me\u0111utim, vorp-spejs je uvrnut, pa ako se na\u0111e\u0161 na polju uz njegovu ivicu i poku\u0161a\u0161 da se pomeri\u0161 u pravcu te ivice, osvanu\u0107e\u0161 na polju koje se nalazi na suprotnoj strani vorp-spejsa. Preciznije, ako se nalazi\u0161 u prvoj vrsti i poku\u0161a\u0161 da ide\u0161 gore, pojavi\u0107e\u0161 se u istoj koloni, ali u poslednjoj vrsti; i obrnuto, ako se nalazi\u0161 u poslednjoj vrsti i poku\u0161a\u0161 da ide\u0161 dole, pojavi\u0107e\u0161 se u istoj koloni, ali u prvoj vrsti. Sli\u010dno va\u017ei i za levo i desno - pomeranjem u levo u prvoj koloni, zavr\u0161i\u0107e\u0161 u poslednjoj koloni iste vrste; i obrnuto, pomeranjem u desno u poslednjoj koloni, zavr\u0161i\u0107e\u0161 u prvoj koloni iste vrste.</p> <p>Veruje\u0161 da \u0107e tvoj stomak umiriti i prosto saznanje koliko je tvoj brod udaljen od izlaza iz vorp-spejsa, pa za prvu verziju programa \u017eeli\u0161 da izra\u010duna\u0161 samo to - minimalno potrebno vreme da brod do\u0111e do izlaza.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Marko Savi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji nalaze se celi brojevi \\(D_x\\) i \\(D_y\\), koji predstavljaju broj kolona i broj vrsta vorp-spejsa. U drugoj liniji nalaze se celi brojevi \\(A_x\\) i \\(A_y\\), koji predstavljaju kolonu i vrstu u kojoj se nalazi tvoj brod. U tre\u0107oj liniji se nalaze celi brojevi \\(B_x\\) i \\(B_y\\), koji predstavljaju kolonu i vrstu u kojoj se nalazi izlaz. Brojevi vrsta i kolona po\u010dinju od \\(0\\).</p>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji izlaza ispisati ta\u010dno jedan broj - minimalno potrebno vreme da tvoj brod dovede\u0161 do izlaza.</p>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#ulaz","title":"Ulaz","text":"<pre><code>6 6\n0 3\n2 2 \n</code></pre>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Do izlaza \u0107e\u0161 najbr\u017ee do\u0107i u tri jedinice vremena, na primer tako \u0161to ide\u0161 jednom na gore i dva puta na desno</p>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#ulaz_1","title":"Ulaz","text":"<pre><code>9 7\n6 1\n1 5 \n</code></pre>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#izlaz_1","title":"Izlaz","text":"<pre><code>7\n</code></pre>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Jedno od mogu\u0107ih najkra\u0107ih re\u0161enja je prikazano na slici.</p> <p></p>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq D_x, D_y \\leq 1000\\)</li> <li>\\(0 \\leq A_x, B_x &lt; D_x\\)</li> <li>\\(0 \\leq A_y, B_y &lt; D_y\\)</li> </ul>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#napomene","title":"Napomene","text":"<ul> <li>Od \u010coko-Smokija se manje maste prsti.</li> <li>Soko \u0160tark nije sponzor ovog zadatka.</li> </ul>"},{"location":"takprog/2018_2019/kv3/01_vorpspejs/#analiza","title":"Analiza","text":"<p>Primetimo da koordinate mo\u017eemo da posmatramo nezavisno. Najlak\u0161i na\u010din da re\u0161imo zadatak je analizom slu\u010dajeva. Za obe koordinate razmatramo dva slu\u010daja, da li smo pre\u0161li preko ivice ili ne. Posmatrajmo \\(x\\) koordinatu po\u010detnog i krajnjeg polja. Ukoliko nismo pre\u0161li ivicu od polja \\(A_{x}\\) do polja \\(B_{x}\\), rastojanje je \\(|A_{x}-B_{x}|\\). Ukoliko jesmo i du\u017eina vorp-spejsa je \\(D_{x}\\), rastojanje je \\(D_{x}-|A_{x}-B_{x}|\\).  Dakle, minimalan broj koraka da bi smo se na\u0161li na \\(x\\) koordinati na kojoj je krajnje polje je \\(\\min(|A_{x}-B_{x}|,D_{x}-|A_{x}-B_{x}|)\\). Sli\u010dan rezultat dobijamo za \\(y\\) koordinatu,   \\(\\min(|A_{y}-B_{y}|,D_{y}-|A_{y}-B_{y}|)\\). Ukupan broj koraka je \\(\\min(|A_{x}-B_{x}|,D_{x}-|A_{x}-B_{x}|) + \\min(|A_{y}-B_{y}|,D_{y}-|A_{y}-B_{y}|)\\).</p> 01_vorpspejs.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    int m,n;\n    int a,b;\n    int c,d;\n    scanf(\"%d %d\",&amp;m,&amp;n);\n    scanf(\"%d %d\",&amp;a,&amp;b);\n    scanf(\"%d %d\",&amp;c,&amp;d);\n    printf(\"%d\",min(abs(c-a),m-abs(c-a))+min(abs(d-b),n-abs(d-b)));\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/","title":"2 - Mo\u0107 niza","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Dat je niz \\(A_{i}\\) koji se sastoji od \\(N\\) cifara. Mo\u0107 niza defini\u0161emo kao razliku kvadrata najve\u0107e cifre u njemu i kvadrata najmanje cifre u njemu. U jednoj operaciji mo\u017eete da izbri\u0161ete proizvoljnu cifru u nizu. Primeniti najvi\u0161e \\(K\\) operacija, tako da mo\u0107 niza koji ostane bude najmanja mogu\u0107a i ispisati tu mo\u0107. Primetite da u nizu posle brisanja mo\u017ee da ostane i samo jedna cifra, u tom slu\u010daju ona je istovremeno i najve\u0107a i najmanja, pa je rezultat \\(0\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milenkovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se brojevi \\(N\\), du\u017eina niza i \\(K\\) najve\u0107i broj operacija koje mo\u017eete primeniti. U drugom redu nalazi se niz od \\(N\\) cifara.</p>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati najmanju mo\u0107 niza koji se dobija primenom najvi\u0161e \\(K\\) operacija na po\u010detni niz.</p>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv3/02_moc_niza/#ulaz","title":"Ulaz","text":"<pre><code>5 4\n5 9 6 9 1\n</code></pre>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#izlaz","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv3/02_moc_niza/#ulaz_1","title":"Ulaz","text":"<pre><code>5 3\n5 9 6 8 1\n</code></pre>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#izlaz_1","title":"Izlaz","text":"<pre><code>11\n</code></pre>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, izbrisa\u0107emo cifre \\(9\\), \\(6\\), \\(9\\) i \\(1\\). Tako \u0107e nam ostati niz \\(5\\),  kojem je mo\u0107 \\(5^2-5^2 = 0\\). U drugom primeru, izbrisa\u0107emo cifre \\(9\\), \\(8\\) i \\(1\\). Tako \u0107e nam ostati niz \\(5\\) \\(6\\),  kojem je mo\u0107 \\(6^2 - 5^2 = 11\\).</p>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq K &lt; N \\leq 10^5\\)</li> <li>\\(0 \\leq A_{i} \\leq 9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 30 poena: \\(N=3\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 15\\).</li> <li>U test primerima vrednim 10 poena: \\(N \\leq 10^3\\), \\(K=1\\).</li> <li>U test primerima vrednim 10 poena: Sve cifre su ili \\(1\\) ili \\(2\\).</li> <li>U test primerima vrednim 30 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#analiza","title":"Analiza","text":""},{"location":"takprog/2018_2019/kv3/02_moc_niza/#nacin-1","title":"Na\u010din 1","text":"<p>Primetimo da razli\u010ditih cifara koje mogu da se pojavljuju u broju mo\u017ee da ima najvi\u0161e 10, tako da mo\u017eemo uraditi zadatak slede\u0107im postupkom: fiksiramo najmanju i najve\u0107u cifru (njihove vrednosti) koje ostaju u broju, i vidimo da li u \\(K\\) operacija mo\u017eemo izbrisati sve cifre koje su manje od najmanje i ve\u0107e od najve\u0107e. Ukoliko mo\u017eemo, razlika kvadrata te dve cifre je jedan od kandidata za re\u0161enje, a nama od svih kandidata treba onaj maksimalni.</p>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#nacin-2","title":"Na\u010din 2","text":"<p>Ukoliko sortiramo (nekim \\(O(N \\log N)\\) algoritmom) sve cifre na\u0161eg broja, primetimo da \u0107e u optimalnom re\u0161enju biti uzastopni podniz tog sortiranog niza (du\u017eine \\(N - K\\)). Takvih podnizova ima \\(O(N)\\), pa mo\u017eemo pro\u0107i kroz sve i izabrati onaj koji daje maksimalnu razliku kvadrata.</p>"},{"location":"takprog/2018_2019/kv3/02_moc_niza/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Ukoliko koristimo prvi na\u010din potreban nam je broja\u010d pojavljivanja svake cifre u broju kako ne bismo svaki put kad brojimo prolazili kroz ceo broj - slo\u017eenost implementacije mo\u017ee varirati, ali postoji 10 cifara, tako da bilo \u0161ta \u0161to koristi nekoliko petlji te du\u017eine prolazi. Ukoliko koristimo drugi na\u010din, u ukupnoj slo\u017eenosti dominira slo\u017eenost sortiranja - \\(O(N \\log N)\\) za neki standardni sort, \\(O(N)\\) ukoliko koristimo counting sort.</p> 02_moc_niza.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100005\nusing namespace std;\nint a[maxn];\nint n;\nint k;\nint br[10];\nint main()\n{\n    scanf(\"%d %d\",&amp;n,&amp;k);\n    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]);\n    for(int i=0;i&lt;n;i++) br[a[i]]++;\n    int mk=100;\n    int s=0;\n    for(int i=0;i&lt;=9;i++) {\n        s=0;\n        for(int j=i;j&lt;=9;j++) {\n            s+=br[j];\n            if(s+k&gt;=n) mk=min(mk,j*j-i*i);\n        }\n    }\n    printf(\"%d\",mk);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/","title":"3 - Pakovanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1600ms 64MB <p>Dato vam je \\(M\\) predmeta. Predmet \\(i\\) ima vrednost \\(V_{i}\\) i te\u017einu \\(T_{i}\\). Imate i \\(N\\) kutija. Kutija \\(j\\) ima nosivost \\(C_{j}\\) i u svaku kutiju mo\u017eemo da spakujemo najvi\u0161e jedan predmet. Predmet \\(i\\) mo\u017ee da stane u kutiju \\(j\\) ukoliko je \\(T_{i} &lt; C_{j}\\). Interesuje vas kolika je najve\u0107a mogu\u0107a suma vrednosti predmeta koje mo\u017eete spakovati u kutije.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dragan Uro\u0161evi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milovanovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji nalaze se vrednosti \\(M\\), broj predmeta i \\(N\\), broj kutija. U drugoj liniji nalazi se \\(M\\) prirodnih brojeva, koji predstavljaju te\u017eine predmeta. U tre\u0107oj liniji nalazi se \\(M\\) prirodnih brojeva, koji predstavljaju vrednosti predmeta. U \u010detvrtoj liniji nalazi se \\(N\\) prirodnih brojeva, koji predstavljaju nosivosti kutija.</p>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati najve\u0107u mogu\u0107u sumu vrednosti predmeta koji se mogu spakovati u kutije.</p>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv3/03_pakovanje/#ulaz","title":"Ulaz","text":"<pre><code>2 1\n8 100\n12 100\n15\n</code></pre>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#izlaz","title":"Izlaz","text":"<pre><code>12\n</code></pre>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/kv3/03_pakovanje/#ulaz_1","title":"Ulaz","text":"<pre><code>4 3\n1 8 4 9\n1000000000 25 1000000000 1000000000\n10 2 5\n</code></pre>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#izlaz_1","title":"Izlaz","text":"<pre><code>3000000000\n</code></pre>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru u jedinu kutiju, koja ima nosivost \\(15\\), mo\u017eemo da spakujemo samo prvi predmet, koji ima te\u017einu \\(8\\) i vrednost \\(12\\). U drugom primeru imamo tri kutije. U prvu, koja ima nosivost \\(10\\) stavljamo \u010detvrti predmet, koji ima te\u017einu \\(9\\) i vrednost \\(1000000000\\), u drugu kutiju, koja ima nosivost \\(2\\) stavljamo prvi predmet, koji ima te\u017einu \\(1\\) i vrednost \\(1000000000\\), a u tre\u0107u kutiju, koja ima nosivost \\(5\\) stavljamo tre\u0107i predmet, koji ima te\u017einu \\(4\\) i vrednost \\(1000000000\\). Ukupna vrednost je  \\(1000000000+1000000000+1000000000=3000000000\\)</p>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq M, N \\leq 300.000\\)</li> <li>\\(1 \\leq T_{i}, V_{i}, C_{j} \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena: \\(1 \\leq M, N \\leq 6\\).</li> <li>U test primerima vrednim 20 poena: \\(1 \\leq M, N \\leq 1000\\).</li> <li>U test primerima vrednim 10 poena: Nosivost svake kutije je ve\u0107a od te\u017eine svakog predmeta, tj. va\u017ei \\(T_{i} &lt; C_{j}\\) za \\(1\\leq i \\leq M\\), \\(1\\leq j \\leq N\\).</li> <li>U test primerima vrednim 20 poena: Svi predmeti imaju istu vrednost.</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#napomena","title":"Napomena","text":"<p>Primetite da rezultat mo\u017ee da prekora\u010di 32-bitni tip podataka.</p>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#analiza","title":"Analiza","text":"<p>Zadatkom je dato ukupno \\(N\\) kutija i \\(M\\) predmeta, pri \u010demu svaka kutija ima neku svoju nosivost, dok svaki predmet ima neku svoju te\u017einu i odre\u0111enu vrednost. Tako\u0111e, klju\u010dna stavka u postavci zadatka jeste ograni\u010denje da je u jednu kutiju mogu\u0107e smestiti ta\u010dno jedan predmet i to samo ako je nosivost kutije ve\u0107a od te\u017eine predmeta.</p> <p>Prethodnim je svaki predmet definisan jednim ure\u0111enim parom (te\u017eina, vrednost), dok je svaka kutija definisana svojom nosivo\u0161\u0107u. Najpre, radi efikasnijeg re\u0161avanja zadatka sortirati i kutije i predmete u neopadaju\u0107em redosledu prema njihovoj nosivosti, odnosno te\u017eini, respektivno. Ove operacije lako se izvode u ukupnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(M\\log M)+\\mathcal{O}(N\\log N)\\) ukoliko se koristi neki napredniji algoritam sortiranja.</p> <p>Zatim, polaze\u0107i od kutije sa najni\u017eom nosivo\u0161\u0107u, proveriti koji sve predmeti su lak\u0161i od njene nosivosti i odabrati predmet sa najvi\u0161om vredno\u0161\u0107u. Pri svakoj narednoj iteraciji tako\u0111e je neophodno proveravati koje je predmete mogu\u0107e poneti odre\u0111enom kutijom i birati uvek predmet \u010dija je vrednost najve\u0107a. Kako su kutije sortirane po nosivosti, a predmeti po te\u017eini, svakom slede\u0107om kutijom bi\u0107e izvodljivo poneti svaki od predmeta koji bilo mogu\u0107e poneti i onom ni\u017ee nosivosti i eventualno jo\u0161 poneki.</p> <p>Lako se dokazuje da se do najve\u0107e zbirne vrednosti predmeta prenosive zadatim kutijama dolazi tako \u0161to se u svakoj iteraciji bira najvredniji predmet koji je prema njegovoj te\u017eini u datu kutiju mogu\u0107e smestiti, naravno kre\u0107u\u0107i se od kutije sa najni\u017eom ka kutiji sa najvi\u0161om nosivo\u0161\u0107u. Predmeti koji zadovoljavaju uslov da im je te\u017eina ni\u017ea od nosivosti trenutne kutije potrebno je \u010duvati unutar neke strukture podataka iz koje se na efikasniji na\u010din od puke linearne pretrage mo\u017ee prona\u0107i i izvu\u0107i ba\u0161 onaj \u010dlan sa najvi\u0161om vredno\u0161\u0107u.</p> <p>Konkretno, jedna od takvih apstraktnih struktura podataka jeste prioritetni red (eng. priority queue), koji se obi\u010dno implementira preko takozvane hrpe (eng. heap), a koji na ra\u010dun logaritamske slo\u017eenosti umetanja proizvoljnog elementa dozvoljava va\u0111enje \u010dlana sa maksimalnom vredno\u0161\u0107u tako\u0111e u logaritamskoj vremenskoj slo\u017eenosti po broju elemenata.</p>"},{"location":"takprog/2018_2019/kv3/03_pakovanje/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Nakon sortiranja kutija po nosivosti i predmeta po te\u017eini, inicijalizovati rezultat koji predstavlja ukupnu sumu vrednosti predmeta na nulu. U petlji prolaziti kroz kutije po\u010dev\u0161i od one sa najni\u017eom ka onoj sa najvi\u0161om nosivo\u0161\u0107u i u svakom prolasku ispitivati koji sve predmeti imaju ni\u017eu te\u017einu od nosivosti trenutne kutije i dodavati ih u prioritetni red prema njihovoj vrednosti. Na kraju iteracije izvaditi iz reda predmet sa najvi\u0161om vredno\u0161\u0107u i njegovu vrednost sabrati s trenutnim rezultatom. Po izlasku iz petlje ispisati rezultat. Nije te\u0161ko pokazati da je asimptotska vremenska slo\u017eenost ovakvog algoritma loglinearna \\(\\mathcal{O}(M\\log M)+\\mathcal{O}(N\\log N)\\), odnosno asimptotski jednaka sortiranju ulaznih vrednosti.</p> 03_pakovanje.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 400000\nusing namespace std;\nint m,n;\nlong long result=0;\npair&lt;int,int&gt; p[maxn];\nint c[maxn];\nint t[maxn];\nint v[maxn];\npriority_queue&lt;long long&gt; pq;\nint main()\n{\n    scanf(\"%d %d\",&amp;m,&amp;n);\n    for(int i=0;i&lt;m;i++) scanf(\"%d\",&amp;t[i]);\n    for(int i=0;i&lt;m;i++) scanf(\"%d\",&amp;v[i]);\n    for(int i=0;i&lt;m;i++) p[i]=make_pair(t[i],v[i]);\n    sort(p,p+m);\n    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;c[i]);\n    sort(c,c+n);\n    int i=0;\n    for(int j=0;j&lt;n;j++) {\n        while(i&lt;m &amp;&amp; p[i].first&lt;c[j]) {\n            pq.push(p[i].second);\n            i++;\n        }\n        if(pq.size()&gt;0) {\n            result+=pq.top();\n            pq.pop();\n        }\n    }\n    printf(\"%lld\",result);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv3/04_pozar/","title":"4 - Po\u017ear","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U jednom predgra\u0111u Ni\u0161a nalazi se velika, takore\u0107i beskona\u010dna njiva u obliku dvodimenzione ravni. Bogata porodica Vatreni\u0107 se ne podnosi sa drugom bogatom porodicom Bla\u017ei\u0107. Porodica Bla\u017ei\u0107 poseduje \\(N\\) opti\u010dkih kablova, \\(i\\)-ti kabl je u obliku beskona\u010dne prave koja prolazi kroz ta\u010dke \\((x_i, y_i)\\) i \\((u_i, v_i)\\). Vatreni\u0107i su poznati po paljenju njiva, te je va\u0161 zadatak da za svaki od datih \\(Q\\) scenarija \u0161irenja po\u017eara odredite koliko kablova \u0107e se o\u0161tetiti. Scenario sa rednim brojem \\(j\\) se odnosi na jedan krug \\(K_j\\) sa centrom u ta\u010dki \\((a_j, b_j)\\) i radijusom \\(r_j\\), krug do kojeg \u0107e se ra\u0161iriti po\u017ear u tom scenariju. Pritom, za ove krugove va\u017ei: \\(K_j \\subset K_{j+1}\\) za svako \\(1 \\leq j &lt; Q\\), drugim re\u010dima, \\(j\\)-ti krug je u potpunosti sadr\u017ean u \\((j+1)\\)-om krugu, tako\u0111e, granice nikoja dva kruga se ne dodiruju. Kabl koji je u obliku prave \\(p\\) \u0107e se o\u0161tetiti u scenariju \\(C\\) ako i samo ako je skup \\(p \\cap C\\) neprazan, odnosno, ako se krug i prava seku u bar jednoj ta\u010dki. Kako je vatra nepredvidiva pojava, u svakom scenariju se garantuje da se re\u0161enje (broj o\u0161te\u0107enih kablova) ne\u0107e promeniti \u010dak ni ako se polupre\u010dnik kruga \\(r\\) pove\u0107a ili smanji za \\(r \\cdot 10^{-12}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2018_2019/kv3/04_pozar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(N\\) - broj kablova koje poseduje porodica Bla\u017ei\u0107. U narednih \\(N\\) linija nalaze se po \u010detiri cela broja, \\(x_i, y_i, u_i, v_i\\), koordinate dve ta\u010dke kroz koje prolazi \\(i\\)-ti kabl. Naredna linija sadr\u017ei jedan prirodan broj \\(Q\\), broj scenarija. U narednih \\(Q\\) redova nalaze se po tri cela broja \\(a_i, b_i, r_i\\), koordinate centra kruga i polupre\u010dnik kruga kod \\(i\\)-tog scenarija.</p>"},{"location":"takprog/2018_2019/kv3/04_pozar/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(Q\\) scenarija ispisati po jedan ceo broj - u \\(j\\)-ti red ispisati broj kablova koji \u0107e se o\u0161tetiti u scenariju pod rednim brojem \\(j\\).</p>"},{"location":"takprog/2018_2019/kv3/04_pozar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv3/04_pozar/#ulaz","title":"Ulaz","text":"<pre><code>4\n4 -3 -5 1\n6 -2 -4 10\n6 11 6 8\n6 8 6 11\n3\n0 5 1\n1 4 3\n3 5 6\n</code></pre>"},{"location":"takprog/2018_2019/kv3/04_pozar/#izlaz","title":"Izlaz","text":"<pre><code>1\n1\n3\n</code></pre>"},{"location":"takprog/2018_2019/kv3/04_pozar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prva dva scenarija \u0107e se o\u0161tetiti samo jedan kabl (kabl sa rednim brojem \\(2\\)), dok \u0107e se u tre\u0107em scenariju pored ovog o\u0161tetiti i kablovi sa rednim brojevima \\(3, 4\\) (koji su podudarni).</p> <p></p>"},{"location":"takprog/2018_2019/kv3/04_pozar/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei:</p> <ul> <li>\\(-10^8 \\leq x_i, y_i, u_i, v_i, a_j, b_j \\leq 10^8\\) za svako \\(1 \\leq i \\leq N, 1 \\leq j \\leq Q\\) </li> <li>\\(1 \\leq r_j \\leq 10^8\\) za svako \\(1 \\leq j \\leq Q\\)</li> <li>\\(N, Q \\leq 100000\\).</li> <li>Za svako \\(1 \\leq i \\leq N\\) va\u017ei da se ta\u010dke \\((x_i, y_i)\\) i \\((u_i, v_i)\\) ne podudaraju.</li> </ul> <p>Test primeri su podeljeni u slede\u0107e grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N, Q \\leq 500\\).</li> <li>U test primerima vrednim 20 poena: \\(a_i = a_j, b_i = b_j\\) za svako \\(1 \\leq i, j \\leq Q\\).</li> <li>U test primerima vrednim 20 poena: \\(y_i = v_i\\) za svako \\(1 \\leq i \\leq N\\).</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv3/04_pozar/#analiza","title":"Analiza","text":"<p>Umesto da posmatramo problem \"iz perspektive kruga\", na\u0111imo za svaku pravu skup krugova imaju presek sa njom. Kako je \\(i\\)-ti krug sadr\u017ean u narednom, ako prava se\u010de \\(i\\)-ti krug, tada sigurno se\u010de i svaki naredni, \u0161to zna\u010di da ovaj skup krugova \u010dini segment, pritom, sufiks, niza krugova. Na\u0111imo, dakle, za svaku pravu najmanji krug koji se se\u010de sa njom. Iz gore izlo\u017eenog zaklju\u010dujemo da se ovaj krug mo\u017ee na\u0107i binarnom pretragom po krugovima - ako se neki krug ne se\u010de sa pravom, nastavljamo pretragu po ve\u0107im krugovima, ina\u010de, pamtimo re\u0161enje i tra\u017eimo me\u0111u manjim krugovima. Nakon \u0161to smo na\u0161li indeks \\(j\\) ovog najmanjeg kruga, u nizu re\u0161enja \\(z\\) treba brojevima \\(z_j, z_{j+1}, \\ldots, z_n\\) da dodamo \\(1\\), \u0161to mo\u017eemo uraditi tako \u0161to dodamo \\(1\\) broju \\(z_j\\) a nakon \u0161to obradimo sve prave izra\u010dunamo prefiksnu sumu niza \\(z\\), koju \u0161tampamo. </p>"},{"location":"takprog/2018_2019/kv3/04_pozar/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Da bismo ispitali da li se prava odre\u0111ena dvema ta\u010dkama \\(A, B\\) se\u010de sa krugom radijusa \\(r\\) sa centrom u ta\u010dki \\(C\\), najjednostavniji na\u010din je da na\u0111emo udaljenost prave \\(AB\\) do ta\u010dke \\(C\\) i da taj broj uporedimo sa \\(r\\). Izra\u010dunajmo dvostruku povr\u0161inu trougla \\(ABC\\) kao apsolutnu vrednost vektorskog proizvoda \\(2P = |CA \\times CB|\\) i du\u017einu du\u017ei \\(|AB|\\). Kako je udaljenost prave \\(AB\\) od \\(C\\) zapravo visina trougla \\(h_C\\), tu visinu mo\u017eemo izra\u010dunati preko povr\u0161ine: \\(h_C = \\frac{2P}{|AB|}\\). Pritom, sve ove operacije se mogu pouzdano izra\u010dunati pomo\u0107u tipa <code>double</code> sa relativnom precizno\u0161\u0107u \\(10^{-14}\\) \u0161to je dovoljno dobro za ovaj zadatak.</p> 04_pozar.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef ll niz[100005];\n\nint n, q;\nniz a, b, u, v, x, y, r, z;\n\nll det(ll ax, ll ay, ll bx, ll by, ll cx, ll cy) {\n    return ax*by + bx*cy + cx*ay - ay*bx - by*cx - cy*ax;\n}\n\nll kv(ll x) {\n    return x*x;\n}\n\nll dist2(ll a, ll b, ll c, ll d) {\n    return kv(a-c) + kv(b-d);\n}\n\nbool presek(ll u, ll v, ll x, ll y, ll a, ll b, ll r) {\n    ld dc = abs(det(u, v, x, y, a, b)) / sqrt((ld)dist2(u, v, x, y));\n    /*\n    ld eps = 1.2e-12;\n    ld err = abs((dc / r) - 1);\n    if (err &lt; eps) {\n        cerr &lt;&lt; \"Upozorenje! Vrednosti su previse blizu! Resenje je nepouzdano!\\n\";\n        exit(1);\n    }\n    */\n    return dc &lt; r;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;&gt; n;\n    for (int i=0; i&lt;n; i++)\n        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; u[i] &gt;&gt; v[i];\n    cin &gt;&gt; q;\n    for (int j=0; j&lt;q; j++)\n        cin &gt;&gt; a[j] &gt;&gt; b[j] &gt;&gt; r[j];\n\n    for (int i=0; i&lt;n; i++) {\n        int lo = 0, hi = q-1, o = q;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi) &gt;&gt; 1;\n            if (presek(u[i], v[i], x[i], y[i], a[mid], b[mid], r[mid])) {\n                o = mid;\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        z[o]++;\n    }\n    cerr &lt;&lt; '\\n';\n\n    ll sol = 0;\n\n    for (int i=0; i&lt;q; i++)\n        cout &lt;&lt; (sol += z[i]) &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2018_2019/kv3/05_sveska/","title":"5 - Sveska","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Nakon \u0161to je saznao da se porodica Vatreni\u0107 odselila iz Ni\u0161a, gospodin Bla\u017ei\u0107 mo\u017ee da prestane da brine o svojim opti\u010dkim kablovima i mo\u017ee da se posveti svojoj omiljenoj igri sa brojevima. On je na poklon dobio svesku sa \\(N\\) prirodnih brojeva, i svakog od narednih \\(Q\\) dana planira da uradi jednu od dve stvari:</p> <ol> <li>Da zameni \\(p\\)-ti broj u svesci (tj. \\(a_p\\)) brojem \\(x\\).</li> <li>Da za neka dva broja \\(l, r\\) uzme brojeve \\(a_l, a_{l+1}, \\ldots, a_r\\) i sa njima igra slede\u0107u igru:</li> </ol> <p>Prvo Bla\u017ei\u0107 bri\u0161e tablu a zatim zapisuje brojeve \\(a_l, a_{l+1}, \\ldots, a_r\\) na tu tablu. Zatim, ako je na tabli jedan od zapisanih brojeva broj \\(x\\), on u jednom potezu mo\u017ee da napi\u0161e na tablu broj \\(2x\\). Mo\u017ee da napi\u0161e i broj \\(\\frac x 2\\) pod uslovom da je \\(x\\) deljivo sa \\(2\\). Tako\u0111e, ako su na tabli napisani razli\u010diti brojevi \\(x, y\\), on mo\u017ee da napi\u0161e broj \\(x \\text{ xor } y\\) (za definiciju operacije \\(\\text{ xor }\\) videti napomenu). Pritom, prethodno zapisani brojevi se ne bri\u0161u. Va\u0161 zadatak je da, svaki put kada gospodin Bla\u017ei\u0107 igra igru, otkrijete koji je najmanji prirodan broj koji mo\u017ee biti zapisan na tabli nakon kona\u010dno mnogo poteza.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Slobodan Mitrovi\u0107 Slobodan Mitrovi\u0107"},{"location":"takprog/2018_2019/kv3/05_sveska/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan prirodan broj \\(N\\) - broj brojeva u svesci. Naredna linija sadr\u017ei \\(N\\) prirodnih brojeva \\(a_1, a_2 \\ldots, a_N\\), brojeve u svesci. Naredna linija sadr\u017ei jedan prirodan broj \\(Q\\) - broj dana. Zatim, \\(j\\)-ta od narednih \\(Q\\) linija po\u010dinje brojem \\(t_j\\) - tipom akcije koju \u0107e gospodin Bla\u017ei\u0107 preduzeti \\(j\\)-tog dana. Ukoliko je \\(t_j = 1\\), slede dva prirodna broja \\(p_j, x_j\\), koji ozna\u010davaju da \u0107e Bla\u017ei\u0107 \\(p_j\\)-ti broj u svesci zameniti brojem \\(x_j\\). Ukoliko je \\(t_j = 2\\), slede dva prirodna broja \\(l_j, r_j\\) i to zna\u010di da \u0107e tog dana gospodin Bla\u017ei\u0107 igrati igru po\u010dev\u0161i od trenutnih vrednosti brojeva \\(a_{l_j}, a_{l_j + 1}, \\ldots, a_{r_j}\\).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki dan kada je \\(t_j = 2\\) u posebnu liniju standardnog izlaza ispisati jedan prirodan broj - najmanji mogu\u0107 broj koji se mo\u017ee dobiti na tabli nakon kona\u010dno mnogo poteza ako se igra sa brojevima iz segmenta \\([l_j, t_j]\\).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/kv3/05_sveska/#ulaz","title":"Ulaz","text":"<pre><code>3\n3 5 15\n3\n2 1 3\n1 2 11\n2 1 2\n</code></pre>"},{"location":"takprog/2018_2019/kv3/05_sveska/#izlaz","title":"Izlaz","text":"<pre><code>3\n1\n</code></pre>"},{"location":"takprog/2018_2019/kv3/05_sveska/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Kada gospodin Bla\u017ei\u0107 prvi put igra igru, igra po\u010dinje sa brojevima \\([3, 5, 15]\\). Neki od brojeva koje Bla\u017ei\u0107 mo\u017ee da napi\u0161e na tabli su \\(6 = 3 \\text{ xor } 5\\), \\(30 = 2 \\cdot 15\\), ali, ne postoji na\u010din da zapi\u0161e broj manji od \\(3\\). Zatim, Bla\u017ei\u0107 zameni broj \\(a_2 = 5\\) brojem \\(11\\). Narednog dana on igra igru sa brojevima \\([3, 11]\\). On mo\u017ee dobiti broj \\(1\\) na slede\u0107i na\u010din: Prvo napravi \\(8 = 3 \\text{ xor } 11\\) a zatim deljenjem sa dva dobija redom brojeve \\(4, 2, 1\\).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei: \\(N, Q \\leq 100000\\), \\(0 &lt; a_i, x_j &lt; 2^{62}\\), \\(t_j \\in \\{1, 2\\}\\), \\(1 \\leq l_j \\leq r_j \\leq N\\), \\(1 \\leq p_j \\leq N\\), za svako \\(1 \\leq i \\leq N, 1 \\leq j \\leq Q\\).</p> <ul> <li>U test primerima vrednim 16 poena: \\(N, Q \\leq 100, a_i, x_j \\leq 7\\).</li> <li>U test primerima vrednim 28 poena: \\(N, Q \\leq 500\\).</li> <li>U test primerima vrednim 56 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/kv3/05_sveska/#napomena","title":"Napomena","text":"<p>Operator \\(\\text{ xor }\\) (ekskluzivna disjunkcija) u Pascal-u je ozna\u010den sa <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>^</code>. Ova operacija \\(x \\text{ xor } y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din: prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots, b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k\\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_i=0, b_i=0\\) va\u017ei \\(c_i=0\\)</li> <li>Za \\(a_i=0, b_i=1\\) va\u017ei \\(c_i=1\\)</li> <li>Za \\(a_i=1, b_i=0\\) va\u017ei \\(c_i=1\\)</li> <li>Za \\(a_i=1, b_i=1\\) va\u017ei \\(c_i=0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\text{ xor } y\\).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#analiza","title":"Analiza","text":"<p>Ukratko, re\u0161enje zadatka \u0107e izgledati ovako. Koristi\u0107emo segmentno stablo da odgovorimo na upite. Listovi u segmentnom stablu \u0107e biti jednaki nizu \\(a\\). \u010cvor u stablu koji je otac listova \\(a_i, \\ldots, a_j\\) \u0107e sadr\u017eati najmanji broj koji mo\u017ee biti zapisan na tabli nakon kona\u010dno mnogo poteza igre sa brojevima \\(a_i, \\ldots, a_j\\). Ovaj pristup name\u0107e dva glavna pitanja: - Za\u0161to je za svaki \u010dvor dovoljno \u010duvati samo najmanji broj koji se mo\u017ee dobiti igraju\u0107i se njegovim sinovima? - Ako je \u010dvor \\(v\\) otac \u010dvorova \\(L\\) i \\(R\\), kako iskombinovati vrednosti sa\u010duvane u \\(L\\) i \\(R\\) da se dobije vrednost za \u010dvor \\(v\\)?</p> <p>Da bismo odgovorili na ova pitanja, posmatra\u0107emo ovaj problem kao zadatak sa polinomima nad \\(\\mathbb{Z}_2\\).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#polinomi-nad-mathbbz_2-umesto-brojeva","title":"Polinomi nad \\(\\mathbb{Z}_2\\) umesto brojeva","text":"<p>Za broj \\(a\\) defini\u0161emo polinom \\(P_a(x)\\) nad \\(\\mathbb{Z}_2\\) na slede\u0107i na\u010din: \\(P_a(x)\\) sadr\u017ei \\(x^i\\) akko je \\(i\\)-ti bit broja \\(a\\) jednak \\(1\\). Primetimo da ako \\(P_a(x)\\) sadr\u017ei \\(x^i\\), onda je koeficijent ispred \\(x^i\\) ta\u010dno \\(1\\). Na primer, \\(P_5(x) = x^2 + 1\\), jer u binarnom zapisu broj \\(5\\) je jednak \\(101\\).</p> <p>Tada broj \\(a\\text{ xor }b\\) odgovara polinomu \\(P_a(x) + P_b(x)\\). Broj \\(2 \\cdot a\\) odgovara polinomu \\(x \\cdot P_a(x)\\), i broj \\(\\frac a 2\\) odgovara polinomu \\(\\frac {P_a(x)} x\\) (pod uslovom da je \\(a\\) deljivo sa \\(2\\)).</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#zadatak-bez-operacije-deljenja","title":"Zadatak bez operacije deljenja","text":"<p>Prvo \u0107emo posmatrati zadatak u slu\u010daju da opcija deljenja nije na raspolaganju, tj. mo\u017eemo da koristimo samo xor i mno\u017eenje (ili, u svetu polinoma, ako koristimo sabiranje i mno\u017eenje sa \\(x\\)).</p> <p>Primetimo da za bilo koji polinom \\(Q(x)\\) nad \\(\\mathbb{Z}_2\\), ako po\u010dnemo od polinoma \\(P_a(x)\\) mo\u017eemo dobiti polinom \\(P_a(x) \\cdot Q(x)\\) primenom samo ove dve operacije. Na primer, da bismo dobili \\(P_a(x) \\cdot Q(x)\\) po\u010dev\u0161i od \\(P_a(x)\\), prvo za svako \\(x^i\\) koje ima pozitivan koeficijent u \\(Q(x)\\) napravimo polinom \\(x^i \\cdot P_a(x)\\). Potom saberemo sve te polinome.</p> <p>Neka je \\(A\\) skup polinoma. Iz Bezuovog stava sada sledi da se primenom ove dve operacije na skup polinoma iz \\(A\\) mo\u017ee dobiti \\(NZD(A)\\) (najve\u0107i zajedni\u010dki delilac polinoma iz \\(A\\)). Po\u0161to se sabiranjem dva (razli\u010dita) polinoma koji su deljivi sa \\(NZD(A)\\) dobija polinom deljiv sa \\(NZD(A)\\) (koji je jednak ili ve\u0107i od \\(NZD(A)\\)), i tako\u0111e po\u0161to se mno\u017eenjem polinoma sa \\(x\\) dobija polinom deljiv sa \\(NZD(A)\\), to zna\u010di da je \\(NZD(A)\\) najmanji polinom koji mo\u017eemo dobiti primenom ove dve operacije.</p> <p>Tako\u0111e, ako imamo dva skupa polinoma \\(A\\) i \\(B\\), tada va\u017ei \\(NZD(NZD(A), NZD(B)) = NZD(A \\cup B)\\). Ovo opravdava pristup opisan na po\u010detku u kojem, da bismo izra\u010dunali najmanji zapisan broj u nekom intervalu (za koji smo u slu\u010daju da koristimo samo dve operacije zaklju\u010dili da odgovara \\(NZD\\) vrednosti odgovaraju\u0107ih polinoma), smo koristili segmentno stablo.</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#zadatak-sa-operacijom-deljenja","title":"Zadatak sa operacijom deljenja","text":"<p>Dosada\u0161nji opis re\u0161enja ovog zadatka je podrazumevao da ne koristimo operaciju deljenja sa \\(x\\). Po\u0161to ova operacija prakti\u010dno ka\u017ee da krajnji polinom ne treba da bude deljiv sa \\(x\\) (ina\u010de nije najmanji), deljenje mo\u017eemo primeniti tek na kraju ili \u010dak u svakom koraku tokom primene \\(NZD\\) operacija. \\(NZD\\) polinomi koje dobijamo u me\u0111u-koracima bi se u zavisnosti od primene deljenja razlikovali samo u deljivosti sa \\(x\\), \u0161to je nebitno za krajnji rezultat. Dakle, deljenje sa \\(x\\) je dovoljno primeniti samo na krajnji rezultat i ignorisati do tada.</p>"},{"location":"takprog/2018_2019/kv3/05_sveska/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Implementacija bilo koja od dva upita u segmentom stablu zahteva \\(O(\\log{n})\\) \\(NZD\\) operacija.</p> <p>Da bismo na\u0161li \\(NZD\\) dva polinoma \\(P_a(x)\\) i \\(P_b(x)\\) mo\u017eemo da iskoristimo neki od standardnih algoritama, na primer, Euklidov algoritam. Taj ceo proces u na\u0161em slu\u010daju, gde tako\u0111e imamo operaciju deljenja, mo\u017ee da se uradi na jednostavan na\u010din. Naime, po\u010dnemo od \\(a\\) i \\(b\\), i sve dok su oba razli\u010dita od \\(0\\) radimo slede\u0107e. Neka je \\(a \\leq b\\), i neka je \\(c\\) broj dobijen od \\(a\\) mno\u017eenjem (\"shift\"-ovanjem) sa \\(2\\) sve dok se \\(c\\) i \\(b\\) razlikuju po du\u017eini u binarnom zapisu. Potom \\(b\\) zamenimo sa \\(b\\text{ xor }c\\), i nastavimo proces. Kad jedan od brojeva \\(a\\) ili \\(b\\) postane \\(0\\), vratimo ne-nula me\u0111u njima na koji je primenjeno deljenje sa \\(2\\) dok je to mogu\u0107e.</p> 05_sveska.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nll bit_remove_tz(ll x) {\n    return x &gt;&gt; __builtin_ctzll(x);\n}\n\nll bit_gcd(ll x, ll y) { // x, y su neparni ili 0\n    if (!x) return y;\n    if (!y) return x;\n    while (1) {\n        x = bit_remove_tz(x);\n        y = bit_remove_tz(y);\n        if (x == y)\n            return x;\n        auto a = __builtin_clzll(x);\n        auto b = __builtin_clzll(y);\n        ll t = x;\n        x = (x &lt;&lt; max(a-b, 0)) ^ y;\n        y = t;\n    }\n}\n\nconst int MAXN = 131072;\nll a[2 * MAXN];\n\nll solve(int l, int r, int x, int xl, int xr) {\n    if (r &lt; xl || xr &lt; l)\n        return 0;\n    if (l &lt;= xl &amp;&amp; xr &lt;= r)\n        return a[x];\n    int xm = (xl + xr) &gt;&gt; 1;\n    return bit_gcd(solve(l, r, 2*x, xl, xm), solve(l, r, 2*x+1, xm+1, xr));\n}\n\nvoid change(int p, ll x) {\n    p += MAXN;\n    a[p] = x;\n    while (p &gt; 1) {\n        p &gt;&gt;= 1;\n        a[p] = bit_gcd(a[2*p], a[2*p+1]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n;\n    for (int i=1; i&lt;=n; i++) {\n        ll x;\n        cin &gt;&gt; x;\n        change(i, bit_remove_tz(x));\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int t;\n        cin &gt;&gt; t;\n        if (t == 2) {\n            int l, r;\n            cin &gt;&gt; l &gt;&gt; r;\n            cout &lt;&lt; solve(l, r, 1, 0, MAXN-1) &lt;&lt; '\\n';\n        } else {\n            int p;\n            ll x;\n            cin &gt;&gt; p &gt;&gt; x;\n            change(p, bit_remove_tz(x));\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/01_piramida/","title":"B1 - Piramida","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>U enigmatici, piramida je tip mozgalice koji treba da se popuni sa \\(P\\) re\u010di u \\(P\\) redova. Da bi se pravilno popunila, po\u010dinje se od prve re\u010di koja se sastoji od samo jednog slova. Svaka naredna re\u010d ima jedno slovo vi\u0161e od prethodne i mo\u017ee da se dobije dodavanjem jednog slova, a zatim proizvoljnim menjanjem redosleda dobijenih slova.</p> <p>Vama je dat niz od \\(N\\) stringova koji se sastoje od velikih slova engleske abecede. Ovi stringovi ne moraju nu\u017eno biti re\u010di nekog jezika, ve\u0107 mogu biti proizvoljni nizovi slova. Pritom, \\(k\\)-ti string ima du\u017einu ta\u010dno \\(k\\). Va\u0161 zadatak je da odredite najve\u0107i prirodan broj \\(P\\) takav da prvih \\(P\\) stringova \u010dini piramidu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Ivan Sto\u0161i\u0107 Dragan Uro\u0161evi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2018_2019/okr/01_piramida/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan prirodan broj \\(N\\) - broj stringova. Narednih \\(N\\) linija sadr\u017ei po jedan string (\\(k\\)-ti string \u0107e biti du\u017eine ta\u010dno \\(k\\)), odnosno niz velikih slova engleske abecede.</p>"},{"location":"takprog/2018_2019/okr/01_piramida/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati najve\u0107i prirodan broj \\(P\\) takav da prvih \\(P\\) stringova \u010dini piramidu.</p>"},{"location":"takprog/2018_2019/okr/01_piramida/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/01_piramida/#ulaz","title":"Ulaz","text":"<pre><code>7\nA\nAR\nRAK\nTRKA\nKARTA\nARTIKL\nAKROLIT\n</code></pre>"},{"location":"takprog/2018_2019/okr/01_piramida/#izlaz","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2018_2019/okr/01_piramida/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/okr/01_piramida/#ulaz_1","title":"Ulaz","text":"<pre><code>3\nA\nBC\nDEF\n</code></pre>"},{"location":"takprog/2018_2019/okr/01_piramida/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2018_2019/okr/01_piramida/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, najve\u0107a piramida koja mo\u017ee da se dobije se sastoji od prvih \\(5\\) stringova. Naime, re\u010d ARTIKL ne mo\u017ee da se dobije dodavanjem jednog slova re\u010di KARTA i menjanjem redosleda slova u rezultatu.</p> <p>U drugom primeru najdu\u017ea piramida se sastoji samo od prve re\u010di.</p>"},{"location":"takprog/2018_2019/okr/01_piramida/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei: \\(N \\leq 2500\\). Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N \\leq 10\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\).</li> <li>U test primerima vrednim 20 poena: Svi stringovi sadr\u017ee samo slova A i B.</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/okr/01_piramida/#napomena","title":"Napomena","text":"<p>Engleska abeceda se sastoji od slede\u0107ih slova: <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>. ASCII vrednosti ovih karaktera su od \\(65\\) za veliko slovo A do \\(90\\) za veliko slovo Z.</p>"},{"location":"takprog/2018_2019/okr/01_piramida/#analiza","title":"Analiza","text":"<p>Lako se zaklju\u010duje da se problem svodi na utvr\u0111ivanje da li par uzastopnih stringova mogu biti uzastopni redovi piramide. Provera da li dva stringa mogu biti uzastopni redovi se svodi na utvr\u0111ivanje broja pojavljivanja pojedinih slova engleskog alfabeta (nad kojim su stringovi napisani).  Ako sa \\(n_x[A], n_x[B], n_x[C], ..., n_x[Z]\\) ozna\u010dimo broj pojavljivanja, redom, slova \\(A, B, C, ..., Z\\) u stringu \\(x\\), a sa \\(n_y[A], n_y[B], n_y[C], ..., n_y[Z]\\) ozna\u010dimo broj pojavljivanja, redom, slova \\(A, B, C, ..., Z\\) u stringu \\(y\\), onda stringovi \\(x\\) i \\(y\\) mogu biti uzastopni redovi piramide ako i samo ako va\u017ei</p> \\[ |n_y[A]-n_x[A]| + |n_y[B]-n_x[B]| + |n_y[C]-n_x[C]+...+|n_y[Z]-n_x[Z]| = 1. \\]"},{"location":"takprog/2018_2019/okr/01_piramida/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Implementacija se svodi na proveru da li parovi uzastopnih stringova mogu biti redovi piramide. A ta provera se svodi na odre\u0111ivanje broja pojavljivanja pojedinih slova u ta dva stringa. Prebrajanje se mo\u017ee izvesti jednim prolazom kroz odgovaraju\u0107i string. Postupak se prekida u trenutku kada se stigne do para uzastopnih stringova koji ne mogu biti uzastopni redovi piramide ili kada se stigne do poslednjeg para stringova.</p> 01_piramida.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nbool moze(string s, string t) {\n    vector&lt;int&gt; f(26, 0);\n    for (char x : s)\n        f[x - 'A']++;\n    for (char x : t)\n        f[x - 'A']--;\n    return count(f.begin(), f.end(), 0) == 25;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.tie(nullptr);\n\n    int n, sol = 1;\n    string s;\n\n    cin &gt;&gt; n &gt;&gt; s;\n    for (int i=2; i&lt;=n; i++) {\n        string t;\n        cin &gt;&gt; t;\n        if (moze(s, t)) {\n            sol = i;\n            s = t;\n        } else {\n            break;\n        }\n    }\n\n    cout &lt;&lt; sol &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/","title":"B2 - Fotografisanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Anastasija je kupila nov fotoaparat i \u017eeli da postane fotograf. Kako bi zapo\u010dela svoju fotografsku karijeru odlu\u010dila je da prvog dana fotografi\u0161e svoje drugare, besplatno. </p> <p>Ona ima ukupno \\(N\\) drugara koje \u0107e fotografisati tog dana i oni su numerisani brojevima od \\(1\\) do \\(N\\). Svako od njenih drugara joj je rekao vreme u tom danu kada bi on \u017eeleo da ga Anastasija fotografi\u0161e. Dan ima \\(10^9\\) trenutaka koji su ozna\u010deni celim brojevima od \\(1\\) do \\(10^9\\). Ona u jednom trenutku mo\u017ee fotografisati vi\u0161e ljudi, ako su svi oni izrazili \u017eelju da se fotografi\u0161u u istom trenutku. </p> <p>Anastasija \u017eeli da pobolj\u0161a ovaj raspored. Po\u0161to nema mnogo vremena ona bira samo jednog drugara i bri\u0161e njegov termin za fotografisanje. Ona zatim bira novi termin za njega istog dana u intervalu od \\(1\\) do \\(10^9\\), takav da najve\u0107a pauza izme\u0111u dva uzastopna fotografisanja bude \u0161to manja. Pritom, dozvoljeno je da upi\u0161e isti termin kao onaj koji je prethodno bio upisan.</p> <p>Pomozite Anastasiji i umesto nje odaberite kom drugaru \u0107e da promeni termin i koje je vreme novog fotografisanja, kako ona ne bi gubila vreme i pripremila se \u0161to bolje za naporan prvi radni dan.</p> <p>Ako ima vi\u0161e re\u0161enja ispisati bilo koje. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Filip \u0106osovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalazi jedan ceo broj, \\(N\\), koji predstavlja broj Anastasijinih drugara koji \u0107e se fotografisati. U narednoj liniji se nalazi niz \\(T\\) od \\(N\\) celih broejeva, gde \\(T_i\\) predstavlja vreme za fotografisanje \\(i\\)-tog drugara. Niz \\(T\\) je dat u neopadaju\u0107em poretku.</p>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza se nalaze dva cela broja \\(X\\) i \\(Y\\) gde \\(X\\) predstavlja indeks drugara koji menja termin, a \\(Y\\) novo vreme za njegovo fotografisanje.</p>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/02_fotografisanje/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 6 7\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#izlaz","title":"Izlaz","text":"<pre><code>1 5\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/okr/02_fotografisanje/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n2 4 4\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#izlaz_1","title":"Izlaz","text":"<pre><code>1 4\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2018_2019/okr/02_fotografisanje/#ulaz_2","title":"Ulaz","text":"<pre><code>3\n28 28 28\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#izlaz_2","title":"Izlaz","text":"<pre><code>2 28\n</code></pre>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru je najbolje prvog drugara premestiti u trenutak 5 i tada je minimalna pauza 1. Mogu\u0107e je i premestiti ga u trenutak 6 ili 7, ali opet je minimalna pauza 1.</p> <p>U drugom primeru je najbolje prvog drugara premestiti u trenutak 4 i tako ne\u0107e biti pauze izme\u0111u termina za fotografisanje.</p> <p>U tre\u0107em primeru nema pauze izme\u0111u fotografisanja i najbolje je sve ostaviti kako je bilo.</p>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei:</p> <ul> <li>Niz \\(T\\) je sortiran neopadaju\u0107e.</li> <li>\\(2 \\leq N \\leq 2 \\cdot 10^5\\)</li> <li>\\(1 \\leq T_i \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N = 3\\).</li> <li>U test primerima vrednim 20 poena: Razlika najmanjeg i najve\u0107eg \u010dlana niza \\(T\\) je \\(1\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\)</li> <li>U test primerima vrednim 40 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#analiza","title":"Analiza","text":"<p>Prakti\u010dno je u zadatku dat sortiran niz od \\(N\\) prirodnih brojeva i zahteva se promena najvi\u0161e jednog \u010dlana tog niza tako da se minimizuje najve\u0107a razlika \u010dlanova koji su susedni ne po indeksima, ve\u0107 po vrednostima.</p> <p>Da bi se to postiglo, potrebno u jednom prolasku kroz niz odrediti najve\u0107u razliku izme\u0111u dva susedna \u010dlana. Ta najve\u0107a razlika mo\u017ee biti jedinstvena ili nejedinstvena, a mo\u017ee se pojavljivati na rubovima (po\u010detak i/ili kraj) niza i/ili u sredini niza.</p> <p>Ukoliko se najve\u0107a razlika susednih \u010dlanova niza pojavljuje na po\u010detku, odnosno na kraju niza, mogu\u0107e je prostim izjedna\u010davanjem prvog sa drugim \u010dlanom niza, odnosno poslednjeg sa pretposlednjim \u010dlanom u potpunosti eliminisati tu razliku.</p> <p>Me\u0111utim, za razliku od unutra\u0161njih \u010dlanova niza, pa\u017eljivom promenom rubnih \u010dlanova ne mo\u017ee do\u0107i do pove\u0107anja maksimalne razlike. Ova \u010dinjenica mo\u017ee se iskoristiti za smanjenje jo\u0161 neke razlike unutar ili na drugom kraju niza. Naime, umesto izjedna\u010davanja rubnog \u010dlana niza sa njegovim susedom, ovaj \u010dlan se mo\u017ee iskoristiti za potiranje druge najve\u0107e razlike. Na taj na\u010din, prakti\u010dno je u pojedinim slu\u010dajevima mogu\u0107e eliminisati prve dve najve\u0107e razlike pod uslovom da se jedna od njih nalazi na rubu niza.</p> <p>Konkretno, nije te\u0161ko pokazati da se do optimalnog re\u0161enja uvek dolazi promenom najmanjeg ili najve\u0107eg \u010dlana niza. Od ova dva \u010dlana neophodno je izmeniti onaj \u010dija je razlika s njegovim jedinim susedom ve\u0107a. Izmenjena vrednost treba da umanji najve\u0107u razliku u ostatku niza, a to je ispravno u\u010diniti promenom na vrednost aritmeti\u010dke sredine susednih \u010dlanova niza me\u0111u kojima je razlika najve\u0107a.</p>"},{"location":"takprog/2018_2019/okr/02_fotografisanje/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Mo\u017ee se prvo ispitati grani\u010dni slu\u010daj od dva \u010dlana koji se jednostavno re\u0161ava izjedna\u010davanjem vrednosti bilo prvog \u010dlana sa drugim, bilo drugog sa prvim. Ukoliko se pak niz sastoji od tri i vi\u0161e \u010dlanova treba odrediti da li je ve\u0107a razlika izme\u0111u prvog i drugog ili pretposlednjeg i poslednjeg \u010dlana niza. Potom u jednom prolasku kroz ostatak niza (kome ne pripada rub niza sa ve\u0107om razlikom) odrediti najve\u0107u razliku izme\u0111u susednih \u010dlanova. Jednostavnom promenom vrednosti rubnog \u010dlana na vrednost aritmeti\u010dke sredine dva susedna \u010dlana s najve\u0107om razlikom dolazimo do re\u0161enja zadatka. Kako u zadatku imamo jedan prolazak kroz niz u kojoj se tra\u017ei najve\u0107a razlika susednih \u010dlanova slo\u017eenosti \\(\\mathcal{O}(N)\\), to je ukupna vremenska slo\u017eenost algoritma linearna.</p> 02_fotografisanje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int MAXN=int(2e5+50);\n\nint main()\n{\n    int n;\n    pair &lt;int,int&gt; a[MAXN];\n\n    scanf(\"%d\",&amp;n);\n\n    for (int i=1; i&lt;=n; i++)\n    {\n        scanf(\"%d\",&amp;a[i].first);\n        a[i].second=i;\n    }\n\n    if (n==2)\n    {\n        printf(\"1 %d\\n\",a[2].first);\n        return 0;\n    }\n\n    sort(a+1,a+n+1);\n\n    if (a[2].first-a[1].first&gt;a[n].first-a[n-1].first)\n    {\n        int mx=-1;\n        for (int i=3; i&lt;=n; i++)\n            if (mx==-1 || a[i].first-a[i-1].first &gt; a[mx].first-a[mx-1].first)\n                mx=i;\n        printf(\"%d %d\\n\",a[1].second,(a[mx].first+a[mx-1].first)/2);\n    }\n    else\n    {\n        int mx=-1;\n        for (int i=2; i&lt;=n-1; i++)\n            if (mx==-1 || a[i].first-a[i-1].first &gt; a[mx].first-a[mx-1].first)\n                mx=i;\n        printf(\"%d %d\\n\",a[n].second,(a[mx].first+a[mx-1].first)/2);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/03_grupe/","title":"B3 - Grupe","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Dat je niz \\(A\\) du\u017eine \\(N\\). Tako\u0111e, dat je prirodan broj \\(L\\), tako da je \\(N\\) uvek deljivo sa \\(L\\).  Niz \\(A\\) podelimo na \\(L\\) grupa, gde je svaka grupa sa\u010dinjena od elemenata \u010diji indeksi daju iste ostatke pri deljenju sa \\(L\\).</p> <p>Na koliko na\u010dina se mogu izabrati indeksi \\(i\\) i \\(j\\), gde va\u017ei \\(1 \\leq i &lt; j \\leq N\\), tako da nakon \u0161to razmenimo elemente niza \\(A\\) sa ovim indeksima, va\u017ei da je suma svih grupa jednaka?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksandar Zlateski Dragan Uro\u0161evi\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2018_2019/okr/03_grupe/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva prirodna broja \\(N\\), \\(L\\) odvojena razmakom. Naredna linija sadr\u017ei \\(N\\) elemenata odvojenih razmakom - niz \\(A\\).</p>"},{"location":"takprog/2018_2019/okr/03_grupe/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati tra\u017eeno re\u0161enje.</p>"},{"location":"takprog/2018_2019/okr/03_grupe/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/03_grupe/#ulaz","title":"Ulaz","text":"<pre><code>4 2\n1 5 3 3\n</code></pre>"},{"location":"takprog/2018_2019/okr/03_grupe/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2018_2019/okr/03_grupe/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/okr/03_grupe/#ulaz_1","title":"Ulaz","text":"<pre><code>6 2\n1 2 3 4 5 6\n</code></pre>"},{"location":"takprog/2018_2019/okr/03_grupe/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2018_2019/okr/03_grupe/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru jednu grupu \u010dine elementi \u010diji indeksi daju ostatak \\(0\\) pri deljenju sa \\(2\\), i to su indeksi \\(2,4\\) na kojima se nalaze brojevi \\(A_2=5,A_4=3\\), dok drugu grupu \u010dine elementi \u010diji indeksi daju ostatak \\(1\\) pri deljenju sa \\(2\\), i to su indeksi \\(1,3\\) na kojima se nalaze brojevi \\(A_1=1,A_3=3\\). Mo\u017eemo razmeniti elemente sa indeksima 2 i 3, ili elemente sa indeksima 1 i 4.</p> <p>U drugom primeru ne postoji ni jedan na\u010din da razmenom dva elementa dobijemo da dve grupe imaju jednaku sumu.</p>"},{"location":"takprog/2018_2019/okr/03_grupe/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei:</p> <ul> <li>\\(1 \\leq N \\leq 200000\\)</li> <li>\\(0 \\leq A_i \\leq 2 \\cdot 10^6\\).</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N \\leq 10\\) i \\(A_i \\leq 500\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 100\\) i \\(A_i \\leq 500\\).</li> <li>U test primerima vrednim 20 poena: \\(A_i \\leq 500\\).</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/okr/03_grupe/#analiza","title":"Analiza","text":"<p>Primetimo da ako zbir svih elemenata niza nije deljiv brojm \\(L\\), onda ne postoji re\u0161enje, jer se niz ne mo\u017ee podeliti u \\(L\\) grupa koji imaju jednake zbirove. Zna\u010di u tom slu\u010daju je re\u0161enje nula (0). Ako je \\(S\\) zbir svih elemenata niza \\(S\\) i ako je \\(S\\) deljivo brojem \\(L\\), onda zbir svake od grupa mora biti \\(S/L\\). Neka je \\(L'\\) broj grupa za koje va\u017ei da je zbir razli\u010dit od \\(S/L\\). Tada va\u017ei slede\u0107e: Ako \\(L'\\not\\in\\{0,2\\}\\), onda ne postoji niti jedna razmena kojom bi se izjedna\u010dio zbir elemenata u svim grupama, pa je re\u0161enje nula. Ako je \\(L'=0\\), onda sve grupe ve\u0107 imaju jednak zbir, pa zbog toga razmena bilo kog para elemenata iz iste grupe ili bilo kog para elemenata koji imaju istu vrednost dovodi do niza koji zadovoljava uslov (da sve grupe imaju isti zbir). Broj razmena u kojima se razmenjuju elementi iz iste grupe je</p> \\[ L \\times \\frac{N/L(N/L-1)}{2}. \\] <p>Broj razmena u kojima se razmenjuju jednaki elementi se dobija tako \u0161to se prebroji broj pojavljivanja svake od vrednosti. Ako su \\(V_1, V_2, V_3, ..., V_K\\) razli\u010dite vrednosti koji se pojavljuju u nizu \\(a\\), a \\(n_{V_1}, n_{V_2}, n_{V_3}, ..., n_{V_K}\\), brojevi pojavljivanja tih vrednosti onda je broj razmena elemenata koji imaju istu vrednost jednak:</p> \\[ \\frac{n_{V_1}(n_{V_1}-1)}{2} + \\frac{n_{V_2}(n_{V_2}-1)}{2} + ... + \\frac{n_{V_K}(n_{V_K}-1)}{2}. \\] <p>Me\u0111utim, u ovom izrazu figuri\u0161u i razmene jednakih koji se nalaze u istoj grupi. Zbog toga te razmene treba oduzeti, a to \u0107emo izvesti tako \u0161to \u0107emo isti postupak prebrajanja vrednosti izvesti za svaku grupu i izra\u010dunati vrednost odgovaraju\u0107eg izraza (ekvivalentnog gornjem). Ako je \\(L'=2\\), onda postoje dve grupe u kojima se zbir ne poklapa sa prose\u010dnom vredno\u0161\u0107u (tj. sa \\(S/L\\)). U jednoj grupi je zbir ve\u0107i od proseka, a u drugoj je manji od proseka (pri \u010demu su apsolutne razlike tih suma i proseka jednake). Ozna\u010dimo sa \\(d\\) apsolutnu razliku sume jedne od tih grupa i proseka \\(S/L\\). Tada se mo\u017ee razmeniti bilo koji par elemenata iz te dve grupe za koji va\u017ei da je razlika elementa koji se nalazi grupi sa ve\u0107im zbirom i elementa koji se nalazi u grupi u kojoj je manji zbir jednak \\(d\\). Zna\u010di, potrebno je prebrojati broj pojavljivanja pojedinih vrednosti u dve grupe, nakon toga izmno\u017eiti odgovaraju\u0107e brojeve pojavljivanja i proizvode sabrati.</p>"},{"location":"takprog/2018_2019/okr/03_grupe/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Budu\u0107i da su vrednosti elementa manje od ili jednake \\(10^6\\), mo\u017ee se formirati niz u kome \u0107e se ra\u010dunati brojevi pojavljivanja pojedinih vrednosti. Zbog toga brojeve pojavljivanja pojedinih vrednosti mo\u017eemo odrediti jednim prolazom kroz niz. Pored toga potreban je jedan prolaz kroz niz kako bi se odredili zbirovi elemenata po grupama. Ali kako se u oba slu\u010daja radi o jednom prolazu kroz niz, algoritam ima linearnu slo\u017eenost.</p> 03_grupe.cpp<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing std::int64_t;\n\nint main()\n{\n    int64_t N, K, sum = 0;\n    std::cin &gt;&gt; N &gt;&gt; K;\n\n    std::vector&lt;std::map&lt;int64_t, int64_t&gt;&gt; distributions(K);\n    std::vector&lt;int64_t&gt;                    groups(K);\n    std::map&lt;int64_t, int64_t&gt;              frequencies;\n\n    for (int64_t i = 0; i &lt; N; ++i)\n    {\n        int64_t w;\n        std::cin &gt;&gt; w;\n        sum += w;\n        groups[i % K] += w;\n        ++distributions[i % K][w];\n        ++frequencies[w];\n    }\n\n    if (sum % K)\n    {\n        std::cout &lt;&lt; \"0\\n\";\n        return 0;\n    }\n\n    auto average = sum / K;\n\n    std::vector&lt;int64_t&gt; not_average;\n    for (int64_t i = 0; i &lt; K; ++i)\n    {\n        if (groups[i] != average)\n            not_average.push_back(i);\n    }\n\n    int64_t solution = 0;\n\n    // Mozemo da zamenimo bilo koji par elemenata iste vrednosti, ili\n    // bilo koja dva elementa iz iste grupe\n    if (not_average.size() == 0)\n    {\n        solution = K * (N / K) * (N / K - 1) / 2;\n        for (auto const&amp; f : frequencies)\n            solution += (f.second * (f.second - 1)) / 2;\n        // Neke smo racunali duplo (iste vrednosti iz istih grupa)\n        for (auto const&amp; d : distributions)\n            for (auto const&amp; f : d)\n                solution -= (f.second * (f.second - 1)) / 2;\n    }\n    // Moramo da zamenimo elemente iz ove dve grupe\n    else if (not_average.size() == 2)\n    {\n        auto const&amp; distribution_a = distributions[not_average[0]];\n        auto&amp;       distribution_b = distributions[not_average[1]];\n\n        int64_t delta = average - groups[not_average[0]];\n\n        for (auto const&amp; d : distribution_a)\n        {\n            solution += d.second * distribution_b[d.first + delta];\n        }\n    }\n\n    std::cout &lt;&lt; solution &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/","title":"A1 - Izgubljeni niz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Profesor Fe\u0111a, strastveni ribolovac i obo\u017eavalac ronjenja na dah, prona\u0161ao je svoj 14. omiljeni hobi - zaboravljanje nizova. Ova novootkrivena disciplina te\u010de na slede\u0107i na\u010din: </p> <p>Na po\u010detku, Fe\u0111a zamisli niz \\(A\\) sa \\(N\\) prirodnih brojeva. Nakon toga on na papiru zapi\u0161e niz \\(B\\) sa ta\u010dno \\(\\frac{N (N+1)}{2}\\) brojeva. \u010clanovi niza \\(B\\) su dobijeni primenom bitovne operacije $\\ \\text{or} \\ $ (videti napomenu) na sve parove brojeva iz niza \\(A\\), preciznije:</p> <p>Za svaki ure\u0111eni par indeksa (\\(i, j\\)), (\\(1 \\leq i \\leq j \\leq N\\)) iz niza \\(A\\) u nizu \\(B\\) je zapisana vrednost \\(A_i \\ \\text{or} \\  A_j\\). Ako je neka vrednost ista za vi\u0161e parova, ona se u nizu \\(B\\) pojaljuje ta\u010dno onoliko puta koliko ima parova sa tom vredno\u0161\u0107u. Ove vrednosti se u nizu \\(B\\) mogu javiti u proizvoljnom redosledu.</p> <p>Naravno, profesor se umorio nakon zapisivanja svih ovih brojeva i u potpunosti zaboravio prvobitno zami\u0161ljeni niz \\(A\\). Sre\u0107om na papiru mu je ostao zapisan niz \\(B\\). Da li mo\u017eete da pomognete na\u0161em dragom profesoru i prona\u0111ete izgubljeni niz \\(A\\)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Vladimir Milovanovi\u0107 Mom\u010dilo Topalovi\u0107"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se jedan prirodan broj \\(N\\), du\u017eina izgubljenog niza \\(A\\). U drugoj liniji standardnog ulaza nalazi se \\(\\frac{N (N+1)}{2}\\) prirodnih brojeva, elementi niza \\(B\\) opisanog u tekstu zadatka.</p>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati \\(N\\) prirodnih brojeva, elemente izgubljenog niza \\(A\\). Garantuje se da su ulazni podaci takvi da postoji bar jedan odgovaraju\u0107i niz. Ako postoje vi\u0161e mogu\u0107ih nizova, ispisati bilo koje re\u0161enje.</p>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#ulaz","title":"Ulaz","text":"<pre><code>3\n5 4 2 3 1 6\n</code></pre>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#izlaz","title":"Izlaz","text":"<pre><code>1 4 2\n</code></pre>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Izgubljeni niz \\(A\\) ima \\(N=3\\) \u010dlana i treba ga prona\u0107i koriste\u0107i niz \\(B=[5, 4, 2, 3, 1, 6]\\). Jedan od mogu\u0107ih nizova je \\(A = [1, 4, 2]\\). Ako primenimo bitovnu operaciju \\(or\\) na sve parove brojeva u nizu \\(A\\) dobijamo:</p> <ul> <li>\\(A_1 \\ \\text{or} \\ A_2 = 5 = B_1\\)</li> <li>\\(A_2 \\ \\text{or} \\  A_2 = 4 = B_2\\)</li> <li>\\(A_3 \\ \\text{or} \\  A_3 = 2 = B_3\\)</li> <li>\\(A_1 \\ \\text{or} \\  A_3 = 3 = B_4\\)</li> <li>\\(A_1 \\ \\text{or} \\ A_1 = 1 = B_5\\)</li> <li>\\(A_2 \\ \\text{or} \\  A_3 = 6 = B_6\\)</li> </ul>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ee ograni\u010denja </p> <ul> <li>\\(1 \\leq N \\leq 1268\\)</li> <li>\\(1 \\leq B_i &lt; 2^{20}\\)</li> </ul> <p>Test primeri su podeljeni u \\(3\\) disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ee ograni\u010denja \\(1 \\leq N \\leq 7\\) i \\(1 \\leq B_i \\leq 7\\) .</li> <li>U test primerima vrednim \\(40\\) poena va\u017ei ograni\u010denje \\(1 \\leq N \\leq 91\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#napomena","title":"Napomena","text":"<p>Operator disjunkcije u Pascal-u je ozna\u010den sa <code>or</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>|</code>. Ova operacija \\(x\\ \\text{or} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_i = 0, b_i = 0\\) va\u017ei \\(c_i = 0\\)</li> <li>Za \\(a_i = 0, b_i = 1\\) va\u017ei \\(c_i = 1\\)</li> <li>Za \\(a_i = 1, b_i = 0\\) va\u017ei \\(c_i = 1\\)</li> <li>Za \\(a_i = 1, b_i = 1\\) va\u017ei \\(c_i = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{or} \\  y\\).</p>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#analiza","title":"Analiza","text":"<p>Pre po\u010detka klju\u010dno je uvideti da po\u0161to za svako \\(x\\) va\u017ei \\(x\\ \\text{or}\\ x = x\\), a kako niz \\(B\\) izme\u0111u ostalih sadr\u017ei i rezultate operacije ili primenjene nad istim \u010dlanom izvornog niza, zaklju\u010duje se da je tra\u017eeni niz \\(A\\) zapravo podskup zadatog niza. Name\u0107e se naivno re\u0161enje da se formiraju svi podskupovi niza \\(B\\) koji sadr\u017ee ta\u010dno \\(N\\) \u010dlanova, a zatim ispita koji ta\u010dno od njih daje zadati niz \\(B\\), me\u0111utim, ovo re\u0161enje pati od izuzetno visoke vremenske slo\u017eenosti.</p> <p>Nije te\u0161ko dalje zaklju\u010diti da rezultat ili operacije nad bitovima dva prirodna broja (operandi) nikada nije manji, ve\u0107 isklju\u010divo broj ve\u0107i ili jednak ve\u0107em operandu. Iz prethodnog lako se izvodi da su dva po vrednosti najmanja \u010dlana datog niza \\(B\\), ozna\u010dimo ih sa \\(B_{S1}\\) i \\(B_{S2}\\), sigurno i \u010dlanovi izvornog niza \\(A\\), odnosno \\(A_1 = B_{S1}\\) i \\(A_2 = B_{S2}\\). Slede\u0107i \u010dlan izvornog niza \\(A_3\\) bi\u0107e ili tre\u0107i po vrednosti \u010dlan niza \\(B\\), to jest \\(B_{S3}\\), ili pak \u010detvrti, \\(B_{S4}\\), ukoliko je \\(A_1\\ \\text{or}\\ A_2 = B_{S3}\\). Ponavljanjem ovog postupka, mo\u017ee se do\u0107i do svih \u010dlanova izvornog niza, na mnogo efikasniji na\u010din od prethodno pomenutog.</p> <p>Naime, u svakom koraku algoritma iz niza \\(B\\) treba eliminisati ili na neki na\u010din ozna\u010diti sve \u010dlanove koje je mogu\u0107e formirati pomo\u0107u \u010dlanova niza \\(A\\) koji su ve\u0107 odre\u0111eni, a zatim u niz \\(A\\) dodati prvi slede\u0107i po vrednosti \u010dlan zadatog niza.</p>"},{"location":"takprog/2018_2019/okr/04_izgubljeni_niz/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Po u\u010ditavanju \u010dlanova niza \\(B\\) najpre je zadati niz neophodno sortirati u neopadaju\u0107em redosledu koriste\u0107i se nekim efikasnim algoritmom. Po\u0161to niz \\(B\\) ne sadr\u017ei jedinstvene vrednosti, ve\u0107 se jedna vrednost mo\u017ee ponavljati vi\u0161e puta, u jednom prolasku kroz dobijeni sortiran niz ozna\u010diti indekse kada se svaka vrednost pojavljuje prvi put. Zatim, u glavnoj petlji, prolaziti kroz sortiran zadati niz \\(B\\) i dodavati \u010dlanove u niz \\(A\\), ali samo pod uslovom da taj \u010dlan ve\u0107 nije mogu\u0107e dobiti nekom kombinacijom \u010dlanova koji su ve\u0107 dodati u niz \\(A\\). Da bi se ovo izvelo na efikasan na\u010din, prilikom svakog novog dodavanja u niz \\(A\\) proveriti i ozna\u010diti sve indekse \u010dlanova niza \\(B\\) koje je mogu\u0107e formirati uparivanjem poslednje dodatog \u010dlana sa svim prethodnim koji se ve\u0107 nalaze u nizu \\(A\\). Drugim re\u010dima mogu\u0107e je koriste\u0107i se ve\u0107 ozna\u010denim indeksima pojedinih vrednosti i njihovim inkrementiranjem znati do kog indeksa niza \\(B\\) je izvodljivo generisati sve \u010dlanove, a zatim dodati prvi slede\u0107i kada se do njega do\u0111e. Ovaj proces nastaviti dok se ne pro\u0111e kroz \u010ditav zadati niz. Kako niz \\(B\\) sadr\u017ei \\(\\frac{N(N+1)}{2}\\) \u010dlanova, glavna petlja ima zapravo kvadratnu slo\u017eenost, odnosno \\(\\mathcal{O}(N^2)\\). Me\u0111utim, kako je zadati niz prethodno sortiran, to \u0107e ova operacija dominirati, te je zapravo \\(\\mathcal{O}(N^2\\log N)\\) ukupna vremenska slo\u017eenost ovog algoritma.</p> 04_izgubljeni_niz.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxA=1&lt;&lt;20;\nint vis[maxA], a[maxA], b[maxA], cnt[maxA];\nint n,m;\nint main()\n{\n    cin&gt;&gt;n;\n    m = (n*(n+1))/2;\n\n    for (int i=1; i&lt;=m; i++)\n        scanf(\"%d\",&amp;b[i]);\n\n    sort(b+1,b+m+1);\n\n    for (int i=1; i&lt;=m; i++)\n        if (!cnt[b[i]])\n            cnt[b[i]]=i;\n\n    int cur = 0;\n    for (int i = 1; i &lt;= m; i++)\n        if (!vis[i])\n        {\n            a[++cur] = b[i];\n\n            for (int j=1; j&lt;=cur; j++)\n            {\n                vis[cnt[a[j]|a[cur]]] = 1;\n                cnt[a[j]|a[cur]]++;\n            }\n        }\n\n    for (int i = 1; i &lt;= n; i++)\n        printf(\"%d \",a[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/","title":"A2 - Slepi brojevi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 128MB <p>Mali \u0110ole je sino\u0107 sanjao dva broja: \\(S\\) i \\(K\\). Iznenada se probudio, i odmah zapisao dve definicije koje su mu pale na pamet:</p> <ul> <li>Slepi brojevi su oni brojevi \u010dija je suma cifara jednaka \\(S\\).</li> <li>Klepi par \u010dine dva Slepa broja \u010diji je proizvod deljiv sa \\(K\\).</li> </ul> <p>Da bi se \u0110ole ponovo uspavao, on \u017eeli da prebroji koliko ima Klepih parova, koje \u010dine neka dva Slepa broja iz intervala \\([A,B]\\). Brzo je shvatio da ovakvih parova mo\u017ee imati mnogo, pa vas je zamolio za pomo\u0107 da mu brzo ka\u017eete kako bi odmoran stigao na takmi\u010denje iz enigmatike.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Vladimir Milenkovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei \u010detiri prirodna broja broj \\(A, B, S\\) i \\(K\\) odvojena razmakom.</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati ukupan broj Klepih parova koje \u010dine neka dva Slepa broja iz intervala \\([A,B]\\).</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#ulaz","title":"Ulaz","text":"<pre><code>1 100 3 9\n</code></pre>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#izlaz","title":"Izlaz","text":"<pre><code>10\n</code></pre>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#ulaz_1","title":"Ulaz","text":"<pre><code>80 120 15 6\n</code></pre>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru Slepi brojevi iz datog intervala su: \\(3,12,21\\) i \\(30\\) (svi brojevi od \\(1\\) do \\(100\\) \u010dija je suma cifara \\(3\\)). Parovi Slepih brojeva \u010diji je proizvod deljiv sa \\(9\\) \u010dine Klepe brojeve, i u ovom slu\u010daju imamo \\(10\\) takvih parova: \\((3,3), (3,12), (3,21), (3,30), (12,12), (12,21), (12,30), (21,21), (21,30), (30,30).\\)</p> <p>U drugom primeru imamo dva Slepa broja: \\(87\\) i \\(96\\), i dva Klepa para: \\((87,96), (96,96)\\).</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei: \\(1 \\leq S \\leq 100\\), i \\(B \\geq A \\geq 1\\), i \\(K \\geq 1\\).</p> <p>Test primeri su podeljeni u \\(4\\) disjunktne grupe:</p> <ul> <li>U test primerima vrednim 25 poena: \\(A,B,K \\leq 10000\\).</li> <li>U test primerima vrednim 30 poena: \\(A,B \\leq 10^6\\), i \\(K \\leq 10000\\).</li> <li>U test primerima vrednim 35 poena: \\(A,B,K \\leq 10^6\\).</li> <li>U test primerima vrednim 10 poena: \\(A,B \\leq 10^{12}\\), i \\(B-A \\leq 10^6\\), i \\(K \\leq 10^6\\).</li> </ul>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#analiza","title":"Analiza","text":"<p>Primetimo da, u svim potproblemima, mo\u017eemo na po\u010detku izdvojiti sve slepe brojeve - proveru da li je neki broj slep mo\u017eemo uraditi u slo\u017eenosti \\(O(\\log B)\\), tako da mo\u017eemo izdvojiti sve takve u \\(\\mathcal{O}((B - A)\\log B)\\), \u0161to je dovoljno brzo.</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#potproblem-1","title":"Potproblem 1","text":"<p>Primetimo da mo\u017eemo da probamo sve parove slepih brojeva (ima ih najvi\u0161e \\((B - A) ^ 2\\) (gruba granica)), i videti koji od tih parova je klep, proverom da li \\(K\\) deli njihov proizvod, u slo\u017eenosti \\(\\mathcal{O}((B - A) ^ 2)\\)</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#potproblem-2","title":"Potproblem 2","text":"<p>Zapravo, nas samo interesuju ostaci svih slepih brojeva pri deljenju sa  \\(K\\) - samo od ostataka pri deljenju dva broja nekim brojem zavisi i ostatak proizvoda. Dakle, mo\u017eemo imati broja\u010d koliko postoji slepih brojeva sa svakim ostatkom, i u \\(\\mathcal{O}(K^2)\\) izra\u010dunati koliko ima klepih parova.</p>"},{"location":"takprog/2018_2019/okr/05_slepi_brojevi/#potproblemi-3-i-4","title":"Potproblemi 3 i 4","text":"<p>Neka je \\(z\\) broj slepih brojeva deljivih sa  \\(K\\). Posmatrajmo sve ostale slepe brojeve. Ukoliko posmatramo neki broj \\(x\\), neka je \\(t = gcd(x, k)\\). Par  \\((x, y)\\) \u0107e biti klep ukoliko va\u017ei \\(\\frac{k}{t} \\mid y\\) - dakle, kada tra\u017eimo sve brojeve koji formiraju klep par sa brojem \\(x\\), treba nam broj brojeva deljivih sa nekim brojem. To mo\u017eemo lako uraditi prolaskom kroz niz slepih brojeva (tj. njihovih ostataka pri deljenju sa \\(K\\)) - kada nai\u0111emo na broj \\(x\\), dodamo \\(\\mathrm{count}[K / gcd(x, K)]\\) na re\u0161enje, i uve\u0107amo \\(\\mathrm{count}\\) svakog delioca broja \\(x\\) za 1. Ovo re\u0161enje radi u slo\u017eenosti \\(\\mathcal{O}(\\mathrm{brSlepih} \\cdot \\sqrt{K})\\), \u0161to je sigurno dovoljno brzo, jer ne postoji ulaz za koji je broj slepih brojeva ve\u0107i od 50000. Na ovo dobijeno re\u0161enje treba dodati \\(z \\choose 2\\), kao i \\(z \\cdot (\\mathrm{brSlepih} - z)\\).</p> 05_slepi_brojevi.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXKLEPI 1000555\n#define MAXK 1000555\n\nlong long zbir_cifara(long long x) {\n    if (x == 0) return 0;\n    return (x%10) + zbir_cifara(x/10);\n}\n\nlong long nzd(long long a, long long b) {\n    return b ? nzd(b, a%b) : a;\n}\n\nlong long ostaci[MAXK];\nlong long solve(long long a, long long b, long long s, long long k) {\n\n    for(long long i=0; i&lt;=k; i++) ostaci[i] = 0;\n\n    for(long long i=a; i&lt;=b; i++) {\n        if (zbir_cifara(i) == s) {\n            ostaci[i%k]++;\n        }\n    }\n\n    long long res = (ostaci[0]*(ostaci[0]+1))/2;\n    for(long long i=1; i&lt;k; i++) {\n\n        res += ostaci[i]*ostaci[0];\n\n        long long t = k / nzd(i,k);\n        long long j;\n        for(j=t; j&lt;i; j+=t) {\n            res += ostaci[i]*ostaci[j];\n        }\n        if (j==i) {\n            res += (ostaci[i]*(ostaci[i]+1))/2;\n        }\n    }\n\n    return res;\n}\nint main() {\n\n    long long a,b,s,k;\n    scanf(\"%lld%lld%lld%lld\", &amp;a, &amp;b, &amp;s, &amp;k);\n    printf(\"%lld\\n\", solve(a,b,s,k));\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/okr/06_zetoni/","title":"A3 - \u017detoni","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Buba u svom laptopu ima igricu koja sadr\u017ei beskona\u010dnu tablu \u010dije su vrste i kolone indeksirane prirodnim brojevima. U po\u010detku, kada se igrica pokrene, na polju \\((1, 1)\\) nalazi se jedan \u017eeton. Svakog dana, kad nema \u0161ta drugo da radi, ona klikne na polje na kojem se nalazi bar jedan \u017eeton, recimo, polje \\((x, y)\\), i nakon toga se jedan \u017eeton skloni sa tog polja a po jedan \u017eeton se dodaje na polja \\((x+1, y)\\) i \\((x, y+1)\\). Ali avaj! Zli kosmi\u010dki zrak (po svojoj prirodi gama foton energije nekoliko desetina megaelektronvolti) je udario u \u0107eliju RAM memorije i time izbrisao sve \u017eetone sa table.</p> <p>Bubu je ovo jako potreslo pa je njen drug odlu\u010dio da joj pomogne. Oni su prona\u0161li i skinuli izvorni kod igrice i pokrenuli je u debug modu. U ovom modu igra\u010d mo\u017ee kliknuti na bilo koje polje table i na to polje se dodaje jedan \u017eeton. Ako se u nekom trenutku tabla nalazi u stanju do kojeg je mogu\u0107e do\u0107i normalnim igranjem igre, Buba \u0107e uzviknuti \"Stop!\" a zatim \u0107e izdiktirati niz poteza koji bi pri normalnom igranju igre doveo tablu u to stanje.</p> <p>Va\u0161 zadatak je da pomognete Bubinom drugu da, za dati niz klikova u debug modu predvidi u kom trenutku \u0107e ona uzviknuti \"Stop!\", kao i koji niz poteza bi ona tada mogla da izdiktira.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Mom\u010dilo Topalovi\u0107"},{"location":"takprog/2018_2019/okr/06_zetoni/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan prirodan broj \\(N\\) - du\u017einu niza klikova. Narednih \\(N\\) linija sadr\u017ei po dva prirodna broja \\(x_i, y_i\\), odvojena razmakom - koordinate polja na koja \u0107e kliknuti Bubin drug.</p>"},{"location":"takprog/2018_2019/okr/06_zetoni/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko \u0107e Buba u nekom trenutku uzviknuti \"Stop!\", ispisati trenutak u kojem \u0107e se to desiti. Preciznije, ukoliko \u0107e ona uzviknuti \"Stop!\" nakon \\(k\\) klikova, u prvu liniju standardnog izlaza ispisati broj \\(k\\). U narednih \\(k-1\\) linija ispisati redom poteze, ta\u010dnije, koordinate polja odvojene razmakom, koji bi pri normalnoj igri doveli tablu u taj polo\u017eaj. Ako postoji vi\u0161e takvih nizova poteza, \u0161tampati bilo koji. U suprotnom, ako Buba ne\u0107e ni u jednom trenutku uzviknuti \"Stop!\", u prvu i jedinu liniju standardnog izlaza ispisati broj \\(-1\\).</p>"},{"location":"takprog/2018_2019/okr/06_zetoni/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/okr/06_zetoni/#ulaz","title":"Ulaz","text":"<pre><code>4\n2 2\n1 2\n3 1\n2 3\n</code></pre>"},{"location":"takprog/2018_2019/okr/06_zetoni/#izlaz","title":"Izlaz","text":"<pre><code>3\n1 1\n2 1\n</code></pre>"},{"location":"takprog/2018_2019/okr/06_zetoni/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2018_2019/okr/06_zetoni/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n4 1\n3 2\n2 3\n1 4\n</code></pre>"},{"location":"takprog/2018_2019/okr/06_zetoni/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2018_2019/okr/06_zetoni/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, Buba \u0107e uzviknuti \"Stop!\" nakon \u0161to njen drug doda tri \u017eetona na polja \\((2, 2), (1, 2), (3, 1)\\). Buba mo\u017ee do istog izgleda table do\u0107i normalnom igrom tako \u0161to prvo klikne na polje \\((1, 1)\\), pri \u010demu \u0107e se taj \u017eeton obrisati sa tog polja a pojavi\u0107e se po jedan \u017eeton na poljima \\((2, 1)\\) i \\((1, 2)\\). Nakon toga ona mo\u017ee da klikne na polje \\((2, 1)\\). Sa tog polja se \u017eeton bri\u0161e a dodaje se po jedan \u017eeton na polja \\((3, 1)\\) i \\((2, 2)\\). Sada se na tabli nalaze tri \u017eetona na pozicijama: \\((3, 1), (2, 2), (1, 2)\\), odnosno, dobija se isti izgled table kao onaj koji je njen drug napravio nakon tri klika u debug modu.</p> <p>U drugom primeru ni u jednom trenutku se ne dobija tabla koju Buba mo\u017ee da napravi normalnom igrom.</p>"},{"location":"takprog/2018_2019/okr/06_zetoni/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei: \\(N, x_i, y_i \\leq 500.000\\). Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 8 poena: \\(N, x_i, y_i \\leq 4\\).</li> <li>U test primerima vrednim 28 poena: \\(N, x_i, y_i \\leq 10\\).</li> <li>U test primerima vrednim 18 poena: \\(N, x_i, y_i \\leq 100\\).</li> <li>U test primerima vrednim 54 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/okr/06_zetoni/#analiza","title":"Analiza","text":"<p>Dodelimo \u017eetonu na poziciji \\((x, y)\\) vrednost \\(2^{2-x-y}\\). Primetimo da se nakon jednog poteza pri normalnoj igri zbir vrednosti svih \u017eetona ne\u0107e promeniti, \u0161to zna\u010di da je potreban (ali ne i dovoljan) uslov da Buba ka\u017ee \"Stop!\" da zbir vrednosti svih \u017eetona bude ta\u010dno \\(1\\). Po\u0161to se dodavanjem novog \u017eetona u debug modu ova vrednost pove\u0107ava, ovo zna\u010di da \u0107e u najvi\u0161e jednom trenutku zbir vrednosti svih \u017eetona na tabli biti jednak \\(1\\). Ako vrednost table \"presko\u010di\" \\(1\\) ili nikad ne dostigne \\(1\\), znamo da nema re\u0161enja.</p> <p>U trenutku kada vrednost dostigne \\(1\\), poku\u0161a\u0107emo da rekonstrui\u0161emo niz poteza koji tablu dovodi u to stanje. Ovo \u0107emo raditi grabljivim algoritmom odnazad. Posmatrajmo sve \u017eetone u poslednjoj nepraznoj dijagonali (pod dijagonalom podrazumevamo skup polja sa konstantnom vredno\u0161\u0107u \\(x+y\\)). Re\u0161enje postoji ako i samo ako se oni mogu upariti tako da svaki par \u010dine dva \u017eetona koji se nalaze na poljima koja imaju zajedni\u010dko teme.</p> <p>Ovo uparivanje se mo\u017ee uraditi na jedinstven na\u010din, ako je uop\u0161te mogu\u0107e, ponovo grabljivim algoritmom redom od \u017eetona sa najmanjom \\(x\\)-koordinatom. Ako smo uspe\u0161no uparili sve \u017eetone iz ove dijagonale, za svaki par uparenih \u017eetona na pozicijama \\((x, y+1), (x+1, y)\\) kreiramo jedan \u017eeton na poziciji \\((x, y)\\). Ovaj postupak ponavljamo sve dok ne do\u0111emo do prve dijagonale ili ne do\u0111emo u situaciju da ne mo\u017eemo da uparimo \u017eetone.</p> <p>Ako do\u0111emo do stanja gde je samo jedan \u017eeton u prvoj dijagonali, re\u0161enje \u0161tampamo kao obrnuti niz \u017eetona koje smo kreirali tokom obilaska dijagonala.</p>"},{"location":"takprog/2018_2019/okr/06_zetoni/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Trenutak kada zbir vrednosti svih \u017eetona postane jednak \\(1\\) mo\u017eemo prona\u0107i tako \u0161to odr\u017eavamo binarni zapis razlomka koji sadr\u017ei trenutni zbir vrednosti. Kada dodajemo \u017eeton na poziciju \\((x,y)\\), u pomo\u0107nom nizu \\(c\\) treba pove\u0107ati broj \\(c_{x+y-2}\\) za \\(1\\). Ako njegova vrednost postane \\(2\\), onda je postavljamo na \\(0\\) i isti postupak ponavljamo za cifru na poziciji \\(x+y-3\\), i tako dalje, do zaustavljanja.</p> <p>Amortizovanom analizom slo\u017eenosti se mo\u017ee pokazati da ovaj postupak ima vremensku slo\u017eenost \\(O(N)\\). U re\u0161enju dominira vremenska slo\u017eenost za sortiranje svake dijagonale, po\u0161to \u0107e sve one ukupno sadr\u017eati \\(O(N)\\) \u017eetona vremenska slo\u017eenost je \\(O(N \\log N)\\) dok je memorijska slo\u017eenost \\(O(N)\\).</p> 06_zetoni.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint c[1000005], cp, n, x[500005], y[500005];\n\nvoid dodaj(int x) {\n    if (++c[x] == 2) {\n        c[x] = 0;\n        cp--;\n        dodaj(x-1);\n    } else {\n        cp++;\n    }\n}\n\nbasic_string&lt;int&gt; e[1000005];\n\nvoid nema() {\n    cout &lt;&lt; \"-1\\n\";\n    exit(0);\n}\n\nvoid resi(int k) {\n    for (int i=1; i&lt;=k; i++)\n        e[x[i] + y[i]] += x[i] - y[i];\n    basic_string&lt;pair&lt;int, int&gt;&gt; sol;\n    for (int i=1000000; i&gt;=3; i--) {\n        sort(e[i].begin(), e[i].end());\n        basic_string&lt;pair&lt;int, int&gt;&gt; freqs;\n        {\n            int last = -123123123, cnt = 0;\n            for (int x : e[i])\n                if (x == last)\n                    cnt++;\n                else {\n                    if (cnt)\n                        freqs += {last, cnt};\n                    cnt = 1;\n                    last = x;\n                }\n            if (cnt)\n                freqs += {last, cnt};\n        }\n\n        int last_g = 0, last_c = 0;\n        for (int j=0; j&lt;(int)freqs.size(); j++) {\n            if (last_c &gt; 0) {\n                if (freqs[j].first != last_g + 2)\n                    nema();\n                if (freqs[j].second &lt; last_c)\n                    nema();\n                freqs[j].second -= last_c;\n                while (last_c--) {\n                    sol += {(last_g + i) / 2, (i - last_g) / 2 - 1};\n                    e[i-1] += last_g + 1;\n                }\n            }\n            last_c = freqs[j].second;\n            last_g = freqs[j].first;\n        }\n    }\n\n    if (e[2].size() != 1 || e[2][0] != 0)\n        nema();\n\n    cout &lt;&lt; k &lt;&lt; '\\n';\n    reverse(sol.begin(), sol.end());\n    for (auto p : sol)\n        cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\\n';\n    exit(0);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin &gt;&gt; n;\n    for (int i=1; i&lt;=n; i++)\n        cin &gt;&gt; x[i] &gt;&gt; y[i];\n\n    for (int i=1; i&lt;=n; i++) {\n        dodaj(x[i] + y[i]);\n        if (c[2] == 1) {\n            if (cp == 1)\n                resi(i);\n            else\n                nema();\n        }\n    }\n    nema();\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/","title":"1 - Kombinovanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Na\u0161 omiljeni \u010darobnjak je poznat po tome \u0161to voli da se hvali kako ima ne jedan, ve\u0107 dva automobila. Kako nikog od njegovih prijatelja ne \u017eeli da 58. put slu\u0161a o njima, \u010darobnjak je odlu\u010dio da ih iskombinuje u jedan.</p> <p>Oba automobila mo\u017eemo predstaviti kao matrice \\(A\\) i \\(B\\) nenegativnih celih brojeva dimenzija \\(N \\times N\\). Kombinovanjem dva automobila nastaje novi automobil \u010dija se vrednost ra\u010duna kao suma proizvoda elemenata po\u010detnih matrica, tj. vrednost automobila je \\(\\sum_{i=1}^N\\sum_{j=1}^NA_{ij}B_{ij}\\). \u010carobnjakov cilj je da napravi auto \u0161to ve\u0107e vrednosti.</p> <p>\u010carobnjak mo\u017ee da zameni bilo koja dva reda ili bilo koje dve kolone drugog automobila. Dobro\u0107udni \u010darobnjak \u017eeli da i vi u\u010destvujete u \u010darima kombinovanja automobila. Va\u0161 zadatak je da mu date niz transformacija matrice \\(B\\). \u010carobnjak \u0107e u\u010diniti da va\u0161 broj poena na ovom zadatku bude proporcionalan vrednosti automobila koji se dobija kombinovanjem po\u010detna dva.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Mom\u010dilo Topalovi\u0107 Nikola Spasi\u0107 Aleksa Plav\u0161i\u0107 <p>S obzirom da po\u010detna konfiguracija matrice mo\u017ee biti ciljano postavljena u nepovoljan polo\u017eaj kolone, i redovi matrice se izme\u0161aju na slede\u0107i na\u010din. Za svako \\(i\\) slu\u010dajno se biraju dva broja \\(j\\) i \\(k\\) i zatim se \\(i\\)-ta kolona zameni sa \\(j\\)-tom a \\(i\\)-ti red sa \\(k\\)-tim redom.</p> <p>Zatim pro\u0111e se kroz sve parove \\((i, j)\\) i ukoliko bi se zamenom \\(i\\)-te i \\(j\\)-te kolone rezultat pobolj\u0161ao kolone se zamene, zatim ukoliko bi se zamenom \\(i\\)-tog i \\(j\\)-tog reda rezultat pobolj\u0161ao redovi se zamene.</p> <p>Prethodno prolazenje kroz sve parove ponovi se 20 puta.</p> <p>Nakon toga izaberu se 4 slu\u010dajna broja \\(a\\), \\(b\\), \\(c\\) i \\(d\\) i ukoliko bi se zamenom \\(a\\)-te i \\(b\\)-te kolone a zatim zamenom \\(c\\)-tog i \\(d\\)-tog reda pobolj\u0161ao rezultat pomenute kolone i redovi se zamene.</p> <p>Poslednji opisan deo ponovimo \\(20*n^2\\) puta. </p> 01_kombinovanje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define ll long long\n\nconst int SVE=10,PUTA=20; //Moze se igrati sa ovim konstantama da se dobije dobro resenje\n\nint n;\nll p,q,bestAns;\nstruct resenje{\n    int cntResenje;\n    string resenje;\n}trResenje, best;\nstruct matrica{\n    vector&lt;vector&lt;int&gt; &gt; mat;\n    vector&lt;int&gt; rowid, colid;\n    void ucitaj(){\n        mat.resize(n, vector&lt;int&gt;(n));\n        rowid.resize(n);\n        iota(rowid.begin(), rowid.end(), 0);\n        colid.resize(n);\n        iota(colid.begin(), colid.end(), 0);\n        for(int i=0;i&lt;n;i++)\n            for(int j=0;j&lt;n;j++)\n                cin &gt;&gt; mat[i][j];\n    }\n    void swap_row(int i,int j){\n        trResenje.cntResenje++;\n        trResenje.resenje+=\"R \" + to_string(i+1) + \" \" + to_string(j+1) + \"\\n\";\n        swap(rowid[i],rowid[j]);\n    }\n    void swap_col(int i,int j){\n        trResenje.cntResenje++;\n        trResenje.resenje+=\"C \" + to_string(i+1) + \" \" + to_string(j+1) + \"\\n\";\n        swap(colid[i],colid[j]);\n    }\n    void izmesaj(){\n        for(int i=0;i&lt;n;i++){\n            int j = rng()%n, k = rng()%n;\n            swap_row(i,j);\n            swap_col(i,k);\n        }\n    }\n    int get(int i,int j){\n        return mat[rowid[i]][colid[j]];\n    }\n}A,B,Backup;\nll getSum(){\n    ll sum=0;\n    for(int i=0;i&lt;n;i++)\n        for(int j=0;j&lt;n;j++)\n            sum+=(ll)A.get(i,j)*B.get(i,j);\n    return sum;\n}\nint main(){\n    freopen(\"1.in\",\"r\",stdin);  //Ovo se menja za razlicite inputa\n    freopen(\"1.out\",\"w\",stdout);\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; q;\n    A.ucitaj();\n    Backup.ucitaj();\n    for(int oo=0;oo&lt;SVE;oo++){\n        trResenje.cntResenje=0;\n        trResenje.resenje.clear();\n        B=Backup;\n        B.izmesaj();\n        for(int o=0;o&lt;PUTA;o++){\n            for(int i=0;i&lt;n;i++)\n                for(int j=i+1;j&lt;n;j++){\n                    ll diffRow=0;\n                    for(int k=0;k&lt;n;k++)\n                        diffRow+=(ll)A.get(i,k)*B.get(j,k)-(ll)A.get(i,k)*B.get(i,k)+(ll)A.get(j,k)*B.get(i,k)-(ll)A.get(j,k)*B.get(j,k);\n                    if(diffRow&gt;0)\n                        B.swap_row(i,j);\n                    ll diffCol=0;\n                    for(int k=0;k&lt;n;k++)\n                        diffCol+=(ll)A.get(k,i)*B.get(k,j)-(ll)A.get(k,i)*B.get(k,i)+(ll)A.get(k,j)*B.get(k,i)-(ll)A.get(k,j)*B.get(k,j);\n                    if(diffCol&gt;0)\n                        B.swap_col(i,j);\n                }\n        }\n        for(int o=0;o&lt;n*n*PUTA;o++){\n            int a=rng()%n, b=rng()%n, c=rng()%n, d=rng()%n;\n            ll diffRow=0;\n            for(int k=0;k&lt;n;k++)\n                diffRow+=(ll)A.get(c,k)*B.get(d,k)-(ll)A.get(c,k)*B.get(c,k)+(ll)A.get(d,k)*B.get(c,k)-(ll)A.get(d,k)*B.get(d,k);\n            if(diffRow&gt;0)\n                B.swap_row(c,d);\n            ll diffCol=0;\n            for(int k=0;k&lt;n;k++)\n                diffCol+=(ll)A.get(k,a)*B.get(k,b)-(ll)A.get(k,a)*B.get(k,a)+(ll)A.get(k,b)*B.get(k,a)-(ll)A.get(k,b)*B.get(k,b);\n            if(diffCol&gt;0)\n                B.swap_col(a,b);\n        }\n        if(getSum()&gt;bestAns)\n            bestAns=getSum(),best=trResenje;\n    }\n    cerr &lt;&lt; bestAns;\n    cout &lt;&lt; best.cntResenje &lt;&lt; endl &lt;&lt; best.resenje &lt;&lt; endl;\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#napomena","title":"Napomena","text":"<p>Ovo je zadatak sa poznatim ulazom (output-only zadatak). Vama su dati ulazni fajlovi (<code>1.in</code>, <code>2.in</code>, <code>3.in</code>, <code>4.in</code>), dok vi treba da po\u0161aljete samo odgovaraju\u0107e izlazne fajlove za njih (<code>1.out</code>, <code>2.out</code>, <code>3.out</code>, <code>4.out</code>).</p>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaznih fajlova nalaze se tri prirodna broja \\(N\\), \\(P\\) i \\(Q\\) - dimenzija automobila, kao i parametri za bodovanje. U narednih \\(N\\) redova se nalazi po \\(N\\) brojeva koji predstavljaju automobil \\(A\\). U preostalih \\(N\\) redova se nalazi po \\(N\\) brojeva koji predstavljaju automobil \\(B\\).</p>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Na po\u010detku va\u0161ih izlaznih fajlova treba da se nalazi prirodan broj \\(M\\), broj transformacija. Nakon toga potrebno je ispisati \\(M\\) linija tako da \\((i+1)\\)-va sadr\u017ei tip transformacije - jedan karakter \\(T_i\\) (<code>R</code> ako je \u017eeljena transformacija zamena redova, ili <code>C</code> ina\u010de), kao i dva broja \\(X_i, Y_i\\), (\\(1 \\leq X_i, Y_i \\leq N\\)) koji predstavljaju indekse kolona i vrsta koje \u017eelite da zamenite.</p>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2018_2019/sio/01_kombinovanje/#ulaz","title":"Ulaz","text":"<pre><code>2 0 1\n0 0\n1 0\n1 0\n0 0\n</code></pre>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#izlaz","title":"Izlaz","text":"<pre><code>1\nR 1 2\n</code></pre>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Nakon zamene prvog i drugog reda, dobijena je slede\u0107a matrica: <pre><code>0 0\n1 0\n</code></pre></p>"},{"location":"takprog/2018_2019/sio/01_kombinovanje/#bodovanje","title":"Bodovanje","text":"<p>Va\u0161e re\u0161enje za neki od ulaza \u0107e se smatrati neva\u017ee\u0107im ukoliko je ispunjen bar jedan od slede\u0107ih uslova:</p> <ul> <li>\\(M &gt; 2 \\times N^2\\)</li> <li>\\(T_i\\) nije ni 'R' ni 'C'</li> <li>\\(X_i\\) ili \\(Y_i\\) nisu u intervalu \\([1, N]\\)</li> <li>Ulaz ne sadr\u017ei \\(M+1\\) liniju</li> </ul> <p>U suprotnom, neka je $k$ vrednost koju posti\u017ee va\u0161e re\u0161enje.</p> <ul> <li>Ukoliko va\u017ei \\(k \\geq Q\\), osvajate 25 poena za taj ulaz;</li> <li>Ukoliko va\u017ei \\(k \\leq P\\), osvajate 0 poena za taj ulaz;</li> <li>Ina\u010de, osvajate \\(\\lfloor 25\\frac{k - P}{Q - P}\\rfloor\\) poena za taj ulaz.</li> </ul>"},{"location":"takprog/2018_2019/sio/02_zvezda/","title":"2 - Crno bela zvezda","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 400ms 64MB <p>Svet je kona\u010dno postao jedno mirno mesto, puno sre\u0107e i ljubavi. Kako bi uspela da se suprostave kragujeva\u010dkom fudbalskom gigantu, dva mala fudbalska kluba Partizan i Crvena zvezda su se ujedinili u jedan i postali Crno Bela Zvezda. Nakon ujedinjenja, Crno Bela Zvezda je dobila novi grb. Grb je u obliku crno belog zvezda grafa sa \\(4\\) \u010dvora. Crno beli zvezda graf sa \\(4\\) \u010dvora predstalja stablo \u010diji su svi \u010dvorovi obojeni crnom ili belom bojom i \u010diji je koren obojen suprotnom bojom od listova (ako je koren obojen crnom bojom onda su listovi obojeni belom, dok ako je koren obojen belom bojom listovi su obojeni crnom).</p> <p>Mladi \u0106imi, vo\u0111a navija\u010da Crno Bele Zvezde, dobio je crveni papir na kome su nacrtane crne i bele ta\u010dke. Nacrtano je ta\u010dno \\(N\\) ta\u010daka numerisanih brojevima od \\(1\\) do \\(N\\). Boje ta\u010daka su odre\u0111ene nizom \\(A\\), ako je \\(i\\)-ta ta\u010dka bela onda je \\(A_i = 0\\), u suportnom \\(A_i = 1\\). Kada bi se ta\u010dke spojile redom \\(1 -&gt; 2 -&gt; \\dots -&gt; N -&gt; 1\\), gradile bi pravilan \\(N\\)-tougao. \u0106imi je prosto opsednut grbom novog kluba i \u017eeli da ga nacrta ta\u010dno  \\(\\frac{N}{4}\\) puta na tom crvenom papiru. On \u017eeli da svaka ta\u010dka pripada ta\u010dno jednom grbu i da se grbovi me\u0111usobno ne presecaju, jer misli da bi tako uru\u0161io lepotu grbova.</p> <p>\u0106imi vas je zamolio da mu pomognete da izra\u010duna broj na\u010dina da nacrta ta\u010dno \\(\\frac{N}{4}\\) grbova. Dva na\u010dina se razlikuju ako postoji bar jedan grb koji je nacrtan na jednom crte\u017eu i nije nacrtan na drugom. Kako broj na\u010dina mo\u017ee biti veliki, ispisati taj broj po modulu \\(10^9 + 7\\). </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Aleksa Plav\u0161i\u0107 Nikola Spasi\u0107 Nikola Spasi\u0107"},{"location":"takprog/2018_2019/sio/02_zvezda/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju:</p> <ul> <li>\\(Zvezda (\\)N\\(, A[\\dots])\\)</li> </ul> <p>\\(N\\) je broj ta\u010daka na papiru. \\(A\\) je niz du\u017eine \\(N\\) koji predstavlja boje ta\u010daka,  \\(i\\)-ta ta\u010dka je bela ako va\u017ei \\(A_i = 0\\), ina\u010de je ta\u010dka crna i \\(A_i = 1\\).  Niz \\(A\\) je indeksiran od \\(1\\).</p> <p>Funkcija treba da vrati ceo broj \\(X\\) -- broj na\u010dina da \u0106imi nacrta grbove po modulu \\(10^9 + 7\\).</p>"},{"location":"takprog/2018_2019/sio/02_zvezda/#primer","title":"Primer","text":"<p>Neka je \\(N = 8\\), \\(A = [1, 1, 0, 1, 0, 1, 1, 1]\\). </p> <p>Postoji \\(2\\) na\u010dina da se nacrtaju zvezde:</p> <ul> <li>prva zvezda : \\([1, 2, 3, 4]\\), druga zvezda \\([5, 6, 7, 8]\\)</li> <li>prva zvezda : \\([8, 1, 2, 3]\\), druga zvezda \\([4, 5, 6, 7]\\)</li> </ul>"},{"location":"takprog/2018_2019/sio/02_zvezda/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 500\\) , \\(N\\) je deljivo sa \\(4\\)</li> <li>\\(0 \\leq A_i \\leq 1\\)</li> </ul>"},{"location":"takprog/2018_2019/sio/02_zvezda/#podzadaci","title":"Podzadaci","text":"<p>Postoji ukupno \\(14\\) podzadataka, koji zadovoljavaju ograni\u010denja napisana u tabeli:</p> Redni broj podzadatka Ograni\u010denje za N Broj poena 1 12 4 2 24 4 3 52 4 4 76 4 5 100 4 6 128 5 7 152 5 8 200 5 9 252 5 10 300 12 11 352 12 12 400 12 13 452 12 14 500 12"},{"location":"takprog/2018_2019/sio/02_zvezda/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>zvezda.cpp</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Zvezda(int N, int *A);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p>"},{"location":"takprog/2018_2019/sio/02_zvezda/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\),</li> <li>U narednom redu \\(N\\) celih brojeva - \\(A_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa vrednost koju je funkcija vratila. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2018_2019/sio/02_zvezda/#analiza","title":"Analiza","text":"<p>Prvo napravima dva geometrijska zaklju\u010dka.</p> <ul> <li>Ukoliko bismo rekli da grb treba da bude konveksan \u010detvorougao koji ima kao tri temena ta\u010dke jedne a kao preostalo teme ta\u010dku druge boje broj na\u010dina za iscrtavanje grbova ne bi se razlikovao od onog tra\u017eenog u zadatku.</li> <li>Ukoliko bi se po\u010detne crne i bele ta\u010dke nalazile u temenima proizvoljnog konveksnog mnogougla broj na\u010dina za iscrtavanje grbova ne bi se razlikovao od onog tra\u017eenog u zadatku.</li> </ul> <p>Dakle kada odaberemo \u010detiri ta\u010dke koje \u0107emo povezati tokom crtanja jednog grba one dele preostale ta\u010dke na \u010detiri grupe (neke od kojih su potencijalno prazne) naime na \u010detiri cikli\u010dna segmenta po\u010detnog niza ta\u010daka. </p> <p>Kako sada ne mogu postojati du\u017ei koje spajaju ta\u010dke iz razli\u010ditih grupa svaki novi grb koji nacrtamo (odnosno njegova temena) nalazi\u0107e se ta\u010dno u jednoj od grupa, a kako ta\u010dke svake grupe opet \u010dine konveksan mnogougao vidimo da je problem nala\u017eenja broja na\u010dina da se nacrtaju grbovi koriste\u0107i temena neke grupe u stvari analogan po\u010detnom problemu.</p> <p>Re\u0161imo sada problem dinami\u010dkim programiranjem, defini\u0161imo:</p> <ul> <li>\\(d[i][j][0]\\) - broj na\u010dina da se na cikli\u010dnom segmentu \\([i, j)\\) (uklju\u010duje \\(i\\), ne uklju\u010duje \\(j\\)) na\u0111e ta\u010dka \\(s\\) boje \\(0\\) i da se ta\u010dke segmenata \\([i,s)\\) i \\([s + 1, j)\\) spoje u grbove (svaki grb (odnosno njegova temena) da se nalaze ta\u010dno u jednom od segmenata, u \\([i,s)\\) ili u \\([s + 1, j)\\))</li> <li>\\(d[i][j][1]\\) - analogno samo za \\(s\\) boje \\(1\\)</li> <li>\\(d[i][j][2]\\) - broj na\u010dina da se ta\u010dke segmenata \\([i, j)\\) spoje u grbove.</li> </ul> <p>Pre nego \u0161to po\u010dnemo primetimo da \\(d[i][j][0]\\) i \\(d[i][j][1]\\) mogu biti ne nula samo ukoliko je du\u017eina (broj ta\u010daka) u cikli\u010dnom intervalu \\([i, j)\\) oblika \\(4k + 1\\), dok \\(d[i][j][2]\\) mo\u017ee biti ne nula samo ukoliko je ud\u017eina tog intervala oblika \\(4k\\).</p> <p>Na\u0161i po\u010detni uslovi su </p> <ul> <li>Za svako \\(1 \\leq i \\leq n\\), \\(d[i][i][2] = 1\\)</li> <li>Za svako \\(1 \\leq i \\leq n\\), \\(d[i][i + 1][a[i]] = 1\\)</li> <li>Za svake \\(i, j, k\\), \\(d[i][j][k] = 0\\) sem za gore pomenute</li> </ul> <p>Ostaje jo\u0161 da pro\u0111emo kroz sve intervale, sortirane po du\u017eini (broju ta\u010daka u njima).</p> <p>Sada kada ra\u010dunamo \\(d[i][j][0]\\) jasno je da za svaki \\(s\\) iz intervala \\([i, j)\\) takav da \\(A[s] = 0\\), trebamo \\(d[i][j][0]\\) da uve\u0107amo za \\(d[i][s][2] * d[s + 1][j][2]\\), po definiciji.</p> <p>Analogno za \\(d[i][j][1]\\).</p> <p>U slu\u010daju ra\u010dunanja \\(d[i][j][2]\\) znamo da je ta\u010dka \\(i\\) u grbu sa jo\u0161 tri ta\u010dke nazovimo onu koja se u smislu cikli\u010dnog poretka nalazi izme\u0111u druge dve, odnosno \"srednju\" ta\u010dku, \\(s\\). Ukoliko je ona iste boje kao ta\u010dka \\(i\\) broj na\u010dina da se ta\u010dke intervala \\([i, j)\\) spoje u grbove na takav na\u010din je po definiciji \\(d[i + 1][s][0] * d[s + 1][j][1] + d[i + 1][s][1] * d[s + 1][j][0]\\) (ta\u010dke koje su nesparene u popunjavanju manjih segmenata sada uzimamo u isti grb sa ta\u010dkama \\(i\\) i \\(s\\), i vodimo ra\u010duna o tome da su razli\u010ditih boja), dok analogno ukoliko su \\(i\\) i \\(s\\) istih boja broj na\u010dina je \\(d[i + 1][s][0] * d[s + 1][j][0] + d[i + 1][s][1] * d[s + 1][j][1]\\).</p> <p>Sve prethodno re\u010deno daje nam ukupnu slo\u017eenost \\(O(n^3)\\).</p>"},{"location":"takprog/2018_2019/sio/02_zvezda/#dodatak","title":"Dodatak","text":"<p>Re\u0161enje se mo\u017ee dodatno ubrzati ukoliko se primeti da ao na segmentu \\([i, j)\\) ima \\(a\\) ta\u010daka boje \\(0\\) i \\(b\\) ta\u010daka boje \\(1\\), sistem jedna\u010dina \\(3A + B = a\\), \\(A + 3B = b\\), mora imati nenegativna re\u0161enja (ukoliko posmatramo da je \\(A\\) broj grbova kojima je teme obojeno bojom \\(1\\), a \\(B\\) broj grbova kojima je teme obojeno bojom \\(0\\) jedna\u010dine direktno slede). Ovime i analognim uslovom za slu\u010dajeve kada ra\u010dunamo segment kom ostavljamo jednu ta\u010dku negrupisanu mo\u017eemo izbe\u0107i bespotrebne prolaske kroz unutra\u0161nju petlju algoritma.</p> <p>Tako\u0111e implementacija algoritma postaje zna\u010dajno pojednostavljena ukoliko umesto cikli\u010dnih segmenata datog niza posmatramo obi\u010dne segmente dvostruko du\u017eeg niza koji bismo dobili ukoliko bismo na kraj na\u0161eg niza nalepili jo\u0161 jedan identi\u010dan, uz gotovo identi\u010dne jedna\u010dine.</p> 02_zvezda.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nusing namespace std;\n\nstatic const int M = 1000000007;\nstatic const int N = 1005;\n\n\nlong long d[2 * N][2 * N][3];\nint b[2 * N];\n\nint Zvezda(int n, int* a)\n{\n    for(int i = 1; i &lt;= n; i++)\n    {\n        b[i] = a[i];\n        b[i + n] = a[i];\n    }\n\n    for(int i = 1; i &lt;= 2 * n; i++)\n        for(int j = 1; j &lt;= 2 * n; j++)\n            for(int k = 0; k &lt; 3; k++)\n                d[i][j][k] = 0;\n\n    for(int i = 1; i &lt;= 2 * n; i++)\n    {\n        d[i][i][2] = 1;\n        d[i][i + 1][b[i]] = 1;\n    }\n\n    for(int g = 4; g &lt;= n; g += 4)\n    {\n        // deo za ceo\n\n        for(int i = 1; i &lt;= n; i++)\n        {\n            int j = i + g;\n            for(int s = i + 2; s + 1 &lt; j; s += 4)\n            {\n                if(b[i] == b[s])\n                {\n                    d[i][j][2] += d[i + 1][s][0] * d[s + 1][j][1];\n                    d[i][j][2] += d[i + 1][s][1] * d[s + 1][j][0];\n                }\n                else\n                {\n                    d[i][j][2] += d[i + 1][s][0] * d[s + 1][j][0];\n                    d[i][j][2] += d[i + 1][s][1] * d[s + 1][j][1];\n                }\n                d[i][j][2] %= M;\n            }\n        }\n\n        // deo sa ostatkom\n\n        for(int i = 1; i &lt;= n; i++)\n        {\n            int j = i + g + 1;\n            for(int s = i; s &lt;= j; s += 4)\n        {\n                d[i][j][b[s]] += d[i][s][2] * d[s + 1][j][2];\n            d[i][j][b[s]] %= M;\n        }   \n        }\n    }\n\n    return d[1][n + 1][2];\n}\n\nint main()\n{\n    int A[N];\n    int n;\n\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; A[i];\n\n    cout &lt;&lt; Zvezda(n, A) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/03_kamera/","title":"3 - Kamera","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 5000ms 512MB <p>Na nedavno odr\u017eanom takmi\u010denju iz programiranja, va\u0161 tim je osvojio kameru - i to ne bilo kakvu kameru! Proizvo\u0111a\u010d kamere, firma \"MST\" tvrdi da ova kamera ima neverovatnu sposobnost - kada se njom slika neki skup neusmerenih grana nekog grafa, ona je u stanju da izra\u010duna da li je mogu\u0107e od tih grana formirati stablo (stablo je povezan graf bez ciklusa) koje obuhvata sve \u010dvorove tog grafa, i ne samo to! Ako se svakoj od grana dodeli neka nenegativna celobrojna te\u017eina, ona \u0107e prona\u0107i ono stablo kod kojeg je zbir te\u017eina svih grana koje u\u010destvuju u stablu minimalan.</p> <p>Va\u0161 zadatak je da proverite da li kamera radi korektno. Vama \u0107e biti dat pravougaoni list papira podeljen na \\(R\\) vrsta i \\(C\\) kolona, kao i broj \\(N\\) - broj \u010dvorova grafa. U svakom polju nalazi se jedna neusmerena grana, ta\u010dnije, brojevi \\(U_{i, j}, V_{i, j}, W_{i, j}\\) (\\(U_{i, j} \\neq V_{i, j}\\)) koji zna\u010de da se u polju \\(i, j\\) (\\(1 \\leq i \\leq R, 1 \\leq j \\leq C\\)) nalazi neusmerena grana koja spaja \u010dvorove \\(U_{i, j}, V_{i, j}\\) i ima te\u017einu \\(W_{i, j}\\). Zatim, dato vam je \\(Q\\) upita oblika \\(X_1, Y_1, X_2, Y_2\\) (\\(1 \\leq X_1 \\leq X_2 \\leq R, 1 \\leq Y_1 \\leq Y_2 \\leq C\\)). Va\u0161 zadatak je da za svaki upit odredite da li postoji stablo koje povezuje sve \u010dvorove od \\(1\\) do \\(N\\) a \u010dije se grane nalaze u toj podmatrici, ta\u010dnije, uzimaju se u obzir samo one grane koje se nalaze u poljima \\(x, y\\) za koja va\u017ei \\(X_1 \\leq x \\leq X_2, Y_1 \\leq y \\leq Y_2\\), a ako postoji, da odredite minimalnu ukupnu te\u017einu takvog stabla. Kako se radi o kameri, va\u017ei\u0107e slede\u0107e: Ozna\u010dimo sa \\(a\\) vrednost \\(\\frac{X_2-X_1+1}{Y_2-Y_1+1}\\). U svim upitima va\u017ei \\(\\frac{2}{3} \\leq a \\leq \\frac{3}{2}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksa Plav\u0161i\u0107 <p>Kod prva dva podzadatka bilo je dovoljno implementirati bilo koji efikasan algoritam za nala\u017eenje minimalnog pokrivaju\u0107eg stabla - u nastavku MST od minimum spanning tree, tako\u0111e, sa \\(MSF\\) \u0107emo ozna\u010diti minimalnu pokrivaju\u0107u \u0161umu grafa, ta\u010dnije, to je podgraf koji je \u0161uma minimalne te\u017eine a ima iste povezane komponente, pri \u010demu je za prvi podzadatak bio dovoljan bilo koji ta\u010dan brute force pristup.</p> <p>Za 3. i 4. podzadatak mogla je da se koristi bilo koja 2D struktura podataka koja efikasno odgovara na upite \"koji je minimum u podmatrici\". Za 3. podzadatak (\\(N=2\\)) dovoljno je samo na\u0107i granu minimalne te\u017eine. Za 4. podzadatak (\\(N=3\\)) potrebno je na\u0107i minimalnu te\u017einu grane me\u0111u svim granama koje spajaju \u010dvorove \\(1,2\\), analogno za \u010dvorove \\(2,3\\) i \\(1,3\\). Ukoliko se me\u0111u ovim granama javlja jedna ili nijedna, onda stablo ne postoji. Ako se javljaju ta\u010dno dve onda upravo one \u010dine stablo, a ako se jave tri onda se stablo dobija odbacivanjem najte\u017ee od te tri grane. Najlak\u0161a za implementaciju (a ipak dovoljno brza) takva struktura bi bila slede\u0107a asimetri\u010dna tabela: Za svaki podsegment svakog reda izra\u010dunamo minimalni element, ovo radimo u slo\u017eenosti \\(O(R \\times C^2)\\), svaki upit re\u0161avamo u \\(O(R)\\) prolazom kroz odgovaraju\u0107e redove.</p> <p>Da bi se zadatak re\u0161io za 100 poena klju\u010dna je slede\u0107a opservacija vezana za pojam MST-a:</p> <p>Neka je \\(A\\) skup grana grafa sa \u010dvorovima \\(V = \\{1, \\ldots, N\\}\\), i neka je \\(T(A)\\) minimalna pokrivaju\u0107a \u0161uma tog grafa (ukoliko ih ima vi\u0161e, onda bilo koja). Tada va\u017ei slede\u0107e: \\(T(T(A) \\cup T(B))\\) je minimalna pokrivaju\u0107a \u0161uma za skup grana \\(A \\cup B\\). Ovo se mo\u017ee dokazati analizom rada Kruskal-ovog algoritma za nala\u017eenje MST-a. U prevodu, ovo zna\u010di da, ako ho\u0107emo da izra\u010dunamo \\(MSF\\) za neki, potencijalno veliki skup grana, mi ga mo\u017eemo podeliti na dva manja skupa, koji se \u010dak mogu i preklapati (potrebno je samo da je njihova unija jednaka po\u010detnom skupu), zatim na\u0107i njihov \\(MSF\\) a zatim zajedni\u010dki \\(MSF\\) na sada ve\u0107 znatno manjem skupu grana.</p> <p>Ovo nas usmerava ka tome da napravimo dvodimenzionu sparse table strukturu podataka, gde \u0107emo za svako \\(i,j,k\\) (\\(1 \\leq i \\leq R\\), \\(1 \\leq j \\leq C\\), \\(0 \\leq k \\leq \\log_2(\\min(R,C))\\) \u010duvati skup grana koji u\u010destvuje u \\(MSF\\)-u skupa grana koje se nalaze u kvadratnoj podmatrici \u010dije je gornje levo teme polje \\(i,j\\) a stranica tog kvadrata je \\(2^k\\). Jasno je da se svako polje ove tabele mo\u017ee izra\u010dunati kao unija \u010detiri polja gde su stranice kvadrata duplo manje. Ako sa \\(\\alpha(N)\\) ozna\u010dimo slo\u017eenost jedne operacije pomo\u0107ne strukture podataka za disjunktne skupove (DSU, Disjoint Set Union) a koja je za ovako male vrednosti \\(N\\) prakti\u010dno konstantna, tada se cela ova tabela mo\u017ee konstruisati u slo\u017eenosti \\(O(RC\\log(\\min(R,C))N \\alpha(N))\\).</p> <p>Jo\u0161 jedna klju\u010dna stvar je ta \u0161to, usled toga \u0161to je koli\u010dnik stranica pravougaonika kod svakog upita broj izme\u0111u \\(\\frac23\\) i \\(\\frac32\\), svaki ovakav pravougaonik mo\u017ee da se \"pokrije\" sa najvi\u0161e \\(6\\) kvadrata \u010dija je stranica stepen dvojke, \u0161to nam omogu\u0107ava da re\u0161imo svaki upit u slo\u017eenosti \\(O(N \\alpha(N))\\).</p> 03_kamera.cpp<pre><code>#include &lt;array&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef uint16_t tezina_t;\ntypedef uint8_t cvor_t;\nconst int MAX_N = 42;\nconst int MAX_SZ = 252;\nconst int MAX_LOG = 8;\n\nstruct grana {\n    cvor_t u, v;\n    tezina_t w;\n\n    grana() : u(0), v(0), w(0) {}\n    grana(cvor_t u, cvor_t v, tezina_t w) : u(u), v(v), w(w) {}\n\n    bool operator&lt; (const grana&amp; b) const {\n        return w &lt; b.w;\n    }\n};\n\ntypedef array&lt;grana, MAX_N&gt; mst;\n\nstruct dsu {\n    array&lt;cvor_t, MAX_N&gt; p, s;\n\n    dsu() {\n        iota(p.begin(), p.end(), 0);\n        fill(s.begin(), s.end(), 1);\n    }\n\n    cvor_t e(cvor_t x) {\n        if (x == p[x])\n            return x = p[x];\n        return p[x] = e(p[x]);\n    }\n\n    bool spoji(cvor_t x, cvor_t y) {\n        x = e(x);\n        y = e(y);\n        if (x == y)\n            return false;\n        if (s[x] &gt; s[y])\n            swap(x, y);\n        p[x] = y;\n        s[y] += s[x];\n        return true;\n    }\n};\n\nmst spoji(const mst&amp; a, const mst&amp; b) {\n    mst c;\n    dsu d;\n    int i = 0, j = 0, k = 0;\n    while (a[i].u || b[j].u) {\n        bool prva = (a[i].u &amp;&amp; b[j].u &amp;&amp; a[i].w &lt; b[j].w) || !b[j].u;\n        grana g = prva ? a[i++] : b[j++];\n        if (d.spoji(g.u, g.v))\n            c[k++] = g; \n    }\n    return c;\n}\n\nmst tbl[MAX_SZ][MAX_SZ][MAX_LOG], prazan;\n\nconst mst&amp; daj(int x, int y, int z) {\n    if (x &gt;= MAX_SZ || y &gt;= MAX_SZ)\n        return prazan;\n    return tbl[x][y][z];\n}\n\nvoid Resi(\n    int N, int R, int C, int Q,\n    int** U, int** V, int** W,\n    int* X1, int* Y1, int* X2, int* Y2,\n    int* O)\n{\n    for (int i=1; i&lt;=R; i++)\n        for (int j=1; j&lt;=C; j++)\n            tbl[i][j][0][0] = grana(U[i][j], V[i][j], W[i][j]);\n    for (int k=1; k&lt;MAX_LOG; k++) {\n        int w = 1 &lt;&lt; (k-1);\n        for (int i=1; i&lt;=R; i++)\n            for (int j=1; j&lt;=C; j++)\n                tbl[i][j][k] = spoji(\n                    spoji(daj(i+w, j, k-1), daj(i, j+w, k-1)),\n                    spoji(daj(i, j, k-1), daj(i+w, j+w, k-1)));\n    }\n\n    for (int i=1; i&lt;=Q; i++) {\n        int p = X2[i] - X1[i] + 1;\n        int q = Y2[i] - Y1[i] + 1;\n        int k = 0, l = 1;\n        while (2*l &lt;= min(p, q))\n            l&lt;&lt;=1, k++;\n\n        mst tmp;\n        if (p &gt;= q) {\n            int xt = X1[i];\n            while (1) {\n                if (X2[i]-xt+1 &gt; l) {\n                    tmp = spoji(tmp, daj(xt, Y1[i]    , k));\n                    tmp = spoji(tmp, daj(xt, Y2[i]-l+1, k));\n                    xt += l;\n                } else {\n                    tmp = spoji(tmp, daj(X2[i]-l+1, Y1[i]    , k));\n                    tmp = spoji(tmp, daj(X2[i]-l+1, Y2[i]-l+1, k));\n                    break;\n                }\n            }\n        } else {\n            int yt = Y1[i];\n            while (1) {\n                if (Y2[i]-yt+1 &gt; l) {\n                    tmp = spoji(tmp, daj(X1[i],     yt, k));\n                    tmp = spoji(tmp, daj(X2[i]-l+1, yt, k));\n                    yt += l;\n                } else {\n                    tmp = spoji(tmp, daj(X1[i],     Y2[i]-l+1, k));\n                    tmp = spoji(tmp, daj(X2[i]-l+1, Y2[i]-l+1, k));\n                    break;\n                }\n            }\n        }\n\n        int z = 0, uw = 0;\n        for (int j=0; j&lt;MAX_N; j++)\n            if (tmp[j].u)\n                uw += tmp[j].w, z++;\n        if (z &lt; N-1)\n            uw = -1;\n        O[i] = uw;\n    }\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/03_kamera/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, R, C, Q, U[\\ldots][\\ldots], V[\\ldots][\\ldots], W[\\ldots][\\ldots], X1[\\ldots], Y1[\\ldots], X2[\\ldots], Y2[\\ldots], O[\\ldots])\\)</li> </ul> <p>koja treba da obradi sve upite i smesti odgovore u niz \\(O\\). Ako stablo ne postoji, u odgovaraju\u0107i element niza \\(O\\) upisati \\(-1\\), u suprotnom, upisati minimalnu te\u017einu stabla. Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2018_2019/sio/03_kamera/#primer","title":"Primer","text":"<p>Neka je \\(N = 4, R = 3, C = 4, Q = 3\\). Radi preglednosti, neka je zajedni\u010dka matrica trojki \\((U_{i, j}, V_{i, j}, W_{i, j})\\) slede\u0107a: <pre><code>  (1,2,1)     (1,2,2)     (1,2,3)     (1,2,100)\n  (2,3,2)     (2,3,3)     (2,3,1)     (2,3,101)\n  (3,4,3)     (3,4,1)     (3,4,2)     (3,4,102)\n</code></pre></p> <p>a zajedni\u010dki niz upita \\((X_1, Y_1, X_2, Y_2)\\) slede\u0107i: \\((1,1,3,4), (1,2,3,3), (3,4,3,4)\\). U prvom upitu u\u010destvuju sve grane: <pre><code>**(1,2,1)** **(1,2,2)** **(1,2,3)** **(1,2,100)**\n**(2,3,2)** **(2,3,3)** **(2,3,1)** **(2,3,101)**\n**(3,4,3)** **(3,4,1)** **(3,4,2)** **(3,4,102)**\n</code></pre></p> <p>Minimalno stablo dobijamo ako odaberemo grane \\((1,2,1), (2,3,1), (3,4,1)\\), pa je odgovor na prvi upit \\(3\\).</p> <p>U drugom upitu u\u010destvuju slede\u0107e grane: <pre><code>  (1,2,1)   **(1,2,2)** **(1,2,3)**   (1,2,100)\n  (2,3,2)   **(2,3,3)** **(2,3,1)**   (2,3,101)\n  (3,4,3)   **(3,4,1)** **(3,4,2)**   (3,4,102)\n</code></pre></p> <p>Minimalno stablo dobijamo ako odaberemo grane \\((1,2,2), (2,3,1), (3,4,1)\\), pa je odgovor na ovaj upit \\(4\\).</p> <p>U tre\u0107em upitu u\u010destvuju slede\u0107e grane: <pre><code>  (1,2,1)     (1,2,2)     (1,2,3)     (1,2,100)\n  (2,3,2)     (2,3,3)     (2,3,1)     (2,3,101)\n  (3,4,3)     (3,4,1)     (3,4,2)   **(3,4,102)**\n</code></pre></p> <p>Jasno je da stablo koje povezuje sve \u010dvorove ne postoji, pa u niz \\(O\\) na poziciji \\(3\\) treba upisati \\(-1\\).</p>"},{"location":"takprog/2018_2019/sio/03_kamera/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 40\\)</li> <li>\\(1 \\leq R, C \\leq 250\\)</li> <li>\\(1 \\leq Q \\leq 200000\\)</li> <li>\\(0 \\leq W_{i, j} \\leq 65535\\)</li> </ul>"},{"location":"takprog/2018_2019/sio/03_kamera/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [8 poena]: \\(N \\leq 4, R,C,Q \\leq 10\\)</li> <li>Podzadatak 2 [13 poena]: \\(R,C,Q \\leq 100\\)</li> <li>Podzadatak 3 [12 poena]: \\(N=2\\)</li> <li>Podzadatak 4 [16 poena]: \\(N=3\\)</li> <li>Podzadatak 5 [20 poena]: \\(Q \\leq 50000\\)</li> <li>Podzadatak 6 [31 poena]: bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2018_2019/sio/03_kamera/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>kamera.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int R, int C, int Q, int** U, int** V, int** W, int* X1, int* Y1, int* X2, int* Y2, int* O);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, R, C, Q\\),</li> <li>U narednih \\(R\\) redova po \\(3C\\) brojeva. U \\(i\\)-tom redu nalaze se brojevi \\(U_{i,1}, V_{i,1}, W_{i,1}\\), \\(U_{i,2}, V_{i,2}, W_{i,2}\\), \\(\\ldots\\), \\(U_{i,C}, V_{i,C}, W_{i,C}\\),</li> <li>U narednih \\(Q\\) redova po 4 broja: \\(X_1, Y_1, X_2, Y_2\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa brojeve \\(O[1], \\ldots, O[Q]\\), svaki u posebnom redu. Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2018_2019/sio/04_skladiste/","title":"4 - Skladi\u0161te","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 128MB <p>Nizom \u010dudnih doga\u0111aja, \u010dlanovi Komisije su postali vlasnici skladi\u0161ta, u kojem se kutije dr\u017ee pore\u0111ane u niz. Svaki put kada se dostava pojavi da bi isporu\u010dila novu kutiju, potrebno je odlu\u010diti da li \u0107e im se otvoriti prednja ili zadnja vrata, odnosno da li \u0107e kutija biti dodata na po\u010detak ili kraj niza.</p> <p>Kada je potrebno izvaditi kutiju iz skladi\u0161ta, \u010dlan Komisije koji poslednji smisli razlog za\u0161to ba\u0161 on nema vremena mora da u\u0111e na prednja vrata, prona\u0111e tra\u017eenu kutiju, iznese je i sredi skladi\u0161te. Ako je kutija na poziciji \\(i\\), ra\u010dunato od po\u010detka niza (prva kutija je na poziciji \\(0\\)), ova operacija traje \\(i\\) nanosekundi. Sre\u0111ivanje uklju\u010duje \"popravljanje\" niza, tako da ne\u0107e ostati prazno mesto (sve kutije nakon \\(i\\)-te \u0107e se pomeriti za jedno mesto).</p> <p>Po\u0161to Komisija trenutno ba\u0161 i nema vremena, zamolili su vas da preuzmete dono\u0161enje odluka tokom dostave. Dobili ste raspored za danas, u kom je dato vreme dostave i odno\u0161enja svake kutije. Va\u0161 zadatak je da odredite koliko je najmanje vremena potrebno provesti u va\u0111enju kutija (u nanosekundama).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Dimitrije Erdeljan Aleksandar Zlateski <p>Posmatrajmo trenutak dostave jedne od kutija. Neka se u skladi\u0161tu trenutno nalazi \\(n\\) kutija koje \u0107e biti izva\u0111ene u trenucima \\(T_0, T_1, \\dots, T_n\\), i neka je vreme va\u0111enja one koju trenutno ubacujemo \\(t\\).</p> <p>Ako je ukupno vreme potrebno da se izvade kutije koje su trenutno u skladi\u0161tu \\(R\\) (ako nema daljih dostava), nakon \u0161to dodamo novu, postoje dve mogu\u0107nosti:</p> <ul> <li>novu kutiju stavimo na kraj: vremena va\u0111enja pojedina\u010dnih kutija koje su ve\u0107 u skladi\u0161tu se ne\u0107e promeniti. Kada nova kutija do\u0111e na red, ispred nje \u0107e biti one za koje va\u017ei \\(T_i &gt; t\\), tako da je ukupno vreme \\(R + |i : T_i &gt; t|\\).</li> <li>novu kutiju stavimo na po\u010detak: za kutije koje se vade pre nje (\\(T_i &lt; t\\)), vreme \u0107e se pove\u0107ati za \\(1\\), a za novu kutiju \u0107e vreme va\u0111enja biti \\(0\\). Novo ukupno vreme je dakle \\(R + |i : T_i &lt; t|\\).</li> </ul> <p>Primetimo da ove dve vrednosti uop\u0161te ne zavise od trenutnog redosleda kutija u skladi\u0161tu. Samim tim, izbor koji daje manje ukupno vreme je optimalan i u slu\u010daju u kom trenutna kutija nije poslednja, tako da je dovoljno da izra\u010dunamo ove dve vrednosti za svaku kutiju i odaberemo manju.</p> <p>Da bi dobili re\u0161enje \u010dija je vremenska slo\u017eenost \\(\\mathcal{O}(N \\log{N})\\), neophodna nam je struktura koja podr\u017eava slede\u0107e operacije u logaritamskom vremenu:</p> <ul> <li>dodaj \\(x\\) u skup,</li> <li>izbaci \\(x\\) iz skupa, i</li> <li>odgovori na \"koliko elemenata skupa su manji od \\(x\\)?\"</li> </ul> <p>Jedna opcija je struktura sli\u010dna <code>set</code>-u, ali C++ standardna biblioteka ne podr\u017eava direktno upit koji nam je potreban. Po\u0161to su svi elementi mali (maksimalno \\(2N\\)), jedna alternativa je segmentno stablo (ili Fenwick stablo). Ovde, u \\(i\\)-tom elementu \u010duvamo \\(1\\) ako je \\(i\\) u skupu, i \\(0\\) u suprotnom. Upit se u tom slu\u010daju svodi na pronala\u017eenje zbira na intervalu \\([0, x)\\).</p> 04_skladiste.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nstruct event\n{\n    int t, box;\n    bool delivery;\n} ;\n\nbool operator&lt;(event a, event b)\n{\n    return a.t &lt; b.t;\n}\n\nstruct segtree\n{\n    static const int N = 1 &lt;&lt; 18;\n    int tree[2 * N];\n\n    void set(int pos, int val)\n    {\n        tree[pos += N] = val;\n        for(pos /= 2; pos; pos /= 2)\n            tree[pos] = tree[2 * pos] + tree[2 * pos + 1];\n    }\n\n    int query(int left, int right)\n    {\n        if(left == right) return tree[left + N];\n        int res = tree[left += N] + tree[right += N];\n        while(left / 2 != right / 2)\n        {\n            if(left % 2 == 0) res += tree[left + 1];\n            if(right % 2 == 1) res += tree[right - 1];\n            left /= 2; right /= 2;\n        }\n        return res;\n    }\n} ;\n\nsegtree active;\n\nlong long Resi(int N, int *A, int *B)\n{\n    std::vector&lt;event&gt; events;\n    for(int i = 0; i &lt; N; i++)\n    {\n        events.push_back({A[i], i, true});\n        events.push_back({B[i], i, false});\n    }\n    std::sort(events.begin(), events.end());\n\n    long long res = 0;\n    for(event e : events)\n    {\n        if(e.delivery)\n        {\n            int pre = active.query(B[e.box] + 1, 2 * N);\n            int post = active.query(0, B[e.box] - 1);\n            res += std::min(pre, post);\n            active.set(B[e.box], 1);\n        }\n        else\n        {\n            active.set(B[e.box], 0);\n        }\n    }\n\n    return res;\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/04_skladiste/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate slede\u0107u funkciju:</p> <ul> <li>\\(Resi(N, A[\\ldots], B[\\ldots])\\)</li> </ul> <p>\\(N\\) je broj kutija koje \u0107e tokom dana biti dostavljene u skladi\u0161te (i kasnije izva\u0111ene), \\(A\\) i \\(B\\) su nizovi du\u017eine \\(N\\) u kojima je dat raspored -- \\(A_i\\) je vreme dostave \\(i\\)-te kutije (u minutima), a \\(B_i\\) vreme kada \u0107e Komisija izvaditi istu kutiju iz skladi\u0161ta.</p> <p>Funkcija treba da vrati ceo broj \\(T\\) -- vreme koje \u0107e Komisija provesti u skladi\u0161tu (u nanosekundama), ako su dostave usmerene tako da je ovo vreme minimizovano. Svi nizovi su indeksirani od 0.</p>"},{"location":"takprog/2018_2019/sio/04_skladiste/#primer","title":"Primer","text":"<p>Neka je \\(N = 4\\), \\(A = [0, 1, 2, 5]\\) i \\(B = [3, 7, 4, 6]\\). Ovi parametri odgovaraju slede\u0107em redosledu doga\u0111aja:</p> <ul> <li>kutije 1, 2 i 3 se redom donose u skladi\u0161te,</li> <li>kutije 1 i 3 (redom) se vade iz skladi\u0161ta,</li> <li>kutija 4 se donosi, i</li> <li>kutije 4 i 2 se vade.</li> </ul> <p>Optimalan raspored dostava je: kutije 1, 2 i 4 dostaviti na zadnja vrata, a 3 na prednja. U ovom slu\u010daju, sve kutije osim 1 \u0107e biti prve u skladi\u0161tu kada se vade, a kutija 1 \u0107e biti druga, tako da je ukupno vreme \\(1\\) nanosekunda.</p>"},{"location":"takprog/2018_2019/sio/04_skladiste/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\)</li> <li>\\(0 \\leq A_i, B_i &lt; 2N\\)</li> <li>sve vrednosti \\(A_i\\) i \\(B_i\\) su me\u0111usobno razli\u010dite</li> </ul>"},{"location":"takprog/2018_2019/sio/04_skladiste/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [20 poena]: \\(N \\leq 20\\)</li> <li>Podzadatak 2 [40 poena]: \\(N \\leq 3000\\)</li> <li>Podzadatak 3 [21 poena]: \\(\\forall i,j . A_i &lt; B_j\\)</li> <li>Podzadatak 4 [19 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2018_2019/sio/04_skladiste/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>skladiste.cpp</code> koji implementira pomenfutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>long long Resi(int N, int *A, int *B)</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>y prvom redu broj \\(N\\), i</li> <li>u narednih \\(N\\) redova po dva broja: vrednosti \\(A_i\\) i \\(B_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa povratnu vrednost \\(T\\). Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2018_2019/sio/05_planine/","title":"5 - Planine","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Drevni programer Cep Lu Splus provodi dane mrze\u0107i \u017ealbe i mrze\u0107i provo\u0111enje dana u mr\u017enji. Povremeno mu dolaze se\u0107anja na drevna vremena kada je bio \u010dlan Komisije i odbijao \u017ealbe najbolje od svih. Jednom, u ta vremena, dobio je izuzetno neosnovanu \u017ealbu i dok je hodao drevnom planinom u potrazi za znakom da li da je prvo pro\u010dita ili prvo odbije -- \u017ealba mu je ispala iz ranca i bi zauvek izgubljena. Od tada ga ovo mrsko se\u0107anje neprestano progoni i zbog toga ne mo\u017ee da spava.</p> <p>Ali sada ste do\u0161li vi, za\u0161titnici takmi\u010dara koji se \u017eale, i odlu\u010dili da prona\u0111ete planinu na kojoj je izgubljena \u017ealba. Poznato je da je Cep tog sudbonosnog dana bio u oblasti koja li\u010di na kvadratnu matricu dimenzija \\(N \\times N\\) \u010dije svako polje predstavlja neku planinu odre\u0111ene visine. Kako Cep mrzi niske planine i kolone, planina na kojoj je on bio tog dana je strogo vi\u0161a od svih ostalih planina iz svoje vrste. Analogno, kako Cep mrzi slanu plazmu i radne subote, ta planina je ujedno i strogo ni\u017ea od svih ostalih planina iz svoje kolone.</p> <p>Lo\u0161a vest je \u0161to vi ne znate visine planina a jo\u0161 gora \u0161to Cep zna. No, njegova mr\u017enja prema mrskim se\u0107anjima i nesanici je blago ja\u010da od mr\u017enje prema vama i on \u0107e vam iskreno odgovarati na pitanja oblika \"kolika je visina planine koja se nalazi u \\(i\\)-toj vrsti i \\(j\\)-toj koloni?\". Jasno, Cep mrzi drevni broj \\(K\\) i ne \u017eelite da znate \u0161ta \u0107e se desiti ukoliko mu postavite vi\u0161e od \\(K\\) pitanja.</p> <p>Prona\u0111ite bar jednu planinu na kojoj je mogla biti izgubljena \u017ealba ili konstatujte da takva planina ne postoji postavljaju\u0107i ne vi\u0161e od \\(K\\) pitanja.  Neka izgubljena \u017ealba kona\u010dno bude i formalno odbijena...</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Aleksandar Zlateski"},{"location":"takprog/2018_2019/sio/05_planine/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Nadji(N, K)\\)</li> </ul> <p>koja treba da odredi da li se u matrici planina sa \\(N\\) vrsta i \\(N\\) kolona nalazi planina koja je strogo ve\u0107a od svih ostalih planina iz svoje vrste i strogo manja od svih ostalih planina iz svoje kolone. Ova funkcija mora da vrati niz (vektor) du\u017eine 2 koji sadr\u017ei, redom, brojeve \\(i\\) i \\(j\\) koji ozna\u010davaju da je tra\u017eena planina u preseku \\(i\\)-te vrste i \\(j\\)-te kolone. Vrste i kolone su indeksirane od 1. Ukoliko ima vi\u0161e re\u0161enja, vratiti bilo koje; ukoliko nema re\u0161enja vratiti niz sa dve nule.</p> <p>Na raspolaganju imate funkciju </p> <ul> <li>\\(Pitaj(i, j)\\)</li> </ul> <p>koju smete pozvati najvi\u0161e \\(K\\) puta. Ova funkcija vra\u0107a visinu planine u preseku \\(i\\)-te vrste i \\(j\\)-te kolone. Ukoliko su koordinate \\(i\\) i \\(j\\) van opsega, funkcija \u0107e vratiti \\(-1\\). </p>"},{"location":"takprog/2018_2019/sio/05_planine/#primer","title":"Primer","text":"<p>Neka je \\(N = 3\\), \\(K = 9\\) i neka su visine planina u matrici:</p> <pre><code>3 9 9\n2 2 7\n7 5 8\n</code></pre> <p>Za npr. upit \\(Pitaj(2, 1)\\), odgovor bi bio \\(2\\); za upit \\(Pitaj(2, 3)\\) odgovor bi bio \\(7\\); za upit \\(Pitaj(3, 3)\\) odgovor bi bio \\(8\\) itd. Jedino re\u0161enje za ovaj primer je planina u preseku druge vrste i tre\u0107e kolone (visina 7) i va\u0161a funkcija mora da vrati niz \\((2, 3)\\) koriste\u0107i ne vi\u0161e od \\(9\\) upita.</p>"},{"location":"takprog/2018_2019/sio/05_planine/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Visine svih planina su prirodni brojevi iz segmenta \\([1, 10^9]\\).</li> </ul>"},{"location":"takprog/2018_2019/sio/05_planine/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [4 poena]: \\(N = 100\\), \\(K = 10.000\\)</li> <li>Podzadatak 2 [9 poena]: \\(N = 1.000\\), \\(K = 1.000.000\\)</li> <li>Podzadatak 3 [12 poena]: \\(N = 1.000\\), \\(K = 5.000\\), visine planina su \\(1\\), \\(2\\) ili \\(3\\)</li> <li>Podzadatak 4 [18 poena]: \\(N = 1.000\\), \\(K = 501.500\\)</li> <li>Podzadatak 5 [19 poena]: \\(N = 2.048\\), \\(K = 360.000\\)</li> <li>Podzadatak 6 [14 poena]: \\(N = 3.000\\), \\(K = 12.000\\)</li> <li>Podzadatak 7 [24 poena]: \\(N = 100.000\\), \\(K = 400.000\\)</li> </ul>"},{"location":"takprog/2018_2019/sio/05_planine/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>planine.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>std::vector&lt;int&gt; Nadji(int N, int K);</code></p> <p>Va\u0161a funkcija mo\u017ee koristiti funkciju</p> <p><code>int Pitaj(int i, int j);</code></p> <p>Da bi funkcija <code>Pitaj</code> bila \"vidljiva\" va\u0161oj funkciji <code>Nadji</code>, potrebno je dodati liniju <code>#include \"code.h\"</code> na po\u010detku fajla koji sadr\u017ei implementaciju funkcije <code>Nadji</code>.</p>"},{"location":"takprog/2018_2019/sio/05_planine/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111eni program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(K\\)</li> <li>U narednih \\(N\\) redova po \\(N\\) brojeva koji predstavljaju visine planina</li> </ul> <p>a zatim poziva va\u0161u funkciju sa u\u010ditanim parametrima \\(N\\) i \\(K\\). Na kraju, na standardni izlaz \u0161tampa, redom, brojeve \\(x\\), \\(y\\) i \\(T\\), gde su \\(x\\) i \\(y\\) redni broj vrste i kolone koje je vratila va\u0161a funkcija a \\(T\\) broj poziva funkciji  <code>Pitaj</code>. Kodove ovih programa mo\u017eete menjati po potrebi. Ne garantuje se da \u0107e za testiranje biti kori\u0161\u0107ena ba\u0161 ova verzija programa <code>grader.cpp</code>.</p>"},{"location":"takprog/2018_2019/sio/05_planine/#analiza","title":"Analiza","text":"<p>Potrebno je u kvadratnoj matrici \\(A\\) prona\u0107i element koji je strogo najve\u0107i u svojoj vrsti i strogo najmanji u svojoj koloni -- nazovimo takav element (ukoliko postoji) sedlo (to je, ina\u010de, standarni termin). Za po\u010detak primetimo da ukoliko sedlo postoji, onda je jedinstveno; zaista, pretpostavimo da su \\(A_{i,j}\\) i \\(A_{k,l}\\) sedla. O\u010digledno, \\(i \\neq k\\) i \\(j \\neq l\\). Ukoliko je \\(A_{i,j} \\leq A_{k,l}\\), tada, zbog definicije sedla, \\(A_{i,j} &gt; A_{i,l} &gt; A_{k,l}\\) \u0161to je kontradikcija; za \\(A_{i,j} &gt; A_{k,l}\\) ponovo dobijamo kontradikciju preko \\(A_{i,j} &lt; A_{k,j} &lt; A_{k,l}\\) pa je nemogu\u0107e da postoje dva ili vi\u0161e sedla.</p> <p>Iz prethodnog razmatranja sledi: ukoliko su nam poznate vrednosti neka dva polja (npr. \\(A_{i,j}\\) i \\(A_{k,l}\\)), mo\u017eemo eliminasti bar jedno od njih kao potencijalnog kandidata za sedlo upitom nad najvi\u0161e jednim dodatnim poljem (\\(A_{i,l}\\) ili \\(A_{k,j}\\)). Dakle, proizvoljnih \\(M\\) potencijalnih kandidata za sedlo (za koje znamo vrednosti) mo\u017eemo svesti na samo \\(1\\) uz ne vi\u0161e od \\(M-1\\) pitanja korite\u0107i ovaj metod koji \u0107emo jednostavno zvati Eliminacija.</p> <p>Podzadaci 1 i 2: Ovde je \\(K = N^2\\) pa jednostavno mo\u017eemo pitati za vrednosti svih polja i na\u0107i sedlo u poznatoj matrici u slo\u017eenosti \\(O(N^3)\\) ukoliko za svako polje prolazimo celu njegovu vrstu i kolonu ili u slo\u017eenosti \\(O(N^2)\\) ukoliko prekalkuli\u0161emo maksimume po vrstama i minimume po kolonama.</p> <p>Podzadatak 3: Kako su vrednosti iz skupa \\(\\{1,2,3\\}\\), jasno je da element \\(A_{i,j}\\) mo\u017ee biti sedlo ako i samo ako je \\(A_{i,j} = 2\\), svi ostali elementi u njegovoj vrsti su \\(1\\) i svi ostali elementi u njegovoj koloni su \\(3\\). Prema tome, ukoliko upitamo za vrednost \\(A_{i,j}\\) i dobijemo vrednost \\(1\\), eliminisali smo celu \\(j\\)-tu kolonu (tamo ne mo\u017ee biti sedlo), ako dobijemo vrednost \\(3\\) -- eliminisali smo celu \\(i\\)-tu vrstu, a ako dobijemo vrednost \\(2\\) - eliminisali smo celu \\(i\\)-tu vrstu i \\(j\\)-tu kolonu osim potencijalno ba\u0161 elementa \\(A_{i,j}\\). Upite mo\u017eemo postavljati tako da u svakom upitu elimini\u0161emo bar jednu vrstu ili kolonu pa \u0107emo nakon najvi\u0161e \\(2N\\) upita eliminisati sve vrste i kolone i osta\u0107e nam najvi\u0161e \\(N\\) polja koja mogu biti potencijalna sedla. Sada primenimo Eliminaciju (najvi\u0161e jo\u0161 \\(N\\) upita) i jo\u0161 najvi\u0161e \\(2N\\) upita za proveru da li je preostali element zaista sedlo (mo\u017ee se pokazati da je za ovaj metod gornja granica za broj upita zapravo \\(4N\\) umesto \\(5N\\)).</p> <p>Podzadatak 4: Postavimo upite za sve elemente sa glavne dijagonale i permutujmo vrste i kolone tako da va\u017ei \\(A_{1,1} \\leq A_{2,2} \\leq \\ldots \\leq A_{N,N}\\) (ovo nije problem, dovoljno je samo zapamtiti te permutacije i za svako naredno \\(Pitaj(i,j)\\) zapravo postavljati \\(Pitaj(row[i], col[j])\\)). U novodobijenoj matrici, nijedan element ispod glavne dijagonale ne mo\u017ee biti sedlo (nemogu\u0107e da za \\(i &gt; j\\) va\u017ei \\(A_{i,j} &gt; A_{i,i}\\) i \\(A_{i,j} &lt; A_{j,j}\\) jer \\(A_{j,j} \\leq A_{i,i}\\)) pa sedlo mo\u017eemo tra\u017eiti samo na glavnoj dijagonali i iznad, pitaju\u0107i za vrednosti sve kandidate (njih \\(\\frac{N(N+1)}{2}\\)) i primenjuju\u0107i Eliminaciju (pokazati da nam prilikom Eliminacije nikada ne\u0107e trebati vrednosti elemenata ispod glavne dijagonale jer mo\u017eemo koristiti poredak na njoj!). Ovaj deo mo\u017eemo i jednostavnije, nalaze\u0107i sedlo kao u Podzadatku 2 ne koriste\u0107i elemente ispod glavne dijagonale (pokazati da \u0107emo i u slu\u010daju \"polu-matrice\" sa soritranom dijagonalom dobiti najvi\u0161e jednog kandidata!). Kada dobijemo jedinstvenog kandidata, dovoljno je jo\u0161 \\(N-1\\) upita za proveru jer je najvi\u0161e toliko polja iz njegove vrste i kolone (od njih \\(2N-1\\)) ispod glavne dijagonale. Dakle, treba nam \\(\\frac{N(N+1)}{2} + N - 1\\) upita, \u0161to se uklapa u ograni\u010denja.</p> <p>Podzadatak 5: U prethodnom podzadatku, umesto da pitamo za sva polja iznad glavne dijagonale, mo\u017eemo npr. rekurzivno primeniti logiku za gornji-desni kvadrat (i opet pitati samo oko polovinu svih elemenata u njemu). Preciznije, radimo slede\u0107e  - Ukoliko je trenutni kvadrat dimenzija \\(1 \\times 1\\) pitamo i vratimo to polje kao potencijalnog kandidata; ina\u010de  - Pitamo za sve elemente glavne dijagonale trenutnog kvadrata i permutujemo vrste/kolone tako da va\u017ei poredak kao u prethodnom podzadatku  - Rekurzivno ponovimo postupak za gornji-levi, donji-desni i gornji-desni podkvadrat (za prva dva postavimo marker da ne moramo pitati/sortirati dijagonalu jer je ve\u0107 sortirana kao deo originalne) i od 3 dobijena kandidata Eliminacijom vratimo samo jedan.</p> <p>Ako je \\(T(N)\\) broj poziva \\(Pitaj\\) ovog algoritma za kvadrat dimenzije \\(N \\times N\\), nije te\u0161ko zaklju\u010diti da va\u017ei \\(T(1) = 1\\) i \\(T(N) = 3T(\\lceil \\frac{N}{2} \\rceil)\\) za \\(N &gt; 1\\) (kako ima puno \"preklapanja\" dijagonala, mo\u017eemo zamisliti da zapravo ne pitamo za polja osim ako je kvadrat \\(1 \\times 1\\)) pa je \\(T(N) = 3^{\\log_2 N} = N^{\\log_2 3}\\) (polja koja pitamo obrazuju neku vrstu fraktala a implementacija je blago zgodnija jer je \\(N\\) stepen dvojke). Za Eliminaciju nam u najgorem slu\u010daju treba jo\u0161 toliko upita (a u praksi mnogo manje zbog preklapanja) i ra\u010dunaju\u0107i kona\u010dnu proveru to je najvi\u0161e \\(2\\cdot N^{\\log_2 3} + 2N\\) upita, \u0161to se uklapa u ograni\u010denja.</p> <p>Podzadaci 6 i 7: Nazovimo skup polja \\(S\\) (matrice) dobrim ukoliko nikoja dva polja iz \\(S\\) nisu u istoj vrsti ili koloni i ukoliko se sedlo (ukoliko postoji) cele matrice nalazi u preseku vrste u kojoj je neki element iz \\(S\\) i kolone u kojoj je neki element iz \\(S\\). Npr. jedan dobar skup je \\(D = \\{(1,1), (2,2), \\ldots, (N,N)\\}\\). </p> <p>\\((*)\\) Primetimo da ako je \\(S\\) dobar skup, tada sedlo ne sme biti ve\u0107e od najve\u0107eg elementa iz \\(S\\) i ne sme biti manje od najmanjeg elementa iz \\(S\\). Zaista, kako sedlo pripada nekoj koloni iz \\(S\\), ono je manje ili jednako od bar jednog elementa iz \\(S\\) pa i od maksimuma; sli\u010dno i za minimum.</p> <p>Neka je \\(S\\) proizvoljan dobar skup i neka je \\((i, j) \\in S\\) takvo da je \\(A_{i,j}\\) najmanja vrednost od svih vrednosti iz \\(S\\) a \\((k, l) \\in S\\) takvo da je \\(A_{k,l}\\) najve\u0107a vrednost od svih vrednosti iz \\(S\\). Od dobrog skupa \\(S\\) mo\u017eemo dobiti dobar skup sa jednim elementom manje na slede\u0107i na\u010din: pitamo za vrednost elementa \\(A_{i,l}\\) i razlikujemo 3 slu\u010daja:</p> <ul> <li>\\(A_{i,l} \\leq A_{i,j}\\): Ako je sedlo u koloni \\(l\\) onda je ono manje od \\(A_{i,l}\\) a samim tim i od \\(A_{i,j}\\) tj. od svih elemenata skupa \\(S\\) \u0161to je nemogu\u0107e zbog \\((*)\\) . Dakle, u koloni \\(l\\) nema sedla. Sa druge strane, u vrsti \\(k\\) je jedini kandidat za sedlo \\(A_{k,l}\\) (ina\u010de bi sedlo moralo biti ve\u0107e od svih elemenata iz \\(S\\) \u0161to je nemogu\u0107e zbog \\((*)\\) ) ali ve\u0107 smo zaklju\u010dili da u koloni \\(l\\) nema sedla pa sedlo nije ni u vrsti \\(k\\). Dakle, izbacivanjem elementa \\((k, l)\\) iz \\(S\\) opet dobijamo dobar skup.</li> <li>\\(A_{k,l} \\leq A_{i,l}\\): Analognim razmatranjem kao u prethodnom slu\u010daju, dobijamo da se izbacivanjem elementa \\((i, j)\\) iz \\(S\\) opet dobija dobar skup.</li> <li>\\(A_{i,j} &lt; A_{i,l} &lt; A_{k,l}\\): Koriste\u0107i \\((*)\\) kao u prethodnim slu\u010dajevima, dobijamo da je \\(A_{i,j}\\) jedini kandidat za sedlo u koloni \\(j\\) i da je \\(A_{k,l}\\) jedini kandidat za sedlo u vrsti \\(k\\). Me\u0111utim, \\(A_{i,j}\\) i \\(A_{k,l}\\) ne mogu biti sedla zbog, redom, \\(A_{i,j} &lt; A_{i,l}\\) i \\(A_{i,l} &lt; A_{k,l}\\) pa sledi da sedlo nije ni u vrsti \\(k\\) ni u koloni \\(j\\). Ovu vrstu i kolonu mo\u017eemo izbaciti tako \u0161to iz skupa \\(S\\) izbacimo elemente \\((i, j)\\) i \\((k, l)\\) ali ubacimo element \\((i, l)\\) (jer moramo zadr\u017eati \\(i\\)-tu vrstu i \\(l\\)-tu kolonu). Novodobijeni skup je dobar i sadr\u017ei element manje.</li> </ul> <p>Kada dobijemo dobar skup sa jednim elementom, on je jedini kandidat za sedlo. Dakle, algoritam je slede\u0107i: krenemo od npr. dobrog skupa sa dijagonalnim elementima \\(D\\) (N upita), svedemo ga na dobar skup sa jednim elementom pomo\u0107u dodatnih \\(N-1\\) upita i na kraju potro\u0161imo jo\u0161 najvi\u0161e \\(2N\\) upita za proveru. U zavisnosti da li minimum/maksimum u svakom koraku tra\u017eimo u \\(O(N)\\) (trivijalno) ili u \\(O(\\log N)\\) (uz pomo\u0107 neke strukture), ovo prolazi za prvih 6 ili za svih 7 podzadataka.</p> <p>Re\u0161enje sa o\u010dekivanim brojem upita reda \\(O(N)\\): Primetimo da ukoliko znamo vrednosti neka dva polja (npr. \\(A_{i,j}\\) i \\(A_{k,l}\\)) mo\u017eemo eliminisati bar jedno od polja \\(A_{i,j}, A_{k,l}, A_{i, l}, A_{k,j}\\) kao potencijalnog kandidata za sedlo bez ikakvih dodatnih upita (npr. ako je \\(A_{i,j} \\leq A_{k,l}\\), mo\u017eemo zaklju\u010diti da \\(A_{j,k}\\)  ne mo\u017ee biti sedlo iako mu mo\u017eda ne znamo vrednost). Prema tome, ukoliko smo postavili \\(X\\) upita, teoretski mo\u017eemo eliminisati \\(\\frac{X(X-1)}{2}\\) polja gledaju\u0107i svaki par upita. Naravno, ovde mo\u017ee do\u0107i do puno preklapanja (razli\u010diti parovi upita elimini\u0161u isto polje) ali se mo\u017ee pokazati (a i intuitivno je jasno) da je o\u010dekivani broj upita (ako ih postavljamo random) potreban za eliminaciju svih \\(N^2\\) polja (osim eventualno jednog) reda veli\u010dine \\(O(N)\\). Dodatno, upiti ne moraju biti postavljani bilo kako ve\u0107 u svakom koraku pitati samo neko trenutno ne-eliminisano polje (i pomo\u0107u njega i prethodnih upita raditi pomenutu elminaciju); ukoliko ostane \\(O(N)\\) ne-eliminisanih polja u nekom trenutku, mo\u017eda je bolje prebaciti se na standardnu Eliminaciju itd.</p> <p>Ovaj pristup, uz eventualnu randomizaciju ili bolje odabrani redosled upita, prolazi za Podzadatke 1, 2, 4 i 5 a \u010desto i za 3 (zbog specifi\u010dnih vrednosti i malo ve\u0107e konstante za dozvoljeni broj upita u odnosu na Podzadatke 6 i 7). Sa druge strane ovo (verovatno) ne mo\u017ee re\u0161iti Podzadatak 6 (zbog stro\u017eeg ograni\u010denja u broju upita i eventualno memorijskog ograni\u010denja) kao ni Podzadatak 7 (jer je slo\u017eenost \\(O(N^2)\\)). </p> 05_planine.cpp<pre><code>#include \"code.h\"\n#include &lt;set&gt;\n\nstruct field\n{\n    int i, j, val;\n    field(int _i, int _j, int _val)\n    {\n        i = _i; j = _j; val = _val;\n    }\n};\n\nstruct cmp\n{\n    bool operator () (const field&amp; A, const field&amp; B)\n    {\n        if (A.val != B.val)\n            return (A.val &lt; B.val);\n        if (A.i != B.i)\n            return (A.i &lt; B.i);\n        return (A.j &lt; B.j);\n    }\n};\n\nstd::set&lt;field, cmp&gt; heap;\n\nstd::vector&lt;int&gt; Nadji(int N, int K)\n{\n    heap.clear();\n    for (int i = 1; i &lt;= N; i++)\n    {\n        int val = Pitaj(i, i);\n        heap.insert(field(i, i, val));\n    }\n\n    while (heap.size() &gt; 1)\n    {\n        field minF = *heap.begin();\n        field maxF = *(--heap.end());\n\n        int i = minF.i;\n        int j = minF.j;\n        int k = maxF.i;\n        int l = maxF.j;\n\n        int val = Pitaj(i, l);\n\n        if (val &lt;= minF.val)\n        {\n            heap.erase(--heap.end());\n        }\n        else if (val &gt;= maxF.val)\n        {\n            heap.erase(heap.begin());\n        }\n        else\n        {\n            heap.erase(--heap.end());\n            heap.erase(heap.begin());\n            heap.insert(field(i, l, val));\n        }\n    }\n\n    field saddle = *heap.begin();\n\n    int I = saddle.i;\n    int J = saddle.j;\n    for (int i = 1; i &lt;= N &amp;&amp; I != 0 &amp;&amp; J != 0; i++)\n    {\n        if (i != I &amp;&amp; Pitaj(i, J) &lt;= saddle.val)\n        {\n            I = 0; J = 0;\n        }\n    }\n    for (int j = 1; j &lt;= N &amp;&amp; I != 0 &amp;&amp; J != 0; j++)\n    {\n        if (j != J &amp;&amp; Pitaj(I, j) &gt;= saddle.val)\n        {\n            I = 0; J = 0;\n        }\n    }\n\n    std::vector&lt;int&gt; out;\n    out.push_back(I);\n    out.push_back(J);\n    return out;\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/06_film/","title":"6 - Film","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Bio jednom jedan film. Vi stojite ispred bioskopa i pitali ste \\(N\\) ljudi da vam ispri\u010daju jednu scenu iz filma. Kako su pukom koincidencijom svi ti ljudi tako\u0111e odli\u010dni programeri kao i vi, svako od njih vam je ispri\u010dao jednu scenu, predstavljenu kao string malih slova engleske abecede, uz napomenu da se ta scena javlja u filmu ta\u010dno jednom. Va\u0161 zadatak je da rekonstrui\u0161ete film, ta\u010dnije, da prona\u0111ete string \\(S\\) najkra\u0107e mogu\u0107e du\u017eine koji \u0107e svaku scenu sadr\u017eati ta\u010dno jednom, takav da se taj string sastoji samo od prvih \\(K\\) malih slova engleske abecede.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Aleksandar Zlateski <p>Prvi podzadatak se mo\u017ee re\u0161iti generisanjem svih stringova du\u017eine do \\(18\\) a zatim proverom za svaki od njih da li se svaki dati string javlja ta\u010dno jednom. Treba biti pa\u017eljiv jer je mogu\u0107e da dati stringovi sadr\u017ee slova koja nisu me\u0111u prvih \\(K\\) slova engleskog alfabeta.</p> <p>Drugi podzadatak se mo\u017ee re\u0161iti generisanjem svih mogu\u0107ih preklapanja data dva stringa, uklju\u010duju\u0107i i situaciju kada se stringovi uop\u0161te ne preklapaju.</p> <p>Na sli\u010dan na\u010din se mo\u017ee re\u0161iti i tre\u0107i podzadatak, samo je u slu\u010daju kada imamo \\(N = 3\\) stringa pove\u0107ava se slo\u017eenost generisanja preklapanja.</p> <p>Postoji i druga\u010dije re\u0161enje za ova dva podzadatka, \u010dija ideja je jako va\u017ena za re\u0161avanje zadatka za maksimalni broj poena. Recimo, za \\(N=3\\), posmatrajmo jedno parcijalno re\u0161enje, odnosno, prefiks nekog najkra\u0107eg validnog stringa. Neka je \\(mask\\) bit-maska sa \\(3\\) bit-pozicije koja nam govori da li se \\(i\\)-ti string do sada ve\u0107 javio, i neka su \\(p_1,p_2,p_3\\) du\u017eine najdu\u017eeg stringa koji je sufiks trenutnog re\u0161enja a ujedno i prefiks prvog, drugog i tre\u0107eg stringa, redom. Dodavanjem jednog slova mi mo\u017eemo da proverimo koje su nove vrednosti najdu\u017eeg sufiksa za sva tri stringa. Ako je neka od tih du\u017eina sufiksa postala jednaka du\u017eini celog stringa, to je novo pojavljivanje tog stringa. Ako se taj string ve\u0107 javio, re\u0161enje postale nevalidno, ina\u010de, u odgovaraju\u0107i bit trenutne bit-maske treba upisati bit \\(1\\). Korisno je unapred izra\u010dunati prelaze, tj. trojke \\((l, x) \\rightarrow l'\\), gde je \\(l\\) stara du\u017eina prefiksa stringa, \\(x\\) slovo koje se dodaje, \\(l'\\) je nova du\u017eina tog najdu\u017eeg prefiksa. Ovi prelazi se mogu izra\u010dunati \\(KMP\\) algoritmom, ali i ne moraju, s obzirom da brute-force implementacija ima vremensku slo\u017eenost \\(O(L_i^3)\\). Nas onda samo zanima najkra\u0107i put (gledano po broju slova) od stanja \\((mask=000_2, p_1=0, p_2=0, p_3=0)\\) do nekog stanja gde je \\(mask=111_2\\). Pored prelaza, ovo re\u0161enje radi u slo\u017eenosti \\(O(K \\times L_1 \\times L_2 \\times L_3)\\).</p> <p>Za maksimalni broj poena dovoljno je da primetimo da ne moramo da pamtimo najdu\u017ei prefiks za svaki pojedina\u010dni string, ve\u0107 je dovoljno da nam stanje bude najdu\u017ei sufiks trenutnog parcijalnog re\u0161enja koji je ujedno i prefiks nekog od datih stringova, ta\u010dnije, stanje \u0107e nam biti ta\u010dno o kom prefiksu se radi - ovih prefiksa mo\u017ee biti najvi\u0161e \\(\\sum L_i\\). Prelaze mo\u017eemo izra\u010dunati u linearnom vremenu pomo\u0107u Aho-Corasick algoritma ali, kao i ranije, ne moramo, jer ponovo brute-force nala\u017eenje prelaza radi u vremenskoj slo\u017eenosti \\(O((\\sum L_i)^3)\\) i mo\u017ee se implementirati elementarnim (i sporim) algoritmima pretrage stringova. Sada, kona\u010dno re\u0161enje izgleda ovako: Napravimo graf \u010diji su \u010dvorovi ure\u0111eni parovi \\((mask, prefix)\\) gde je \\(mask\\) bit-maska sa \\(N\\) pozicija koja nam govori o tome da li se \\(i\\)-ti string do sada javio, a grane su usmerene i od svakog \u010dvora izlazi ta\u010dno \\(K\\) grana, po jedna za svako slovo, dolazni \u010dvor za svaku granu se mo\u017ee na\u0107i gore opisanim postupkom pomo\u0107u izra\u010dunatih prelaza. Sada je re\u0161enje najkra\u0107i put u ovom grafu od \u010dvora \\((0, \"\")\\) do nekog \u010dvora \u010dija se bit-maska sastoji samo od jedinica. Ovaj najkra\u0107i put mo\u017eemo na\u0107i obi\u010dnim \\(BFS\\) algoritmom. Vremenska slo\u017eenost je \\(O((\\sum L_i)^3 + (\\sum L_i) \\times 2^N \\times K)\\).</p> 06_film.cpp<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;queue&gt;\n#include &lt;tuple&gt;\nusing namespace std;\n\nconst int MAXTOTLEN = 200;\nconst int MAXN = 15;\n\nstruct node {\n    int next[26], link[26], mask;\n} b[MAXTOTLEN]; int sz = 1;\n\nchar hi;\n\nvoid trie_dodaj(const string&amp; s) {\n    int t = 0;\n    for (char x : s) {\n        int y = x - 'a';\n        if (!b[t].next[y])\n            t = b[t].next[y] = sz++;\n        else\n            t = b[t].next[y];\n    }\n}\n\nint trie_trazi(const string&amp; s) {\n    int t = 0;\n    for (char x : s) {\n        int y = x - 'a';\n        if (!b[t].next[y])\n            return -1;\n        else\n            t = b[t].next[y];\n    }\n    return t;\n}\n\nvoid nadji_linkove(int t, string s) {\n    for (char x='a'; x&lt;=hi; x++) {\n        string p = s + x;\n        int y = -1;\n        while ((y = trie_trazi(p)) == -1)\n            p = p.substr(1);\n        b[t].link[x - 'a'] = y;\n    }\n\n    for (char x='a'; x&lt;='z'; x++) {\n        int y = b[t].next[x-'a'];\n        if (y)\n            nadji_linkove(y, s+x);\n    }\n}\n\nvoid nadji_maske(int t, string s, vector&lt;string&gt;&amp; vs) {\n    for (int i=0; i&lt;(int)vs.size(); i++) {\n        if (s.size() &gt;= vs[i].size() &amp;&amp; equal(vs[i].begin(), vs[i].end(),\n            s.begin() + (s.size() - vs[i].size())))\n        {\n            b[t].mask |= 1 &lt;&lt; i;\n        }\n    }   \n\n    for (char x='a'; x&lt;='z'; x++) {\n        int y = b[t].next[x - 'a'];\n        if (y)\n            nadji_maske(y, s+x, vs);\n    }\n}\n\nint dist[1 &lt;&lt; MAXN][MAXTOTLEN];\ntuple&lt;char, int, int&gt; pre[1 &lt;&lt; MAXN][MAXTOTLEN];\n\nint Resi(int N, int K, int* L, char** A, char* S) {\n    hi = 'a' + K - 1;\n    // konstruisi trie\n    vector&lt;string&gt; vs(N);\n    for (int i=1; i&lt;=N; i++) {\n        vs[i-1] = string(A[i]+1, A[i]+L[i]+1);\n        trie_dodaj(vs[i-1]);\n    }\n    nadji_linkove(0, \"\");\n    nadji_maske(0, \"\", vs);\n    memset(dist, 255, sizeof(dist));\n    dist[0][0] = 0;\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n    q.push({0, 0});\n    while (q.size()) {\n        auto ee = q.front(); q.pop();\n        int mask = ee.first;\n        int cvor = ee.second;\n        for (char x='a'; x&lt;=hi; x++) {\n            int tgt = b[cvor].link[x-'a'];\n            int mask2 = b[tgt].mask;\n            if (mask2 &amp; mask)\n                continue;\n            mask2 |= mask;\n            if (dist[mask2][tgt] == -1) {\n                dist[mask2][tgt] = dist[mask][cvor] + 1;\n                pre[mask2][tgt] = {x, mask, cvor};\n                q.push({mask2, tgt});\n            }\n        }\n    }\n    int sol = 123123123, idx = -1;\n    for (int i=0; i&lt;MAXTOTLEN; i++) {\n        int d = dist[(1&lt;&lt;N)-1][i];\n        if (d != -1) {\n            if (d &lt; sol) {\n                sol = d;\n                idx = i;\n            }\n        }\n    }\n    if (sol == 123123123) {\n        return -1;\n    } else {\n        int pos = sol;\n        int mask = (1 &lt;&lt; N) - 1;\n        int cvor = idx;\n        while (get&lt;0&gt;(pre[mask][idx])) {\n            S[pos--] = get&lt;0&gt;(pre[mask][idx]);\n            int mask_tmp = get&lt;1&gt;(pre[mask][idx]);\n            int idx_tmp  = get&lt;2&gt;(pre[mask][idx]);\n\n            mask = mask_tmp;\n            idx = idx_tmp;\n        }\n        return sol;\n    }\n}\n</code></pre>"},{"location":"takprog/2018_2019/sio/06_film/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, K, L[\\ldots], A[\\ldots][\\ldots], S[\\ldots])\\)</li> </ul> <p>koja treba da na\u0111e string opisan u tekstu zadatka. \\(N\\) ozna\u010dava broj ljudi koji su vam rekli jednu scenu iz filma. \\(K\\) je broj koji ozna\u010dava koliko prvih malih slova engleske abecede mo\u017eete koristiti za konstruisanje filma. \\(L\\) je niz du\u017eine \\(N\\) koji sadr\u017ei du\u017eine datih scena. \\(A\\) je niz nizova, gde elementi \\(A[i][1], \\ldots, A[i][L[i]]\\) \u010dine \\(i\\)-tu scenu. Svi ovi elementi su mala slova engleske abecede. Ukoliko takav string postoji, prona\u0111eni string minimalne du\u017eine smestite u niz \\(S\\) po\u010dev od pozicije \\(1\\), a njegovu du\u017einu vratite kao rezultat funkcije. Ukoliko takav string ne postoji, dovoljno je da iz funkcije vratite broj \\(-1\\). Garantuje se da \u0107e za string \\(S\\) biti rezervisano dovoljno memorije da ceo rezultuju\u0107i string mo\u017ee da stane. Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2018_2019/sio/06_film/#primeri","title":"Primeri","text":""},{"location":"takprog/2018_2019/sio/06_film/#primer-1","title":"Primer 1","text":"<p>Neka je \\(N=6, K=26\\), a stringovi su <code>ave</code>, <code>venge</code>, <code>ger</code>, <code>rs</code>, <code>r</code>, <code>av</code>. Re\u0161enje je string <code>avengers</code>. Va\u0161a funkcija treba da upi\u0161e ovaj string na pozicije \\(S[1], \\ldots, S[8]\\) i da vrati broj \\(8\\).</p>"},{"location":"takprog/2018_2019/sio/06_film/#primer-2","title":"Primer 2","text":"<p>Neka je \\(N=2, K=2\\), a stringovi su <code>ababa</code>, <code>aba</code>. Re\u0161enje ne postoji. U ovom slu\u010daju dovoljno je da va\u0161a funkcija vrati broj \\(-1\\).</p>"},{"location":"takprog/2018_2019/sio/06_film/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 14\\)</li> <li>\\(1 \\leq K \\leq 26\\)</li> <li>\\(L_i \\geq 1\\)</li> <li>\\(\\sum_{i=1}^N L_i \\leq 150\\)</li> </ul>"},{"location":"takprog/2018_2019/sio/06_film/#podzadaci","title":"Podzadaci","text":"<ul> <li>Podzadatak 1 [14 poena]: \\(K = 2\\), ukoliko re\u0161enje postoji, tada je ono ne du\u017ee od \\(18\\).</li> <li>Podzadatak 2 [12 poena]: \\(N = 2\\)</li> <li>Podzadatak 3 [23 poena]: \\(N = 3\\)</li> <li>Podzadatak 4 [51 poen]: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2018_2019/sio/06_film/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>film.cpp</code>, koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Resi(int N, int K, int* L, char** A, char* S);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p>"},{"location":"takprog/2018_2019/sio/06_film/#testiranje-i-eksperimentisanje","title":"Testiranje i eksperimentisanje","text":"<p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, K\\),</li> <li>U narednih \\(N\\) redova po jedan string - \\(A_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju. Neka je va\u0161a funkcija vratila broj \\(X\\). Ukoliko je \\(X &lt; 0\\), \u0161tampa se samo \\(X\\). U suprotnom, \u0161tampa se \\(X\\) i prvih \\(X\\) karaktera niza \\(S\\). Kodove ovih programa mo\u017eete menjati po potrebi.</p>"},{"location":"takprog/2019_2020/drz/01_lek/","title":"B1 - Lek","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>U ovo vreme globalne epidemije virusa, na\u0161 poznati nau\u010dnik Milo\u0161 je, kao jedini dovoljno kvalifikovani nau\u010dnik za ovaj posao, dobio zadatak da analizira genetsku strukturu virusa u svojoj labaratoriji. Ako njegova analiza bude uspe\u0161na, ona \u0107e zagarantovati pronala\u017eenje leka i oslobo\u0111enje sveta od virusa.</p> <p>Genetska struktura virusa \\(G\\) se mo\u017ee predstaviti kao permutacija brojeva od \\(1\\) do \\(N\\), to jest, niz brojeva od \\(1\\) do \\(N\\) du\u017eine \\(N\\) gde se svaki broj pojavljuje ta\u010dno jednom.</p> <p>Kako bi Milo\u0161 mogao da uradi svoju analizu, genetska struktura mora da bude sortirana. Za soritranje genetske strukture, Milo\u0161 koristi veoma specijalnu ma\u0161inu. Ova ma\u0161ina mu dozvoljava da uzme neki segment niza i obrne ga. Ta\u010dnije, mo\u017ee da odabere dva indeksa \\(l\\) i \\(r\\) tako da va\u017ei \\(l\\leq r\\), i obrne podniz od  \\(l\\)-te do \\(r\\)-te pozicije u nizu (zameni mesta elementima \\(G_l\\) i \\(G_r\\), \\(G_{l+1}\\) i \\(G_{r-1}\\), \\(\\ldots\\) ). Milo\u0161 tako\u0111e zna da su geni veoma osetljivi i da \u0107e se o\u0161tetiti ako upotrebi ma\u0161inu vi\u0161e puta na isti gen (Milo\u0161 mo\u017ee da upotrebi ma\u0161inu proizvoljan broj puta, ali intervali indeksa koje odabere moraju biti disjunktni).</p> <p>Kako Milo\u0161 nema iskustva sa kori\u0161\u0107enjem ove ma\u0161ine, potrebna mu je va\u0161a pomo\u0107! Ka\u017eite mu da li je mogu\u0107e uz pomo\u0107 ove ma\u0161ine sortirati genetsku strukturu bez o\u0161te\u0107enja gena ili ne. Ako je sortiranje genetske strukture mogu\u0107e, tako\u0107e mu je potrebna i sekvenca operacija koju treba primeniti radi uspe\u0161nog sortiranja. Zbog toga \u0161to je ma\u0161ina spora, a Milo\u0161 ho\u0107e da lek bude gotov \u0161to pre, potrebno je i da sekvenca operacija bude najkra\u0107a mogu\u0107a (ukoliko postoji vi\u0161e najkra\u0107ih sekvenci, ispisati bilo koju).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Pe\u0161i\u0107 Dimitrije Erdeljan Aleksandar Zlateski <p>Po\u0161to svaki element mo\u017ee biti deo najvi\u0161e jednog intervala koji okre\u0107emo, znamo da va\u017ei slede\u0107e:</p> <ul> <li>Ako \\(A_i = i\\), taj element se ne pomera, tako da ne sme biti deo   nijednog intervala.</li> <li>Ako \\(A_i \\neq i\\), taj element mora biti deo intervala koji ga dovodi   na poziciju \\(A_i\\).</li> </ul> <p>Ako za neko \\(i\\) imamo \\(A_i \\neq i\\) i \\(A_{i-1} = i-1\\) (ili \\(i=1\\)), jedan interval mora po\u010dinjati na poziciji \\(i\\) (jer ne sme da obuhvati \\(i-1\\)) i imati du\u017einu takvu da \\(A_i\\) postavi na ispravnu poziciju: \\(A_i - i + 1\\).</p> <p>Dakle, da bi odredili pozicije svih intervala, dovoljno je da pro\u0111emo kroz ceo niz i svaki put kada nai\u0111emo na neko \\(A_i \\neq i\\), obrnemo interval du\u017eine \\(A_i - i + 1\\) i nastavimo od prve pozicije nakon tog intervala (jer elemente koje smo ovime pomerili ne smemo da ponovo pomerimo). Kada do\u0111emo do kraja niza, u drugom prolazu mo\u017eemo proveriti da li je sortiran: ako jeste, na\u0161li smo (jedino mogu\u0107e) re\u0161enje, a ako nije re\u0161enje ne postoji.</p> <p>Algoritam prolazi kroz niz dva puta, i u okretanju intervala svaki element posmatra najvi\u0161e jednom (jer se intervali ne seku), tako da je ukupna slo\u017eenost \\(\\mathcal{O}(N)\\).</p> 01_lek.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n;\nvoid rev(int l,int r,vector&lt;int&gt; &amp;p){\n    for(int j=l;r-j+l&gt;j;j++)\n    swap(p[j],p[r-j+l]);\n}\nbool ok(vector&lt;int&gt; &amp;p){\n    for(int i=0;i&lt;p.size();i++)\n        if(p[i]!=i)\n            return 0;\n    return 1;\n}\nint main(){\n    scanf(\"%i\",&amp;n);\n  vector&lt;int&gt; perm(n+2);\n  for(int i=1;i&lt;=n;i++)\n    scanf(\"%i\",&amp;perm[i]);\n  perm[n+1]=n+1;\n  vector&lt;pair&lt;int,int&gt; &gt; sol;\n  int lst=-1;\n  for(int i=1;i&lt;=n+1;i++){\n    if(perm[i]&gt;perm[i-1]){\n        if(lst!=-1){\n            rev(lst,i-1,perm);\n            sol.push_back({lst,i-1});\n            lst=-1;\n        }\n    }\n    else{\n        if(lst==-1)\n            lst=i-1;\n    }\n  }\n  if(!ok(perm)){\n    printf(\"Nema spasa\\n\");\n    return 0;\n  }\n  printf(\"Svet je spasen\\n%i\\n\",sol.size());\n  for(auto p:sol)\n    printf(\"%i %i\\n\",p.first,p.second);\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/drz/01_lek/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei broj \\(N\\), du\u017einu genetske strukture.  Druga linija standardnog ulaza sadr\u017ei niz \\(G\\), genetsku strukturu.</p>"},{"location":"takprog/2019_2020/drz/01_lek/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko je sortiranje genetske strukture mogu\u0107e, u prvoj liniji standardnog izlaza ispisati \"Svet je spasen\", u drugoj liniji standardnog izlaza ispisati du\u017einu najkra\u0107e mogu\u0107e sekvence operacija \\(K\\).  U svakoj od narednih \\(K\\) linija ispisati dva broja \\(l_i\\) i \\(r_i\\), indekse koje Milo\u0161 treba da odabere za \\(i\\)-tu operaciju.  Ukoliko sortiranje genetske strukture nije mogu\u0107e, u prvoj i jedinoj liniji standardnog izlaza ispisati \"Nema spasa\"</p>"},{"location":"takprog/2019_2020/drz/01_lek/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/01_lek/#ulaz","title":"Ulaz","text":"<pre><code>8\n2 1 4 3 5 6 7 8\n</code></pre>"},{"location":"takprog/2019_2020/drz/01_lek/#izlaz","title":"Izlaz","text":"<pre><code>Svet je spasen\n2\n1 2\n3 4\n</code></pre>"},{"location":"takprog/2019_2020/drz/01_lek/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/drz/01_lek/#ulaz_1","title":"Ulaz","text":"<pre><code>8\n1 6 7 3 2 5 4 8\n</code></pre>"},{"location":"takprog/2019_2020/drz/01_lek/#izlaz_1","title":"Izlaz","text":"<pre><code>Nema spasa\n</code></pre>"},{"location":"takprog/2019_2020/drz/01_lek/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq10^6\\)</li> <li>\\(1\\leq G_i\\leq N\\)</li> <li>Svaki broj od \\(1\\) do \\(N\\) se pojavljuje ta\u010dno jednom u \\(G\\).</li> </ul> <p>Test primeri su podeljeni u 5 podzadatka:</p> <ul> <li>[10 poena]: \\(N \\leq 3\\)</li> <li>[20 poena]: \\(N \\leq 20\\)</li> <li>[30 poena]: Ako postoji, najkra\u0107a sekvenca operacija je du\u017eine \\(0\\) ili \\(1\\), \\(N \\leq 500\\)</li> <li>[20 poena]: \\(N \\leq 500\\)</li> <li>[20 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/drz/02_vestica/","title":"B2 - Ve\u0161tica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Denino brdo, ina\u010de najve\u0107e brdo na svetu, prepuno je ve\u0161tica. Za odr\u017eavanje javnog reda i mira na Deninom brdu zadu\u017eena je glavna i naj\u0161kolovanija ve\u0161tica An\u0111elija. Ona je upravo odbranila doktorsku disertaciju pod nazivom \"Laki lete\u0107i objekti\" na FCM-u (Fakultet za crnu magiju u Crnoj Reci).</p> <p>Tajna svake uspe\u0161ne ve\u0161tice je u neprestanoj ve\u017ebi i ponavljanju razli\u010ditih magi\u010dnih trikova. An\u0111elija je odlu\u010dila da danas ve\u017eba sa lebde\u0107im kutijama u svojoj ku\u0107i. Ona je postavila odre\u0111eni broj kutija uz zid i svaku podigla na neku visinu. Zid je visok \\(N\\) metara i \u0161irok \\(M\\) metara (formalnije, mo\u017ee se predstaviti kao matrica dimenzije \\(N \\times M\\)), dok je svaka kutija visoka \\(1\\) metar i \u0161iroka \\(1\\) metar (formalnije, mo\u017ee se predstaviti kao jedno polje u matrici koja ozna\u010dava zid). Na svakoj visini se nalazi odre\u0111eni broj kutija koje lebde i taj broj je strogo ve\u0107i od \\(0\\) za svaku visinu. Kutije na nekoj visini su pore\u0111ane jedna do druge, tako da se mogu ozna\u010diti jednim intervalom. \\([L_i, R_i]\\). Za svaku visinu \\(i\\)  su nam data dva broja \\(L_i\\), \\(R_i\\), koji ozna\u010davaju da je prva kutija na toj visini na koordinati \\((i, L_i)\\), a poslednja na koordinati \\((i, R_i)\\).</p> <p>Normalno, Denino brdo naseljavaju i skroz obi\u010dni ljudi, koji i ne slute da su oko njih ve\u0161tice. Zato An\u0111elija \u017eeli da ostane neupadljiva, a kutije koje lebde to sigurno nisu. Odlu\u010dila je da pore\u0111a kutije tako da izgleda da one stoje jedna na drugoj (grade neku figuru koja po malo li\u010di na piramidu). Za ovaj poduhvat je potrebno da interval kutija na odre\u0111enoj visini bude podinterval kutija na ni\u017eoj visni (formalnije, da va\u017ee slede\u0107i uslovi:  \\(L_{i-1} \\leq L_i\\) i \\(R_i \\leq R_{i-1}\\) za \\(2 \\leq i \\leq N\\)).</p> <p>U jednom potezu An\u0111elija mo\u017ee da pomeri sve kutije na odre\u0111enoj visini za \\(1\\) metar levo ili desno. Kutije ne mogu oti\u0107i van granica zida, odnosno da poseduju koordinatu po \u0161irini manju od \\(1\\) i ve\u0107u \\(M\\). Tako\u0111e, nije dozvoljeno menjati visine kutija. Da li mo\u017eete pomo\u0107i An\u0111eliji da odredi minimalan broj poteza da svoje kutije dovede u red. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Plav\u0161i\u0107 Slobodan Mitrovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2019_2020/drz/02_vestica/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva broja, \\(N\\) i \\(M\\), visinu i \u0161irinu zida redom.</p> <p>Svaka od narednih \\(N\\) linija sadr\u017ei po dva cela broja, \\(L_i\\) i \\(R_i\\), po\u010detak i kraj intervala kutija koje lebde na visini od \\(i\\) metara.</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati minimalan broj poteza koji An\u0111elija treba da napravi.</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/02_vestica/#ulaz","title":"Ulaz","text":"<pre><code>4 8\n1 4\n4 7\n4 5\n3 3\n</code></pre>"},{"location":"takprog/2019_2020/drz/02_vestica/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2019_2020/drz/02_vestica/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/drz/02_vestica/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3\n1 1\n2 2\n3 3\n</code></pre>"},{"location":"takprog/2019_2020/drz/02_vestica/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2019_2020/drz/02_vestica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Re\u0161enje prvog primera je predstavljeno na slici ispod.</p> <p></p> <p>U drugom primeru je optimalno pomeriti kutiju na visini \\(1\\) za jedan metar u desno, dok kutiju na visini \\(3\\) za jedan metar u levo.</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 10.000\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\leq M\\)</li> <li>Garantuje se da su primeri takvi da uvek postoji re\u0161enje.</li> </ul> <p>Test primeri su podeljeni u 5 podzadatka:</p> <ul> <li>[13 poena]: \\(N,M\\leq 5\\)</li> <li>[12 poena]: Svi intervali kutija su iste du\u017eine (\\(R_i - L_i + 1 = c\\), za \\(1\\leq i \\leq N\\), i neku celobrojnu konstantu \\(c\\))</li> <li>[33 poena]: \\(N, M \\leq 500\\)</li> <li>[23 poena]: \\(N, M \\leq 2.000\\)</li> <li>[19 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/drz/02_vestica/#analiza","title":"Analiza","text":"<p>Po\u010de\u0107emo od DP re\u0161enja za ovaj problem. Definisa\u0107emo \\(DP[row][pos]\\) na slede\u0107i na\u010din:</p> <p>\\(DP[row][pos] =\\) najmanji broj poteza koji treba napraviti tako da polica u redu \\(row\\) po\u010dinje na poziciji \\(pos\\).</p> <p>Neka \\(W_i\\) predstavlja du\u017einu \\(i\\)-tog reda, tj., \\(W_i = R_i - L_i + 1\\). Tada za \\(row &gt; 1\\) i \\(1 \\le pos \\le M - W_{row} + 1\\), \\(DP[row][pos]\\) mo\u017ee da se izra\u010duna na slede\u0107i na\u010din:</p> \\[ DP[row][pos] = |pos - L_i| + \\min_{offset = 0 \\ldots W_{row} - W_{row - 1}} DP[row - 1][pos + offset] \\] <p>Za \\(row = 1\\) imamo \\(DP[1][pos] = |pos - L_1|\\).</p> <p>Re\u0161enje problema je \\(\\min_{pos = 1 \\ldots N - W_N + 1} DP[N][pos]\\).</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#analiza-slozenosti","title":"Analiza slo\u017eenosti","text":"<p>Lako je videti da gore opisani na\u010din za ra\u010dunanje \\(DP[row][pos]\\) zahteva najvi\u0161e \\(O(N \\cdot M \\cdot M)\\) koraka -- za svako od \\(N \\cdot M\\) vrednosti \\((row, pos)\\) treba \\(W_{row} - W_{row - 1} + 1 \\le M\\) koraka. \\(N \\cdot M \\cdot M\\) koraka je presporo za ograni\u010denja u ovom zadatku.</p> <p>Jedna opcija je da izra\u010dunamo \\(\\min\\) u definiciji \\(DP[row][pos]\\) efikasnije nego da posetimo svako od \\(W_{row} - W_{row - 1} + 1\\) vrednost u \\(DP[row - 1]\\). Za to postoje bar dva na\u010dina.</p> <p>-- Na primer, ako \\(DP[row - 1]\\) \u010duvamo u segmentnom stablu onda mo\u017eemo da na\u0111emo \\(\\min\\) datog intervala u \\(O(\\log M)\\) vremenu.</p> <p>-- Ili, ra\u010dunanje \\(DP[row][pos + 1]\\) u odnosu na \\(DP[row][pos]\\) se razlikuje u tome \u0161to se ``prozor'' od \\(W_{row} - W_{row - 1} + 1\\) elemenata koji nam trebaju iz \\(DP[row - 1]\\) pomeri za \\(1\\). To zna\u010di da ako bismo primenili Metod 3 sa https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/, onda bismo mogli da izra\u010dunamo \\(DP[row][pos + 1]\\) u \\(O(1)\\) vremenu, pod pretpostavkom da ra\u010dunamo u redosledu \\(DP[row][1], DP[row][2], \\ldots, DP[row][M - W_{row} + 1]\\). Ovo bi bilo dovoljno za re\u0161enje koje radi efikasno na svim primerima.</p> <p>Druga opcija, ona koju \u0107emo mi primeniti, jeste da prvo preciznije odredimo slo\u017eenost gore navedenog pristupa, pa tek onda ako je potrebno da optimizujemo.</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#preciznija-analiza-slozenosti","title":"Preciznija analiza slo\u017eenosti","text":"<p>Da bismo izra\u010dunali \\(DP[row][pos]\\) za \\textbf{sve validne} vrednosti \\(pos\\) direktno koriste\u0107i formulu iznad treba nam \\((M - W_{row} + 1) \\cdot (W_{row} - W_{row - 1} + 2)\\) operacija -- \\((W_{row} - W_{row - 1} + 1)\\) dolazi od \\(\\min\\), a dodatna operacija od \\(|pos - L_i|\\). Kada sumiramo za sve \\(row \\ge 2\\), dobijemo</p> \\[ \\sum_{row = 2}^N (M - W_{row} + 1) \\cdot (W_{row} - W_{row - 1} + 2) \\le \\sum_{row = 2}^N (M + 1) \\cdot (W_{row} - W_{row - 1} + 2) = 2 (N - 1) (M + 1) + (M + 1) \\sum_{row = 2}^M (W_{row} - W_{row - 1}). \\] <p>Svi elementi sem \\(W_N\\) i \\(W_1\\) se zgodno skrate u poslednjoj sumi, te dobijemo</p> \\[ \\sum_{row = 2}^N (M - W_{row} + 1) \\cdot (W_{row} - W_{row - 1} + 2) \\le 2 (N - 1) (M + 1) + (M + 1) (W_N - W_1) \\le 3 (N - 1) (M + 1). \\] <p>Drugim re\u010dima, direktna implementcija gore date \\(DP\\) definicije, i verovatno najjednostavnije re\u0161enje ovog problema, je dovoljno efikasna za sve test primere.</p>"},{"location":"takprog/2019_2020/drz/02_vestica/#optimizacija-potrosnje-memorije","title":"Optimizacija potro\u0161nje memorije","text":"<p>\\(DP\\) ne mo\u017eemo deklarisati sa \\(10000 \\times 10000\\) polja jer to zauzima vi\u0161e memorije nego \u0161to je dozvoljeno. Umesto toga, dovoljno je da u memoriji \u010duvamo samo \\(DP[row]\\) i \\(DP[row - 1]\\), gde je \\(row\\) red koji se trenutno obra\u0111uje. To nam omogu\u0107ava da znatno u\u0161tedimo na memoriji.</p> 02_vestica.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 10007\nusing namespace std;\nint n,m,dp[MAXN],dpl[MAXN],l[MAXN],r[MAXN],d[MAXN];\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;n;i++) cin&gt;&gt;l[i]&gt;&gt;r[i];\n    for(int i=0;i&lt;n;i++) d[i]=r[i]-l[i];\n    fill(dpl,dpl+MAXN,1000000000);\n    for(int i=1;i+d[0]&lt;=m;i++) dpl[i]=abs(i-l[0]);\n    for(int i=1;i&lt;n;i++)\n    {\n        fill(dp,dp+MAXN,1000000000);\n        for(int j=1;j+d[i]&lt;=m;j++) for(int k=j;k&gt;=max(0,j+d[i]-d[i-1]);k--) dp[j]=min(dp[j],dpl[k]+abs(j-l[i]));\n        for(int j=1;j&lt;=m;j++) dpl[j]=dp[j];\n    }\n    int res=100000000; for(int i=0;i&lt;MAXN;i++) res=min(res,dp[i]);\n    cout&lt;&lt;res;\n}\n</code></pre>"},{"location":"takprog/2019_2020/drz/03_trookrugao/","title":"B3 - Trookrugao","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 512MB <p>Mali Programer Pera mnogo voli geometriju i kada poraste \u017eeli biti geometar. Omiljene geometrijske figure su mu trougao i krug, pa se pohvalio profesoru matematike da je smislio novi pojam: trookrugao -- trougao oko koga se mo\u017ee opisati krug. Dobio je odgovor da mu je ma\u0161ta na nivou digitrona i da se oko svakog trougla mo\u017ee opisati krug. Pera se hitro ispravio -- sada je odlu\u010dio da 'trookrugao' ozna\u010dava krug sa tri ugla. Dobio je odgovor da batali matematiku i bavi se ne\u010dim lak\u0161im, npr. programiranjem. Poslednjim atomima kreativnosti, Pera je smislio ultimativnu definiciju: Trookrugao je trougao \u010dija su sva temena u celobrojnim ta\u010dkama koordinatne ravni i \u010diji je centar opisanog kruga tako\u0111e u celobrojnoj ta\u010dki te ravni. '\u0160tagod', rekao je profesor.</p> <p>Dato je \\(N\\) razli\u010ditih ta\u010daka u ravni sa celobrojnim koordinatama kao i prirodan broj \\(R\\). Odrediti koliko trookruglova \u010diji je polupre\u010dnik opisane kru\u017enice jednak \\(R\\) odre\u0111uju ove ta\u010dke.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2019_2020/drz/03_trookrugao/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei dva prirodna broja broja \\(N\\) i \\(R\\), broj ta\u010daka i zadatu du\u017einu polupre\u010dnika. U narednih \\(N\\) redova nalaze se po dva cela broja \\(x_i\\) i \\(y_i\\), koji predstavljaju koordinate odgovaraju\u0107e ta\u010dke.</p>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati broj trookruglova polupre\u010dnika \\(R\\) koje odre\u0111uju date ta\u010dke.</p>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/03_trookrugao/#ulaz","title":"Ulaz","text":"<pre><code>7 5\n0 0\n8 0\n0 6\n-5 0\n0 -5\n-4 3\n-8 6\n</code></pre>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/drz/03_trookrugao/#ulaz_1","title":"Ulaz","text":"<pre><code>4 1\n100000 99999\n99999 99998\n99998 99999\n99999 100000\n</code></pre>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru svi trookruglovi polupre\u010dnika \\(5\\) su \\(\\{ (0,0), (8,0), (0,6) \\}\\), \\(\\{ (0,0), (0,6), (-8, 6) \\}\\) i \\(\\{ (-5,0), (0,-5), (-4,3) \\}\\). U drugom test primeru, svake tri ta\u010dke odre\u0111uju trookrugao polupre\u010dnika \\(1\\).</p>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 50.000\\)</li> <li>\\(1 \\leq R \\leq 10^5\\)</li> <li>\\(-10^5 \\leq x_i, y_i \\leq 10^5\\)</li> <li>Ne postoje dve ta\u010dke koje se poklapaju.</li> </ul> <p>Test primeri su podeljeni u 5 podzadataka:</p> <ul> <li>[16 poena]: \\(N \\leq 200\\)</li> <li>[17 poena]: \\(N \\leq 2000\\)</li> <li>[19 poena]: \\(R = 1\\)</li> <li>[21 poena]: \\(1 \\leq x_i, y_i, R \\leq 300\\)</li> <li>[27 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/drz/03_trookrugao/#analiza","title":"Analiza","text":"<p>Najjednostavnije re\u0161enje je za svake tri ta\u010dke proveriti da li formiraju trookrugao polupre\u010dnika \\(R\\) - sve \u0161to nam treba su koordinate centra opisane kru\u017enice. Ako su koordinate temena trougla \\((x_1, y_1)\\), \\((x_2, y_2)\\) i \\((x_3, y_3)\\) a koordinate centra \\((x_c, y_c)\\), tada izjedna\u010davanjem rastojanja dobijamo: \\((x_1-x_c)^2 + (y_1 - y_c)^2 = (x_2-x_c)^2 + (y_2 - y_c)^2\\) \\((x_1-x_c)^2 + (y_1 - y_c)^2 = (x_3-x_c)^2 + (y_3 - y_c)^2\\) Nakon sre\u0111ivanja se gube kvadrati uz \\(x_c\\) i \\(y_c\\) pa dobijamo samo dve linearne jedna\u010dine sa dve nepoznate. Ukoliko su re\u0161enja celobrojna i polupre\u010dnik je \\(R\\), pove\u0107amo re\u0161enje za \\(1\\). Slo\u017eenost algoritma je \\(O(N^3)\\) i re\u0161ava podzadatak 1.</p> <p>Skup \\(C\\) svih mogu\u0107ih centara opisanih kru\u017enica tra\u017eenih trookruglova mo\u017eemo dobiti tako \u0161to za svake dve ta\u010dke \\(A\\) i \\(B\\) odredimo (najvi\u0161e) 2 druge ta\u010dke koje su i od \\(A\\) i od \\(B\\) udaljene ta\u010dno \\(R\\) i, ukoliko su celobrojne, ubacimo ih u pomenuti skup. Ra\u010dun za koordinte te dve ta\u010dke je analogan kao u re\u0161enju podzadatka 1 (koristmo i \\(R\\) ovog puta) a mogu se odrediti i binarnom pretragom po simetrali du\u017ei \\(AB\\). Ukoliko se u skupu \\(C\\) neka ta\u010dka \\(T\\) javlja \\(a\\) puta, to zna\u010di da je na kru\u017enici polupre\u010dnika \\(R\\) opisanoj oko \\(T\\) ta\u010dno \\(b\\) ta\u010daka, gde je \\(a = \\frac{b(b-1)}{2}\\) jer smo svaki par brojali ta\u010dno jednom. Svake 3 od tih \\(b\\) ta\u010daka formiraju tra\u017eeni trookrugao pa re\u0161enju treba dodati \\(\\binom{b}{3}\\) za svaku ta\u010dku \\(T\\) iz \\(C\\). Brojanje pojavljivanja svake ta\u010dke je najlak\u0161e uraditi sortiranjem skupa \\(S\\); kako on sadr\u017ei \\(O(N^2)\\) mogu\u0107ih centara, slo\u017eenost algoritma je \\(O(N^2 \\log N)\\) i re\u0161ava podzadatke 1 i 2.</p> <p>Ako je \\(R = 1\\), zadatak se svodi na \"koliko jednakokrako-pravouglih trouglova sa hipotenuzom du\u017eine \\(2\\) ima me\u0111u datim ta\u010dkama?\". Ovo se mo\u017ee re\u0161iti proverom za svaku od \\(N\\) ta\u010daka da li je teme pravog ugla takvog trougla - npr. ako proveravamo da li postoji takav trougao \u010dije je teme pravog ugla \"nadole\" i u ta\u010dki \\((x, y)\\), treba ispitati da li se ta\u010dke \\((x-1, y+1)\\) i \\((x+1, y+1)\\) nalaze me\u0111u datih \\(N\\) ta\u010daka. Ukoliko na po\u010detku soritramo ta\u010dke, ovo ispitivanje mo\u017eemo odraditi u \\(O(\\log N)\\) preko binarne pretrage (mo\u017ee i preko nekih drugih struktura, npr. C++ mapa). Slo\u017eenost ovog pristupa je \\(O(N \\log N)\\) i re\u0161ava podzadatak 3.</p> <p>Ozna\u010dimo sa \\(minVal\\) i \\(maxVal\\) najmanje i najve\u0107e koordinate datih ta\u010daka. Centar opisane kru\u017enice tra\u017eenog trookrugla mo\u017ee biti samo u delu koordinatne ravni ograni\u010den sa \\([minVal - R, maxVal + R] \\times [minVal - R, maxVal + R]\\). Za svaku ta\u010dku iz ove oblasti mo\u017eemo izra\u010dunati koliko se datih ta\u010daka nalazi na rastojanju \\(R\\) od nje (ako ih ima \\(a\\), tada ima \\(\\binom{a}{3}\\) trookruglova \u010diji je centar opisanog kruga ova ta\u010dka) ispitivanjem svih \\(O(R)\\) kandidata (provera u slo\u017eenosti \\(O(1)\\) jer su koordinate male i mo\u017eemo markirati ta\u010dke u matrici). Ukupna slo\u017eenost ovog algoritma je \\(O((maxVal - minVal + 2R)^2 \\cdot R)\\) i re\u0161ava podzadatak 4. </p> <p>Ozna\u010dimo sa \\(f(R)\\) broj celobrojnih ta\u010daka koje se nalaze na kru\u017enici polupre\u010dnika \\(R\\) \u010diji je centar u nekoj celobrojnoj ta\u010dki. Npr. \\(f(1) = f(2) = f(3) = f(4) = 4\\), \\(f(5) = 12\\), itd. (primetimo da nije bitno u kojoj celobrojnoj ta\u010dki je centar). \\(f(R)\\) je zapravo broj celobrojnih re\u0161enja jedna\u010dine \\(x^2 + y^2 =R^2\\) i sva ta re\u0161enja mo\u017eemo prona\u0107i u slo\u017eenosti \\(O(R)\\) npr. isprobavanjem svih mogu\u0107nosti za \\(x\\). Ovo izra\u010dunamo na po\u010detku i ozna\u010dimo skup tih re\u0161enja sa \\(\\{(x_i,y_i), (x_2, y_2), \\ldots, (x_{f(R)}, y_{f(R)}\\}\\).  Ukoliko oko svake od \\(N\\) ta\u010daka opi\u0161emo kru\u017enicu polupre\u010dnika \\(R\\) i sve celobrojne ta\u010dke sa te kru\u017enice (za ta\u010dku \\((x,y)\\) tih \\(f(R)\\) celobrojnih ta\u010daka su \\((x+x_i, y+y_i)\\), \\(i = \\overline{1, f(R)}\\)) smestimo u jedan skup (niz) \\(C\\) (veli\u010dine \\(N \\cdot f(R)\\)), tada je \\(C\\)  skup svih potencijalnih centara tra\u017eenih trookruglova jer svaki takav centar mora biti na rastojanju \\(R\\) od bar jedne od \\(N\\) ta\u010daka. Ukoliko se \\(C\\) sastoji od \\(M\\) razli\u010ditih ta\u010daka od kojih se \\(i\\)-ta pojavljuje \\(a_i\\) puta, ukupno re\u0161enje je \\(\\binom{a_1}{3} + \\binom{a_2}{3} + \\ldots + \\binom{a_M}{3}\\). Broj ponavljanja svake ta\u010dke mo\u017eemo izra\u010dunati sortiranjem niza \\(C\\) i brojanjem uzastopnih istih elemenata. Zavisno od toga da li koristimo QuickSort ili CountingSort (prvo po \\(x\\) pa po \\(y\\)), slo\u017eenost algoritma je \\(O(N\\cdot f(R) \\cdot \\log(N\\cdot f(R)))\\) ili \\(O(N \\cdot f(R))\\).</p> <p>Klju\u010dna stvar koju treba uo\u010diti je da su vrednosti \\(f(R)\\) \"dovoljno male\" za data ograni\u010denja - ispostavlja se da je za  \\(f(R) \\leq 324\\) za svako \\(1\\leq R\\leq 10^5\\). Ovo je intuitivno (obi\u010dno nema ba\u0161 puno celobrojnih ta\u010daka na opisanim kru\u017enicama) a moglo se i lako proveriti za vreme takmi\u010denja: ukoliko takmi\u010dar (na lokalnoj ma\u0161ini) izra\u010duna \\(f(R)\\) za svako \\(R\\) do \\(10^5\\) u ukupnoj slo\u017eenosti \\(O(R^2)\\), dobi\u0107e tra\u017eeni rezultat za 2-3 minuta. Dakle, poslednji opisani algoritam zaista re\u0161ava ceo zadatak u zadatom vremenskom ograni\u010denju.</p> 03_trookrugao.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 50000;\nconst int MAX_COORD = 100000;\nconst int MAX_CIRC_POINTS = 324;\n\nstruct point\n{\n    int x, y;\n\n    point() {}\n    point(int x_, int y_)\n    {\n        x = x_; y = y_;\n    }\n};\n\nint n, R;\nint X[MAX_N + 10], Y[MAX_N + 10];\nint N;\npoint centers[MAX_N * MAX_CIRC_POINTS + 10];\npoint tmp[MAX_N * MAX_CIRC_POINTS + 10];\nint c[4 * MAX_COORD + 10];\nint RN;\npoint circlePoints[MAX_CIRC_POINTS + 10];\n\nvoid findPointsOnCircle(int R)\n{\n    RN = 0;\n    circlePoints[RN++] = point(0, R);\n    circlePoints[RN++] = point(0, -R);\n    circlePoints[RN++] = point(R, 0);\n    circlePoints[RN++] = point(-R, 0);\n\n    long long rsqr = (long long)R * (long long)R;\n    long long b = R - 1;\n    for (long long a = 1; a &lt; R; a++)\n    {\n        while (a*a + b*b &gt; rsqr)\n            b--;\n        if (a*a + b*b == rsqr)\n        {\n            circlePoints[RN++] = point((int)a, (int)b);\n            circlePoints[RN++] = point((int)a, (int)-b);\n            circlePoints[RN++] = point((int)-a, (int)b);\n            circlePoints[RN++] = point((int)-a, (int)-b);\n        }\n    }\n}\n\n\nvoid countSort(int N, point points[], bool sortByX)\n{\n    int K = 4 * MAX_COORD;\n\n    for (int i = 0; i &lt;= K; i++)\n        c[i] = 0;\n    for (int i = 0; i &lt; N; i++)\n        c[sortByX ? points[i].x : points[i].y]++;\n    for (int i = 1; i &lt;= K; i++)\n        c[i] = c[i - 1] + c[i];\n\n    for (int i = N - 1; i &gt;= 0; i--)\n    {\n        tmp[c[sortByX ? points[i].x : points[i].y] - 1] = points[i];\n        c[sortByX ? points[i].x : points[i].y]--;\n    }\n\n    for (int i = 0; i &lt; N; i++)\n        points[i] = tmp[i];\n}\n\nint main()\n{\n    scanf(\"%d%d\", &amp;n, &amp;R);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%d%d\", &amp;X[i], &amp;Y[i]);\n    }\n\n    findPointsOnCircle(R);\n\n    N = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 0; j &lt; RN; j++)\n        {\n            centers[N++] = point(2 * MAX_COORD + X[i] + circlePoints[j].x, 2 * MAX_COORD + Y[i] + circlePoints[j].y);\n        }\n    }\n\n    countSort(N, centers, false);\n    countSort(N, centers, true);\n\n    long long sol = 0;\n    int k = 1;\n    for (int i = 0; i &lt; N; i++)\n    {\n        if (i &lt; N - 1 &amp;&amp; (centers[i].x == centers[i + 1].x &amp;&amp; centers[i].y == centers[i + 1].y))\n        {\n            k++;\n        }\n        else\n        {\n            sol = sol + k * (k - 1) * (k - 2) / 6;\n            k = 1;\n        }\n    }\n\n    printf(\"%lld\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/","title":"A1 - Statistika","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Dobili ste pristup bazi podataka o rasprostranjenosti virusa u va\u0161em gradu, iz koje se mo\u017ee zaklju\u010diti puno korisnih podataka o \u0161irenju bolesti. Grad je podeljen na polja koja \u010dine matricu sa \\(N\\) redova i \\(M\\) kolona, i vrednost \\(A_{i,j}\\) u bazi predstavlja broj slu\u010dajeva virusa u polju \\((i, j)\\).</p> <p>Odlu\u010dili ste da prona\u0111ete broj najzdravijih polja, odnosno polja koja sadr\u017ee manji ili jednak broj slu\u010dajeva od svakog polja u matrici. Da bi u\u010dinili analizu zanimljivijom, palo vam je na pamet da je ponovite \\(Q\\) puta, i da svaki put odaberete neki pravougaoni deo grada koji \u0107ete ignorisati.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Ivan Sto\u0161i\u0107 <p>Mo\u017eemo podeliti grad na tri dela: deo koji ignori\u0161emo (u primeru dole obele\u017een sa <code>?</code>), gornji levi (<code>A</code>) i donji desni \"trougao\" (<code>b</code>):</p> <pre><code>AAAAAAAA\nAA???bbb\nAA???bbb\nAAbbbbbb\nAAbbbbbb\n</code></pre> <p>Za oba trougla \u0107emo izra\u010dunati par \\((m, n)\\), gde je \\(m\\) broj slu\u010dajeva u najzdravijem polju, a \\(n\\) broj takvih polja. Ako smo dobili \\((m_a, n_a)\\) za gornji levi, a \\((m_b, n_b)\\) za donji desni, ukupno re\u0161enje mo\u017eemo odrediti kao:</p> <ul> <li>\\((m_a, n_a)\\), ako \\(m_a &lt; m_b\\)</li> <li>\\((m_b, n_b)\\), ako \\(m_a &gt; m_b\\)</li> <li>\\((m_a, n_a + n_b)\\), ako \\(m_a = m_b\\)</li> </ul> <p>Gornji levi trougao mo\u017eemo posmatrati kao dva preklopljena pravougaonika sa jednim temenom u gornjem levom uglu table -- na slici, <code>A</code> i <code>a</code> (preklapanje obele\u017eeno sa <code>@</code>):</p> <pre><code>@@aaaaaa\nAA???...\nAA???...\nAA......\nAA......\n</code></pre> <p>Kao i ranije, mo\u017eemo odrediti broj slu\u010dajeva u najzdravijem polju i broj takvih polja u trouglu \"sabiranjem\" ovih re\u0161enja za dva pravougaonika. U dobijenom rezultatu \u0107e polja obele\u017eena sa <code>@</code> biti ura\u010dunata dva puta i moramo eliminsati jedno od pojavljivanja -- neka je \\((m,n)\\) \"zbir\" pravougaonika \\(A\\) i \\(a\\), a \\((m', n')\\) obuhvata samo <code>@</code>. Tada je ukupno re\u0161enje za trougao:</p> <ul> <li>\\((m, n-n')\\), ako \\(m = m'\\) (neka od najzdravijih polja jesu u <code>@</code>)</li> <li>\\((m, n)\\), ako \\(m \\neq m'\\) (nijedno od tih polja nije u <code>@</code>, tako da   ni\u0161ta nismo brojali dva puta).</li> </ul> <p>Sada je samo potrebno da pre upita odredimo ove parove za svaki pravougaonik sa temenom u gornjem levom uglu matrice. Ovo mo\u017eemo uraditi u \\(\\mathcal{O}(N^2)\\): svaki pravougaonik mo\u017eemo posmatrati kao uniju donjeg desnog polja i \"trougla\", vrednost za trougao odrediti kao \u0161to je gore opisano (iz prethodno izra\u010dunatih vrednosti za manje pravougaonike) i dodati joj donje desno polje.</p> <p>Isti postupak \u0107emo koristiti za donji desni \"trougao\", gde unapred odre\u0111ujemo re\u0161enja za pravougaonike sa temenom u donjem desnom uglu. Ukupna slo\u017eenost je \\(\\mathcal{O}(N^2)\\) za izra\u010dunavanje ovih vrednosti, i \\(\\mathcal{O}(1)\\) po upitu, odnosno \\(\\mathcal{O}(N^2 + Q)\\) za ceo zadatak.</p> 04_statistika.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cassert&gt;\n\nstruct entry { int min, count; } ;\nconst entry ZERO = {1&lt;&lt;30, 0};\nbool operator==(const entry a, const entry b) { return a.min == b.min &amp;&amp; a.count == b.count; }\nentry operator+(const entry a, const entry b)\n{\n    if(a.min &lt; b.min) return a;\n    else if(a.min &gt; b.min) return b;\n    else return {a.min, a.count + b.count};\n}\nentry operator-(const entry a, const entry b)\n{\n    // only called if a has double-counted entries in b, so this\n    // should hold\n    assert(a.min != b.min || (a == ZERO &amp;&amp; b == ZERO) || a.count &gt; b.count);\n    return {a.min, a.min == b.min ? (a.count - b.count) : a.count};\n}\nconst int N = 1000;\nint city[N][N];\nentry sum_up[N][N], sum_down[N][N];\nint n, m;\n\ninline entry get_up(int i, int j)\n{\n    assert(i &lt; n &amp;&amp; j &lt; m);\n    return i &gt;= 0 &amp;&amp; j &gt;= 0 ? sum_up[i][j] : ZERO;\n}\ninline entry get_down(int i, int j)\n{\n    assert(i &gt;= 0 &amp;&amp; j &gt;= 0);\n    return i &lt; n &amp;&amp; j &lt; m ? sum_down[i][j] : ZERO;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q);\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; m; j++)\n            scanf(\"%d\", &amp;city[i][j]);\n\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; m; j++)\n            sum_up[i][j] = (entry){city[i][j], 1} + get_up(i-1, j) + get_up(i, j-1) - get_up(i-1, j-1);\n\n    for(int i = n - 1; i &gt;= 0; i--)\n        for(int j = m - 1; j &gt;= 0; j--)\n            sum_down[i][j] = (entry){city[i][j], 1} + get_down(i+1, j) + get_down(i, j+1) - get_down(i+1, j+1);\n\n    while(q--)\n    {\n        int i, j, h, w;\n        scanf(\"%d %d %d %d\", &amp;i, &amp;j, &amp;h, &amp;w);\n        i--; j--;  // 0-indexing\n        int ii = i + h - 1, jj = j + w - 1;  // bottom-right\n        entry topleft = get_up(n-1, j-1) + get_up(i-1, m-1) - get_up(i-1, j-1);\n        entry botright = get_down(i, jj+1) + get_down(ii+1, j) - get_down(ii+1, jj+1);\n        entry res = topleft + botright;\n        printf(\"%d\\n\", res.count);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei tri prirodna broja: broj redova i kolona u gradu \\(N\\) i \\(M\\), kao i broj upita \\(Q\\).</p> <p>Narednih \\(N\\) linija sadr\u017ee po \\(M\\) brojeva \\(A_{i,j}\\) koji \u010dine matricu brojeva slu\u010dajeva virusa.</p> <p>Narednih \\(Q\\) linija sadr\u017ee po \u010detiri broja \\(i\\), \\(j\\), \\(h\\) i \\(w\\), koji opisuju deo grada koji treba ignorisati kada tra\u017eite najzdravija polja u tom upitu: gornje levo polje je u \\(i\\)-toj vrsti i \\(j\\)-toj koloni (gde \\((1,1)\\) odgovara gornjem levom uglu grada), \\(h\\) je visina dela (broj vrsta) a \\(w\\) \u0161irina (broj kolona).</p>"},{"location":"takprog/2019_2020/drz/04_statistika/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(Q\\) linija sa po jednim prirodnim brojem, gde \\(i\\)-ta linija sadr\u017ei broj najzdravijih polja u gradu bez dela opisanog u \\(i\\)-tom upitu.</p>"},{"location":"takprog/2019_2020/drz/04_statistika/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/04_statistika/#ulaz","title":"Ulaz","text":"<pre><code>3 3 3\n1 2 3\n1 1 2\n3 3 3\n1 1 1 1\n1 1 2 2\n2 2 1 1\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/#izlaz","title":"Izlaz","text":"<pre><code>2\n1\n2\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/drz/04_statistika/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3 1\n1 2 3\n2 1 3\n1 9 1\n2 2 1 1\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2019_2020/drz/04_statistika/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, u prvom upitu posmatramo ceo grad osim gornjeg levog polja. Najzdravija polja su u ovom slu\u010daju ona koja imaju samo jedan slu\u010daj, i takvih ima dva (osim ignorisanog). U drugom upitu posmatramo samo kranju desnu kolonu i poslednji red, gde je najzdravije jedino polje sa dva slu\u010daja. U poslednjem upitu ignori\u0161emo centralno polje, i ostaju dva sa po jednim slu\u010dajem.</p>"},{"location":"takprog/2019_2020/drz/04_statistika/#napomene","title":"Napomene","text":"<p>Zbog velikog ulaza, nije preporu\u010dljivo koristiti sporije metode u\u010ditavanja podataka, kao \u0161to su cin/cout bez sinhronizacije u C++-u.</p>"},{"location":"takprog/2019_2020/drz/04_statistika/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N, M \\leq 1000\\)</li> <li>\\(Q \\leq 10^5\\)</li> <li>\\(0 \\leq A_{i,j} \\leq 10^9\\) za sve \\(1 \\leq i \\leq N, 1 \\leq j \\leq M\\)</li> <li>Ni u jednom upitu ne\u0107e biti ignorisan ceo grad.</li> </ul> <p>Test primeri su podeljeni u pet podzadataka:</p> <ul> <li>[20 poena]: \\(N, M, Q \\leq 100\\)</li> <li>[15 poena]: \\(N, M \\leq 300, Q \\leq 2 \\cdot 10^4\\)</li> <li>[15 poena]: \\(A_{i,j} \\in \\{0, 1\\}\\) za sve \\(1 \\leq i \\leq N, 1 \\leq j \\leq M\\)</li> <li>[20 poena]: \\(h, w \\leq 10\\) za sve zadate podmatrice.</li> <li>[30 poena]: bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/drz/05_spec/","title":"A2 - Spec zadatak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Spec (skra\u0107eno od specifi\u010dna) vrednost niza se ra\u010duna kao proizvod svih elemenata niza podeljen sa brojem elemenata tog niza. Npr. spec vrednost niza \\([5, 9, 7]\\) je \\(\\frac{5 \\cdot 9 \\cdot 7}{3} = 105\\).</p> <p>Spec X-0-1-transformacija niza transformi\u0161e niz tako \u0161to svaki element koji nije \\(0\\) ili \\(X\\) postaje \\(1\\). Npr. spec 3-0-1-transformacija niza \\([4, 3, 2, 0, 3, 1, 0, 5]\\) \u0107e transformisati ovaj niz u: \\([1, 3, 1, 0, 3, 1, 0, 1]\\).</p> <p>Spec L-R-odsecanje niza se radi tako \u0161to iz niza izbri\u0161emo sve elemente \u010diji je indeks manji od \\(L\\) ili ve\u0107i od \\(R\\) (ra\u010dunamo da indeksiranje po\u010dinje od \\(0\\), i \\(L \\leq R\\)). Npr. nakon spec 2-5-odsecanja niza \\([3, 6, 2, 5, 3, 10, 0, 4]\\) \u0107e ostati niz \\([2, 5, 3, 10]\\).</p> <p>Dat vam je niz \\(A\\) koji se sastoji od \\(N\\) celih brojeva. Potrebno je odgovoriti na \\(Q\\) upita, gde se svaki upit sastoji od jednog broja \\(Q_i\\). Za svaki upit je potrebno prona\u0107i brojeve \\(L\\) i \\(R\\) za koje je spec vrednost niza najve\u0107a mogu\u0107a nakon \u0161to se nad po\u010detnim datim nizom uradi spec \\(Q_i\\)-0-1-transformacija i spec L-R-odsecanje. Ukoliko postoji vi\u0161e mogu\u0107ih re\u0161enja, izabrati ono gde je \\(L\\) najmanje, ukoliko i dalje postoji vi\u0161e re\u0161enja izabrati ono gde je \\(R\\) najmanje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Slobodan Mitrovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2019_2020/drz/05_spec/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija ulaza sadr\u017ei dva broja, broj elemenata niza \\(N\\), i broj upita \\(Q\\). Druga linija ulaza sadr\u017ei niz \\(A\\) od \\(N\\) brojeva. U narednih \\(Q\\) linija ulaza se nalazi po jedan broj \\(Q_i\\).</p>"},{"location":"takprog/2019_2020/drz/05_spec/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(Q\\) linija, tako da u \\(i\\)-toj liniji budu ispisana dva broja, \\(L\\) i \\(R\\), odvojena razmakom, koji su odgovor na upit \\(Q_i\\).</p>"},{"location":"takprog/2019_2020/drz/05_spec/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/05_spec/#ulaz","title":"Ulaz","text":"<pre><code>16 7\n4 1 4 5 2 2 3 3 2 3 5 0 5 4 4 2\n5\n3\n2\n1\n4\n6\n3\n</code></pre>"},{"location":"takprog/2019_2020/drz/05_spec/#izlaz","title":"Izlaz","text":"<pre><code>3 3\n6 9\n4 4\n0 0\n13 14\n0 0\n6 9\n</code></pre>"},{"location":"takprog/2019_2020/drz/05_spec/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ukoliko posmatramo peti upit, gde je \\(Q_i = 4\\), nakon spec 4-0-1-transformacije niz \u0107e nam biti \\([4,1,4,1,1,1,1,1,1,1,1,0,1,4,4,1]\\), pa je najbolje odraditi spec 13-14 odsecanje kako bi nam ostao niz \\([4,4]\\) \u010dija je spec vrednost \\(8\\) \u0161to je najve\u0107e mogu\u0107e. Ukoliko posmatramo tre\u0107i upit, gde je \\(Q_i = 2\\), nakon spec 2-0-1-transformacije niz \u0107e nam biti \\([1,1,1,1,2,2,1,1,2,1,1,0,1,1,1,2]\\). Najve\u0107u spec vrednost koju mo\u017eemo dobiti nakon odsecanja je 2 \u0161to se mo\u017ee dobiti sa vi\u0161e razli\u010ditih odsecanja (npr. za \\(L=15\\), \\(R=15\\) ili \\(L=4\\),\\(R=5\\) ili \\(L=4\\),\\(R=4\\)), ali po uslovima zadatka treba ispisati \\(L=4\\) i \\(R=4\\). U \u010detvrtom i \u0161estom upitu, gde je \\(Q_i = 1\\) i \\(Q_i = 6\\), nakon spec transformacije niz \u0107e biti \\([1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1]\\).</p>"},{"location":"takprog/2019_2020/drz/05_spec/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 300.000\\)</li> <li>\\(0 \\leq A_i, Q_i \\leq 1.000.000\\)</li> </ul> <p>Test primeri su podeljeni u 5 podzadatka:</p> <ul> <li>[11 poena]: \\(A_i \\in \\{0, 1, 10^6\\}\\), odnosno niz se sastoji samo od elemenata \\(0\\), \\(1\\) i \\(10^6\\)</li> <li>[12 poena]: \\(N,Q \\leq 200\\)</li> <li>[20 poena]: \\(N,Q \\leq 1000\\)</li> <li>[22 poena]: \\(A_i &gt; 0\\), odnosno nema broja \\(0\\) u nizu</li> <li>[35 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/drz/05_spec/#analiza","title":"Analiza","text":"<p>Najpre, primetimo da je spec vrednost podniza nula (\u0161to je i najmanja mogu\u0107a) ako taj podniz sadr\u017ei nulu. Ovo tako\u0111e va\u017ei bez obzira koju transformaciju primenimo na niz. Tako da \u0107emo ulazni niz podeliti na maksimalne podnizove koji ne sadr\u017ee \\(0\\). Svaki takav podniz \u0107emo zvati ne-nula.</p> <p>Neka je \\(A'\\) jedan ne-nula podniz. Prvo \u0107emo za svako \\(X\\) koje postoji u \\(A'\\) napraviti niz \\(A_X = (i_1, i_2, \\ldots, i_{n_X})\\), gde je \\(i_k\\) indeks \\(k\\)-tog pojavljivanja broja \\(X\\) u \\(A'\\), a \\(n_X\\) je broj pojavljivanja \\(X\\) u \\(A'\\). Ove nizove \u0107emo \u010duvati u C++ map strukturi ili sortirane po \\(X\\) tako da za dato \\(X\\) odgovaraju\u0107i niz mo\u017eemo na\u0107i u \\(O(\\log N)\\) vremenu, npr, binarnom pretragom ako nizove \u010duvamo sortirane po \\(X\\). Na isti na\u010din \u0107emo obraditi sve ne-nula podnizove. Dakle, C++ map struktura \u0107e za dato \\(X\\) \u010duvati vi\u0161e razli\u010ditih \\(A_X\\), najvi\u0161e jedno \\(A_X\\) za dati ne-nula podniz.</p>"},{"location":"takprog/2019_2020/drz/05_spec/#resenje-za-dato-a_x","title":"Re\u0161enje za dato \\(A_X\\)","text":"<p>Najpre, ako je \\(X = 1\\) ili ako \\(X\\) ne postoji u ulaznom nizu, tada je re\u0161enje trivijalno -- trebalo bi ispisati ``najlevlji'' podniz du\u017eine \\(1\\) koji sadr\u017ei ne-nula vrednost. Dakle, pretpostavimo da \\(X \\ge 2\\) i neka je \\(B_X\\) neki podniz za \\(X\\) sa najve\u0107om spec vredno\u0161\u0107u. Neka \\(K\\) ozna\u010dava broj pojavljivanja \\(X\\), a \\(P\\) du\u017einu odgovaraju\u0107eg podniza. Lako je zapaziti da spec vrednost podniza raste vrlo brzo, tj., eksponencijalno, sa pove\u0107anjem \\(K\\) dok raste linearno sa pove\u0107anjem \\(P\\). Vrlo korisna posledica ovog zapa\u017eanja je da \\(B_X\\) mo\u017ee da izostavi najvi\u0161e \\(\\lfloor \\log_X N \\rfloor\\) pojavljivanja broja \\(X\\) -- u suprotnom bi ceo odgovaraju\u0107i ne-nula podniz \\(A'\\) imao strogo ve\u0107u spec vrednost nego \\(B_X\\).</p> <p>Ova zapa\u017eanja sada lako vode do re\u0161enja: za dato \\(X\\) posmatrajmo sve podnizove od \\(A_X\\) od indeksa \\(L\\) do indeksa \\(R\\) (indeksi kre\u0107u od \\(1\\)) tako da \\(L \\le R\\) i \\((L - 1) + (|A_X| - R) \\le \\lfloor \\log_X N \\rfloor\\); najbolji od tih podnizova je re\u0161enje za \\(A_X\\). Za dato \\(X\\), ima najvi\u0161e \\((\\lfloor \\log_X N \\rfloor + 1) \\cdot (2 + \\lfloor \\log_X N \\rfloor) / 2\\) takvih indeksa \\(L\\) i \\(R\\).</p>"},{"location":"takprog/2019_2020/drz/05_spec/#resenje-za-dato-x-meu-svim-ne-nula-podnizovima","title":"Re\u0161enje za dato \\(X\\) me\u0111u svim ne-nula podnizovima","text":"<p>Za svako \\(A_X\\) \u0107emo na\u0107i njegov najbolji podniz \\(R_X\\), gde iteriramo po \\(A_X\\) iz svakog ne-nula podniza. Me\u0111u svim \\(R_X\\) \u0107emo ispisati onaj koji imaj najve\u0107u spec vrednost; detalji kako da na\u0111emo takav podniz su dati u nastavku.</p>"},{"location":"takprog/2019_2020/drz/05_spec/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Za kona\u010dan algoritam su potrebna jo\u0161 dva detalja.</p> <p>Prvo, kad jednom izra\u010dunamo re\u0161enje za \\(X = Q_i\\), zapamti\u0107emo ovo re\u0161enje, na primer, u nizu veli\u010dine \\(1.000.000\\). Clede\u0107i put ako dobijemo upit \\(X = Q_j\\) mo\u017eemo da vratimo re\u0161enje iz tog niza.</p> <p>Drugo, tokom obrade upita za dato \\(X\\), iterira\u0107emo me\u0111u podnizovima od \\(A_X\\) (kao \u0161to je opisano iznad), i za svaki podniz ispisati par \\((c, P)\\). U ovom slu\u010daju \\(c\\) predstavlja broj pojavljivanja \\(X\\) u datom podnizu od \\(A_X\\), a \\(P\\) predstavlja du\u017einu tog podniza. Pretpostavimo da \\(c_1 \\ge c_2\\) (suprotan slu\u010daj se analogno re\u0161ava). Podniz sa \\((c_1, P_1)\\) ima ve\u0107u spec vrednost od podniza sa \\((c_2, P_2)\\) akko \\(X^{c_1} / P_1 &gt; X^{c_2} / P_2\\), \u0161to povla\u010di \\(X^{c_1 - c_2} \\cdot P_2 &gt; P_1\\). Po konstrukciji imamo \\(c_1 - c_2 \\le \\lfloor \\log_X N \\rfloor\\), \u0161to povla\u010di da \\(X^{c_1 - c_2} \\cdot P_2\\) staje u tip long long.</p> <p>Koriste\u0107i istu ideju za dato \\(X\\) mo\u017eemo na\u0107i najbolji podniz me\u0111u svim ne-nula podnizovima. Kada imamo vi\u0161e podnizova sa istom spec vredno\u0161\u0107u, onda biramo onaj koji je ``levlji'', kao \u0161to je to opisano u postavci zadatka. Ovaj deo re\u0161enja se jednostavno implementira.</p>"},{"location":"takprog/2019_2020/drz/05_spec/#procena-slozenosti","title":"Procena slo\u017eenosti","text":"<p>Za dato \\(X\\) obrada upita zahteva vreme \\((\\lfloor \\log_X N \\rfloor + 1) \\cdot (2 + \\lfloor \\log_X N \\rfloor) / 2\\) pomno\u017eeno sa brojem ne-nula podnizova koji sadr\u017ee \\(X\\) (zapravo, slo\u017eenost je potencijalno manja jer nije obavezno da svi podnizovi sadr\u017ee bar \\(\\lfloor \\log_X N \\rfloor\\) pojavljivanja broja \\(X\\)). Imamo \\((\\lfloor \\log_X N \\rfloor + 1) \\cdot (2 + \\lfloor \\log_X N \\rfloor) / 2 \\le 210\\), gde se maksimum dosti\u017ee za \\(X = 2\\). Za \\(X &gt; 1000\\) imamo \\(\\lfloor \\log_X N \\rfloor \\le 1\\), \u0161to povla\u010di da je \\((\\lfloor \\log_X N \\rfloor + 1) \\cdot (2 + \\lfloor \\log_X N \\rfloor) / 2 \\le 3\\) za ve\u0107inu vrednosti koja se mo\u017ee na\u0107i na ulazu.</p> <p>Broj svih nepraznih podnizova \\(A_X\\), za sve vrednosti \\(X\\), je najvi\u0161e \\(N\\). To nam sada daje kona\u010dnu slo\u017eenost od \\(210 \\cdot N\\) koja je dovoljno mala za vremensko ograni\u010denje. Kao \u0161to je navedeno, razmatranjem nekoliko slu\u010dajeva se mo\u017ee pokazati da se ova slo\u017eenost nikad ne dosti\u017ee nego da je bar nekoliko puta manja.</p> 05_spec.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 333555\n#define MAXQ 333555\n#define MAXA 1000333\n\nint n,q;\nlong long nll;\nint a[MAXN];\nint resl[MAXA],resr[MAXA];\n\nvector&lt; vector&lt;int&gt; &gt; positions[MAXA];\n\nlong long powll(long long x, long long st) {\n    long long r = 1;\n    for(int i=0; i&lt;st; i++) {\n        r *= x;\n    }\n\n    return r;\n}\n\nbool boljires(int bestK, int bestD, int tk, int td, int x, int stp) {\n\n    if (bestK == -1 || tk &gt; bestK+stp) {\n        return true;\n    }\n\n    if (bestK == tk) {\n        if (td &lt; bestD) return true;\n    }\n\n    if (tk &gt; bestK) {\n        if (powll((long long)x, tk-bestK) * (long long)bestD &gt; (long long)td) {\n            return true;\n        }\n    }\n\n    if (td &lt; bestD) {\n\n        if (bestK - tk &gt; stp) return false;\n\n        if ((long long)bestD &gt; (long long)td * powll((long long)x, bestK-tk)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n\n    scanf(\"%d%d\", &amp;n, &amp;q);\n    nll = n;\n\n    int last0 = -1;\n    int firstNon0 = -1;\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%d\", &amp;a[i]);\n\n        if (a[i] == 0) {\n            last0 = i;\n            continue;\n        }\n\n        if (firstNon0 == -1) firstNon0 = i;\n\n        if (a[i] &gt; 1) {\n            if (positions[a[i]].empty() || last0 &gt; positions[a[i]].back().back()) {\n                vector&lt;int&gt; vec;\n                vec.push_back(i);\n                positions[a[i]].push_back(vec);\n            } else {\n                positions[a[i]].back().push_back(i);\n            }\n        }\n\n    }\n    if (firstNon0 == -1) firstNon0 = 0;\n\n    for(int i=0; i&lt;q; i++) {\n\n        int x;\n        scanf(\"%d\", &amp;x);\n\n        if (resl[x] == 0) {\n\n            if (positions[x].empty()) {\n                resl[x] = firstNon0;\n                resr[x] = firstNon0;\n            } else {\n\n                int bestK = -1;\n                int bestD = -1;\n\n                int stp = 2;\n                long long t = x;\n                while(t &lt; nll) {\n                    t*=x;\n                    stp++;\n                }\n\n                for(int j=0; j&lt;positions[x].size(); j++) {\n\n                    int cnt = positions[x][j].size();\n                    for(int pl = 0; pl&lt;cnt; pl++) {\n                        for(int pr = max(pl,cnt-stp+pl); pr&lt;cnt; pr++) {\n\n                            int posl = positions[x][j][pl];\n                            int posr = positions[x][j][pr];\n\n                            int tk = pr-pl + 1;\n                            int td = posr-posl + 1;\n\n                            if (boljires(bestK,bestD,tk,td,x,stp)) {\n                                bestK = tk;\n                                bestD = td;\n\n                                resl[x] = posl;\n                                resr[x] = posr;\n                            }\n                        }\n                    }\n\n                }\n            }\n\n            resl[x]++;\n            resr[x]++;\n        }\n\n        printf(\"%d %d\\n\", resl[x]-1, resr[x]-1);\n    }\n\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/drz/06_festival/","title":"A3 - Festival","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 256MB <p>Kao \u0161to znate, usled trenutne svetske epidemiolo\u0161ke situacije, mnogobrojni festivali \u0161irom sveta su otkazani. Me\u0111utim, postoji jedan festival, koji se odr\u017eava svake godine u blizini jednog vama vrlo poznatog gradi\u0107a u Rusiji, koji je odlu\u010dio da se uprkos svemu ipak odr\u017ei. Kako nemate mnogo izbora koji festival da posetite ovog leta, odlu\u010dili ste da i vi postanete ove godine u\u010desnik svetski poznatog Festivala intervala.</p> <p>Na ovom festivalu svaka atrakcija je predstavljena jednim intervalom na brojevnoj pravi. Zbog neke bizarne geometrije koja se javlja u opskurnim delovima Rusije, znamo da su dve atrakcije susedne ako i samo ako je interval koji odgovara jednoj od te dve atrakcije podinterval intervala koji odgovara drugoj od njih. Podse\u0107amo vas da je interval \\([a,b]\\) podinterval intervala \\([c,d]\\) ako \\(c\\leq a\\leq b\\leq d\\).</p> <p>Vi ne znate ta\u010dno kako \u0107ete se kretati po festivalu, pa vas za date atrakcije \\(u\\) i \\(v\\) interesuje najkra\u0107i put od atrakcije \\(u\\) do atrakcije \\(v\\), to jest, koliko puta morate da putujete izme\u0111u susednih atrakcija da biste stigli od atrakcije \\(u\\) do atrakcije \\(v\\). Veoma ste uzbu\u0111eni povodom va\u0161eg provoda na festivalu, pa \u017eelite da saznate odgovor na prethodno pitanje za \u010dak \\(Q\\) razli\u010ditih parova atrakcija \\((u,v)\\)!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Lazar Milenkovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2019_2020/drz/06_festival/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva broja, broj intervala \\(N\\), i broj upita \\(Q\\). Druga linija standardnog ulaza sadr\u017ei niz \\(A_i\\) od \\(2\\cdot N\\) brojeva, po \\(2\\) pojavljivanja svakog broja iz skupa \\(\\{1,2,\\ldots,N\\}\\), tako da indeks prvog pojavljivanja broja \\(i\\) u tom nizu predstavlja po\u010detak intervala \\(i\\), dok indeks drugog pojavljivanja broja \\(i\\) u tom nizu predstavlja kraj intervala \\(i\\). U narednih \\(Q\\) linija standardnog ulaza nalaze se po dva prirodna broja \\(u_i,v_i\\): indeksi atrakcija izme\u0111u kojih tra\u017eimo du\u017einu najkra\u0107eg puta.</p>"},{"location":"takprog/2019_2020/drz/06_festival/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispi\u0161ite \\(Q\\) linija: u \\(i\\)-toj liniji treba da pi\u0161e odgovor na \\(i\\)-ti upit.</p>"},{"location":"takprog/2019_2020/drz/06_festival/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/drz/06_festival/#ulaz","title":"Ulaz","text":"<pre><code>3 2\n3 1 2 1 2 3\n2 3\n1 2\n</code></pre>"},{"location":"takprog/2019_2020/drz/06_festival/#izlaz","title":"Izlaz","text":"<pre><code>1\n2\n</code></pre>"},{"location":"takprog/2019_2020/drz/06_festival/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Od \\(2\\) do \\(3\\) mo\u017eemo da stignemo direktno, jer je interval koji odgovara atrakciji \\(2\\) podinterval intervala koji odgovara atrakciji \\(3\\). Atrakcije \\(1\\) i \\(2\\) nisu susedne, pa je najkra\u0107i put me\u0111u njima \\(1-3-2\\).  </p>"},{"location":"takprog/2019_2020/drz/06_festival/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 300.000\\)</li> <li>\\(1 \\leq A_i \\leq N\\)</li> <li>Svaka vrednost od \\(1\\) do \\(N\\) se pojavljuje ta\u010dno \\(2\\) puta u nizu \\(A_i\\).</li> <li>\\(1 \\leq u_i,v_i \\leq N\\)</li> <li>\\(u_i \\neq v_i\\)</li> </ul> <p>Test primeri su podeljeni u 4 podzadatka:</p> <ul> <li>[18 poena]: \\(N,Q\\leq500\\)</li> <li>[26 poena]: \\(N,Q\\leq3000\\)</li> <li>[16 poena]: Svaka dva intervala su ili disjunktna, ili je jedan podinterval drugog</li> <li>[40 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/drz/06_festival/#analiza","title":"Analiza","text":"<p>Na po\u010detku je potrebno proveriti da li je jedan interval podinterval drugog i u tom slu\u010daju re\u0161enje je 1. Ukoliko su u pitanju dva ista intervala, tada je re\u0161enje 0. Nakon \u0161to smo razre\u0161ili dva specijalna slu\u010daja, mo\u017eemo se upustiti u generalniju diskusiju.</p> <p>Nakon toga, pretpostavimo bez gubitka op\u0161tosti da tra\u017eimo najkra\u0107i put od intervala \u010diji je po\u010detak levo u odnosu na po\u010detak drugog intervala. Najbitnija stvar koju je potrebno primetiti ovde jeste da je uvek dovoljno da se kre\u0107emo (u desno) ka podintervalu \u010diji je po\u010detak najudaljeniji ili ka nadintervalu \u010diji je kraj najudaljeniji. Ako smo u prvom koraku krenuli ka podintervalu, tada u narednom koraku idemo ka nadintervalu. Ovaj proces se nastavlja sve dok ne stignemo do tra\u017eenog intervala ili ne mo\u017eemo u\u010diniti naredni korak. Podsti\u010demo takmi\u010dare da doka\u017eu korektnost ovog pristupa.</p>"},{"location":"takprog/2019_2020/drz/06_festival/#resenje-u-on-cdot-q","title":"Re\u0161enje u \\(O(N \\cdot Q)\\)","text":"<p>Gore opisano kretanje po intervalima mo\u017eemo implementirati u linearnoj slo\u017eenosti, tako da za svaki od \\(Q\\) upita imamo najvi\u0161e \\(N\\) koraka.</p>"},{"location":"takprog/2019_2020/drz/06_festival/#resenje-za-sve-poene","title":"Re\u0161enje za sve poene","text":"<p>U ovom slu\u010daju, kretanje po intervalima je potrebno implementirati u logaritamskoj slo\u017eenosti, koriste\u0107i takozvani \"binary lifting\". Naime, za svaki interval \u010duvamo intervale koji se nalaze na rastojanju \\(2^0, 2^1, 2^2,... 2^{\\lfloor \\log_2 N \\rfloor}\\).</p>"},{"location":"takprog/2019_2020/drz/06_festival/#resenje-u-on3","title":"Re\u0161enje u \\(O(N^3)\\)","text":"<p>U ovom slu\u010daju eksplicitno konstrui\u0161emo graf gde su \u010dvorovi intervali a ivice postoje izme\u0111u susednih intervala. Nakon toga, mo\u017eemo odrediti sve parove najkra\u0107ih puteva koriste\u0107i BFS ili Flojdov algoritam. Po\u0161to imamo \\(N\\) \u010dvorova i \\(O(N^2)\\) ivica, slo\u017eenost ovog pristupa je \\(O(N^3)\\), \u0161to je dovoljno za slu\u010daj kada je \\(N \\leq 500\\).</p>"},{"location":"takprog/2019_2020/drz/06_festival/#resenje-za-slucaj-kada-su-intervali-ili-disjunktni-ili-je-jedan-podinterval-drugog","title":"Re\u0161enje za slu\u010daj kada su intervali ili disjunktni ili je jedan podinterval drugog","text":"<p>U ovom slu\u010daju nije te\u0161ko videti da je re\u0161enje uvek -1, 0, 1 ili 2 (za\u0161to?). Po\u0161to smo razre\u0161ili slu\u010dajeve kada je re\u0161enje 0 ili 1, potrebno je proveriti da li je re\u0161enje -1 ili 2. Za svaki interval, \u010duvamo naj\u0161iri interval koji ga sadr\u017ei. Ukoliko se naj\u0161iri interval koji sadr\u017ei po\u010detni poklapa sa naj\u0161irim intervalom koji sadr\u017ei krajnji, tada je re\u0161enje 2. U suprotnom je re\u0161enje -1.</p> 06_festival.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 300007\n#define MAXL 20\nusing namespace std;\nint a[2*MAXN],nxt[MAXL][MAXN],rs[MAXN],rf[MAXN],l[MAXN],r[MAXN],p[2*MAXN];\nbool check(int u, int v)\n{\n    return (l[u]&lt;l[v] &amp;&amp; r[v]&lt;r[u]) || (l[v]&lt;l[u] &amp;&amp; r[u]&lt;r[v]);\n}\nbool left(int u,int v)\n{\n    if(check(u,v)) return false;\n    return l[u]&lt;l[v];\n}\nint dist(int u,int v)\n{\n    if(u==v) return 0;\n    if(check(u,v)) return 1;\n    int w=u,d=1;\n    for(int i=MAXL-1;i&gt;=0;i--) if(left(nxt[i][w],v)) {w=nxt[i][w]; d+=(1&lt;&lt;i);}\n    return d+1;\n}\nint main()\n{\n    int n,q;\n    scanf(\"%d%d\",&amp;n,&amp;q);\n    for(int i=1;i&lt;=2*n;i++) scanf(\"%d\",&amp;a[i]);\n    for(int i=1;i&lt;=2*n;i++)\n    {\n        if(!l[a[i]]) l[a[i]]=i;\n        else r[a[i]]=i;\n    }\n    for(int i=1;i&lt;=n;i++) {p[l[i]]=r[i]; p[r[i]]=l[i];}\n    int mxr=0,nd=0;\n    for(int i=1;i&lt;=2*n;i++) if(p[i]&gt;i)\n    {\n        if(p[i]&lt;mxr) rf[a[i]]=nd;\n        else {rf[a[i]]=-1; mxr=p[i]; nd=a[i];}\n    }\n    int mxl=0; nd=0;\n    for(int i=1;i&lt;=2*n;i++) if(p[i]&lt;i)\n    {\n        if(p[i]&lt;mxl) rs[a[i]]=nd;\n        else {rs[a[i]]=-1; mxl=p[i]; nd=a[i];}\n    }\n    for(int i=1;i&lt;=n;i++)\n    {\n        if(rs[i]==-1) nxt[0][i]=(rf[i]==-1)?i:rf[i];\n        if(rf[i]==-1) nxt[0][i]=(rs[i]==-1)?i:rs[i];\n    }\n    for(int i=1;i&lt;MAXL;i++) for(int j=1;j&lt;=n;j++) nxt[i][j]=nxt[i-1][nxt[i-1][j]];\n    for(int i=1;i&lt;=q;i++)\n    {\n        int u,v; scanf(\"%d%d\",&amp;u,&amp;v);\n        if(u==v) {printf(\"0\\n\"); continue;}\n        if(check(u,v)) {printf(\"1\\n\"); continue;}\n        if(left(v,u)) swap(u,v);\n        int ws=u,wf=u,ds=0,df=0;\n        if(rs[u]!=-1) {ws=rs[u]; ds++;}\n        if(rf[u]!=-1) {wf=rf[u]; df++;}\n        int w=nxt[MAXL-1][ws];\n        if(left(w,v)) {printf(\"-1\\n\"); continue;}\n        int res1=dist(ws,v)+ds,res2=dist(wf,v)+df;\n        printf(\"%d\\n\",min(res1,res2));\n    }\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv1/01_isplata/","title":"1 - Isplata","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 64MB <p>Spremaju\u0107i se za put u Egipat, Milo\u0161 je \u010ditao o nov\u010danom sistemu u drevnom Egiptu. Otkrio je da su postojale samo nov\u010danice u vrednosti \\(d \\cdot 10^k\\) za za svako \\(d\\) iz skupa \\(\\{ 1,2,5 \\}\\), i svaki nenegativan ceo broj \\(k\\), tj. nov\u010danice u vrednosti \\(\\{1,2,5,10,20,50,100,200,500,\\ldots\\}\\). Razmi\u0161ljaju\u0107i o ovome, Milo\u0161 se zapitao koliko je najmanje nov\u010danica potrebno da se isplati neka suma \\(V\\)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Aleksa Milisavljevi\u0107 Nikola Jovanovi\u0107 Aleksandar Zlateski"},{"location":"takprog/2019_2020/kv1/01_isplata/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalazi se nenegativan ceo broj \\(V\\), suma koju je potrebno isplatiti.</p>"},{"location":"takprog/2019_2020/kv1/01_isplata/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati najmanji broj nov\u010danica, potrebnih da se isplati data suma.</p>"},{"location":"takprog/2019_2020/kv1/01_isplata/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv1/01_isplata/#ulaz","title":"Ulaz","text":"<pre><code>42\n</code></pre>"},{"location":"takprog/2019_2020/kv1/01_isplata/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2019_2020/kv1/01_isplata/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv1/01_isplata/#ulaz_1","title":"Ulaz","text":"<pre><code>121412181214\n</code></pre>"},{"location":"takprog/2019_2020/kv1/01_isplata/#izlaz_1","title":"Izlaz","text":"<pre><code>16\n</code></pre>"},{"location":"takprog/2019_2020/kv1/01_isplata/#objasnjenje-primera-1","title":"Obja\u0161njenje primera 1","text":"<p>U datom primeru, sumu mo\u017eemo isplatiti koriste\u0107i \\(2\\) nov\u010danice vrednosti \\(20\\) i jedne nov\u010danice vrednosti \\(2\\).</p>"},{"location":"takprog/2019_2020/kv1/01_isplata/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq V &lt; 10^{18}\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(V &lt; 10\\).</li> <li>U test primerima vrednim 20 poena: Broj \\(V\\) se sastoji samo od cifara \\(1\\), \\(2\\) i \\(5\\).</li> <li>U test primerima vrednim 45 poena: \\(V &lt; 10^9\\).</li> <li>U test primerima vrednim 15 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv1/01_isplata/#analiza","title":"Analiza","text":"<p>Uo\u010dimo da \u0107emo za fiksno \\(k\\) i skup \\(\\{1 \\cdot 10^k, 2 \\cdot 10^k,  5 \\cdot 10^k\\}\\) u optimalnom re\u0161enju iskoristiti: * najvi\u0161e jednu nov\u010danicu tipa \\(1 \\cdot 10^k\\) (dve \\(1 \\cdot 10^k\\) se mogu zameniti jednom \\(2 \\cdot 10^k\\)); * najvi\u0161e jednu nov\u010danicu tipa \\(5 \\cdot 10^k\\) (dve \\(5 \\cdot 10^k\\) se mogu zameniti jednom \\(1 \\cdot 10^{k+1}\\)); * najvi\u0161e dve nov\u010danice tipa \\(2 \\cdot 10^k\\) (tri \\(2 \\cdot 10^k\\) se mogu zameniti jednom \\(1 \\cdot 10^k\\) i jednom \\(5 \\cdot 10^k\\)), a ako iskoristimo barem dve tada ne koristimo \\(1 \\cdot 10^k\\) (dve \\(2 \\cdot 10^k\\) i jedna \\(1 \\cdot 10^k\\) se mogu zameniti jednom  \\(5 \\cdot 10^k\\)).</p> <p>Odavde sledi da u optimalnom re\u0161enju nema prenosa, tj. ako predstavimo \\(V=c_n 10^n + c_{n-1} 10^{n-1} + \\dots + c_0 10^0\\), nov\u010danice tipa \\(d \\cdot 10^k\\) koristimo samo kako bismo se re\u0161ili \u010dlana \\(c_k 10^k\\). Dakle, optimalno re\u0161enje dobijamo prolaskom kroz \\(V\\) cifru-po-cifru i sabiranjem minimalnog broja nov\u010danica tipa \\(d \\cdot 10^k\\) \u010diji je zbir \\(c_k \\cdot 10^k\\). Na primer, za \\(c_k=7\\) biramo skup \\(\\{\\)\\(5 \\cdot 10^{k}\\), \\(2 \\cdot 10^{k}\\)\\(\\}\\) \u0161to dodaje \\(2\\) na kona\u010dan rezultat. Sve vrednosti minimalnog broja nov\u010danica za \\(c_k \\in \\{0,\\dots9\\}\\) se lako mogu izra\u010dunati: \\([0, 1, 1, 2, 2, 1, 2, 2, 3, 3]\\).</p> <p>Ovaj zadatak je specijalan slu\u010daj change making problema. Za skup nov\u010danica dat u ovom zadatku, greedy pristup (ponovljeno biranje najvrednije nov\u010danice koja nema vrednost ve\u0107u od preostale sume) dao bi optimalno re\u0161enje, ekvivalentno gore opisanom. Ipak, ovaj pristup nije optimalan za sve skupove nov\u010danica, pa se ovaj problem u op\u0161tem slu\u010daju re\u0161ava metodom dinami\u010dkog programiranja.</p> 01_isplata.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nchar s[20];\nint novcanica_za_cifru(int a) {\n    int rt=0;\n    while(a&gt;=5) {\n        a-=5;\n        rt++;\n    }\n    while(a&gt;=2) {\n        a-=2;\n        rt++;\n    }\n    while(a&gt;=1) {\n        a-=1;\n        rt++;\n    }\n    return rt;\n}\nint main()\n{\n    scanf(\"%s\",s);\n    int n=strlen(s);\n    int ans=0;\n    for(int i=0;i&lt;n;i++) ans+=novcanica_za_cifru(s[i]-'0');\n    printf(\"%d\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/","title":"2 - Odbojka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Pavle i \u017divko su dva drugara koja mnogo vole da igraju odbojku. Po\u0161to ne mogu da igraju sami, napravili su dva tima. Kapiten prvog tima je Pavle, a kapiten drugog tima je \u017divko. </p> <p>Organizovali su veliki odbojka\u0161ki me\u010d. Odbojka\u0161ki me\u010d se igra po pravilu \"u tri dobijena seta\", odnosno prvi tim koji osvoji tri seta je pobednik i me\u010d se tada zavr\u0161ava. Da bi se osvojio jedan set potrebno je osvojiti bar \\(A\\) poena u tom setu. Igra se \"na razliku\", pa se set ne mo\u017ee zavr\u0161iti ukoliko je razlika u poenima manja od \\(2\\). Set se zavr\u0161ava \u010dim neki od timova ima \\(A\\) ili vi\u0161e poena, pri \u010demu je razlika bar \\(2\\). Broj poena u jednom setu nije ograni\u010den.</p> <p>Na primer, za \\(A=50\\) neki od mogu\u0107ih rezultata na kraju seta su: \\(50:45\\), \\(48:50\\), \\(125:123\\), \\(49:51\\), \\(50:0\\), dok neki od rezultata koji nisu mogu\u0107i na kraju seta su: \\(50:49\\), \\(61:60\\), \\(50:50\\), \\(45:43\\), \\(60:50\\), \\(50:53\\), \\(63:20\\). </p> <p>Novinar jednog dnevnog lista je do\u0161ao na stadion ba\u0161 na kraju me\u010da i nije znao koji je bio krajnji rezultat. Pitao je kapitene za rezultat kako bi mogao da napi\u0161e \u010dlanak o ovom nesvakida\u0161njem me\u010du. Pavle i \u017divko nisu hteli da mu ka\u017eu ta\u010dan rezultat, jer su bili ljuti na novinara zbog ka\u0161njenja, ali su mu ipak rekli koliki je bio ukupan broj poena tokom celog me\u010da. Novinaru je jako va\u017eno da napi\u0161e vest o me\u010du, \u010dak i po cenu da ona nije ta\u010dna. Jedino mu je bitno da se ukupan broj poena poklapa sa onim brojem koji su mu rekli kapiteni i da je me\u010d bio validan. Pomozite novinaru i napi\u0161ite program koji \u0107e za ukupan broj poena na me\u010du i minimalan broj poena koji je potreban da se osvoji jedan set odrediti da li postoji takav me\u010d i na\u0107i rezultat na kraju me\u010da. Ukoliko ima vi\u0161e mogu\u0107ih re\u0161enja, ispisati bilo koje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Filip \u0106osovi\u0107 Nikola Jovanovi\u0107 Marko Savi\u0107"},{"location":"takprog/2019_2020/kv1/02_odbojka/#opis-ulaza","title":"Opis ulaza","text":"<p>Na stadnardnom ulazu su data dva prirodna broja \\(N\\) i \\(A\\). Broj \\(N\\) predstavlja ukupan broj poena na me\u010du. Broj \\(A\\) predstavlja minimalan broj poena koji je potreban da bi se osvojio jedan set. </p>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko tra\u017eeni me\u010d ne postoji, na izlazu samo ispisati <code>-1</code>. Ako takav me\u010d postoji, ispisati bilo koji mogu\u0107i me\u010d tako \u0161to se ispi\u0161u rezultati po setovima u redosledu u kom su setovi igrani. Rezultat svakog seta prikazati u zasebnom redu, ispisivanjem dva broja koja predstavljaju poene koje su u tom setu osvojili timovi Pavla i \u017divka, tim redom.</p> <p>Voditi ra\u010duna da se igra na \\(3\\) dobijena seta, pa je najmanji mogu\u0107i broj setova \\(3\\), a najve\u0107i \\(5\\).</p>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv1/02_odbojka/#ulaz","title":"Ulaz","text":"<pre><code>92 10\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#izlaz","title":"Izlaz","text":"<pre><code>10 7\n3 10\n12 10\n13 15\n10 2\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv1/02_odbojka/#ulaz_1","title":"Ulaz","text":"<pre><code>20 20\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2019_2020/kv1/02_odbojka/#ulaz_2","title":"Ulaz","text":"<pre><code>163 25\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#izlaz_2","title":"Izlaz","text":"<pre><code>25 17\n12 25\n25 23\n25 11\n</code></pre>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N,A \\leq 10^{9}\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena: \\(N,A \\leq 20\\).</li> <li>U test primerima vrednim 40 poena: \\(A=25\\).</li> <li>U test primerima vrednim 30 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv1/02_odbojka/#analiza","title":"Analiza","text":"<p>Postoje dva slu\u010daja u kojima tra\u017eeni me\u010d ne postoji: ukoliko va\u017ei \\(N &lt; 3A\\) (jer moramo imati barem \\(3\\) seta sa barem \\(A\\) poena u svakom), ili ukoliko va\u017ei \\(A=2\\) i \\(2 \\nmid n\\) (jer se tada svaki set zavr\u0161ava razlikom ta\u010dno \\(2\\), pa ukupan broj poena mora biti paran).</p> <p>U svim ostalim slu\u010dajevima, mo\u017eemo prona\u0107i re\u0161enje u ta\u010dno \\(3\\) seta. Pretpostavimo, bez umanjenja op\u0161tosti, da je prvi tim (\u010diji je kapiten Pavle) pobedio \\(3:0\\) u setovima. Neka su prva dva seta zavr\u0161ena rezultatom \\(A:0\\). Dakle, u tre\u0107em setu je odigrano ta\u010dno \\(N' = N-2A\\) poena. Imamo dva slu\u010daja:</p> <ul> <li>Ako va\u017ei \\(N' \\leq 2A-2\\) tj. \\(N'-A \\leq A-2\\), tre\u0107i set se ne igra ,,na razliku'' i zavr\u0161ava se rezultatom \\(A : (N'-A)\\).</li> <li>U suprotnom, \\(N' &gt; 2A-2\\) tj. \\(\\frac{N'}{2}+1 &gt; A\\), i tre\u0107i set se igra ,,na razliku'', tj. prvi tim osvaja vi\u0161e od \\(A\\) poena i razlika je ta\u010dno \\(2\\).<ul> <li>Ako je \\(N'\\) parno, tre\u0107i set se zavr\u0161ava rezultatom \\(\\frac{N'}{2}+1 : \\frac{N'}{2}-1\\). Po uslovu za ovaj slu\u010daj, rezultat je validan.</li> <li>Ako je \\(N'\\) neparno, tre\u0107i set se zavr\u0161ava rezultatom \\(\\frac{N'-1}{2}+1 : \\frac{N'-1}{2}-1\\). Ponovo, iz uslova za ovaj slu\u010daj sledi \\(\\frac{N'-1}{2}+1 &gt; A\\) (jer je \\(A\\) prirodan broj), pa je ovaj rezultat validan. Sada nam preostaje \\(1\\) poen koji prosto prebacujemo u drugi set, tako da rezultat u njemu postaje \\(A:1\\) (ovo nije mogu\u0107e uraditi jedino u slu\u010daju \\(A=2\\), ali taj slu\u010daj smo za neparno \\(N'\\), dakle neparno \\(N\\), ve\u0107 obradili). </li> </ul> </li> </ul> 02_odbojka.cpp<pre><code>/* kod koji prolazi sve test primere */\n\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n,a;\n    cin &gt;&gt; n &gt;&gt; a;\n    if (n/3&lt;a || (a==2 &amp;&amp; n%2))\n    {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int x1,y1,x2,y2,x3,y3;\n\n    x1 = x2 = a;\n\n    y1 = y2 = 0;\n\n    n -= 2*a;\n\n    if (n&lt;=a+a-2)\n    {\n        x3 = a;\n        y3 = n-a;\n    }\n    else\n    {\n        if (n%2==1)\n            y2++;\n        x3 = n/2 + 1;\n        y3 = n/2 - 1;\n    }\n\n    printf(\"%d %d\\n%d %d\\n%d %d\\n\",x1,y1,x2,y2,x3,y3);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/","title":"3 - Vodopad","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Mali Perica je re\u0161io da obi\u0111e Srbiju i posebno je zainteresovan za obilazak vodopada \u0161irom zemlje. Kada je bio na Gostiljskim vodopadima, poku\u0161ao je da proceni tok vode na dnu vodopada.</p> <p>Kao \u0161to svi znamo, vodopad ima visinu \\(h\\) metara i \u0161irinu \\(n\\) metara. Vodopad je tako\u0111e sa leve i desne strane ograni\u010den ivicama tako da voda nikada ne oti\u010de levo i desno od njegovih granica. Jo\u0161 jedna zanimljiva stvar je \u0161to vodopad mo\u017ee imati stene koje \u0107e preusmeravati tok vode. Naime, ako vertikalni mlaz vode nai\u0111e na stenu, sav njen tok se deli na dva dela tako da jedan deo oti\u010de na desno a drugi na levo. Ukoliko se stena nalazi uz levu ili desnu granicu vodopada, tada se sav tok vode preusmerava na jednu stranu. Vi\u0161e stena se mo\u017ee nalaziti jedna pored druge i u tom slu\u010daju se voda preusmerava samo na kraj i po\u010detak celog niza stena. Garantuje se da \u0107e u svakoj visini vodopada postojati bar jedno mesto koje nema stenu tako da je vodi garantovan prolaz na dole.</p> <p>Formalno, vodopad mo\u017eemo predstaviti binarnom matricom \\(h \\times n\\), u kojoj je svako polje ili prohodno ili se tu nalazi stena. Redovi se indeksiraju po\u010dev\u0161i od 1, tako da je prvi red na vrhu matrice, a \\(h\\)-ti red na dnu. Protok vode ima vrednost 1 na vrhu svake kolone. Voda se u svakoj koloni spu\u0161ta niz matricu, sve dok ne nai\u0111e na stenu. Ukoliko nai\u0111e na stenu, sav protok se deli na dva celobrojna dela i polovina ide na levu stranu a druga polovina na desnu stranu. Ukoliko je protok neparan, tada preostala jedinica ide levo ili desno po slede\u0107em pravilu:</p> <ul> <li> <p>ukoliko je red neparan, jedinica vi\u0161ka ide levo</p> </li> <li> <p>ukoliko je red paran, jedinica vi\u0161ka ide desno</p> </li> </ul> <p>Ako se vi\u0161e uzastopnih nula nalazi u redu matrice (vi\u0161e uzastopnih stena), tada se ukupan protok iznad bloka uzastopnih nula deli na dva dela i jedna polovina preusmerava na prvo mesto levo od bloka a druga na desno. Pravilo za preostalu jedinicu protoka je isto kao i malopre - ako je red neparan vi\u0161ak ide levo od bloka, a ako je paran desno. Ako se stena ili blok stena nalazi uz levu ili desnu ivicu matrice, sav protok iznad stene ili bloka se usmerava na suprotnu stranu. Garantovano je da ne\u0107e postojati red matrice koji sadr\u017ei samo nule.</p> <p>Perica vam je dao matricu koja predstavljaja izgled jednog vodopada. Va\u0161 zadatak je da odredite protok vode na svim mestima na njegovom dnu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Lazar Milenkovi\u0107 Slobodan Mitrovi\u0107 Aleksandar Zlateski"},{"location":"takprog/2019_2020/kv1/03_vodopad/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva broja \\(h\\) i \\(n\\), koji predstavljaju visinu i \u0161irinu matrice, respektivno. U svakom od narednih \\(h\\) redova nalazi se po \\(n\\) brojeva iz skupa \\(\\{0, 1\\}\\), pri \u010demu \\(0\\) ozna\u010dava da se na odgovaraju\u0107em polju nalazi stena, dok \\(1\\) predstavlja prohodno polje.</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza potrebno je ispisati \\(n\\) brojeva - vrednost toka na dnu svake od kolona matrice.</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv1/03_vodopad/#ulaz","title":"Ulaz","text":"<pre><code>3 3\n1 1 0\n1 0 1\n0 1 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#izlaz","title":"Izlaz","text":"<pre><code>0 2 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv1/03_vodopad/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3\n0 1 0\n1 0 1\n1 1 0\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#izlaz_1","title":"Izlaz","text":"<pre><code>1 2 0\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2019_2020/kv1/03_vodopad/#ulaz_2","title":"Ulaz","text":"<pre><code>4 5\n1 0 1 0 1\n1 1 0 0 1\n0 1 1 1 0\n1 0 1 0 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#izlaz_2","title":"Izlaz","text":"<pre><code>1 0 3 0 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#primer-4","title":"Primer 4","text":""},{"location":"takprog/2019_2020/kv1/03_vodopad/#ulaz_3","title":"Ulaz","text":"<pre><code>5 7\n1 1 1 1 0 0 0\n1 0 1 0 1 0 1\n1 1 0 0 0 1 0\n1 0 0 1 1 0 1\n0 1 1 0 1 1 0\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#izlaz_3","title":"Izlaz","text":"<pre><code>0 2 1 0 2 2 0\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#primer-5","title":"Primer 5","text":""},{"location":"takprog/2019_2020/kv1/03_vodopad/#ulaz_4","title":"Ulaz","text":"<pre><code>1 3\n1 0 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#izlaz_4","title":"Izlaz","text":"<pre><code>2 0 1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, posle prvog reda, protoci imaju vrednosti \\([1, 2, 0]\\), jer se voda iz tre\u0107e kolone preusmerava na levo zbog toga \u0161to je tu stena uz desnu ivicu. Nakon drugog reda, protoci su \\([2, 0, 1]\\), jer se dve jedinice protoka iz srednje kolone dele na dva dela. Kona\u010dno, protok na kraju tre\u0107eg reda je \\([0, 2, 1]\\), jer se tok uz ivicu preusmerava na suprotnu stranu.</p> <p></p> <p>U drugom primeru, protoci na kraju redova su:</p> <pre><code>0 3 0\n1 0 2\n1 2 0\n</code></pre> <p></p> <p>U tre\u0107em primeru protoci na kraju redova su:</p> <pre><code>2 0 2 0 1\n2 1 0 0 2\n0 3 0 2 0\n1 0 3 0 1\n</code></pre> <p></p> <p>U \u010detvrtom primeru, protoci na kraju redova su:</p> <pre><code>1 1 1 4 0 0 0\n1 0 4 0 2 0 0\n1 3 0 0 0 3 0\n2 0 0 2 1 0 2\n0 2 1 0 2 2 0\n</code></pre> <p></p> <p>U petom primeru postoji samo jedan red, na \u010dijoj se sredini nalazi stena. Po\u0161to je u pitanju neparan red, tok iz sredine se preusmerava na levo.</p> <p></p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n,h\\)</li> <li>\\(n \\cdot h \\le 10^6\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(n \\le  10\\), \\(h \\le 10\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(h \\le 10\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(n \\le 100\\).</li> <li>U test primerima vrednim \\(20\\) poena: ni u jednoj vrsti nema uzastopnih nula.</li> <li>U test primerima vrednim \\(20\\) poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#analiza","title":"Analiza","text":"<p>Najpre \u0107emo objasniti re\u0161enje koje radi u slo\u017eenosti \\(O(n^2 \\cdot h)\\), \u0161to je dovoljno da se osvoji 70 poena, a zatim \u0107emo pokazati kako se to re\u0161enje mo\u017ee jednostavno izmeniti tako da radi u slo\u017eenosti \\(O(n \\cdot h)\\) i donese 100 poena.</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#resenje-u-on2-cdot-h","title":"Re\u0161enje u \\(O(n^2 \\cdot h)\\)","text":"<p>Ovo re\u0161enje dobijamo jednostavnim simuliranjem protokoa. Naime, za svako \\(i = 1 \\ldots n\\) \"pustimo\" jedini\u010dni protok sa vrha vodopada \\(i\\)-te kolone i simuliramo pona\u0161anje tog jedini\u010dnog protoka. Kad protok udari u stenu, tada ga preusmeravamo levo ili desno prate\u0107i pravila opisana u postavci zadatka. Kada protok zavr\u0161i na dnu vodopada u koloni \\(j\\) tada uve\u0107amo za \\(1\\) ispis za kolonu \\(j\\).</p> <p>Da bismo protok koji udari u stenu pravilno podelili levo i desno, primetimo prvo da postavku problema mo\u017eemo preformulisati na slede\u0107i na\u010din. Posmatrajmo blok stena \\(B\\). - Ako je \\(B\\) u neparnom redu, tada se neparni po redu protok koji udari u \\(B\\) preusmerava levo, dok se parni po redu protok koji udari u \\(B\\) preusmerava desno. - Ako je \\(B\\) u parnom redu, tada se neparni po redu protok koji udari u \\(B\\) preusmerava desno, dok se parni po redu protok koji udari u \\(B\\) preusmerava levo.</p> <p>Dakle, za simulaciju je dovoljno da za svaki blok stena pamtimo gde smo \\emph{poslednji} put preusmerili protok sa tog bloka.</p> <p>U ovom re\u0161enju imamo \\(n\\) jedini\u010dnih protoka koje simuliramo \"polje po polje\". Po\u0161to blok stena mo\u017ee imati du\u017einu \\(n - 1\\), dati protok mo\u017ee obi\u0107i \\(O(n \\cdot h)\\) polja pre nego \u0161to do\u0111e do dna. Odatle sledi gore nazna\u010deno vreme izvr\u0161avanja.</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#resenje-u-on-cdot-h","title":"Re\u0161enje u \\(O(n \\cdot h)\\)","text":"<p>Da bismo ubrzali opisano re\u0161enje iznad, dovoljno je da za svaki blok stena zapamtimo gde su kraj i po\u010detak bloka. Tada kada protok udari bilo gde u blok mo\u017eemo ga odmah simulirati sa jednog od krajeva bloka, bez potrebe da protok polje po polje prelazi preko celog bloka stena. To zna\u010di da se svaki red mo\u017ee simulirati u \\(O(1)\\) vremenu, \u0161to daje ukupnu slo\u017eenost od \\(O(n \\cdot h)\\).</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#smernice-za-algoritam","title":"Smernice za algoritam","text":"<p>Za algoritam je potrebno da ozna\u010dimo kom bloku svaka stena pripada, kao i da za svaki blok odredimo njegov po\u010detak i kraj. Da bismo to uradili, najpre \u0107emo svakom bloku uzastopnih stena dodeliti jedinstven broj, na primer, redom brojeve po\u010dev\u0161i od \\(1\\). To mo\u017eemo uraditi na slede\u0107i na\u010din. \u010cuva\u0107emo promenljivu \\(blockNumber\\), koja \u0107e ozna\u010davati redni broj trenutnog bloka, i obilaziti polja redom po redovima. Kada nai\u0111emo na stenu, ona je po\u010detak novog bloka ako i samo ako je ta stena prva u tom redu, ili ako je prethodno polje bilo \\(1\\). Kada detektujemo po\u010detak bloka, tada uve\u0107amo \\(blockNumber\\) za \\(1\\). Steni, bila prva u bloku ili ne, dodelimo \\(blockNumber\\).</p> <p>Posle ovih koraka svakoj steni je dodeljen broj koji ozna\u010dava kom bloku ona pripada. Stena bloka sa najmanjom kolonom ozna\u010dava po\u010detak odgovaraju\u0107eg bloka, a stena bloka sa najve\u0107om kolonom ozna\u010dava kraj odgovaraju\u0107eg bloka.</p>"},{"location":"takprog/2019_2020/kv1/03_vodopad/#bonus-zadatak","title":"Bonus zadatak","text":"<p>Simulacija koja donosi 100 poena klju\u010dno zavisi od \u010dinjenice da postoji \\(n\\) jedini\u010dnih protoka. Kako bi se mogao ovaj zadatak re\u0161iti u \\(O(n \\cdot h)\\) vremenu ako se sa vrha vodopada iz \\(i\\)-te kolone pu\u0161ta izme\u0111u \\(0\\) i \\(10^9\\) zapremine vode?</p> 03_vodopad.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nint h, n;\nvector&lt;int&gt; tok, novitok;\nvector&lt;vector&lt;int&gt;&gt; mat;\n\nvoid rasporedi(vector&lt;int&gt; &amp;a, bool oddrow, int l, int r, ll curr) {\n    if (l == -1) {\n        // sve ide desno - garantovano je da desno postoji\n        a[r] += curr;\n    } else if (r == n) {\n        // sve ide levo - garantovano je da levo postoji\n        a[l] += curr;\n    } else {\n        // podjednako se raspodeli\n        a[l] += curr / 2;\n        a[r] += curr / 2;\n        if (oddrow) {\n            // u neparnim redovima vi\u0161ak ide levo\n            a[l] += (curr &amp; 1);\n        } else {\n            // u parnim redovima vi\u0161ak ide desno\n            a[r] += (curr &amp; 1);\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    ios_base::sync_with_stdio(false);\n    cin &gt;&gt; h &gt;&gt; n;\n    tok.resize(n);\n    novitok.resize(n);\n    mat.resize(h);\n    for (int i = 0; i &lt; h; i++) {\n        mat[i].resize(n);\n    }\n    for (int i = 0; i &lt; h; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            cin &gt;&gt; mat[i][j];\n        }\n    }\n    for (int i = 0; i &lt; n; i++) {\n        tok[i] = 1;\n    }\n    for (int i = 0; i &lt; h; i++) {\n        int last = -1;\n        int curr = 0;\n        for (int j = 0; j &lt; n; j++) {\n            novitok[j] = 0;\n            if (mat[i][j] == 0) {\n                if (last == -1) {\n                    last = j;\n                }\n                curr += tok[j];\n            } else {\n                novitok[j] += tok[j];\n                if (last != -1) {\n                    rasporedi(novitok, (i + 1) &amp; 1, last - 1, j, curr);\n                    last = -1;\n                    curr = 0;\n                }\n            }\n        }\n        if (last != -1) {\n            rasporedi(novitok, (i + 1) &amp; 1, last - 1, n, curr);\n        }\n        tok = novitok;\n    }\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; tok[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/","title":"4 - \u0160ahovska trka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 1024MB <p>Tokom istra\u017eivanja starog hrama, Milo\u0161 je na\u0161ao misti\u010dnu \u0161ahovsku tablu koja ima \\(h\\) redova i \\(w\\) kolona na kojoj su neka od polja blokirana uz pomo\u0107 magije. On je postao opsednut ovom tablom i krenuo da igra veoma neobi\u010dnu igru na njoj.</p> <p>Na tabli se uvek nalazi ta\u010dno jedna figura koju Milo\u0161 u toku igre mo\u017ee da zamenjuje drugim figurama. Na po\u010detku igre to je kralj koji se nalazi na gornjem levom polju, \\((1,1)\\). Figure se pomeraju po uobi\u010dajenim pravilima \u0161aha, me\u0111utim nije mogu\u0107e staviti ih na blokirana polja. Za svako pomeranje figure Milo\u0161u treba 1 sekund. Njegov cilj je da \u0161to pre stavi neku figuru na donje desno polje, \\((h,w)\\).</p> <p>U proizvoljnom momentu Milo\u0161 mo\u017ee da zameni trenutnu figuru nekom drugom figurom na istoj toj poziciji. Me\u0111utim, on ne mo\u017ee ovo da uradi trenutno, nego mu za to treba odre\u0111eno vreme, u zavisnosti od toga koju novu figuru po\u010dinje da koristi.  Kralj : Milo\u0161u treba 1 sekund da zameni bilo koju figuru kraljem. Kralj se u jednom potezu mo\u017ee pomeriti na jedno od 8 susednih polja ako to polje nije blokirano.  Lovac: Milo\u0161u treba 2 sekunde da zameni bilo koju figuru lovcem. Lovac se u jednom potezu mo\u017ee pomeriti dijagonalno proizvoljan broj polja, sve dok ni jedno od polja na njegovom putu nije blokirano.  Top: Milo\u0161u treba 3 sekunde da zameni bilo koju figuru topom. Top se u jednom potezu mo\u017ee pomeriti levo, desno, gore ili dole proizvoljan broj polja, sve dok ni jedno od polja na njegovom putu nije blokirano.  Konj: Milo\u0161u treba 4 sekunde da zameni bilo koju figuru konjem. Konj se u jednom potezu mo\u017ee pomeriti 2 polja u proizvoljnom od \u010detiri smera (gore, dole, levo, desno) i 1 polje u jednom od dva smera ortogonalna na prethodni smer. Nije bitno da li su polja preko kojih konj usput prelazi blokirana ili ne.  Kraljica: Milo\u0161u treba 5 sekundi da zameni bilo koju figuru kraljicom. Kraljica, u jednom potezu, mo\u017ee da se pomeri levo, desno, gore, dole ili dijagonalno proizvoljan broj polja, sve dok ni jedno od polja na njenom putu nije blokirano.  Pomozite Milo\u0161u i recite mu za koliko najmanje sekundi mo\u017ee da zavr\u0161i ovu igru, ili mu saop\u0161tite da to nije mogu\u0107e.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Pe\u0161i\u0107 Nikola Pe\u0161i\u0107 Nikola Pe\u0161i\u0107 Aleksandar Zlateski <p>Glavna ideja je da se napravi graf od \\(5*h*w\\)  \u010dvorova gde svaka pozicija na tabli ima po 5 \u010dvorova (jedan za svaku figuru). Grane u ovom grafu predstavljaju sve poteze koje mo\u017eemo da napravimo i imaju te\u017einu od 1 do 5. Kako bi izbegli \\(MLE\\), ove grane ne treba da \u010duvamo u memoriji nego da pro\u0111emo kroz njih iterativno kada posmatramo neki \u010dvor. Jedno od re\u0161enja pu\u0161ta \\(Dijkstrin~algoritam\\) na ovom grafu kako bi se na\u0161la udaljenost svih \u010dvorova od \u010drvora koji predstavlja kralja na poziciji \\((1,1)\\).  Kako bi ubrzali algoritam, tokom prola\u017eenja kroz sva polja na koja mo\u017ee kraljica/top/lovac da ode u nekom smeru, pored uslova da se prekine pretraga kada se stigne na blokirano polje, treba uvesti uslov da se prekine pretraga ako se stigne na polje koje ima istu ili manju udaljenost od udaljenosti trenutnog polja (ne ra\u010dunaju\u0107i trenutno polje). Vremenska slo\u017eenost: \\(O(n^3 * log n)\\), Memorijska slo\u017eenost: \\(O(n^2)\\). Jo\u0161 jedna optimizacija programa koja nije bila potrebna za \\(100\\) bodova je da se umesto \\(Dijkstrinog~algoritma\\) pusti \\(Dialov~algoritam\\). Vremenska slo\u017eenost: \\(O(n^3)\\), Memorijska slo\u017eenost: \\(O(n^2)\\).</p> 04_sahovska_trka.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N=500,M=N*N*5,L=5,oo=INT_MAX/N;\nint n,m,tr=N*N*L;\nvector&lt;string&gt; mat(N);\nvector&lt;int&gt; dx={0,0,1,-1,1,1,-1,-1,2,2,-2,-2,1,1,-1,-1},dy={1,-1,0,0,1,-1,1,-1,1,-1,1,-1,2,-2,2,-2},l={0,4,0,8,0},r={7,7,3,15,7},d={1,N,N,1,N};\n/*\n    Indeksi 0: Kralj\n            1: Lovac\n            2: Top\n            3: Konj\n            4: Kraljica\n    dx,dy: indeksi 0-3: Smerovi za top\n           indeksi 4-7: Smerovi za lovca\n           indeksi 8-15: Smerovi za konja\n           (Ovo je obelezeno u nizovima l i r)\n    d: koliko polja figura sme da se pomeru u tom pravcu\n*/\nbool inside(int x,int y){\n    return x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;m &amp;&amp; mat[x][y]=='.';\n}\nint getNum(int x,int y,int z){ //Iz koordinata polja u broj\n    return z + y*L + x*N*L;\n}\ntuple&lt;int,int,int&gt; getField(int i){ //Iz broja u koordinate polja\n    return make_tuple(i/N/L, (i%(N*L))/L, i%L);\n}\nvector&lt;int&gt; dist(M,oo);\nqueue&lt;int&gt; q[6]; //Dial's algorithm\nint main()\n{\n    scanf(\"%i %i\",&amp;n,&amp;m);\n    for(int i=0;i&lt;n;i++)\n        cin &gt;&gt; mat[i];\n    q[0].push(0);\n    dist[0]=0;\n    for(int t=0;t&lt;M;t++)\n        while(q[t%6].size())\n        {\n            int tr=q[t%6].front(),x,y,z;\n            q[t%6].pop();\n            tie(x,y,z)=getField(tr);\n            if(x==n-1&amp;&amp;y==m-1)\n            {\n                printf(\"%i\\n\",dist[tr]);\n                return 0;\n            }\n            for(int i=0;i&lt;5;i++) //Menjanje figure\n            {\n                int br=getNum(x,y,i);\n                if(dist[br]&gt;dist[tr]+i+1)\n                    dist[br]=dist[tr]+i+1,q[dist[br]%6].push(br);\n            }\n            for(int k=l[z];k&lt;=r[z];k++) //Pomeranje figure\n                for(int i=1;i&lt;=d[z];i++)\n                {\n                    int xx=x+dx[k]*i,yy=y+dy[k]*i,br=getNum(xx,yy,z);\n                    if(!inside(xx,yy))\n                        break;\n                    if(dist[br]&lt;=dist[tr]) //Veoma bitan uslov za optimizaciju programa\n                        break;\n                    if(dist[br]&gt;dist[tr]+1)\n                        dist[br]=dist[tr]+1,q[dist[br]%6].push(br);\n                }\n        }\n    printf(\"-1\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva prirodna broja \\(h\\) i \\(w\\), koji obele\u017eavaju redom visinu i \u0161irinu table. U narednih \\(h\\) redova se nalazi niz du\u017eine \\(w\\) koji se sastoji samo od karaktera <code>.</code> i <code>#</code>, gde <code>.</code> ozna\u010dava da je polje slobodno, a <code>#</code> da je polje blokirano.</p>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati ceo broj \\(t\\), najmanji broj sekundi da Milo\u0161 postavi figuru na polje \\((h,w)\\), odnosno \\(-1\\) ako to nije mogu\u0107e.</p>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#ulaz","title":"Ulaz","text":"<pre><code>3 3\n...\n.#.\n...\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#ulaz_1","title":"Ulaz","text":"<pre><code>3 5\n.####\n##.##\n####.\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#ulaz_2","title":"Ulaz","text":"<pre><code>10 10\n...#.###..\n.....#####\n...##..#.#\n#....#....\n.#.......#\n##..#.....\n......#...\n..##..#.#.\n..#..#..#.\n..#..##...\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#izlaz_2","title":"Izlaz","text":"<pre><code>8\n</code></pre>"},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-1_1","title":"Primer 1:","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-2_1","title":"Primer 2:","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#primer-3_1","title":"Primer 3:","text":""},{"location":"takprog/2019_2020/kv1/04_sahovska_trka/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq h,w \\leq 500\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(h,w \\leq 5\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(h,w \\leq 200\\) i ako postoji re\u0161enje, postoji i optimalno re\u0161enje koje ne zahteva zamenu figura.</li> <li>U test primerima vrednim \\(40\\) poena: \\(h,w \\leq 200\\).</li> <li>U test primerima vrednim \\(10\\) poena: Ako postoji re\u0161enje, postoji i optimalno re\u0161enje koje ne zahteva zamenu figura.</li> <li>U test primerima vrednim \\(30\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv1/05_luxor/","title":"5 - Luxor","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>U nedavnoj poseti hramu u Luksoru nai\u0161li ste na interesantnu, drevnu zagonetku. Naime, staroegipatski mudraci su voleli da mno\u017ee i da ra\u010dunaju XOR-vrednost parova prirodnih brojeva. Nai\u0161li ste na tablu na kojoj je ispisano \\(T\\) parova nenegativnih celih brojeva \\(A_i, B_i\\). Interesantno je da je kod svih ovih parova broj \\(A_i\\) neparan. Va\u0161 zadatak je da za svaki od tih parova prona\u0111ete dva prirodna broja \\(X_i, Y_i\\) takva da va\u017ei \\(A_i = X_iY_i\\) i \\(B_i = X_i \\text{ xor } Y_i\\). Mogu\u0107e je da takav par ne postoji, ukoliko je to slu\u010daj, ispi\u0161ite \\(-1\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 i Lazar Korsi\u0107 Ivan Sto\u0161i\u0107 Aleksandar Zlateski"},{"location":"takprog/2019_2020/kv1/05_luxor/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(T\\). U narednih \\(T\\) linija nalaze se po dva nenegativna cela broja odvojena razmakom, \\(A_i\\) i \\(B_i\\).</p>"},{"location":"takprog/2019_2020/kv1/05_luxor/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(T\\) redova, po jedan za svaki upit, ispisati tra\u017eeni par \\(X_i, Y_i\\), odvojen razmakom. Ukoliko takav par ne postoji, ispisati \\(-1\\). Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2019_2020/kv1/05_luxor/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv1/05_luxor/#ulaz","title":"Ulaz","text":"<pre><code>4\n21 4\n2795079079011879151 119681854\n9 0\n9 2\n</code></pre>"},{"location":"takprog/2019_2020/kv1/05_luxor/#izlaz","title":"Izlaz","text":"<pre><code>3 7\n1679133257 1664596343\n3 3\n-1\n</code></pre>"},{"location":"takprog/2019_2020/kv1/05_luxor/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10.000\\)</li> <li>\\(0 \\leq A_i, B_i &lt; 2^{62}\\)</li> <li>\\(A_i\\) je neparan.</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(T \\leq 10\\) i \\(A_i, B_i \\leq 10^{13}\\).</li> <li>U test primerima vrednim 20 poena: \\(T \\leq 500\\).</li> <li>U test primerima vrednim 60 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv1/05_luxor/#napomena","title":"Napomena","text":"<p>Operator XOR, odnosno ekskluzivnu disjunkciju u C++ zapisujemo pomo\u0107u simbola <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\  y\\).</p>"},{"location":"takprog/2019_2020/kv1/05_luxor/#podzadatak-1","title":"Podzadatak 1","text":"<p>Primetimo da je jedan od brojeva \\(X,Y\\) manji ili jednak \\(\\sqrt{A}\\), pa je dovoljno izvr\u0161iti pretragu po svim brojevima \\(X\\) do \\(\\sqrt{A}\\), gde proveravamo da je \\(Y = \\frac{A}{X}\\) ceo broj i da je \\(X \\text{ XOR } Y = B\\). Vremenska slo\u017eenost po primeru je \\(O(\\sqrt{A})\\).</p>"},{"location":"takprog/2019_2020/kv1/05_luxor/#podzadatak-2","title":"Podzadatak 2","text":"<p>Da bi se smanjio broj kandidata za broj \\(X\\) primetimo da \\(X\\) mora biti delilac broja \\(A\\). Mo\u017ee se iskoristiti bilo koji brzi algoritam za faktorizaciju celih brojeva. Jedan takav algoritam je Pollard-Rho algoritam, koji se naj\u010de\u0161\u0107e implementira zajedno sa Miller-Rabin algoritmom za proveru da li je broj prost. Ovaj algoritam ima vremensku slo\u017eenost \\(O(\\sqrt[4]{n})\\) za nala\u017eenje jednog faktora broja \\(n\\), ali ima veliku skrivenu konstantu i iz tog razloga nije dovoljno brz.</p>"},{"location":"takprog/2019_2020/kv1/05_luxor/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Najpre, primetimo da pri ra\u010dunanju XOR vrednosti i proizvoda dva broja, najni\u017eih \\(n\\) bitova rezultata zavise samo od najni\u017eih \\(n\\) bitova operanada. Ako posmatramo fiksne vrednosti \\(n, a, b\\), gde je \\(0 \\leq a, b &lt; 2^n\\) i \\(a\\) je neparno, pokazuje se da postoji najvi\u0161e \\(2^{\\lfloor\\frac{n+3}{2}\\rfloor}\\) re\u0161enja jedna\u010dine</p> <p>\\(xy \\equiv a \\mod 2^n, x \\text{ XOR } y = b\\),</p> <p>gde su \\(x,y\\) nepoznate, tako\u0111e brojevi iz skupa \\([0, 2^n)\\). Iz tog razloga, ako fiksiramo najni\u017eih \\(n\\) bitova broja \\(X\\), ovakvih validnih parcijalnih re\u0161enja ne\u0107e biti vi\u0161e od \\(2^{\\lfloor\\frac{n+3}{2}\\rfloor}\\). Ova parcijalna re\u0161enja mo\u017eemo generisati rekurzivno. U \\(n\\) tom nivou rekurzije imamo ne vi\u0161e od \\(2^{\\lfloor\\frac{n+3}{2}\\rfloor}\\) poziva. Dovoljno je prona\u0107i samo prvih \\(31\\) bitova broja \\(X\\), jer je zbog uslova \\(XY=A\\) bar jedan od brojeva \\(X,Y\\) manji ili jednak \\(A\\), a uvek mo\u017eemo da pretpostavimo da je to broj \\(X\\). Sumiranjem po \\(n\\) dobijamo da ima \\(O(\\sqrt[4]{A})\\) rekurzivnih poziva, pa je upravo ovo vremenska slo\u017eenost re\u0161avanja jednog test primera.</p> 05_luxor.cpp<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nbool rek(ull a, ull b, ull x, int i) {\n    ull y = b ^ x;\n    ull m = (1ull &lt;&lt; i) - 1;\n    if (((x*y) ^ a) &amp; m)\n        return false;\n    if (i == 32)\n        return false;\n    if (x*1.0*y &lt; 5e18 &amp;&amp; x*y == a) {\n        cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\n        return true;\n    }\n    if (rek(a, b, x, i+1))\n        return true;\n    return rek(a, b, x|(1ull&lt;&lt;i), i+1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        ull a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        if (!rek(a, b, 0, 0))\n            cout &lt;&lt; \"-1\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/01_pikado/","title":"1 - Pikado","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 512MB <p>Milo\u0161, na\u0161 omiljeni heroj, koji je od pro\u0161log susreta pomislio da je dobra ideja da se preseli u dvodimenzionalni univerzum, je odlu\u010dio da krene da igra Pikado. Pikado je igra u kojoj igra\u010d baca iz ruke strelice ka meti koja je podeljena na vi\u0161e polja. Me\u0111utim, u dvodimenzionalnom univerzumu meta ne izgleda kao krug, ve\u0107 je predstavljena kao du\u017e. </p> <p>Milo\u0161eva meta se sastoji od centralnog polja, \\(N\\) polja koja se nalaze levo od centra, i \\(N\\) polja koja se nalaze desno od centra. Centralno polje je obele\u017eeno brojem \\(0\\), polja levo od centra su obele\u017eena brojevima \\(-N, \\ldots, -3, -2, -1\\), dok su polja desno od centra obele\u017eena brojevima \\(1,2,3,\\dots,N\\).</p> <p>Milo\u0161 \u0107e da baci ta\u010dno \\(N\\) strelica u metu, i za svaku \u0107e da zabele\u017ei u koje polje je udarila. Mo\u017ee se ra\u010dunati na to da je Milo\u0161 dovoljno precizan da pogodi metu tokom svakog bacanja. </p> <p>Svako polje na tabli se sve vi\u0161e tro\u0161i \u0161to vi\u0161e strelica udari u njega. Milo\u0161 smatra da neko polje treba da se zameni ako ga je pogodilo barem \\(K\\) strelica.  Kako je on lo\u0161 u matematici, zamolio vas je da mu ka\u017eete oznake svih polja koja treba da zameni.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Pe\u0161i\u0107 Lazar Milenkovi\u0107 Filip \u0106osovi\u0107 Nikola Pe\u0161i\u0107"},{"location":"takprog/2019_2020/kv2/01_pikado/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza, nalaze se prirodni brojevi \\(N\\) i \\(K\\).</p> <p>U drugom redu, nalazi se \\(N\\) celih brojeva \\(A_1, A_2, \\dots,A_N\\), gde \\(A_i\\) predstavlja oznaku polja koje je Milo\u0161 pogodio tokom \\(i\\)-tog bacanja.</p>"},{"location":"takprog/2019_2020/kv2/01_pikado/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi red standardnog izlaza, ispisati broj polja koja treba zameniti. U drugom redu ispisati oznake svih takvih polja. Oznake se mogu ispisati u bilo kom redosledu.</p>"},{"location":"takprog/2019_2020/kv2/01_pikado/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv2/01_pikado/#ulaz","title":"Ulaz","text":"<pre><code>6 2\n1 2 -6 2 4 4\n</code></pre>"},{"location":"takprog/2019_2020/kv2/01_pikado/#izlaz","title":"Izlaz","text":"<pre><code>2\n2 4\n</code></pre>"},{"location":"takprog/2019_2020/kv2/01_pikado/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv2/01_pikado/#ulaz_1","title":"Ulaz","text":"<pre><code>6 2\n1 -1 0 -1 -1 0\n</code></pre>"},{"location":"takprog/2019_2020/kv2/01_pikado/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n-1 0\n</code></pre>"},{"location":"takprog/2019_2020/kv2/01_pikado/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, K \\leq 10^6\\)</li> <li>\\(-N \\leq A_i \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(25\\) poena: \\(N \\leq 1000\\).</li> <li>U test primerima vrednim \\(25\\) poena: \\(A_i \\in \\{-1, 0, 1\\}\\).</li> <li>U test primerima vrednim \\(50\\) poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv2/01_pikado/#analiza","title":"Analiza","text":"<p>Potrebno je na\u0107i sve elemente niza \\(A\\) koji se pojavljuju bar \\(K\\) puta u nizu. Elementi niza \\(A\\) su u intervalu \\([-N,N]\\) tako da postoji \\(2 \\cdot N+1\\) razli\u010ditih vrednosti koje se mogu pojaviti u nizu. Mo\u017eemo iskoristiti pomo\u0107ni niz \\(B\\) du\u017eine \\(2 \\cdot N+1\\) koji predstavlja broj pojavljivanja svakog elementa u po\u010detnom nizu.  </p> <p>Na po\u010detku niz \\(B\\) ima vrednost \\(0\\) na svakoj poziciji. Jednim prolaskom kroz niz \\(A\\), kada nai\u0111eimo na element \\(A_i\\) pove\u0107avamo broj pojavljivanja tog elementa za \\(1\\). Po\u0161to ne mo\u017eemo pristupiti negativnim indeksima broj pojavljivanja elementa koji ima vrednost \\(X\\) pamtimo u nizu \\(B\\) na poziciji \\(X+N\\). Tako je interval \\([-N,N]\\) preslikan u interval \\([0, 2 \\cdot N]\\) \u0161to nam omogu\u0107ava da koristimo niz. </p> <p>Prolaskom kroz niz \\(B\\) prebrojavamo i ispisujemo sve brojeve koji su se pojavili bar \\(K\\) puta u nizu. Ako za neko \\(j\\) va\u017ei da je \\(B[j] \\geq K\\) to zna\u010di da se broj \\(j-N\\) pojavio bar \\(K\\) puta. </p> <p>Implementacija kori\u0161\u0107enjem niza je slo\u017eenosti \\(O(N)\\). Mo\u017ee se koristiti i struktura zasnovana na pretra\u017eiva\u010dkom stablu (<code>std::map</code> slo\u017eenosti \\(O(N \\log N)\\)) ili he\u0161 tabela (<code>std::unordered_map</code> o\u010dekivane slo\u017eenosti \\(O(N)\\)) \u0161to nam omogu\u0107ava re\u0161enje i kada su elementi niza \\(A\\) mnogo veliki i nemamo dovoljno memorije da napravimo niz koji obuhvata sve potencijalne vrednosti.</p> 01_pikado.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int MAXN = 1e6 + 16;\n\nint n, k, cnt[MAXN * 2];\nvector&lt;int&gt; sol;\n\nint main(int argc, char *argv[]) {\n    if (argc == 2) {\n        string inFileName = argv[1];\n        string outFileName = inFileName.substr(0, inFileName.length() - 2) + \"out\";\n        freopen(inFileName.c_str(), \"r\", stdin);\n        freopen(outFileName.c_str(), \"w\", stdout);\n    }\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        cnt[x + MAXN]++;\n    }\n    for (int i = 0; i &lt; 2 * MAXN; i++) {\n        if (cnt[i] &gt;= k) {\n            sol.push_back(i - MAXN);\n        }\n    }\n    cout &lt;&lt; sol.size() &lt;&lt; endl;\n    for (auto x : sol) {\n        cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/","title":"2 - Polica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Mika je odlu\u010dio da malo preuredi knjige na svojoj (veoma velikoj) polici, ali da se ne bi previ\u0161e umorio, planira da zameni mesta ta\u010dno dve knjige. Svaka knjiga je obele\u017eena jednom cifrom, i Mika defini\u0161e lepotu rasporeda knjiga kao broj koji se dobija kada se ove cifre pro\u010ditaju redom. Pomozite Miki da odabere dve knjige koje \u0107e zameniti, tako da lepota rasporeda nakon toga bude \u0161to ve\u0107a.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Marko Savi\u0107 <p>Da bi raspored dobijen zamenom dve cifre imao najve\u0107u mogu\u0107u lepotu, \u017eelimo da prva cifra bude najve\u0107a mogu\u0107a, pa ako iza \\(A_1\\) postoji neka ve\u0107a vrednost, zameni\u0107emo je sa onom koja je:</p> <ul> <li>najve\u0107a, i ako postoji nekoliko istih</li> <li>poslednjom takvom (da bi stavili manju cifru \\(A_1\\) na mesto sa \u0161to manjom \"te\u017einom\").</li> </ul> <p>Ukoliko ovakva cifra ne postoji, odnosno \\(A_1\\) je ve\u0107a ili jednaka od svih vrednosti desno od nje, isti proces probamo za slede\u0107u cifru \\(A_2\\) (gde kao kandidate za zamenu gledamo samo one desno od \\(A_2\\)), i tako dalje dok ne na\u0111emo par koji se mo\u017ee zameniti.</p> <p>Ukoliko do\u0111emo do kraja broja i nismo ni\u0161ta zamenili, cifre u po\u010detnom rasporedu su opadaju\u0107e, tako da nije mogu\u0107e pove\u0107ati lepotu rasporeda. U ovom slu\u010daju nam je cilj da je smanjimo \u0161to manje (jer moramo napraviti neku zamenu). Ukoliko postoje dve iste cifre, zameni\u0107emo njih da bi lepota ostala ista. U suprotnom, optimalno re\u0161enje je da zamenimo poslednje dve cifre.</p> <p>\"Naivno\" re\u0161enje zadatka koje za svako \\(A_i\\) prolazi kroz sve cifre desno od nje ima vremensku slo\u017eenost \\(O(N^2)\\), tako da se ne\u0107e izvr\u0161iti u datom ograni\u010denju za poslednji podzadatak. Da bi izbegli ovaj korak, na po\u010detku programa mo\u017eemo prona\u0107i poslednje pojavljivanje svake cifre i sa\u010duvati to u pomo\u0107nom nizu, \u0161to se mo\u017ee iskoristiti da za svako \\(A_i\\) na\u0111emo optimalnu zamenu u konstantnom vremenu, i samim tim daje ukupnu vremensku slo\u017eenost \\(O(N)\\).</p> 02_polica.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n\nconst int N = 1000005;\nint a[N], n;\nint last[10];\n\nvoid print_sol(int x, int y)\n{\n    std::swap(a[x], a[y]);\n    for(int i = 0; i &lt; n; i++)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\nint main()\n{\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;a[i]);\n\n    for(int i = 0; i &lt; 10; i++)\n        last[i] = -1;\n    for(int i = 0; i &lt; n; i++)\n        last[a[i]] = i;\n\n    // Povecan broj\n    for(int i = 0; i &lt; n; i++)\n        for(int d = 9; d &gt; a[i]; d--)\n            if(last[d] &gt; i)\n            {\n                print_sol(i, last[d]);\n                return 0;\n            }\n\n    // Ostaje isti\n    for(int i = 0; i &lt; n; i++)\n        if(last[a[i]] &gt; i)\n        {\n            print_sol(i, last[a[i]]);\n            return 0;\n        }\n\n    // Moramo da smanjimo\n    print_sol(n - 1, n - 2);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se jedan broj, \\(N\\): broj knjiga na polici. U drugom redu nalazi se \\(N\\) brojeva, \\(A_1, A_2, \\dots, A_N\\), gde \\(A_i\\) predstavlja cifru napisanu na \\(i\\)-toj knjizi.</p>"},{"location":"takprog/2019_2020/kv2/02_polica/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati \\(N\\) razmakom razdvojenih brojeva: cifre napisane na knjigama na polici, nakon \u0161to su dve knjige zamenile mesta tako da se dobije raspored najve\u0107e mogu\u0107e lepote.</p>"},{"location":"takprog/2019_2020/kv2/02_polica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv2/02_polica/#ulaz","title":"Ulaz","text":"<pre><code>3\n8 2 5\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/#izlaz","title":"Izlaz","text":"<pre><code>8 5 2\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv2/02_polica/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n6 3\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/#izlaz_1","title":"Izlaz","text":"<pre><code>3 6\n</code></pre>"},{"location":"takprog/2019_2020/kv2/02_polica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Za sve \\(i\\), \\(0 \\leq A_i \\leq 9\\).</li> <li>\\(A_1 \\neq 0\\).</li> <li>Barem dve knjige nisu obele\u017eene cifrom 0.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena, \\(N = 2\\).</li> <li>U test primerima vrednim \\(30\\) poena, \\(N \\leq 8\\).</li> <li>U test primerima vrednim \\(20\\) poena, lepota po\u010detnog rasporeda na   polici je najvi\u0161e \\(4 \\cdot 10^{18}\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(N \\leq 1000\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(N \\leq 10^6\\).</li> </ul>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/","title":"3 - Zlatnici","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Kralj Mida je poznat po svom daru da sve \u0161to dotakne postane zlatno. Me\u0111utim, prekasno je shvatio da neopreznim kori\u0161\u0107enjem svog dara mo\u017ee sebi ozbiljno da na\u0161kodi. Naime, on je celu svoju kolekciju nov\u010di\u0107a od bakra, srebra i gvo\u017e\u0111a, pretvorio u beskorisne zlatnike! Izgubiv\u0161i to \u0161to mu je nekada bilo najdra\u017ee, odlu\u010dio je da sve svoje vreme provodi na najbezbedniji mogu\u0107i na\u010din, igraju\u0107i slede\u0107u igru.</p> <p>Pred sobom ima tablu sa \\(N\\) kolona i \\(N\\) vrsta, i na toj tabli stoje \\(N\\) od njegovih mnogobrojnih zlatnika. Svaki zlatnik zauzima ta\u010dno jedno polje table, i nije mogu\u0107e da dva zlatnika budu na istom polju. Mida u jednoj sekudni mo\u017ee da uzme jedan zlatnik i premesti ga na neko polje koje deli stranicu sa poljem na kome se taj zlatnik trenutno nalazi, pri \u010demu ne sme da premesti zlatnik na polje koje je ve\u0107 zauzeto. Midi je cilj da se u svakoj koloni i u svakoj vrsti na\u0111e ta\u010dno jedan zlatnik.</p> <p>Mida je ve\u0107 poprili\u010dno ve\u0161t u ovoj igri, ali ga interesuje da li uspeva da postigne svoj cilj u najmanjem mogu\u0107em vremenu. Me\u0111utim, kako ne \u017eeli da pozlati svoju tastaturu, on je vas zamolio da vi to izra\u010dunate. Od vas tra\u017ei da, za dati po\u010detan raspored zlatnika, odredite najmanje mogu\u0107e vreme za koje on mo\u017ee da pobedi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan broj, \\(N\\): broj vrsta, kolona i zlatnika. Narednih \\(N\\) linija sadr\u017ee po dva prirodna broja \\(r_i\\) i \\(c_i\\), koji ozna\u010davaju da se na po\u010detku \\(i\\)-ti zlatnik nalazi u preseku vrste \\(r_i\\) i kolone \\(c_i\\).</p>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati jedan broj: najmanji broj sekundi potreban Midi da pobedi za zadati raspored zlatnika.</p>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv2/03_zlatnici/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 1\n2 2\n2 3\n</code></pre>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv2/03_zlatnici/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 2\n3 1\n2 3\n</code></pre>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Za prvi primer, o\u010dito Midi treba bar dve sekunde da ne bi bilo dva zlatnika u drugoj vrsti, a mo\u017ee da pobedi u dva poteza tako \u0161to zlatnik na polju \\((2,2)\\) premesti na polje \\((1,2)\\), a zlatnik na polju \\((2,1)\\) premesti na polje \\((3,1)\\).</p> <p>U drugom primeru Mida ne mora ni\u0161ta da uradi da bi pobedio.</p>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 2\\cdot 10^5\\)</li> <li>\\(1\\leq r_i,c_i\\leq N\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(n \\leq 2\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(n \\leq 7\\).</li> <li>U test primerima vrednim \\(30\\) poena: \\(n \\leq 1000\\).</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv2/03_zlatnici/#analiza","title":"Analiza","text":"<p>Posmatrajmo nizove \\(r_i\\) i \\(c_i\\), koji ozna\u010davaju u kojoj se koloni i vrsti nalaze zlatnici. Vidimo da u jednom potezu uzimamo jedan zlatnik i menjamo mu redni broj vrste ili redni broj kolone za \\(\\pm1\\).  Ovo zna\u010di da mi u jednom potezu menjamo vrednost jednog \u010dlana niza \\(r_i\\) za \\(\\pm 1\\), ili jedan \u010dlan niza \\(c_i\\) za \\(\\pm 1\\). Nama je cilj da na kraju oba niza \\(r_i\\) i \\(c_i\\) postanu permutacija skupa \\(\\{1,2,3,\\cdots,n\\}\\). Ozna\u010dimo sa \\(R\\) minimalni broj poteza da se ovo u\u010dini sa nizom \\(r_i\\) a sa \\(C\\) minimalan broj poteza da se ovo uradi sa nizom \\(c_i\\). Tada je tra\u017eeno re\u0161enje o\u010dito barem \\(R+C\\).</p> <p>Re\u0161imo ovo za niz \\(r_i\\).  Ako na kraju dobijemo niz \\(x_i\\) onda nam je trebalo \\(S=|r_1-x_1|+|r_2-x_2|+\\cdots+|r_n-x_n|\\) poteza. Primetimo da ako \\(r_i&lt;r_j\\) i \\(x_i&gt;x_j\\), tada zamenom vrednosti \\(x_i\\) i \\(x_j\\) ne pove\u0107avamo (a potencijalno smanjujemo) rezultat. Ovo se dokazuje analizom slu\u010daja za sve poretke ovih \\(4\\) vrednosti. Ovime vidimo da je jedno od slu\u010dajeva kada se najbolje re\u0161enje dosti\u017ee je kada su brojevi \\(x_i\\) u istom poretku kao i brojevi \\(r_i\\). Ovo zna\u010di da kada je niz \\(r_i\\) sortiran, onda je \\(R=|r_1-1|+|r_2-2|+\\cdots+|r_n-n|\\).  Po istom principu va\u017ei ako je niz \\(c_i\\) sortiran tada \\(C=|c_1-1|+|c_2-2|+\\cdots+|c_n-n|\\).</p> <p>Prvo \u0107emo analizirati \u0161ta se de\u0161ava u slu\u010daju da mogu postojati dva (ili vi\u0161e) nov\u010di\u0107a na istom polju u istom trenutku. Tada su koordinate zlatnike o\u010digledno nezavisne, pa je odgovor upravo \\(R+C\\).</p> <p>Me\u0111utim, ispostavlja se da je ovo odgovor i u pravom zadatku. Ovo je tako jer je mogu\u0107e izvr\u0161iti niz poteza tako da se dostigne jednakost i za \\(R\\) i za \\(C\\) a da pri tome nikad ne budu dva zlatnika na istom polju. Prvo \u0107emo rasporediti zlatnike u razli\u010ditim redovima u optimalnom broju poteza, a posle toga je o\u010dito jasno da nema problema rasporediti ih po razli\u010ditim kolonama jer to \u0161to su u razli\u010ditim redovima garantuje da su na razli\u010ditim poljima. Za taj prvi deo je o\u010dito dovoljno da za svaku kolonu dovedemo zlatnike na prava mesta bez preklopa, jer zlatnici koji kre\u0107u u razli\u010ditim kolonama \u0107e ostati na razli\u010ditim poljima dok samo menjamo u kojim se redovima menjaju. U svakoj koloni \u0107e postojati neki zlatnici koji idu \"na gore\" i oni koji idu \"na dole\". U svakom trenutku \u0107emo uzeti onaj najvi\u0161i koji treba da ide na gore a nije u pravom redu i pomeriti ga na gore ili najni\u017ei koji treva da ide na dole a nije u pravom redu i pomeriti ga na dole. Jasno je da ovako ne\u0107e biti nikad dva na istom polju jer ako neki zlatnik \u0161to ide na gore se poklopi sa nekim \u0161to ide na gore, to je u kontradikciji sa time da smo izabrali najvi\u0161i takav zlatnik, a ako se poklopi sa nekim \u0161to ide na dole, to je u kontradikciji sa time da su po\u010detne vrednosti \\(r_i\\) u istom poretku kao i kona\u010dne vrednosti \\(r_i\\).</p> <p>Ovaj algoritam se sada lako implementira u \\(O(n \\log (n))\\) sa obi\u010dnim sortom ili \\(O(n)\\) sa counting sortom.</p> 03_zlatnici.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 200007\nusing namespace std;\nlong long x[MAXN],y[MAXN];\nint main()\n{\n    int n;\n    long long res=0;\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;=n;i++) scanf(\"%lld%lld\",&amp;x[i],&amp;y[i]);\n    sort(x+1,x+n+1);\n    sort(y+1,y+n+1);\n    for(int i=1;i&lt;=n;i++) res+=abs(x[i]-i);\n    for(int i=1;i&lt;=n;i++) res+=abs(y[i]-i);\n    printf(\"%lld\",res);\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/","title":"4 - JAG","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>JAG\u2122 je nova revolucionarna strate\u0161ka igra kompanije \"Najbolji ltd.\".</p> <p>U igri postoji \\(N\\) teritorija. Neke dve teritorije mogu deliti granicu. Poznato je da ukupno \\(N-1\\) parova teritorija dele granicu, na takav na\u010din da su sve teritorije povezane, tj. od bilo koje teritorije je mogu\u0107e do\u0107i do bilo koje druge, potencijalno prelaze\u0107i preko drugih teritorija.</p> <p>Igru igraju dva igra\u010da, i na po\u010detku partije oni biraju svoje teritorije. Teritorije biraju naizmeni\u010dno prvi pa drugi igra\u010d. Svako od njih izabere ta\u010dno jednu teritoriju koju do sada ni jedan igra\u010d nije izabrao. Ovo se de\u0161ava sve dok postoji teritorija koju ni jedan igra\u010d nije izabrao.</p> <p>Ra\u0161trkanost teritorija prvog igra\u010da jednaka je udaljenosti dve njegove najdalje teritorije (ta\u010dnije broju granica preko kojih je neophodno pre\u0107i na najkra\u0107em putu izme\u0111u te dve teritorije). Prvi igra\u010d \u017eeli da minimizuje ra\u0161trkanost svojih teritorija, dok drugi igra\u010d \u017eeli da maksimizuje taj broj (ra\u0161trkanost teritorija prvog igra\u010da).</p> <p>Ispisati ovu vrednost pri optimalnoj igri oba igra\u010da.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Dragan Uro\u0161evi\u0107 Nikola Milosavljevi\u0107 <p>Skup teritorija mo\u017eemo reprezentovati kao neorijentisan graf, u kome su \u010dvorovi ba\u0161 tih \\(N\\) teritorija, a grane postoje izme\u0111u parova teritorija koje dele zajedni\u010dku granicu.  Taj graf je povezan (jer je od bilo koje teritorije mogu\u0107e do\u0107i do bilo koje druge, potencijalno prelaze\u0107i preko drugih teritorija). Kako ima ta\u010dno \\(N-1\\) grana (jer toliko ima parova teritorija koje dele granicu), to taj graf predstavlja stablo (povezan graf u kome nema petlji/ciklusa). </p> <p>Dijametar stabla je du\u017eina puta izme\u0111u dva najudaljenija \u010dvora (udaljenost se ra\u010duna kao du\u017eina najkra\u0107eg puta, tj. broj grana na najkra\u0107em putu). Ozna\u010dimo sa \\(D\\) dijametar grafa.  Primetimo da ako postoje bar \\(4\\) teritorije takve da je rastojanje izme\u0111u svake dve jednako dijametru \\(D\\), onda drugi igra\u010d mo\u017ee igrati tako da prvi igra\u010d mora obojiti bar dve od te \u010detiri teritorije i zbog toga je tada ra\u0161trkanost teritorija prvog igra\u010da jednaka \\(D\\). Ali ra\u0161trkanost \u0107e biti jednaka \\(D\\) i ako se mogu izdvojiti dve (disjunktne) grupe teritorija (neka su to \\(A\\) i \\(B\\)) koje imaju po bar dva elementa tako da je rastojanje izme\u0111u svake teritorije iz prve grupe i svake teritorije iz druge grupe jednako dijametru \\(D\\). Naime, i u tom slu\u010daju, drugi igra\u010d mo\u017ee igrati tako da prvi igra\u010d mora obojiti po jednu teritoriju iz svake od dveju grupa (misli se na grupe \\(A\\) i \\(B\\)) i tada je ra\u0161trkanosti jednaka \\(D\\). </p> <p>\u0160ta ako stablo (graf) ne zadovoljava gornje uslove? Neka su \\(u\\) i \\(v\\) \u010dvorovi koji su na rastojanju \\(D\\). Pretpostavimo da postoji bar jo\u0161 jedan \u010dvor koji je na rastojanju \\(D\\) od bar jednog od \u010dvorova (neka je \u010dvor \\(w\\) na rastojanju \\(D\\) od \u010dvora \\(u\\)). Tada se mogu izdvojiti dve (disjunktne) grupe \\(A\\) i \\(B\\) (od kojih jedna ima samo jedan element, ina\u010de bi u suprotnom mogli primeniti razmatranje iz prethodnog odeljka) takve da je rastojanje izme\u0111u svaka dva \u010dvora iz te dve grupe jednako dijametru \\(D\\). U ovom slu\u010daju rezultat zavisi od parnosti broja teritorija. Ako je broj teritorija neparan, prvi igra\u010d \"izvodi'' poslednji potez i zbog toga drugi igra\u010d mo\u017ee igrati tako da prvi igra\u010d mora obojiti po jednu teritoriju ia svake od dveju grupa, pa je ra\u0161trkanost jednaka \\(D\\). Ako je broj teritorija paran, onda prvi igra\u010d mo\u017ee igrati tako da ne uzme teritoriju koja se nalazi u grupi sa samo jednom teritorijom. Zbog toga je ra\u0161trkanost jednaka \\(D-1\\).</p> <p>Ako nije va\u017eio ni prethodni uslov, onda postoje ta\u010dno dve teritorije koje su na rastojanju \\(D\\) (neka su to \\(u\\) i \\(v\\)). U tom slu\u010daju se odre\u0111uje koliko ima teritorija koje su na rastojanju \\(D-1\\) od jedne (ili obe) od ove dve teritorije i izvodi se sli\u010dno razmatranje kao u prethodna dva odeljka sa jedinom razlikom \u0161to \u0107e sada ra\u0161trkanost biti \\(D-1\\) ili \\(D-2\\) zavisno od broja teritorija koje su na rastojanju \\(D-1\\) od teritorija \\(u\\) i \\(v\\) (kao i od parnosti broja \\(N\\), ako postoji po ta\u010dno jedna teritorija koja je na rastojanju \\(D-1\\) od svake teritorija \\(u\\) i \\(v\\)).</p> <p>Za kraj kako odrediti dijametar grafa? Jedan od na\u010dina je primenom dva obilaska u dubinu uz odre\u0111ivanje rastojanja svakog od \u010dvorova stabla od polaznog \u010dvora). Prvi obilazak kre\u0107e od proizvoljnog \u010dvora \\(w\\), a drugi od \u010dvora \\(u\\) koji je na najve\u0107em rastojanju od \u010dvora \\(w\\). Neka je \u010dvor \\(v\\) na najve\u0107em rastojanju od \u010dvora \\(u\\). Mo\u017ee se pokazati da je rastojanje izme\u0111u \u010dvorova \\(u\\) i $ v$  jednako dijametru stabla.   </p> <p>Slo\u017eenost opisanog algoritma je \\(O(N)\\).</p> 04_jag.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 2000000\nusing namespace std;\nint n;\nvector&lt;int&gt; a[maxn];\nint d[2][maxn];\nstack&lt;pair&lt;int,int&gt; &gt; st;\nvoid dfs(int u,int id) {\n    st.push({u,-1});\n    d[id][u]=0;\n    while(st.size()&gt;0) {\n        u=st.top().first;\n        int par=st.top().second;\n        st.pop();\n        for(auto v:a[u]) {\n            if(v!=par) {\n                d[id][v]=d[id][u]+1;\n                st.push({v,u});\n            }\n        }\n    }\n}\nint main() {\n    int u,v;\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n-1;i++) {\n        scanf(\"%d %d\",&amp;u,&amp;v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    dfs(1,0);\n    int x=1;\n    for(int i=1;i&lt;=n;i++) {\n        if(d[0][i]&gt;d[0][x]) x=i;\n    }\n    for(int i=1;i&lt;=n;i++) d[0][i]=0;\n    dfs(x,0);\n    int y=1;\n    for(int i=1;i&lt;=n;i++) {\n        if(d[0][i]&gt;d[0][y]) y=i;\n    }\n    dfs(y,1);\n    int diam = d[0][y];\n    int p=0,q=0,r=0,p1=0,q1=0,r1=0;\n    for(int i=1;i&lt;=n;i++) {\n        if(d[0][i]==diam &amp;&amp; d[1][i]==diam) r++;\n        else {\n            if(d[0][i]==diam) p++;\n            if(d[1][i]==diam) q++;\n        }\n        if(d[0][i]==diam-1 &amp;&amp; d[1][i]==diam-1) r1++;\n        else {\n            if(d[0][i]==diam-1) p1++;\n            if(d[1][i]==diam-1) q1++;\n        }\n    }\n    if(n==2) {\n        printf(\"0\");\n        return 0;\n    }\n    if(p&gt;1 || q&gt;1 || r&gt;0) {\n        if((p&gt;=2 &amp;&amp; q&gt;=2) || (p+r&gt;=2 &amp;&amp; q&gt;=2) || (p&gt;=2 &amp;&amp; q+r&gt;=2) || r&gt;=2) printf(\"%d\",diam);\n        else {\n            if(n%2==0) printf(\"%d\",diam-1);\n            else printf(\"%d\",diam);\n        }\n    }\n    else {\n        if((p1&gt;=2 &amp;&amp; q1&gt;=2) || (p1+r1&gt;=2 &amp;&amp; q1&gt;=2) || (p1&gt;=2 &amp;&amp; q1+r1&gt;=2) || r1&gt;=2) printf(\"%d\",diam-1);\n        else {\n            if(n%2==0) printf(\"%d\",diam-2);\n            else printf(\"%d\",diam-1);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalazi se broj \\(N\\), broj teritorija u igri. U narednih \\(N-1\\) redova nalaze se po dva broja \\(u\\) i \\(v\\), koja ozna\u010davaju da \\(u\\) i \\(v\\) dele granicu.</p>"},{"location":"takprog/2019_2020/kv2/04_jag/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jednu vrednost, ra\u0161trkanost teritorija prvog igra\u010da pri optimalnoj igri oba igra\u010da.</p>"},{"location":"takprog/2019_2020/kv2/04_jag/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv2/04_jag/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 2\n1 3\n1 4\n1 5\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv2/04_jag/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 2\n2 3\n3 4\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2019_2020/kv2/04_jag/#objasnjenje-primera-1","title":"Obja\u0161njenje primera 1","text":"<p>Kako god da prvi igra\u010d igra, mora izabrati bar dve teritorije iz skupa \\(\\{2,3,4,5\\}\\). Izme\u0111u bilo koje dve od njih je rastojanje dva.</p>"},{"location":"takprog/2019_2020/kv2/04_jag/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 10^{5}\\)</li> <li>\\(1 \\leq u, v \\leq n\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N \\leq 10\\).</li> <li>U test primerima vrednim 10 poena: Teritorije \\(i\\) i \\(i+1\\) dele granicu, za svako \\(i\\) za koje va\u017ei \\(1 \\leq i &lt; N\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 10^3\\).</li> <li>U test primerima vrednim 50 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv2/05_gric/","title":"5 - Gric","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Kao nagradu za izuzetan uspeh na prvom krugu kvalifikacija, Aleksa je dobio na poklon par\u010de keksa u obliku pravougaonika dimenzija \\(W \\times H\\), i postavio ga je u ravan tako da mu se temena nalaze na koordinatama \\((0, 0), (W, 0), (W, H)\\) i \\((0, H)\\). Njegov arhineprijatelj Pavle se namera\u010dio na ovo par\u010de keksa i planira da ga pojede. Pavletova vilica se mo\u017ee opisati krugom polupre\u010dnika \\(R\\). Tokom \\(i\\)-tog minuta desi se jedan od slede\u0107a dva doga\u0111aja:</p> <ul> <li> <p>\\(1\\) \\(x_i\\) \\(y_i\\): Pavle pozicionira svoju vilicu tako da se centar kruga nalazi u ta\u010dki sa koordinatama \\((x_i, y_i)\\), zatim grize keks odnosno uklanja sav sadr\u017eaj keksa koji se nalazi u njegovoj vilici,</p> </li> <li> <p>\\(2\\) \\(x_i\\): Aleksa uzima lenjir, postavlja ga tako da bude paralelan sa \\(y\\)-osom, tako da prolazi kroz ta\u010dku \\((x_i, 0)\\) i meri du\u017einu trenutno preostalog par\u010deta keksa koje se preklapa sa ivicom lenjira.</p> </li> </ul> <p>Da li mo\u017eete da predvidite koje rezultate merenja \u0107e Aleksa dobiti?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Nikola Pe\u0161i\u0107 <p>Na osnovu ograni\u010denja \\(y_i \\geq H\\) mo\u017eemo zaklju\u010diti da \u0107e, ukoliko posmatramo proizvoljnu vertikalnu pravu koja prolazi kroz keks, u svakom trenutku, presek preostalog keksa sa tom pravom biti ili prazan, ili \u0107e biti jedna du\u017e. Kad ovo ograni\u010denje ne bi postojalo, bilo bi mogu\u0107e da Pavle pojede par\u010de iz \"sredine\" keksa, u tom slu\u010daju bi taj presek mogao da se sastoji iz vi\u0161e du\u017ei. Osnovna ideja koja je zajedni\u010dka svim re\u0161enjima jeste da se odr\u017eava niz \\(b\\), gde je \\(b_i\\) preostalo par\u010de keksa na poziciji \\(x = i\\). U po\u010detku, pre svih upita imamo \\(b_i = 0\\) za svako \\(i \\in [0, W]\\). Treba obratiti pa\u017enju pri implementaciji da se ne \u0161tampa negativan broj, odnosno, ako neki krug prelazi iks-osu, ne treba smanjivati \\(b_i\\) ispod \\(0\\).</p> <p>U prvom podzadatku, radijus kruga je \\(1\\), pa su izmene na nizu \\(b\\) trivijalne - ukoliko krug ima \\(y=H\\), stavljamo \\(b_{x} = H-1\\).</p> <p>U drugom podzadatku, postavljamo \\(b_x = \\min(b_x, y-2)\\) i \\(b_{x-1} = \\min(b_{x-1}, y - \\sqrt{3})\\), sli\u010dno za \\(b_{x+1}\\), naravno, ukoliko su ove \\(x\\)-koordinate u segmentu \\([0, W]\\). Vremenska slo\u017eenost re\u0161enja prva dva podzadatka je \\(O(Q + W)\\).</p> <p>Tre\u0107i podzadatak je uop\u0161tenje prethodne ideje. Ta\u010dna vrednost na koju treba postaviti broj \\(b_i\\) je \\(\\min(b_i, y - \\sqrt{(R+i-x)(R-i+x)})\\) za sve \\(i \\in [0, W] \\cap [x-R, x+R]\\). Ova formula se mo\u017ee izvesti geometrijski, pomo\u0107u Pitagorine teoreme. Vremenska slo\u017eenost je \\(O(W + QR)\\).</p> <p>Za re\u0161avanje \u010detvrtog i petog podzadatka neophodne su nam slede\u0107e opservacije. Prva je ta da je dovoljno posmatrati oblik koji formiraju donji polukru\u017eni lukovi dodatih krugova. Druga, klju\u010dna je da se nijedna dva takva luka ne mogu se\u0107i vi\u0161e od jednom, osim ako se ne poklapaju. Ovo se mo\u017ee dokazati na slede\u0107i na\u010din: Posmatrajmo neka dva kruga. Ukoliko se oni ne poklapaju, oni se mogu se\u0107i na najvi\u0161e dva mesta. Na osnovu toga \u0161to imaju isti radijus, ta\u010dke preseka su centralno simetri\u010dno raspore\u0111ene u odnosu na ta\u010dku koja se nalazi na sredini du\u017ei koja spaja centre ta dva kruga. Kako ovaj centar ima \\(y\\)-koordinatu ve\u0107u nego \"ni\u017ei\" od ta dva kruga, i jedna od prese\u010dnih ta\u010daka sigurno isto ima ve\u0107u \\(y\\)-koordinatu od centra ni\u017eeg druga, pa ne u\u010destvuje u preseku donjih polukru\u017enica.</p> <p>\u010cetvrti podzadatak se mo\u017ee re\u0161iti tako \u0161to se eksplicitno izra\u010duna oblik keksa. Sortiramo sve krugove po \\(x\\)-koordinati i obra\u0111ujemo ih u ovom redosledu. Pomo\u0107u steka odr\u017eavamo skup polukru\u017enica koje u\u010destvuju u kona\u010dnom obliku keksa, kao i pozicije preseka susednih polukru\u017enica. Odgovor na neki upit mo\u017eemo na\u0107i binarnom pretragom po dobijenom nizu polukru\u017enica, ili jednostavnije, obradom celog niza polukru\u017enica tj. eksplicitnim nala\u017eenjem svih vrednosti \\(b_i\\), u jednom prolazu kroz niz. Ovo re\u0161enje je primenljivo upravo zato \u0161to se svake dve polukru\u017enice seku najvi\u0161e jednom. Ovu ideju nije mogu\u0107e primeniti ukoliko to ne bi va\u017eilo, na primer, ako bi se radijusi datih kru\u017enica razlikovali. Vremenska slo\u017eenost je \\(O(W + Q \\log Q)\\).</p> <p>Odavde je jasno da re\u0161enje \u010detvrtog podzadatka podse\u0107a na ono \u0161to se zove \"trik sa konveksnim omota\u010dem\", gde se nalazi oblik koji formira presek poluravni. Drugi na\u010din da se izra\u010duna ovaj presek poluravni jeste pomo\u0107u takozvanog LiChao segmentnog stabla, pa je prirodno poku\u0161ati prilagoditi tu strukturu podataka za ovaj problem.</p> <p>Naime, formirajmo segmentno stablo, gde se u svakom \u010dvoru nalazi opis jedne polukru\u017enice, koja cela pokriva pridru\u017eeni segment u stablu, odnosno, takva da ako je \u010dvor odgovoran za segment \\([x_l, x_r]\\), tada za kru\u017enicu va\u017ei \\(x-R \\leq x_l \\leq x_r \\leq x+R\\) (uslov 1), gde je \\((x,y)\\) njen centar. Dodatno, name\u0107emo ograni\u010denje da za list, tj. \u010dvor koji odgovara segmentu \\([x, x]\\), put u stablu od tog lista do korena sadr\u017ei krug koji u \\(x\\) dosti\u017ee najmanju \\(y\\)-koordinatu, u svakom trenutku. Ako ovo va\u017ei, jasno je da na upit mo\u017eemo odgovoriti u \\(O(\\log W)\\), samo posmatranjem tih \\(O(\\log W)\\) \u010dvorova na putu od lista do korena.</p> <p>Kako dodati novi krug? Posmatrajmo rekurzivnu funkciju koja polazi od korena stabla, koji odgovara \u010dvoru koji \u010duva segment \\([0, W]\\). Ukoliko za trenutni \u010dvor ne va\u017ei uslov 1, i segmenti koji odgovaraju krugu i \u010dvoru se ne seku, mo\u017eemo odmah iza\u0107i, ina\u010de rekurzivno dodajemo krug u oba \u010dvora deteta trenutnog \u010dvora. Na dalje pretpostavimo da uslov 1 va\u017ei. Ako u trenutnom \u010dvoru nema nikakvog kruga, slobodno mo\u017eemo staviti u taj \u010dvor novi krug i iza\u0107i iz funkcije. Jo\u0161 jedan slu\u010daj gde mo\u017eemo odmah staviti krug i iza\u0107i jeste ako je novi polukrug ceo ispod starog na celom segmentu trenutnog \u010dvora \\([x_l, x_r]\\), \u0161to se mo\u017ee jednostavno proveriti ako izra\u010dunamo \\(y\\)-koordinate preseka polukrugova sa \\([x_l, x_r]\\), kao po formuli datoj u re\u0161enju podzadatka 3. Ukoliko je novi polukrug ceo iznad starog na tom segmentu, ne moramo da ga dodajemo, ve\u0107 odmah izlazimo iz funkcije. Ina\u010de, ova dva polukruga se seku na ta\u010dno jednom mestu, unutar segmenta. U taj \u010dvor mo\u017eemo upisati onaj od ta dva kruga koji je \"dominantan\" na bar jednoj polovini segmenta, dok drugi mo\u017eemo rekurzivno ubaciti u drugo dete trenutnog \u010dvora. Vremenska slo\u017eenost ovog postupka se razlikuje od onog za obi\u010dno segmentno stablo. U toku rekurzije dolazimo do \\(O(\\log W)\\) \u010dvorova za koje va\u017ei uslov 1, a za svaki od njih imamo po jedan rekurzivni put koji se mo\u017ee sastojati iz najvi\u0161e \\(O(\\log W)\\) \u010dvorova, pa je vremenska slo\u017eenost dodavanja jednog kruga \\(O(\\log^2W)\\), a celog re\u0161enja \\(O(W + Q \\log^2 W)\\).</p> 05_gric.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\ntypedef long double ld;\nconst int maxn = 131072;\n\nint h, w, r, q;\n\nstruct krug {\n    int x, y;\n\n    krug(int x=1e8, int y=1e8) : x(x), y(y) {}\n\n    ld operator* (int t) const {\n        if (t &lt; x-r || t &gt; x+r)\n            return 1e50;\n        return y - sqrt(ld(r+t-x)*(r-t+x));\n    }\n};\n\nkrug b[2*maxn];\n\nvoid dodaj(krug v, int x, int xl, int xr) {\n    if (v.x + r &lt; xl || xr &lt; v.x - r)\n        return;\n    if (v.x - r &lt;= xl &amp;&amp; xr &lt;= v.x + r) {\n        ld vl = v * xl, vr = v * xr;\n        ld bl = b[x] * xl, br = b[x] * xr;\n        if (vl &lt;= bl &amp;&amp; vr &lt;= br) {\n            b[x] = v;\n            return;\n        }\n        if (vl &gt;= bl &amp;&amp; vr &gt;= br)\n            return;\n        if (vl &lt; bl)\n            swap(b[x], v);\n    }\n    int xm = (xl+xr) &gt;&gt; 1;\n    dodaj(v, 2*x, xl, xm);\n    dodaj(v, 2*x+1, xm+1, xr);\n}\n\nld racunaj(int p, int x, int xl, int xr) {\n    ld sol = b[x] * p;\n    if (xl != xr) {\n        int xm = (xl+xr) &gt;&gt; 1;\n        if (p &lt;= xm)\n            sol = min(sol, racunaj(p, 2*x, xl, xm));\n        else\n            sol = min(sol, racunaj(p, 2*x+1, xm+1, xr));\n    }\n    return sol;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout &lt;&lt; setprecision(12) &lt;&lt; fixed;\n\n    cin &gt;&gt; w &gt;&gt; h &gt;&gt; r &gt;&gt; q;\n    for (int i=0; i&lt;=w; i++)\n        dodaj(krug(i, h+r), 1, 0, w);\n    while (q--) {\n        int t;\n        cin &gt;&gt; t;\n        if (t == 2) {\n            int x;\n            cin &gt;&gt; x;\n            cout &lt;&lt; max(ld(0), racunaj(x, 1, 0, w)) &lt;&lt; '\\n';\n        } else if (t == 1) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            dodaj(krug(x, y), 1, 0, w);\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv2/05_gric/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se \u010detiri prirodna broja, odvojena razmakom: \\(W, H, R, Q\\). U narednih \\(Q\\) linija, nalaze se dva ili tri broja: \\(1, x_i, y_i\\) ili \\(2, x_i\\), odvojena razmakom, koji opisuju \\(i\\)-ti doga\u0111aj.</p>"},{"location":"takprog/2019_2020/kv2/05_gric/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki doga\u0111aj tipa \\(2\\) ispisati jedan realan broj - rezultat odgovaraju\u0107eg merenja. Ukoliko je ta\u010dno re\u0161enje tog merenja \\(b\\), a va\u0161 program ispisuje broj \\(a\\), va\u0161 izlaz \u0107e se smatrati ta\u010dnim ukoliko va\u017ei \\(\\frac{|a-b|}{\\max(1,b)} \\leq 10^{-6}\\).</p>"},{"location":"takprog/2019_2020/kv2/05_gric/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv2/05_gric/#ulaz","title":"Ulaz","text":"<pre><code>3 2 2 5\n2 1\n1 2 3\n2 0\n2 1\n2 2\n</code></pre>"},{"location":"takprog/2019_2020/kv2/05_gric/#izlaz","title":"Izlaz","text":"<pre><code>2.000000000000\n2.000\n1.267949192431\n1\n</code></pre>"},{"location":"takprog/2019_2020/kv2/05_gric/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Pre nego \u0161to je Pavle odgrizao par\u010de keksa, na bilo kojoj \\(x\\)-koordinati bila bi izmerena vrednost \\(H = 2\\). Nakon \u0161to je odgrizao par\u010de keksa, na koordinati \\(x = 0\\) je du\u017eina \\(2\\), na \\(x = 1\\) je \\(3 - \\sqrt{3} \\approx 1.268\\) a na \\(x = 2\\) je \\(1\\) (videti sliku).</p> <p></p>"},{"location":"takprog/2019_2020/kv2/05_gric/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq W, H, R, Q \\leq 10^5\\)</li> <li>\\(0 \\leq x_i \\leq W\\)</li> <li>\\(H \\leq y_i \\leq H+R\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena: \\(R = 1\\).</li> <li>U test primerima vrednim 10 poena: \\(R = 2\\).</li> <li>U test primerima vrednim 10 poena: \\(Q \\times W \\leq 10^6\\).</li> <li>U test primerima vrednim 20 poena: Svaki doga\u0111aj tipa \\(2\\) se javlja nakon svih doga\u0111aja tipa \\(1\\).</li> <li>U test primerima vrednim 50 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv2/05_gric/#napomena","title":"Napomena","text":"<p>Da biste izbegli probleme sa precizno\u0161\u0107u, koristite tipove <code>double</code> ili <code>long double</code> u jeziku <code>C++</code>, i ispisujte re\u0161enje na bar \\(9\\) decimala.</p>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/","title":"1 - Upoznavanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Milo\u0161 se nedavno preselio u jednodimenzionalni prostor. Njegova ku\u0107a se nalazi na \\(x\\) metara od koordinatnog po\u010detka. On tako\u0111e zna da ima \\(n\\) kom\u0161ija i zna koordinate njihovih ku\u0107a.</p> <p>Kao i svaki pristojan stanovnik jednodimenzionalnog prostora, Milo\u0161 bi \u017eeleo da se upozna sa svim svojim kom\u0161ijama. On zna da mu je za pe\u0161a\u010denje jednog metra potrebna jedna sekunda.</p> <p>Pomozite Milo\u0161u i recite mu koliko mu je najmanje sekundi potrebno da obi\u0111e sve svoje kom\u0161ije.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Pe\u0161i\u0107 Lazar Milenkovi\u0107 Dragan Uro\u0161evi\u0107 Vladimir Milenkovi\u0107 <p>Re\u0107i \u0107emo da su kom\u0161ije \u010dija je pozicija manja od Milo\u0161eve pozicije kom\u0161ije levo, a kom\u0161ije \u010dija je pozicija ve\u0107a od Milo\u0161eve pozicije kom\u0161ije desno. Ako su sve kom\u0161ije levo od Milo\u0161a, onda \u0107e najbr\u017ee upoznati sve kom\u0161ije tako \u0161to krene ulevo i upoznaje kom\u0161ije u redosledu u kome sti\u017ee do svakog od njih. U tom slu\u010daju \u0107e vreme upoznavanja biti razlika Milo\u0161eve pozicije i pozicije krajnje levog kom\u0161ije. Sli\u010dno, ako su sve kom\u0161ije desno od Milo\u0161a, onda kre\u0107e udesno i upoznaje kom\u0161ije u redosledu u kome sti\u017ee do svakog od njih. Tada \u0107e vreme upoznavanja biti razlika izme\u0111u pozicije krajnje desnog kom\u0161ije i Milo\u0161eve pozicije. Ostaje da re\u0161imo slu\u010daj kada postoji bar jedan kom\u0161ija levo i bar jedan kom\u0161ija desno.</p> <p>Poka\u017eimo da Milo\u0161 u optimalnom postupku (redosledu) upoznavanja sa prijateljima ne mo\u017ee pro\u0107i dva ili vi\u0161e puta \"pored\" svoje ku\u0107e. Neka su kom\u0161ije sortirane prema svojoj poziciji, tj. tako da je $$ a_1 \\leqslant a_2 \\leqslant a_3 \\leqslant \\dotsb \\leqslant a_n. $$</p> <p>Neka je u optimalnom postupku upoznavanja, Milo\u0161 i\u0161ao na desno do kom\u0161ije \\({r_1}\\), zatim se \"vratio\" do kom\u0161ije \\(l\\), a potom od kom\u0161ije \\({l}\\) ponovo krenuo udesno do kom\u0161ije \\({r_2}\\) (\\(r_2 &gt; r_1\\)).  Tada je vreme upoznavanja tih kom\u0161ija iznosilo $$ (a_{r_1} \u2013 x) + (a_{r_1} \u2013 a_l) + (a_{r_2} \u2013 a_{l}). $$ Me\u0111utim, ako bi Milo\u0161 i\u0161ao prvo ulevo do kom\u0161ije \\(l\\), a nakon toga udesno do kom\u0161ije \\({r_2}\\), upoznao bi isti skup kom\u0161ija, ali bi vreme upoznavanja iznosilo $$ (x \u2013 a_l) + (a_{r_2} \u2013 a_{l}). $$ Lako se pokazuje da va\u017ei: $$ (a_{r_1} \u2013 x) + (a_{r_1} \u2013 a_l) + (a_{r_2} \u2013 a_{l}) &gt;  (a_{r_1} \u2013 a_l) + (a_{r_2} \u2013 a_{r_1})  &gt; (x \u2013 a_l) + (a_{r_2} \u2013 a_{r_1}). $$ Na sli\u010dan na\u010din bi se postupilo da je i\u0161ao ulevo do kom\u0161ije \\({l_1}\\), zatim udesno do \\(r\\) i nakon toga ponovo ulevo do kom\u0161ije \\({l_2}\\) (\\(l_2 &lt; l_1\\)). Taj raspored bi se mogao zameniti rasporedom u kome bi i\u0161ao udesno do kom\u0161ije \\(r\\), a zatim ulevo do kom\u0161ije \\({l_2}\\) (a vreme upoznavanja za taj raspored je manje). </p> <p>Prema tome, ako postoji bar jedan kom\u0161ija levo i bar jedan kom\u0161ija desno, izdvajaju se dva redosleda za upoznavanje kom\u0161ija:</p> <ul> <li>Milo\u0161 mo\u017ee i\u0107i ulevo do krajnje levog kom\u0161ije, a zatim udesno do krajnje desnog kom\u0161ije, ili</li> <li>Milo\u0161 mo\u017ee i\u0107i udesno do krajnje desnog kom\u0161ije, a zatim ulevo do krajnje levog kom\u0161ije.</li> </ul> <p>Vreme upoznavanja u prvoj varijanti je $$ x-a_1 + a_n \u2013 a_1,   $$ a u drugoj varijanti je $$ a_n \u2013 x + a_n \u2013 a_1. $$ Minimalno vreme upoznavanja je $$ \\min{ x-a_1 + a_n \u2013 a_1, a_n-x + a_n \u2013 a_1,} = a_n \u2013 a_1 + \\min{x-a_1, a_n \u2013 x}. $$ Za kraj primetimo da niz \\(a\\) nije neophodno sortirati jer je su nam potrebne samo vrednosti prvog i poslednjeg elementa sortiranog niza, a to su zapravo najmanji i najve\u0107i element niza. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(n)\\).</p> 01_upoznavanje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char *argv[]) {\n    ios_base::sync_with_stdio(false);\n//    string path = argv[1];\n//    freopen(path.c_str(), \"r\", stdin);\n//    path = path.substr(0, path.length() - 2) + \"out\";\n//    freopen(path.c_str(), \"w\", stdout);\n\n    int n, x;\n    cin &gt;&gt; n &gt;&gt; x;\n    int mini = x, maxi = x;\n    for (int i = 0; i &lt; n; i++) {\n        int y;\n        cin &gt;&gt; y;\n        mini = min(mini, y);\n        maxi = max(maxi, y);\n    }\n    cout &lt;&lt; min(x - mini, maxi - x) + maxi - mini;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se dva cela broja \\(n\\) i \\(x\\), broj kom\u0161ija i pozicija Milo\u0161eve ku\u0107e. Drugi red sadr\u017ei \\(n\\) celih brojeva, \\(a_1, a_2, \\dots, a_n\\), gde je \\(a_i\\) pozicija \\(i\\)-tog Milo\u0161evog kom\u0161ije.</p>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati jedan ceo broj koji predstavlja minimalno vreme potrebno Milo\u0161u da obi\u0111e sve svoje kom\u0161ije.</p>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#ulaz","title":"Ulaz","text":"<pre><code>2 1\n4 7\n</code></pre>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#ulaz_1","title":"Ulaz","text":"<pre><code>3 4\n3 7 9\n</code></pre>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#izlaz_1","title":"Izlaz","text":"<pre><code>7\n</code></pre>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, Milo\u0161 treba da se kre\u0107e na desno sve do ku\u0107e sa koordinatom \\(7\\).</p> <p>U drugom primeru, Milo\u0161 prvo obilazi levog kom\u0161iju na poziciji \\(3\\), a nakon toga se kre\u0107e na desno do kom\u0161ije sa koordinatom \\(9\\).</p>"},{"location":"takprog/2019_2020/kv3/01_upoznavanje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\le n \\le 10^6\\)</li> <li>\\(-10^8 \\le x \\le 10^8\\)</li> <li>\\(-10^8 \\le a_i \\le 10^8\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena: \\(n \\le 10\\).</li> <li>U test primerima vrednim 15 poena: sve kom\u0161ije se nalaze desno od Milo\u0161a.</li> <li>U test primerima vrednim 15 poena: sve kom\u0161ije se nalaze levo od Milo\u0161a.</li> <li>U test primerima vrednim 40 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv3/02_lubenice/","title":"2 - Lubenice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Ante, ro\u0111eni brat Milo\u0161a (iz prvog zadatka), doselio se zajedno sa svojim bratom u novi kom\u0161iluk. Za razliku od Milo\u0161a koji je odlu\u010dio da poseti kom\u0161ije, Ante misli da je dobar odnos sa kom\u0161inicama mnogo zna\u010dajniji za njegovo budu\u0107e postojanje. On je odredio tri omiljene kom\u0161inice (Lanu i jo\u0161 dve), i re\u0161io da njima pokloni sve\u017ee lubenice. Ante ukupno ima \\(N\\) lubenica, Lani \u0107e pokloniti \\(\\lceil \\frac{N}{p} \\rceil\\) lubenica, drugoj kom\u0161inici \\(\\lceil \\frac{N}{q} \\rceil\\) i tre\u0107oj \\(\\lceil \\frac{N}{r} \\rceil\\). Izraz \\(\\lceil x \\rceil\\) predstavlja broj \\(x\\) zaokru\u017een na gore (npr. \\(\\lceil 4.1 \\rceil  = 5\\), \\(\\lceil 7 \\rceil  = 7\\)).</p> <p>Primetimo da podela koju je Ante naveo nije mogu\u0107a za sve kombinacije brojeva \\(N, p, q, r\\) (mo\u017ee se desiti da on treba da pokloni vi\u0161e lubenica kom\u0161inicama nego \u0161to ih stvarno ima). Njega zanima da za fiksne brojeve \\(p, q, r\\) odredi koliko ima prirodnih brojeva \\(N\\) iz nekog intervala \\([L, R]\\) za koje je mogu\u0107a podela \\(N\\) lubenica (tj. za koliko prirodnih brojeva \\(N\\) iz intervala \\([L, R]\\) va\u017ei nejedankost \\(\\lceil \\frac{N}{p} \\rceil + \\lceil \\frac{N}{q} \\rceil + \\lceil \\frac{N}{r} \\rceil \\leq N\\)).  </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Nikola Jovanovi\u0107 Nikola Jovanovi\u0107"},{"location":"takprog/2019_2020/kv3/02_lubenice/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva i jedina linija ulaza sadr\u017ei redom pet brojeva \\(p, q, r, L, R\\). </p>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji izlaza ispisati za koliko razli\u010ditih brojeva lubenica iz intervala \\([L, R]\\) je podela lubenica mogu\u0107a.</p>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv3/02_lubenice/#ulaz","title":"Ulaz","text":"<pre><code>2 3 7 9 14\n</code></pre>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv3/02_lubenice/#ulaz_1","title":"Ulaz","text":"<pre><code>3 4 5 1 1000000000000000000\n</code></pre>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#izlaz_1","title":"Izlaz","text":"<pre><code>999999999999999998\n</code></pre>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#objasnjenje-primera-1","title":"Obja\u0161njenje primera 1","text":"<p>U prvom primeru validna podela postoji ako imamo \\(12\\) ili \\(14\\) lubenica.</p>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq p, q, r \\leq 10\\)</li> <li>\\(1 \\leq L\\leq R \\leq 10^{18}\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe.</p> <ul> <li>U primerima vrednim 20 poena \\(L, R \\leq 10^5\\)</li> <li>U primerima vrednim 25 poena \\(p = 2, q = 3, r = 7\\).</li> <li>U primerima vrednim 55 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv3/02_lubenice/#analiza","title":"Analiza","text":"<p>Primetimo da za svako \\(k\\) i svako \\(N\\) va\u017ei \\(\\lceil\\frac{N}{k}\\rceil \\geq \\frac{N}{k}\\), iz \u010dega sledi nejednakost \\(\\lceil\\frac{N}{p}\\rceil + \\lceil\\frac{N}{q}\\rceil + \\lceil\\frac{N}{r}\\rceil \\geq \\frac{N}{p} +\\frac{N}{q}+\\frac{N}{r}\\). U skladu sa ovim, razdvajamo problem na tri slu\u010daja u zavisnosti od vrednosti \\(p,q,r\\):</p> <p>Prvi slu\u010daj: \\(\\frac{N}{p} +\\frac{N}{q}+\\frac{N}{r}&gt;N\\) \\(\\Leftrightarrow\\) \\(pq+pr+qr &gt; pqr\\) - Iz gornje nejednakosti imamo \\(\\lceil\\frac{N}{p}\\rceil + \\lceil\\frac{N}{q}\\rceil + \\lceil\\frac{N}{r}\\rceil &gt; N\\), pa uslov tra\u017een u zadatku ne mo\u017ee biti ispunjen ni za jedno \\(N\\), te je kona\u010dno re\u0161enje \\(0\\), nezavisno od vrednosti \\(L\\) i \\(R\\).</p> <p>Drugi slu\u010daj: \\(\\frac{N}{p} +\\frac{N}{q}+\\frac{N}{r}=N\\) \\(\\Leftrightarrow\\) \\(pq+pr+qr = pqr\\) - U ovom slu\u010daju imamo da je uslov tra\u017een u zadatku ispunjen samo ako je \\(\\lceil\\frac{N}{p}\\rceil + \\lceil\\frac{N}{q}\\rceil + \\lceil\\frac{N}{r}\\rceil = \\frac{N}{p} +\\frac{N}{q}+\\frac{N}{r}\\), \u0161to je mogu\u0107e samo ako \\(p|N\\) i \\(q|N\\) i \\(r|N\\), \u0161to je ekvivalentno tome da \\(d | N\\), gde je \\(d=NZS(p,q,r)\\). Dakle, treba na\u0107i broj prirodnih brojeva deljivih sa \\(d\\) u intervalu \\([L,R]\\). Ovo dobijamo ra\u010dunanjem broja takvih brojeva u \\([1,R]\\) i oduzimanjem broja takvih brojeva u \\([1,L-1]\\):  \\(\\frac{R}{d} - \\frac{L-1}{d}\\).</p> <p>Tre\u0107i slu\u010daj: \\(\\frac{N}{p} +\\frac{N}{q}+\\frac{N}{r}&lt;N\\) \\(\\Leftrightarrow\\) \\(pq+pr+qr &lt; pqr\\) - Poslednji slu\u010daj je najslo\u017eeniji jer nas prvobitna nejednakost ne dovodi direktno do zaklju\u010dka, tj. da li je podela mogu\u0107a za neko \\(N\\) zavisi na netrivijalan na\u010din od deljivosti sa \\(p,q,r\\).  - Iako nas ograni\u010denja za \\(L\\) i \\(R\\) odvra\u0107aju od brute-force re\u0161enja (prolazak kroz sve brojeve od \\(L\\) i \\(R\\) i provera da li je tra\u017eeni izraz ta\u010dan), \u010desto je u ovakvim situacijama, kada je potrebno prona\u0107i \u0161ablon, dobra ideja generisanje i posmatranje vrednosti koje brute-force proizvede. Ukoliko to ovde uradimo za npr. \\((p,q,r)=(2,3,7)\\) (drugi podzadatak) i \\((L,R)=(1,300)\\) mo\u017eemo primetiti da je podela mogu\u0107a za svako \\(N \\in [50, 300]\\), iz \u010dega prirodno pretpostavljamo da je mogu\u0107a za svako \\(N \\geq 50\\). U ovu pretpostavku se mo\u017eemo dodatno ubediti pove\u0107avanjem \\(R\\). - Ukoliko je ovo ta\u010dno za \\((p,q,r)=(2,3,7)\\), ta\u010dno je i za svako drugo \\((p' \\leq q' \\leq r')\\) koje spada u tre\u0107i slu\u010daj, jer mora da va\u017ei \\(p'&gt;p, q'&gt;q, r'&gt;r\\) (proveriti!) pa je stoga (ako je na\u0161a pretpostavka ta\u010dna) za svako  \\(N &gt; 50\\): \\(\\lceil\\frac{N}{p'}\\rceil + \\lceil\\frac{N}{q'}\\rceil + \\lceil\\frac{N}{r'}\\rceil \\leq \\lceil\\frac{N}{p}\\rceil + \\lceil\\frac{N}{q}\\rceil + \\lceil\\frac{N}{r}\\rceil  \\leq N\\). - Ovo nas dovodi do efikasnog re\u0161enja za tre\u0107i slu\u010daj: za svako \\(N &lt; 50\\) u \\([L,R]\\) proverimo uslov \"ru\u010dno\", dok za \\(N \\geq 50\\) pretpostavimo da sigurno va\u017ei. Ovo se ispostavlja kao ta\u010dno, a ukoliko \u017eelimo da budemo u potpunosti sigurni mogu\u0107e je tvrdnju sli\u010dnu na\u0161oj pretpostavci i malo formanije dokazati (hint: posmatrati pona\u0161anje izraza \\(\\lceil\\frac{N}{p}\\rceil + \\lceil\\frac{N}{q}\\rceil + \\lceil\\frac{N}{r}\\rceil\\) za \\(nzs(p,q,r)|N\\)).</p> 02_lubenice.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint k1, k2, k3;\nlong long l, r;\n\nint lcm(int x, int y)\n{\n    return x * y / __gcd(x, y) ;\n}\n\nint main()\n{\n    cin&gt;&gt; k1 &gt;&gt; k2 &gt;&gt; k3 &gt;&gt; l &gt;&gt; r ;\n\n    int sum = k1 * ( k2 + k3 ) + k2 * k3 ;\n\n    if (sum &gt; k1 * k2 * k3) return !printf(\"0\\n\") ;\n\n    if ( sum == k1 * k2 * k3 )\n    {\n        long long nzs = lcm( lcm ( k1, k2 ), k3) ;\n        return !printf( \"%lld\\n\", r / nzs - ( l - 1) / nzs ) ;\n    }\n\n    long long ans = 0;\n    for (long long i = l ; i&lt;= min(l + 3000, r) ; i++)\n    {\n         long long val =  (i + k1 - 1)/k1 + (i + k2 - 1)/k2 + (i + k3 - 1) / k3 ;\n         if (val &lt;= i) ans++;\n    }\n\n    ans += r - min( l + 3000, r ) ;\n\n    return !printf( \"%lld\\n\", ans ) ;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/","title":"3 - Sazve\u017e\u0111a","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 64MB <p>Nena je sino\u0107 sanjala da gleda u zvezdano nebo, koje se mo\u017ee zamisliti kao dvodimenziona ravan, u kojoj se nalaze zvezde, koje su predstavljene kao ta\u010dke. Kada se probudila, pored toga \u0161to je shvatila da kasni, zaboravila je skoro sve detalje svog sna. Jedino \u0161to je zapamtila je \\(K\\), broj kolinearnih trojki ta\u010daka. Formalno, ako su zvezde bile razli\u010dite ta\u010dke \\(A_1, A_2, \\ldots, A_N\\), broj kolinearnih trojki je broj ure\u0111enih trojki \\((i,j,k)\\) takvih da je \\(1 \\leq i &lt; j &lt; k \\leq N\\) i ta\u010dke \\(A_i, A_j, A_k\\) su kolinearne.</p> <p>Pomozite Neni tako \u0161to \u0107ete joj re\u0107i jedan skup sa najvi\u0161e \\(2000\\) razli\u010ditih ta\u010daka za koji va\u017ei da je broj kolinearnih trojki ta\u010dno \\(K\\). Nena voli cele brojeve, a ne voli brojeve kojima je apsolutna vrednost ve\u0107a od \\(10^9\\), pa koordinate va\u0161eg skupa ta\u010daka tako\u0111e moraju zadovoljavati ove osobine. Nije potrebno minimizovati broj ta\u010daka. Garantuje se da pod datim ograni\u010denjima uvek postoji bar jedno re\u0161enje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 Marko Savi\u0107 <p>Ukoliko imamo \\(x\\) ta\u010daka i sve le\u017ee na istoj pravoj, svaka trojka je kolinearna, pa je broj takvih trojki jednak \\(\\binom{x}{3}\\). Jedno re\u0161enje je da se napravi niz brojeva \\(b_1, b_2, \\ldots, b_m\\) takav da va\u017ei \\(\\binom{b_1}{3} + \\binom{b_1}{3} + \\ldots + \\binom{b_m}{3} = K\\) i da se izgeneri\u0161e \\(m\\) pravih, da se na \\(i\\)-tu pravu nanese \\(b_i\\) ta\u010daka, i da se sve ovo uradi na takav na\u010din da nijedne tri ta\u010dke ne budu kolinearne osim ukoliko poti\u010du sa iste prave.</p> <p>Ovaj niz brojeva se mo\u017ee na\u0107i grabljivim postupkom - dokle god je \\(K &gt; 0\\), biramo najve\u0107e \\(x\\) takvo da je \\(\\binom{x}{3} \\leq K\\), dodajemo \\(x\\) na niz i smanjujemo \\(K\\) za \\(\\binom{x}{3}\\). Mo\u017ee se pokazati (na primer, primenom grube sile) da ovaj postupak rezultira u ne vi\u0161e od \\(1049\\) ta\u010daka, i to u ne vi\u0161e od \\(10\\) koraka.</p> <p>Za prave mo\u017eemo izabrati uzastopne razli\u010dite prave koje su paralelne \\(x\\)-osi, odnosno prave \\(y=1, y=2, \\ldots\\). Ta\u010dke mo\u017eemo re\u0111ati po\u010dev od koordinate \\(q_i = i^2 \\times 10^6\\) za \\(i\\)-tu pravu, odnosno, na pravoj sa rednim brojem \\(i\\) bi\u0107e ta\u010dke \\({(q_i, i)}, {(q_i+1, i)}, \\ldots, {(q_i+b_i-1, i)}\\). Ova \"konveksnost\" obezbe\u0111uje da nijedne tri ta\u010dke sa razli\u010ditih pravih ne budu kolinearne.</p> <p>Podzadaci se mogu re\u0161iti primenom grube sile ili nekog jednostavnijeg postupka postavljanja pravih.</p> 03_sazvezdja.cpp<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint f(int b) {\n    return b*(b-1)*(b-2)/6;\n}\n\nint k, l, e, x[2005], y[2005];\n\nint main() {\n    cin &gt;&gt; k;\n    while (k &gt; 0) {\n        int b = 0;\n        while (f(b+1) &lt;= k)\n            b++;\n        k -= f(b);\n        for (int i=0; i&lt;b; i++)\n            x[e] = l*l*500000+i, y[e++] = l;\n        l++;\n    }\n    cout &lt;&lt; e &lt;&lt; '\\n';\n    for (int i=0; i&lt;e; i++)\n        cout &lt;&lt; x[i] &lt;&lt; ' ' &lt;&lt; y[i] &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalazi se jedan ceo broj \\(K\\), tra\u017eeni broj kolinearnih trojki.</p>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvi red standardnog izlaza ispisati prirodan broj \\(N\\), broj ta\u010daka. U narednih \\(N\\) redova ispisati cele brojeve \\(x_i, y_i\\), koordinate ta\u010dke \\(A_i\\). Za ove brojeve mora da va\u017ei \\(-10^9 \\leq x_i, y_i \\leq 10^9\\). Sve od\u0161tampane ta\u010dke moraju biti razli\u010dite.</p>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#ulaz","title":"Ulaz","text":"<pre><code>8\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#izlaz","title":"Izlaz","text":"<pre><code>9\n0 0\n0 1\n0 2\n1 0\n1 1\n1 2\n2 0\n2 1\n2 2\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n0 2\n0 1\n0 0\n1 0\n2 0\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#ulaz_2","title":"Ulaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#izlaz_2","title":"Izlaz","text":"<pre><code>4\n0 0\n1 1\n2 2\n3 3\n</code></pre>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<ul> <li> <p>U prvom primeru ta\u010dke formiraju kvadratnu mre\u017eu formata \\(3 \\times 3\\). Postoje \\(3\\) kolinearne trojke po vrstama, \\(3\\) kolinearne trojke po kolonama i \\(2\\) kolinearne trojke po dijagonalama, \u0161to je ukupno \\(8\\) kolinearnih trojki.</p> </li> <li> <p>U drugom primeru, prve tri ta\u010dke \u010dine jednu kolinearnu trojku, a poslednje tri ta\u010dke drugu kolinearnu trojku.</p> </li> <li> <p>U tre\u0107em primeru, svaka trojka je kolinearna, takvih trojki ima \\(4\\).</p> </li> </ul>"},{"location":"takprog/2019_2020/kv3/03_sazvezdja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq K \\leq 10^8\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(K \\le 10\\).</li> <li>U test primerima vrednim 20 poena: \\(K \\leq 2000\\).</li> <li>U test primerima vrednim 20 poena: \\(K \\leq 10^6\\).</li> <li>U test primerima vrednim 40 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv3/04_boje/","title":"4 - Boje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Kao odmor od kvalifikacija, odlu\u010dili ste da uzmete tablu sa \\(N\\) redova (numerisanih od 1 do \\(N\\)) i \\(M\\) kolona (numerisanih od 1 do \\(M\\)) , i da je obojite u razne boje. Neka polja na tabli su ve\u0107 bila crna, pa ste odlu\u010dili da obojite ostala polja tako da va\u017ei slede\u0107e:</p> <ul> <li>nijedno polje ne obojite u crno,</li> <li>susedna polja obojite istom bojom (polja su susedna ako dele ivicu, tako da jedno polje mo\u017ee imati najvi\u0161e \u010detiri suseda), i</li> <li>tabla sadr\u017ei \u0161to vi\u0161e razli\u010ditih boja.</li> </ul> <p>Va\u0161 zadatak je da odredite koliko \u0107e vam razli\u010ditih boja (ne ra\u010dunaju\u0107i crnu) biti potrebno da obojite tablu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Dimitrije Erdeljan Vladimir Milenkovi\u0107 Slobodan Mitrovi\u0107"},{"location":"takprog/2019_2020/kv3/04_boje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se tri broja \\(N\\), \\(M\\) i \\(K\\), gde su \\(N\\) i \\(M\\) redom broj redova i kolona table, a \\(K\\) je broj crnih polja.</p> <p>U narednih \\(K\\) redova nalaze se po dva broja \\(A_i\\) i \\(B_i\\), koji predstavljaju red i kolonu \\(i\\)-tog crnog polja.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati jedan broj: broj boja potrebnih da bi se tabla obojila u skladu sa datim uslovima.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv3/04_boje/#ulaz","title":"Ulaz","text":"<pre><code>4 4 5\n1 1\n2 2\n3 3\n4 4\n1 3\n</code></pre>"},{"location":"takprog/2019_2020/kv3/04_boje/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2019_2020/kv3/04_boje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/kv3/04_boje/#ulaz_1","title":"Ulaz","text":"<pre><code>2 4 2\n2 2\n2 4\n</code></pre>"},{"location":"takprog/2019_2020/kv3/04_boje/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2019_2020/kv3/04_boje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedan primer bojenja table date u prvom primeru se mo\u017ee videti na slede\u0107oj slici.</p> <p></p> <p>U drugom primeru, jedini na\u010din da se zadovolje svi uslovi je da se sva polja koja nisu crna oboje istom bojom.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq A_i \\leq N\\) i \\(1 \\leq B_i \\leq M\\).</li> <li>\\(0 \\leq K \\leq 100000\\).</li> <li>Postoji barem jedno belo polje.</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena, \\(N, M \\leq 10\\).</li> <li>U test primerima vrednim 20 poena, \\(N, M \\leq 1000\\).</li> <li>U test primerima vrednim 20 poena, \\(N, M \\leq 10^9\\) i \\(K \\leq 3000\\).</li> <li>U test primerima vrednim 40 poena, \\(N, M \\leq 10^9\\).</li> </ul>"},{"location":"takprog/2019_2020/kv3/04_boje/#analiza","title":"Analiza","text":"<p>Lako je videti da se ovaj zadatak mo\u017ee svesti na tra\u017eenje broja povezanih komponenti me\u0111u poljima koja nisu obojena. Svaku takvu komponentu mo\u017eemo obojiti novom obojom. U ostatku re\u0161enja \u0107emo opisati kako se broj povezanih komponenti mo\u017ee efikasno na\u0107i pod ograni\u010denjima datim u ovom zadatku.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#resenje-u-on-cdot-m","title":"Re\u0161enje u \\(O(N \\cdot M)\\)","text":"<p>Da bismo prona\u0161li broj komponenti, jednostavno mo\u017eemo da primenimo Depth First Search (DFS) algoritam od svakog neobojenog polja koje nismo do sada ovim algoritmom posetili. Po\u0161to broj \u010dvorova i grana u grafu koji predstavljaju neobojena polja ima slo\u017eenost \\(O(N \\cdot M)\\), ovaj pristup bi bio vrlo spor za najve\u0107e test primere.</p> <p>Posmatrajmo primer gde je \\(N = M = 10^9\\) i \\(K = 10^5\\). U tom primeru postoje \"veliki\" delovi table koji su neobojeni a povezani. Intuitivno, umesto da svako polje tih \"velikih\" delova posmatramo kao \u010dvor, bilo bi zgodno ako bismo ceo \"veliki\" deo posmatrali kao jedan \u010dvor. U tom slu\u010daju bi gore opisani DFS-pristup imao daleko manju slo\u017eenost. Naravno, glavno pitanje ovde je kako izabrati velike delove tako da je zgodno sa njima raditi, a usput svesti broj \u010dvorova koje posmatramo na mali broj. U ostatku re\u0161enja \u0107emo se fokusirati na ovo pitanje.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#veliki-delovi-table-i-resenje-u-ok-cdot-logk","title":"\"Veliki\" delovi table i re\u0161enje u \\(O(K \\cdot \\log{K})\\)","text":"<p>Sada \u0107emo objasniti kako da od ulaza napravimo graf koji ima \\(O(K)\\) \u010dvorova i \\(O(K)\\) grana.</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#cvorovi","title":"\u010cvorovi","text":"<p>Najpre, uzastopne kolone koji nemaju ijedno crno polje \u0107emo posmatrati kao jedan \u010dvor. Po\u0161to je, sem prvog i poslednjeg, svaki takav \u010dvor ograni\u010den kolonama koje imaju bar jedno crno polje, broj takvih \u010dvorova je najvi\u0161e \\(K + 1\\).</p> <p>Posmatrajmo sada kolonu koja ima bar jedno crno polje. Ako kolona ima \\(t\\) crnih polja tada se ona mo\u017ee izdeliti u \\(t + 1\\) ili manje nizova uzasotpnih neobojenih polja. Svaki od tih nizova \u0107emo posmatrati kao poseban \u010dvor. Takvih \u010dvorova ima najvi\u0161e \\(2 K\\).</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#grane","title":"Grane","text":"<p>Da bismo izlistali grane, posmatra\u0107emo po dve susedne kolone i \u010dvorove koje one defini\u0161u, pod uslovom da bar jedna od kolona ima bar jedno crno polje. (Dve susedne kolone koje nemaju crna polja su deo istog \u010dvora.) Neka je \\(C_1\\) lista \u010dvorova prve, a neka je \\(C_2\\) lista \u010dvorova druge kolone. Svaki \u010dvor \\(v\\) je predstavljen kao par \\((a, b)\\), \u0161to zna\u010di da je \\(v\\) podniz uzastopnih neobojenih polja koji se u odgovaraju\u0107oj koloni pru\u017eaju izme\u0111u redova \\(a\\) i \\(b\\). Pretpostavimo da su \u010dvorovi u \\(C_1\\) i \\(C_2\\) sortirani u rastu\u0107em poretku po prvoj koordinati. Tada, se slede\u0107i algoritam mo\u017ee primeniti da se na\u0111u sve grane izme\u0111u \u010dvorova u \\(C_1\\) i \\(C_2\\).</p> <p>Neka je \\(v_1 = (a_1, b_1) \\in C_1\\) trenutni \u010dvor koji obra\u0111ujemo u \\(C_1\\), a \\(v_2 = (a_2, b_2) \\in C_2\\) trenutni \u010dvor koji obra\u0111ujemo u \\(C_2\\). Na po\u010detku, \\(v_1\\) je prvi \u010dvor iz \\(C_1\\), a \\(v_2\\) je prvi \u010dvor iz \\(C_2\\). Primenjujemo slede\u0107e sve dok nismo pro\u0161li sve \u010dvorove iz bar \\(C_1\\) ili \\(C_2\\): - Ako \\(b_1 &lt; a_2\\), postavimo \\(v_1\\) da bude slede\u0107i \u010dvor u \\(C_1\\). - Ako \\(b_2 &lt; a_1\\), postavimo \\(v_2\\) da bude slede\u0107i \u010dvor u \\(C_2\\). - Ina\u010de, dodamo granu izme\u0111u \\(v_1\\) i \\(v_2\\). Ako je \\(b_1 &lt; b_2\\), onda postavimo \\(v_1\\) da bude slede\u0107i \u010dvor u \\(C_1\\), a ina\u010de postavimo \\(v_2\\) da bude slede\u0107i \u010dvor u \\(C_2\\).</p> <p>Nije te\u0161ko proveriti da se na ovaj na\u010din zaista defini\u0161u sve grane izme\u0111u \u010dvorova u \\(C_1\\) i \\(C_2\\). Pored toga, svaki put kad se doda grana \u010dvor \\(v_1\\) ili \u010dvor \\(v_2\\) se pomere za jedan mesto. To zna\u010di da se u ovom procesu doda najvi\u0161e \\(|C_1| + |C_2|\\) grana. Po\u0161to je svaka kolona susedna sa najvi\u0161e dve druge kolone i po\u0161to smo rekli da je ukupan broj \u010dvorova \\(K + 1 + 2 K\\), ovim procesom se doda najvi\u0161e \\(2 (3K + 1)\\) grana.</p> <p>Da bismo prona\u0161li broj povezanih komponenti nad ovakvim grafom mo\u017eemo da primenimo DFS; alternativno, umesto DFS-a mo\u017eemo iskoristiti union-find strukturu. Cortiranje \u010dvorova u koloni \\(C\\) se mo\u017ee uraditi u vremenu \\(O(|C| \\log{|C|})\\), tako da je ukupna slo\u017eenost celog algoritma \\(O(K \\log{K})\\).</p>"},{"location":"takprog/2019_2020/kv3/04_boje/#alternativno-resenje","title":"Alternativno re\u0161enje","text":"<p>Ovaj zadatak sa tako\u0111e mo\u017ee re\u0161iti primenom Ojlerove formule za planarne grafove. Naime, ako nam je dat planaran graf \\(G\\) na \\(n\\) \u010dvorova, sa \\(m\\) grana, \\(f\\) povezanih oblasti i \\(c\\) komponenti, tada va\u017ei \\(n - m + f = 1 + c\\). Ovu formulu mo\u017eemo iskoristiti da re\u0161imo zadatak na slede\u0107i na\u010din.</p> <p>Za \u010detiri polja koja imaju koordinate \\((x, y)\\), \\((x, y + 1)\\), \\((x + 1, y)\\), \\((x + 1, y + 1)\\) ka\u017eemo da \u010dine 2x2 kvadrat.</p> <p>Zamisli\u0107emo da je tabla oivi\u010dena trakom crne boje. Celu tu traku \u0107emo posmatrati kao jedan \u010dvor. Potom, u centar svakog crnog polja \u0107emo staviti \u010dvor. Poveza\u0107emo dva \u010dvora granom ako odgovaraju\u0107a crna polja dele makar jedno teme, i pored toga izbaci\u0107emo grane koje spajaju naspramna polja u 2x2 crnom kvadratu (granu koja spaja polja \\((x, y)\\) i \\((x + 1, y + 1)\\), i granu koja spaja polja \\((x + 1, y)\\), \\((x, y + 1)\\)). Ove grane izbacujemo da bismo o\u010duvali planarnost. Primetimo da je ova definicija susednih crnih polja druga\u010dija nego ona u postavci zadatka. Tako\u0111e \u0107emo povezati traku koja oivi\u010dava tablu sa svakim \u010dvorom koji dodiruje ivicu table, tj., sa svakim \u010dvorom koji se nalazi u prvom ili u poslednjem redu ili u prvoj ili u poslednjoj koloni. Ovaj graf je planaran. Pored toga, graf ima \\(O(K)\\) grana, tako da vrednost \\(c\\) mo\u017eemo lako na\u0107i, na primer, DFS algoritmom.</p> <p>Koriste\u0107i navedenu formulu mo\u017eemo da izra\u010dunamo \\(f\\). Ali \u0161ta predstavlja \\(f\\)? Najpre, svaka \u010detiri \u010dvora koja \u010dine 2x2 kvadrat \u0107e u ovoj definiciji planarnog grafa formirati jednu povezanu oblast. Tako\u0111e \u0107e i svaka tri \u010dvora u \"G obliku\" (tj. imaju koordinate \\((x, y)\\), \\((x, y + 1)\\), \\((x + 1, y)\\)) i rotacijama ove konfiguracije \u010diniti povezane oblasti. Pored ovih oblasti, \\(f\\) broji povezane oblasti koje odgovaraju neobojenim poljima, \u0161to je upravo broj onih oblasti koje su re\u0161enje ovog problema. Dakle, da bismo re\u0161ili ovaj problem, potrebno je da od \\(f\\) oduzmemo 2x2 crne kvadrate.</p> <p>Za implementiranje DFS-a mo\u017eemo smestiti sva crna polja u hash mapu, ili na primer u strukturu map u C++. Pristupom ovoj mapi je onda lako na\u0107i koje susede ima dati \u010dvor.</p> <p>Da rezimiramo, da bismo re\u0161ili problem, potrebno je da: (1) napravimo graf kao \u0161to je to opisano; (2) izra\u010dunamo \\(c\\); (3) prebrojimo 2x2 crne kvadrate, i prebrojimo crne kvadrate koji \u010dine \"G oblik\" i njegove rotacije; i (4) koriste\u0107i navedenu formulu izra\u010dunamo re\u0161enje ovog problema.</p> 04_boje.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nconst int N = 500005;\nint set[N], rank[N], n_dsu;\n\nint n, m, n_pts;\n\nint push() { set[n_dsu] = n_dsu; rank[n_dsu] = 0; return n_dsu++; }\nint find(int x) { return set[x] == x ? x : find(set[x]); }\nvoid join(int x, int y)\n{\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(rank[x] &lt; rank[y])\n        set[x] = y;\n    else\n    {\n        set[y] = x;\n        rank[x] += rank[x] == rank[y];\n    }\n}\n\nstruct block { int start, end, colour; } ;\n\nvoid join_all(std::vector&lt;block&gt; &amp;a)\n{\n    for(int i = 0; i &lt; a.size() - 1; i++)\n    {\n        join(a[i].colour, a[i + 1].colour);\n    }\n}\n\nvoid join_all(std::vector&lt;block&gt; &amp;a, std::vector&lt;block&gt; &amp;b)\n{\n    for(int i = 0; i &lt; a.size() - 1; i++)\n        join(a[i].colour, a[i + 1].colour);\n    for(int i = 0; i &lt; b.size() - 1; i++)\n        join(b[i].colour, b[i + 1].colour);\n    if(a.size() &amp;&amp; b.size())\n        join(a[0].colour, b[0].colour);\n}\n\n\nvoid join_pairs(std::vector&lt;block&gt; &amp;a, std::vector&lt;block&gt; &amp;b)\n{\n    int j = 0;\n    for(int i = 0; i &lt; b.size(); i++)\n    {\n        while(j &lt; a.size() &amp;&amp; a[j].end &lt; b[i].start) j++;\n        while(j &lt; a.size() &amp;&amp; a[j].start &lt;= b[i].end)\n        {\n            join(a[j].colour, b[i].colour);\n            j++;\n        }\n        if(j) j--;\n    }\n}\n\nvoid try_add_empty(std::map&lt;int, std::vector&lt;block&gt;&gt; &amp;blocks, int x, std::vector&lt;int&gt; &amp;existing_rows)\n{\n    if(x &lt; 0 || x &gt;= n) return;\n    if(blocks.find(x) == blocks.end())\n    {\n        blocks[x].push_back({0, m - 1, push()});\n        existing_rows.push_back(x);\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;n_pts);\n\n    std::map&lt;int, std::vector&lt;int&gt;&gt; points;\n    for(int i = 0; i &lt; n_pts; i++)\n    {\n        int ii, jj;\n        scanf(\"%d %d\", &amp;ii, &amp;jj);\n        ii--; jj--;\n        points[ii].push_back(jj);\n    }\n\n    std::map&lt;int, std::vector&lt;block&gt;&gt; blocks;\n    std::vector&lt;int&gt; existing_rows;\n    for(auto &amp;row : points)\n    {\n        row.second.push_back(m);\n        sort(row.second.begin(), row.second.end());\n\n        int prev_j = -1;\n        for(int point : row.second)\n        {\n            block curr = {prev_j + 1, point - 1, -1};\n            if(curr.start &lt;= curr.end)\n            {\n                curr.colour = push();\n                blocks[row.first].push_back(curr);\n            }\n            prev_j = point;\n        }\n\n        if(blocks.find(row.first) != blocks.end())\n            existing_rows.push_back(row.first);\n    }\n\n    // ugly hack\n    for(auto &amp;row : points)\n    {\n        try_add_empty(blocks, row.first - 1, existing_rows);\n        try_add_empty(blocks, row.first + 1, existing_rows);\n    }\n    std::sort(existing_rows.begin(), existing_rows.end());\n\n    for(int i = 0; i &lt; existing_rows.size(); i++)\n    {\n        int prev = i ? existing_rows[i - 1] : -1;\n        int curr = existing_rows[i];\n        int next = i &lt; existing_rows.size() - 1 ? existing_rows[i + 1] : n;\n\n        // prev or next row empty\n        if(prev != curr - 1 || next != curr + 1)\n            join_all(blocks[curr]);\n\n        // adjacent rows\n        if(i &amp;&amp; prev == curr - 1)\n            join_pairs(blocks[prev], blocks[curr]);\n\n        // empty between\n        if(i &amp;&amp; prev != curr - 1)\n            join_all(blocks[prev], blocks[curr]);\n    }\n\n    std::set&lt;int&gt; colours;\n    for(int i = 0; i &lt; n_dsu; i++)\n        colours.insert(find(set[i]));\n\n    printf(\"%d\\n\", colours.size());\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/","title":"5 - K-ta\u010dne sekvence zagrada","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 5000ms 64MB <p>Ta\u010dnu sekvencu zagrada defini\u0161emo na slede\u0107i na\u010din: - Prazna sekvenca je ta\u010dna sekvenca zagrada. - Ako je \\(A\\) ta\u010dna sekvenca zagrada, onda je i <code>(</code>\\(A\\)<code>)</code> ta\u010dna sekvenca zagrada. - Ako su \\(A\\) i \\(B\\) ta\u010dne sekvence zgrada, onda je i njihova konkatenacija, \\(AB\\), ta\u010dna sekvenca zagrada.</p> <p>\\(K\\)-ta\u010dna sekvenca zagrada je sekvenca zagrada takva da se mo\u017ee dobiti ta\u010dna sekvenca zagrada nakon \u0161to se obri\u0161e \\(K\\) ili manje zagrada iz originalne sekvence. Dato je \\(Q\\) upita od kojih svaki ima slede\u0107i oblik: Na\u0107i \\(T\\)-tu po redu leksikografski najmanju \\(K\\)-ta\u010dnu sekvencu zagrada du\u017eine \\(N\\), ako se uzima da je <code>(</code> leksikografski manje od <code>)</code>.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Pe\u0161i\u0107 Nikola Pe\u0161i\u0107 Nikola Pe\u0161i\u0107 Ivan Sto\u0161i\u0107"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se broj \\(Q\\). U narednih \\(Q\\) linija, nalaze se po 3 cela broja \\(N, K, T\\).</p>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(Q\\) upita ispisati tra\u017eenu sekvencu zagrada ili \"Ne postoji\" ako tra\u017eena sekvenca zagrada ne postoji.</p>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#ulaz","title":"Ulaz","text":"<pre><code>6\n1 1 1\n1 1 2\n1 1 3\n3 1 1\n4 4 9\n8 0 2\n</code></pre>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#izlaz","title":"Izlaz","text":"<pre><code>(\n)\nNe postoji\n(()\n)(((\n((()()))\n</code></pre>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq Q,N\\leq1000\\)</li> <li>\\(0\\leq K\\leq100\\)</li> <li>\\(1\\leq T&lt;2^{60}\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena: \\(N\\leq 8\\).</li> <li>U test primerima vrednim 10 poena: \\(K=N\\).</li> <li>U test primerima vrednim 10 poena: \\(K=0\\).</li> <li>U test primerima vrednim 20 poena: \\(N\\leq100\\).</li> <li>U test primerima vrednim 50 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#ideja-za-dinamicko-programiranje","title":"Ideja za  dinami\u010dko programiranje","text":"<p>Za re\u0161avanje problema koristi\u0107emo dinami\u010dko programiranje. Neka \\(dp[i][v][k]\\) prstavlja \\(dp\\) stanje gde \\(i\\) ozna\u010dava broj zagrada koje jo\u0161 moramo da postavimo, \\(v\\) ozna\u010dava trenutnu prefiksnu sumu postavljenih zagrada (ako uzmemo da je <code>(</code> jednako 1 a <code>)</code> jednako -1) i \\(k\\) predstavlja broj zagrada koje mo\u017eemo jo\u0161 da obri\u0161emo. Za prelaze imamo 2 opcije: Postavi <code>(</code> kao slede\u0107u zagradu ili postavi <code>)</code> kao slede\u0107u zagradu. Ako postavljamo <code>(</code>, iz stanja \\(dp[i][v][k]\\) \u0107emo pre\u0107i u stanje \\(dp[i-1][v+1][k]\\). Ako postavljamo <code>)</code> imamo 2 opcije:  - \\(v=0\\), iz stanja \\(dp[i][0][k]\\) \u0107emo pre\u0107i u stanje \\(dp[i-1][0][k-1]\\). - \\(v&gt;0\\), iz stanja \\(dp[i][v][k]\\) \u0107emo pre\u0107i u stanje \\(dp[i-1][v-1][k]\\).</p> <p>Na po\u010detku treba da inicijalizujemo \\(dp[0][v][k]\\) na \\(1\\) ako je \\(v&lt;=k\\), a na \\(0\\) u ostalim slu\u010dajevima. Tako\u0111e treba paziti na \\(overflow\\), vrednosti u \\(dp\\)-u veoma brzo mogu da prema\u0161e \\(long~long\\), tako da je potrebno ograni\u010diti ih da ne mogu da budu ve\u0107e od \\(2^{61}\\) ili neke sli\u010dne vrednosti. \\(2^{61}\\) je dobra vrednost jer \\(2\\cdot 2^{61}\\) idalje staje u \\(long~long\\), dok je \\(2^{61}\\) ve\u0107e od najve\u0107e mogu\u0107e vrednosti za \\(t\\). Uz pomo\u0107 ovog \\(dp\\)-a, mo\u017eemo da odgovorimo na upite. Za upit \\(n,k,t\\) \u0107emo krenuti od stanja \\(dp[n][0][k]\\) i nakon toga \u0107emo raditi slede\u0107e dok \\(n\\) ne postane \\(0\\) : - Ako je \\(dp[n-1][v+1][k]\\geq t\\), pre\u0107i \u0107emo u to stanje i na odgovor dodati <code>(</code>. - U suprotnom \u0107emo od \\(t\\) oduzeti \\(dp[n-1][v+1][k]\\), na odgovor dodati <code>)</code> i pre\u0107i u stanje \\(dp[i-1][0][k-1]\\) ako je \\(v=0\\) ili \\(dp[i-1][v-1][k]\\) ako je \\(v&gt;0\\).</p> <p>Sa ovim re\u0161enjem se moglo dobiti \\(40\\) bodova, dok se sa malo modifikovanim re\u0161enjem (za slu\u010daj kada je \\(k=0\\)), moglo dobiti jo\u0161  \\(10\\) bodova. Glavni problem ovog re\u0161enja je memorija, tako da \u0107emo se u slede\u0107em delu fokusirati na smanjenje memorije. Bi\u0107e opisana 3 re\u0161enja, u redosledu od najlak\u0161eg do najte\u017eeg za implementaciju. Prvo re\u0161enje je alternativno re\u0161enje za problem, drugo koristi ideju koju je Tadija \u0160ebez koristio da re\u0161i problem, i tre\u0107e je zami\u0161ljeno re\u0161enje.</p> <p>U sva 3 re\u0161enja se koristi klasi\u010dna memorijska optimizacija gde se \u010duvaju samo poslednja 2 reda. Ovo je poprili\u010dno lako uraditi kada se ra\u010duna u redosledu rastu\u0107ih du\u017eina, me\u0111utim, za odgovaranje na upite nama trebaju vrednosti u redosledu opadaju\u0107ih du\u017eina.</p>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#resenje-1","title":"Re\u0161enje 1","text":"<p>Ovo re\u0161enje koristi \u010dinjenicu da u na\u0161em \\(dp\\)-u ima malo vrednosti koje nisu \\(0\\), a manje su od \\(2^{61}\\). \u0160tavi\u0161e, ima ta\u010dno \\(2,358,736\\) takvih vrednosti.  Postoje 2 slu\u010daja kada je \\(dp[i][v][k]=0\\): - \\(i+k-v&lt;0\\) - \\(k=0\\) i \\(i\\not\\equiv v\\ (\\textrm{mod}\\ 2)\\)</p> <p>Treba nam jo\u0161 dobar na\u010din da sa\u010duvamo ove vrednosti. Mo\u017eemo da napravimo matricu gde za sve vrednosti \\(i\\) i \\(v\\) \u010duvamo sve vrednosti \\(k\\) (listu vrednosti) i vrednosti odgovaraju\u0107eg \\(dp\\) stanja. Me\u0111utim, kako vrednosti \\(i\\) i \\(v\\) mogu biti do \\(1000\\), ova matrica \u0107e koristiti previ\u0161e memorije. Da bi smanjili memoriju, mo\u017eemo da primetimo da za neku vrednosti parametra \\(i\\), vrednost parametra \\(v\\) \u0107e biti u intervalu \\([i-k,i+k]\\) za sva polja \u010dija je vrednost u tra\u017eenom intervalu. Time mo\u017eemo da smanjimo matricu na dimenzije \\(1000\\times 200\\). \u0160to se ti\u010de, pronala\u017eenja odgovaraju\u0107e vrednosti za \\(k\\) iz liste, dovoljno je samo da pro\u0111emo kroz celu listu ako nam treba neka vrednost iz nje. Ovo je mogu\u0107e uraditi i u \\(O(\\log{k})\\) ali nema potrebe kako slo\u017eenost programa ostaje ista. Slo\u017eenost: Vreme: \\(O(n^2\\cdot k)\\), Memorija: \\(O(\\)Broj polja \u010dija je vrednost u intervalu \\((0,2^{61})\\) \\()\\).</p>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#resenje-2","title":"Re\u0161enje 2","text":"<p>U ovom i slede\u0107em re\u0161enju re\u0161ava\u0107emo upite oflajn, tj. re\u0161i\u0107emo ih sve jednim prolazom kroz \\(dp\\) tabelu u redosledu opadaju\u0107ih du\u017eina. Za ovo re\u0161enje definisa\u0107emo konstantu \\(S\\) i u odvojenu tabelu \u0107emo zapamtiti svaki \\(S\\)-ti red, tj. \\(dp[0][v][k]\\), \\(dp[S][v][k]\\), \\(dp[2\\cdot S][v][k]\\),... Nakon toga, prolazimo kroz sve du\u017eine u opadaju\u0107em redosledu, i za svaku du\u017einu \\(i\\) \u0107emo da dobijemo red koji koji nam treba, tj. \\(dp[i][v][k]\\) tako \u0161to \u0107emo krenuti od najbli\u017eeg zapam\u0107enog reda, u ovom slu\u010daju to je \\(dp[\\lfloor\\frac{i}{S}\\rfloor\\cdot S][v][k]\\), i pomeriti se \\(i-\\lfloor\\frac{i}{S}\\rfloor\\cdot S\\) koraka do \\(i\\)-tog reda. Odabir konstante \\(S=20\\) je dovoljno velik da re\u0161enje pro\u0111e memorijsko ograni\u010denje, a dovoljno mali da pro\u0111e vremensko ograni\u010denje. Slo\u017eenost: Vreme: \\(O(n^2\\cdot k\\cdot S)\\), Memorija: \\(O(\\frac{n^2}{S}\\cdot k)\\).</p>"},{"location":"takprog/2019_2020/kv3/05_k_tacne_sekvence_zagrada/#resenje-3","title":"Re\u0161enje 3","text":"<p>Ovo re\u0161enje se svodi na memorijsku optimizaciju prve dimenzije \\(dp\\) tabele. Ako znamo sve vrednosti za du\u017einu \\(i+1\\) i prva 2 reda za trenutnu du\u017einu tj. \\(dp[i][0][k]\\) i \\(dp[i][1][k]\\), mo\u017eemo da izra\u010dunamo sve vrednosti za du\u017einu \\(i\\). Ovo je mogu\u0107e uraditi tako \u0161to konstrui\u0161emo graf svih prelaza i ako znamo neku vrednost u redu \\(i\\), oduze\u0107emo tu vrednost od svih stanja (iz reda \\(i+1\\)) sa kojima je to stanje povezano, a ako imamo neko stanje u redu \\(i+1\\) koje je povezano sa ta\u010dno jednim stanjem (iz reda \\(i\\)) za koje ne znamo vrednost, mo\u017eemo da zaklju\u010dimo koja je vrednost tog stanja. Kako bi ovo radilo, moramo da ra\u010dunamo vrednosti po modulu, moduo \\(2^{61}\\) radi iz istih razloga kao u re\u0161enju 1. Sad nam jo\u0161 treba na\u010din da ka\u017eemo da li je vrednost u nekom polju zapravo ve\u0107a od modula ili ne. Za ovo \u0107emo definisati vrednost \\(p=i+k-v\\), polje \\(kada[p][k]\\) \u0107e nam \u010duvati najmanje \\(i\\) za koje je neko stanje \\(dp[i][v][k]\\) \u010dija je vrednost parametra \\(p\\) odgovaraju\u0107a, postalo ve\u0107e od modula. Primetimo da kad jednom postane ve\u0107e od modula za neko \\(i\\), vrednost za svako ve\u0107e \\(i\\) i istom vredno\u0161\u0107u parametra \\(p\\) \u0107e tako\u0111e biti ve\u0107a od modula. Ovo je sve \u0161to nam treba da re\u0161imo problem, re\u0161ava\u0107emo uptite oflajn, prvo izra\u010dunamo vrednosti u predosledu rastu\u0107ih du\u017eina, popunimo tabelu \\(kada\\) i sa\u010duvamo \\(dp\\) vrednosti za \\(v=0\\) i \\(v=1\\), i odgovorimo na upite za koje je re\u0161enje \"Ne postoji\". Nakon toga \u0107emo da izra\u010dunamo vrednosti u redosledu opadaju\u0107ih du\u017eina i odgovorimo na ostale upite. Slo\u017eenost: Vreme: \\(O(n^2\\cdot k)\\), Memorija: \\(O(n\\cdot k)\\).</p> 05_k_tacne_sekvence_zagrada.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\n#include &lt;ext/rope&gt;\n\n#define ll long long\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define f first\n#define s second\n#define all(x) x.begin(), x.end()\n#define D(x) cerr &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; \"\\n\";\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate&lt;class T&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;; ///find_by_order(),order_of_key()\ntemplate&lt;class T1, class T2&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const pair&lt;T1,T2&gt;&amp; a) { os &lt;&lt; '{' &lt;&lt; a.f &lt;&lt; \", \" &lt;&lt; a.s &lt;&lt; '}'; return os; }\ntemplate&lt;class T&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const vector&lt;T&gt;&amp; a){os &lt;&lt; '{';for(int i=0;i&lt;sz(a);i++){if(i&gt;0&amp;&amp;i&lt;sz(a))os &lt;&lt; \", \";os &lt;&lt; a[i];}os&lt;&lt;'}';return os;}\ntemplate&lt;class T&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const set&lt;T&gt;&amp; a) {os &lt;&lt; '{';int i=0;for(auto p:a){if(i&gt;0&amp;&amp;i&lt;sz(a))os &lt;&lt; \", \";os &lt;&lt; p;i++;}os &lt;&lt; '}';return os;}\ntemplate&lt;class T&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const multiset&lt;T&gt;&amp; a) {os &lt;&lt; '{';int i=0;for(auto p:a){if(i&gt;0&amp;&amp;i&lt;sz(a))os &lt;&lt; \", \";os &lt;&lt; p;i++;}os &lt;&lt; '}';return os;}\ntemplate&lt;class T1,class T2&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const map&lt;T1,T2&gt;&amp; a) {os &lt;&lt; '{';int i=0;for(auto p:a){if(i&gt;0&amp;&amp;i&lt;sz(a))os &lt;&lt; \", \";os &lt;&lt; p;i++;}os &lt;&lt; '}';return os;}\n\nconst int K=101,N=1003;\nconst ll mod=1LL&lt;&lt;61;\nbool prebacio;\nll add(ll a,ll b){a+=b;if(a&gt;=mod)a-=mod,prebacio=1;return a;}\nll sub(ll a,ll b){a-=b;if(a&lt;0)a+=mod;return a;}\nll dp[N][K][2],vals[N][2][K]; ///val,k\nint kada[N+K][K],degree[N*K],resetin[N*K];\nint znam[N*K],jedan[N*K],zn,jed;\nbool visited[N*K];\nvector&lt;vector&lt;int&gt; &gt; graf(N*K*2);\nint getInd(int i,int val,int k){return i*N*K+val*K+k;}\npair&lt;int,int&gt; getState(int val){\n    pair&lt;int,int&gt; p;\n    if(val&gt;=N*K)\n        val-=N*K;\n    p.f=val/K;\n    p.s=val-p.f*K;\n    return p;\n}\nvector&lt;vector&lt;pair&lt;pair&lt;int,int&gt;,pair&lt;int,ll&gt; &gt; &gt; &gt; events(N);\nvoid init()\n{\n    for(int i=0;i&lt;N+K;i++)for(int j=0;j&lt;K;j++)kada[i][j]=N;\n    for(int i=0;i&lt;K;i++)for(int k=0;k&lt;=i;k++)dp[k][i][0]=1;\n    for(int val=0;val&lt;N;val++)\n    {\n        for(int k=0;k&lt;K;k++)\n        {\n            if(val&lt;N-1){\n                graf[getInd(1,val,k)].pb(getInd(0,val+1,k));\n                graf[getInd(0,val+1,k)].pb(getInd(1,val,k));\n                degree[getInd(0,val,k)]++;\n            }\n            if(val!=0)\n                graf[getInd(1,val,k)].pb(getInd(0,val-1,k)),graf[getInd(0,val-1,k)].pb(getInd(1,val,k)),degree[getInd(0,val,k)]++;\n            else if(k)\n                graf[getInd(0,val,k-1)].pb(getInd(1,val,k)),graf[getInd(1,val,k)].pb(getInd(0,val,k-1)),degree[getInd(0,val,k)]++;\n        }\n    }\n    for(int val=0;val&lt;2;val++)\n        for(int k=0;k&lt;K;k++)\n            vals[0][val][k]=dp[val][k][0];\n    for(int i=0;i&lt;N*K;i++)\n        resetin[i]=degree[i];\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    init();\n    int t;\n    cin &gt;&gt; t;\n    vector&lt;string&gt; ans(t);\n    vector&lt;pair&lt;pair&lt;int,int&gt;,pair&lt;int,ll&gt; &gt; &gt; qu(t); ///n,i,k,s;\n    for(int i=0;i&lt;t;i++)\n        cin &gt;&gt; qu[i].f.f &gt;&gt; qu[i].s.f &gt;&gt; qu[i].s.s,qu[i].f.s=i;\n    sort(all(qu));\n    int j=0;\n    for(int i=1;i&lt;N;i++) ///Izracunaj DP na gore, popuni vals i kada, odgovori na querije koji su \"Ne postoji\"\n    {\n        for(int val=0;val&lt;N;val++)\n            for(int k=0;k&lt;K;k++)\n            {\n                int pos=i+k-val;\n                if(pos&lt;0)\n                    continue;\n                if(val&lt;N-1)\n                    dp[val][k][i&amp;1]=dp[val+1][k][i&amp;1^1];\n                else\n                    dp[val][k][i&amp;1]=0;\n                if(pos&gt;1)\n                    kada[pos][k]=min(kada[pos][k],kada[pos-2][k]);\n                prebacio=0;\n                if(val!=0)\n                    dp[val][k][i&amp;1]=add(dp[val][k][i&amp;1],dp[val-1][k][i&amp;1^1]);\n                else if(k){\n                    dp[val][k][i&amp;1]=add(dp[val][k][i&amp;1],dp[val][k-1][i&amp;1^1]);\n                    if(pos&gt;1)\n                        kada[pos][k]=min(kada[pos][k],kada[pos-2][k-1]);\n                }\n                if(prebacio&amp;&amp;kada[pos][k]==N)\n                    kada[pos][k]=i;\n                if(val&lt;2)\n                    vals[i][val][k]=dp[val][k][i&amp;1];\n            }\n        while(j&lt;t&amp;&amp;qu[j].f.f==i)\n        {\n            int pos=i+qu[j].s.f;\n            if(kada[pos][qu[j].s.f]==N&amp;&amp;dp[0][qu[j].s.f][i&amp;1]&lt;qu[j].s.s)\n                ans[qu[j].f.s]=\"Ne postoji\";\n            else\n                events[qu[j].f.f].pb({{0,qu[j].s.f},{qu[j].f.s,qu[j].s.s}});\n            j++;\n        }\n    }\n    for(int i=N-3;i&gt;=0;i--) ///Izracunaj DP na dole, odgovori na ostale upite\n    {\n        for(int j=0;j&lt;N*K;j++)\n            degree[j]=resetin[j];\n        memset(visited,0,sizeof(visited));\n        for(int val=0;val&lt;2;val++)\n            for(int k=0;k&lt;K;k++)\n            {\n                int pos=i+k-val;\n                if(pos&lt;0)\n                    continue;\n                dp[val][k][i&amp;1]=vals[i][val][k];\n                znam[zn++]=getInd(0,val,k);\n            }\n        while(zn||jed)\n        {\n            while(zn)\n            {\n                int val,k,tr=znam[--zn];\n                visited[tr]=1;\n                auto p=getState(tr);\n                val=p.f;\n                k=p.s;\n                for(auto p:graf[tr])\n                {\n                    degree[p-N*K]--;\n                    auto d=getState(p);\n                    dp[d.f][d.s][i&amp;1^1]=sub(dp[d.f][d.s][i&amp;1^1],dp[val][k][i&amp;1]);\n                    if(degree[p-N*K]==1)\n                        jedan[jed++]=p;\n                }\n            }\n            while(jed)\n            {\n                int val,k,tr=jedan[--jed];\n                auto p=getState(tr);\n                val=p.f;\n                k=p.s;\n                for(auto p:graf[tr])\n                    if(!visited[p])\n                    {\n                        auto d=getState(p);\n                        dp[d.f][d.s][i&amp;1]=dp[val][k][i&amp;1^1];\n                        znam[zn++]=p;\n                    }\n            }\n        }\n        for(auto p:events[i+1])\n        {\n            int val=p.f.f,k=p.f.s,in=p.s.f;\n            ll s=p.s.s;\n            val++;\n            int pos=i+k-val;\n            if(pos&gt;=0&amp;&amp;(kada[pos][k]&lt;=i||dp[val][k][i&amp;1]&gt;=s))\n            {\n                events[i].pb({{val,k},{in,s}});\n                ans[in]+='(';\n                continue;\n            }\n            s-=dp[val][k][i&amp;1];\n            ans[in]+=')';\n            val--;\n            if(val==0)\n                k--;\n            else\n                val--;\n            events[i].pb({{val,k},{in,s}});\n        }\n    }\n    for(int i=0;i&lt;t;i++)\n        cout &lt;&lt; ans[i] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/01_premestanja/","title":"B1 - Preme\u0161tanja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Na okru\u017enom takmi\u010denju iz informatike u\u010destvuje \\(N\\) takmi\u010dara. Njihova imena su \\(1, 2, \\ldots, N\\). Svi takmi\u010dari rade u velikoj prostoriji u kojoj se nalazi \\(N\\) ra\u010dunara u nizu. Imena ra\u010dunara su \\(1, 2, \\ldots, N\\). Na po\u010detku, takmi\u010dar \\(1\\) sedi za ra\u010dunarom \\(1\\), takmi\u010dar \\(2\\) za ra\u010dunarom \\(2\\), itd., takmi\u010dar \\(N\\) za ra\u010dunarom \\(N\\).</p> <p>Kako su takmi\u010dari generalno nepripremljeni i fragilni, oni se stalno \u017eale na ra\u010dunare, podzemne vode i promaju i tra\u017ee da se premeste za neki drugi ra\u010dunar. Preciznije, tokom takmi\u010denja se desilo ta\u010dno \\(M\\) preme\u0161tanja, redom. U \\(i\\)-tom preme\u0161tanju (\\(1 \\leq i \\leq M\\)) ta\u010dno dva takmi\u010dara menjaju mesta: takmi\u010dar koji je u tom trenutku radio na ra\u010dunaru \\(A_i\\) sada prelazi na ra\u010dunar \\(B_i\\) a takmi\u010dar koji je u tom trenutku radio na ra\u010dunaru \\(B_i\\) prelazi na ra\u010dunar \\(A_i\\). Mogu\u0107e je da se tokom takmi\u010denja neki takmi\u010dar premesti vi\u0161e puta (mo\u017eda i nekoliko puta na isti ra\u010dunar).</p> <p>Organizator Programer Pera vodi evidenciju o preme\u0161tanju takmi\u010dara i svaki put kada postoji bar jedan takmi\u010dar \u010diji se redni broj razlikuje za vi\u0161e od \\(K\\) od rednog broja ra\u010dunara za kojim taj takmi\u010dar trenutno radi, Pera se namr\u0161ti jer se takmi\u010dar ba\u0161 udaljio od svog po\u010detnog ra\u010dunara, \u0161to je sumnjivo! Va\u0161 zadatak je da nakon svakog preme\u0161tanja odredite da li se Pera namr\u0161tio.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Aleksa Milojevi\u0107"},{"location":"takprog/2019_2020/okr/01_premestanja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se nenegativni celi brojevi \\(N\\), \\(M\\) i \\(K\\), redom, koji predstavljaju broj takmi\u010dara, broj preme\u0161tanja i Perin parametar za sumnju. U narednih \\(M\\) redova nalaze se po dva razli\u010dita prirodna broja \\(A_i\\) i \\(B_i\\): redni brojevi ra\u010dunara sa kojih se takmi\u010dari me\u0111usobno preme\u0161taju.</p>"},{"location":"takprog/2019_2020/okr/01_premestanja/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(M\\) brojeva, svaki u posebnom redu, gde je \\(i\\)-ti broj \\(1\\) ukoliko se nakon \\(i\\)-tog preme\u0161tanja Pera namr\u0161tio a \\(0\\) ukoliko nije.</p>"},{"location":"takprog/2019_2020/okr/01_premestanja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/01_premestanja/#ulaz","title":"Ulaz","text":"<pre><code>8 5 3\n4 6\n8 2\n2 5\n5 8\n1 2\n</code></pre>"},{"location":"takprog/2019_2020/okr/01_premestanja/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n1\n0\n1\n</code></pre>"},{"location":"takprog/2019_2020/okr/01_premestanja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/okr/01_premestanja/#ulaz_1","title":"Ulaz","text":"<pre><code>10 2 0\n1 10\n1 10\n</code></pre>"},{"location":"takprog/2019_2020/okr/01_premestanja/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n0\n</code></pre>"},{"location":"takprog/2019_2020/okr/01_premestanja/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Za prvi primer je \\(N = 8\\), \\(M = 5\\), \\(K= 3\\). Raspored u\u010denika po ra\u010dunarima je na po\u010detku 1 2 3 4 5 6 7 8 a nakon svakog preme\u0161tanja je - 1 2 3 6 5 4 7 8 (raspored je dobar jer \\(|1-1|&lt;K, |2-2| &lt; K, \\ldots, |4 - 6| &lt; K\\) itd.) - 1 8 3 6 5 4 7 2 (raspored je sumnjiv jer npr. u\u010denik \\(8\\) sedi za ra\u010dunarom \\(2\\) a \\(|8 - 2| &gt; K\\)) - 1 5 3 6 8 4 7 2 (raspored je sumnjiv jer u\u010denik \\(2\\) sedi za ra\u010dunarom \\(8\\) a \\(|2 - 8| &gt; K\\)) - 1 5 3 6 2 4 7 8 (raspored je dobar) - 5 1 3 6 2 4 7 8 (raspored je sumnjiv jer u\u010denik \\(5\\) sedi za ra\u010dunarom \\(1\\) a \\(|5 - 1| &gt; K\\))</p>"},{"location":"takprog/2019_2020/okr/01_premestanja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N,M \\leq 3 \\cdot 10^5\\)</li> <li>\\(0 \\leq K \\leq 3 \\cdot 10^5\\)</li> <li>\\(1 \\leq A_i, B_i \\leq N\\) i \\(A_i \\neq B_i\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N,M \\leq 10^3\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(M\\leq 10^4\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(K = N - 3\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(K = 0\\).</li> <li>U test primerima vrednim \\(20\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/okr/01_premestanja/#analiza","title":"Analiza","text":"<p>Ozna\u010dimo sa \\(R_i\\) redni broj u\u010denika koji sedi za ra\u010dunarom \\(i\\). Na po\u010detku je \\(R_i = i\\) za svako \\(i = 1, 2, \\ldots, N\\). U svakom preme\u0161tanju mi prakti\u010dno menjamo mesta dva elementa niza \\(R\\) i nakon svakog preme\u0161tanja \u017eelimo da proverimo da li postoji neki indeks \\(i\\) za koji va\u017ei \\(|i - R_i| &gt; K\\).</p> <p>Pomenutu proveru mo\u017eemo uraditi pravolinijski: u svakom od \\(M\\) koraka zamenimo dva elementa niza a zatim pro\u0111emo kroz ceo niz i uporedimo \\(|i - R_i|\\) i \\(K\\). Slo\u017eenost ovog algoritma je \\(O(NM)\\) i re\u0161ava podzadatak 1 (\\(20\\)-\\(30\\) poena) ali je previ\u0161e spor za ostale podzadatke.</p> <p>Primetimo da kada vr\u0161imo proveru nakon \\(i\\) preme\u0161tanja, za sve indekse \\(j\\) koji nisu u\u010destvovali u prvih \\(i\\) preme\u0161tanja va\u017ei \\(R_j = j\\); dakle, ne moramo proveravati ceo niz ve\u0107 (u \\(i\\)-tom koraku) samo indekse iz prvih \\(i\\) preme\u0161tanja (\\(A_1, B_1, A_2, B_2, \\ldots, A_i, B_i\\); me\u0111u njima mo\u017ee biti istih). Ovo daje algoritam slo\u017eenosti \\(O(M^2)\\) \u0161to je dovoljno za prva dva podzadatka (\\(40\\)-\\(50\\) poena).</p> <p>U tre\u0107em podzadatku va\u017ei \\(K = N - 3\\). Me\u0111utim, jedini indeksi \\(i\\) za koje je mogu\u0107e da va\u017ei \\(|i - R_i| &lt; N - 3\\) su \\(1, 2, N-1\\) i \\(N\\) (ostali se ne mogu dovoljno \"udaljiti\"; proveriti!) pa je nakon svake zamene dovoljno proveriti vrednosti \\(R_1, R_2, R_{N-1}\\) i \\(R_N\\) \u0161to nam daje ukupnu slo\u017eenost \\(O(N+M)\\) i re\u0161ava ovaj podzadatak (\\(20\\) poena).</p> <p>Da bismo re\u0161ili ceo zadatak, primetimo da nije neophodno stalno proveravati puno indeksa ve\u0107 je dovoljno da u svakom trenutku pamtimo koliko ima indeksa \\(i\\) za koje va\u017ei \\(|i - R_i| &gt; K\\); ozna\u010dimo tu koli\u010dinu sa \\(x\\) (na po\u010detku je \\(x = 0\\)). Pomenuti indeks postoji akko je \\(x &gt; 0\\).  Zamenom dva elementa niza vrednost \\(x\\) se mo\u017ee promeniti najvi\u0161e za \\(2\\) i razlikovanjem nekoliko slu\u010dajeva lako \"update\"-ujemo \\(x\\) (npr. ako je \\(|A_i - R_{A_i}| \\leq K\\) i \\(|B_i - R_{B_i}| &gt; K\\), a \\(|A_i - R_{B_i}| &gt; K\\) i \\(|B_i - R_{A_i}| &gt; K\\), tada se nakon \\(i\\)-tog preme\u0161tanja \\(x\\) pove\u0107ava za \\(1\\), itd.) . Slo\u017eenost ovog re\u0161enja je \\(O(N+M)\\) i osvaja svih \\(100\\) poena.</p> 01_premestanja.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst int MAX_N = 300100;\n\nint n, m, k;\nint r[MAX_N]; // r[i] - redni broj takmicara koji sedi za racunarom i\n\nint main()\n{\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);\n\n    int num_suspicious = 0; // trenutni broj sumnjivih takmicara\n\n    for (int i = 1; i &lt;= n; i++)\n        r[i] = i;\n\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int a, b, tmp;\n        scanf(\"%d%d\", &amp;a, &amp;b);\n\n        if (abs(a - r[a]) &gt; k) num_suspicious--;\n        if (abs(b - r[b]) &gt; k) num_suspicious--;\n        if (abs(a - r[b]) &gt; k) num_suspicious++;\n        if (abs(b - r[a]) &gt; k) num_suspicious++;\n\n        tmp = r[a]; \n        r[a] = r[b]; \n        r[b] = tmp;\n\n        if (num_suspicious &gt; 0)\n            printf(\"1\\n\");\n        else\n            printf(\"0\\n\");\n    }\n\n    return 0;\n} // O(n + m)\n</code></pre>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/","title":"B2 - Zaboravljena partija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Pera i Mika vole da igraju uop\u0161teni iks-oks, igru sa dva igra\u010da sa slede\u0107im pravilima:</p> <ul> <li>igra se na tabli sa \\(N\\) redova i \\(N\\) kolona,</li> <li>igra\u010di igraju naizmeni\u010dno,</li> <li>u svakom potezu, trenutni igra\u010d obele\u017eava jedno slobodno polje   svojim simbolom: X za prvog igra\u010da, odnosno O za drugog, i</li> <li>pobednik je onaj koji prvi napravi niz koji \u010dini \\(K\\) uzastopnih   simbola tog igra\u010da (horizontalno, vertikalno ili dijagonalno).   Ukoliko se tabla popuni, a ovaj uslov ne ispuni, rezultat partije je   nere\u0161en.</li> </ul> <p>Pera i Mika se se\u0107aju da su ju\u010de igrali odli\u010dnu partiju uop\u0161tenog iks-oksa, ali se ne se\u0107aju kako je ta partija i\u0161la, osim da je jedan od njih dvojice pobedio i da je trajala ta\u010dno \\(T\\) poteza. Zanima ih kako bi ta partija mogla da izgleda, tako da od vas tra\u017ee da im date jedan mogu\u0107i primer, ili da im ka\u017eete da su ne\u0161to pogre\u0161no upamtili i da takva partija ne mo\u017ee da postoji.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Dimitrije Erdeljan Dimitrije Erdeljan Dimitrije Erdeljan Aleksandar Zlateski <p>Za po\u010detak, treba odrediti da li je uop\u0161te mogu\u0107e generisati tablu kakva se tra\u017ei u zadatku. Ukoliko \\(T &lt; 2K-1\\), o\u010digledno nije, jer ni jedan igra\u010d ne\u0107e sti\u0107i da postavi \\(K\\) simbola neophodnih za pobedu. U suprotnom, re\u0161enje uvek postoji (\u0161to \u0107e biti jasno iz algoritma koji ga generi\u0161e), osim ukoliko je \\(K = 2\\) i \\(T &gt; N \\cdot \\lceil \\frac{N}{2} \\rceil + 1\\). Da bi dokazali da u ovom slu\u010daju nema re\u0161enja, mo\u017eemo podeliti tablu na \\(2 \\times 2\\) kvadrate i primetiti da pre poslednjeg poteza u svakom od njih mo\u017ee biti najvi\u0161e jedan <code>X</code> i jedan <code>O</code>.</p> <p>Re\u0161enje za proizvoljno \\(T\\) mo\u017eemo napraviti od re\u0161enja gde \\(T = N^2\\) (<code>X</code> pobe\u0111uje u poslednjem potezu), odnosno \\(T = N \\cdot \\lceil \\frac{N}{2} \\rceil + 1\\) ako \\(K = 2\\), na slede\u0107i na\u010din:</p> <ul> <li>ukoliko je \\(T\\) parno (<code>O</code> treba da pobedi), zamenimo sve <code>X</code> sa <code>O</code>   i obrnuto,</li> <li>izra\u010dunamo koliko \u0107e <code>X</code> i <code>O</code> biti na tabli posle \\(T\\) poteza, i</li> <li>bri\u0161emo simbole dok ne ostane o\u010dekivan broj, vode\u0107i ra\u010duna da ne   obri\u0161emo nijedan iz niza od \\(K\\) uzastopnih zbog kog je jedan od   igra\u010da pobedio.</li> </ul> <p>Ostaje samo da konstrui\u0161emo takvo re\u0161enje. Ovo \u0107emo uraditi odvojeno za tri slu\u010daja: \\(K = 2\\), \\(K = 3\\) i \\(K &gt; 3\\)</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se tri broja: \\(N\\), \\(K\\) i \\(T\\), koji redom predstavljaju dimenziju table na kojoj se igra uop\u0161teni iks-oks, broj uzastopnih simbola potreban za pobedu, i broj poteza koji su Pera i Mika odigrali.</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko ne postoji partija koja se uklapa u podatke date na ulazu, u jedinoj liniji izlaza ispisati <code>nemoguce</code>. </p> <p>U suprotnom, u prvih \\(N\\) redova ispisati po \\(N\\) karaktera, koji predstavljaju stanje table nakon zavr\u0161etka partije, gde su <code>X</code> i <code>O</code> (velika slova) simboli prvog i drugog igra\u010da, a <code>.</code> prazno polje. Izme\u0111u polja ne treba ispisati razmake.</p> <p>U naredni red ispisati dva broja \\(i\\) i \\(j\\): red i kolonu polja na kojem je odigran poslednji potez (gde gornjem levom polju odgovaraju koordinate \\((1, 1)\\), tj. kolone se broje sa leva na desno, a redovi od gore na dole).</p> <p>Ukoliko postoji vi\u0161e partija koje se uklapaju u date podatke, ispisati bilo koju.</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/02_zaboravljena/#ulaz","title":"Ulaz","text":"<pre><code>4 3 5\n</code></pre>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#izlaz","title":"Izlaz","text":"<pre><code>XXX.\n....\n..O.\n...O\n1 3\n</code></pre>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/okr/02_zaboravljena/#ulaz_1","title":"Ulaz","text":"<pre><code>2 2 4\n</code></pre>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#izlaz_1","title":"Izlaz","text":"<pre><code>nemoguce\n</code></pre>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedan mogu\u0107i redosled polja na koja su Pera i Mika upisivali svoje simbole u prvoj partiji je \\((1,1), (4,4), (1,3), (3,3), (1,2)\\).</p> <p>U drugom primeru, kako god da su Pera i Mika igrali, nakon tre\u0107eg poteza bi postojala dva susedna polja sa simbolom <code>X</code>, tako da bi prvi igra\u010d tada pobedio. Dakle, partija koja bi trajala \u010detiri poteza ne postoji.</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 100\\)</li> <li>\\(2 \\leq K \\leq N\\)</li> <li>\\(1 \\leq T \\leq N^2\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(N = K = 3\\).</li> <li>U test primerima vrednim 25 poena: \\(K = 2\\).</li> <li>U test primerima vrednim 25 poena: \\(T \\leq \\frac{N^2}{4}\\).</li> <li>U test primerima vrednim 30 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#k-2","title":"\\(K = 2\\)","text":"<p>Tablu mo\u017eemo popuniti na slede\u0107i na\u010din (naizmeni\u010dni <code>X</code> i <code>O</code>) u svakom drugom redu (primer za \\(N = 7\\)):</p> <pre><code>XOXOXOX\n*......\nOXOXOXO\n.......\nXOXOXOX\n.......\nOXOXOXO\n</code></pre> <p>Igra\u010d koji igra poslednji potez igra na polje obele\u017eeno sa <code>*</code>.</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#k-3","title":"\\(K = 3\\)","text":"<p>Po\u010de\u0107emo od table na kojoj ni jedan igra\u010d ne pobe\u0111uje:</p> <pre><code>xOXOXOX\nXoXOXOX\nOXOXOXO\nOXOXOXO\nXOXOXOX\nXOXOXOX\nOXOXOXO\n</code></pre> <p>Primetimo da, ukoliko zamenimo polja \\((1,1)\\) i \\((2,2)\\) (obele\u017eena malim slovima), dobijamo tablu na kojoj <code>X</code> pobe\u0111uje u poslednjem potezu ako \"za kraj\" ostavi \\((2, 2)\\).</p>"},{"location":"takprog/2019_2020/okr/02_zaboravljena/#k-3_1","title":"\\(K &gt; 3\\)","text":"<p>Sli\u010dno kao za \\(K = 3\\), po\u010de\u0107emo od table u kojoj niko ne pobe\u0111uje, koju konstrui\u0161emo na slede\u0107i na\u010din:</p> <ul> <li>U prvom redu imamo \\(K-1\\) simbola <code>X</code>, zatim jedan <code>O</code>, pa opet \\(K-1\\) <code>X</code>, i tako dalje.</li> <li>Drugi red je isti, sa zamenjenim <code>X</code> i <code>O</code>.</li> <li>Dalje redove pravimo naizmeni\u010dnim ponavljanjem ova dva.</li> <li>Ukoliko je \\(N\\) neparno, da bi imali o\u010dekivani broj <code>X</code> i <code>O</code>,   poslednji red \u010dine naizmeni\u010dni <code>X</code> i <code>O</code>.</li> </ul> <p>Na primer, za \\(N = 7, K = 4\\):</p> <pre><code>XXXXoxX\nOOOOXOO\nXXXXOXX\nOOOOXOO\nXXXXOXX\nOOOOXOO\nXOXOXOX\n</code></pre> <p>Sli\u010dno kao u pro\u0161lom slu\u010daju, mo\u017eemo zameniti prvi <code>O</code> sa <code>X</code> koji se nalazi posle njega i dobiti poziciju u kojoj <code>X</code> \"\u010duva\" potez \\((1, K)\\) za kraj i pobe\u0111uje u poslednjem potezu.</p> <p>Ukoliko \\(N = K\\), ne mo\u017eemo zameniti ova dva simbola (jer nema ni\u010deg desno od tog <code>O</code>). U ovom slu\u010daju, nije te\u0161ko videti da umesto toga mo\u017eemo zameniti prvi <code>O</code> sa poljem \\((3, 1)\\).</p> 02_zaboravljena.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\n#define IMPOSSIBLE \"nemoguce\\n\"\n\nconst int N = 105;\nchar board[N][N];\nint n, k, t;\n\nchar other_player(char p) { return p == 'X' ? 'O' : 'X'; }\n\nvoid replace(char a, char b)\n{\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j++)\n            if(board[i][j] == a)\n                board[i][j] = b;\n}\n\nvoid swap_xo()\n{\n    replace('X', '?');\n    replace('O', 'X');\n    replace('?', 'O');\n}\n\nvoid delete_until(char c, int cnt)\n{\n    int total = 0;\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j++)\n            if(board[i][j] == c)\n                total++;\n\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j++)\n            if(board[i][j] == c &amp;&amp; total &gt; cnt)\n            {\n                board[i][j] = '.';\n                total--;\n            }\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;t);\n\n    if(t &lt; 2*k - 1)\n    {\n        printf(IMPOSSIBLE);\n        return 0;\n    }\n\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j++)\n            board[i][j] = '.';\n    int last_i, last_j;\n\n    if(k == 2)\n    {\n        int max_draw = n * ((n+1)/2);\n        if(t &gt; max_draw + 1)\n        {\n            printf(IMPOSSIBLE);\n            return 0;\n        }\n\n        char last = (t % 2) ? 'X' : 'O';  // we'll modify t, save this now\n\n        char curr = 'X';\n        for(int i = 0; i &lt; n; i += 2)\n            for(int j = 0; j &lt; n; j++)\n                if(t &gt; 1)\n                {\n                    board[i][j] = curr;\n                    t--;\n                    curr = other_player(curr);\n                }\n\n        board[1][0] = last;\n        last_i = 1; last_j = 0;\n    }\n    else if(k == 3)\n    {\n        for(int i = 0; i &lt; n; i++)\n            for(int j = 0; j &lt; n; j++)\n                board[i][j] = (i/2 + j) % 2 ? 'O' : 'X';\n        std::swap(board[0][0], board[1][1]);\n        for(int i = 0; i &lt; 3; i++)\n            board[1][i] = '*';\n        last_i = last_j = 1;\n    }\n    else\n    {\n        for(int i = 0; i &lt; n - n%2; i++)\n        {\n            char curr = i % 2 ? 'O' : 'X';\n            for(int j = 0; j &lt; n; j++)\n                board[i][j] = (j % k != k - 1) ? curr : other_player(curr);\n        }\n        if(n % 2)\n            for(int j = 0; j &lt; n; j++)\n                board[n - 1][j] = j % 2 ? 'O' : 'X';\n\n        if(n == k)\n        {\n            std::swap(board[0][n - 1], board[2][0]);\n            last_i = 0; last_j = n - 1;\n            for(int i = 0; i &lt; n; i++)\n                board[0][i] = '*';\n        }\n        else\n        {\n            std::swap(board[0][k - 1], board[0][k]);\n            last_i = 0; last_j = k - 1;\n            for(int i = 0; i &lt; k; i++)\n                board[0][i] = '*';\n        }\n    }\n\n    if(k &gt; 2)\n    {\n        if(t % 2 == 0) swap_xo();\n        int want_x = (t + 1) / 2;\n        int want_o = t - want_x;\n\n        // '*' that get replaced\n        if(t % 2 == 0) want_o -= k;\n        else want_x -= k;\n\n        delete_until('X', want_x);\n        delete_until('O', want_o);\n        replace('*', t % 2 == 0 ? 'O' : 'X');\n    }\n\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n+1; j++)\n            printf(\"%c\", j == n ? '\\n' : board[i][j]);\n    printf(\"%d %d\\n\", last_i + 1, last_j + 1);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/","title":"B3 - \u010carobnjak iz Voza","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>\u010carobnjak Kiki, nakon boravka u Sankt Peterburgu, se uputio na prelepo putovanje vozom Transsibirskom \u017eeleznicom kroz Rusiju. Na njegovo zaprepa\u0161\u0107enje, u istom kupeu sa njim je sedela i poznata muzi\u010darka Danijela Bajaga. Dok su prolazili pored planine Ural, Danijela je ba\u0161 u tom trenutku pevala njenu poznatu pesmu \u201dRuski voz\u201d, i tako je izuzetno visokim tonovima uspela da probudi Jetija iz zimskog sna, koji je odmah, vidno iznerviran, pojurio ka vozu. Tu je bio red na Kikija da poka\u017ee svoj \u010darobnja\u010dki talenat i spasi voz i putnike od besnog Jetija.</p> <p>Kiki je brzo reagovao, prvo je Jetiju o\u010ditao energiju i uvideo da je ona ta\u010dno \\(E\\), a zatim je, da bi ga \u0161to pre opet uspavao, stvorio \\(N\\) malih \u010darobnjaka. Svakom je od njih je na po\u010detku kreiranja odredio i njihovu po\u010detnu snagu obi\u010dne \u010darolije \\(S_i\\), kao i ja\u010dinu specijalne magije \\(M_i\\). Mali \u010darobnjak u jednoj sekundi mo\u017ee baciti ili obi\u010dnu \u010daroliju na Jetija ili njegovu specijalnu magiju.</p> <p>Ukoliko baci obi\u010dnu \u010daroliju, Jetiju skida onoliko energije koliko je njegova trenutna snaga \u010darolije, ali se nakon bacanja \u010darolije njena snaga smanjuje za duplo, i to uvek na manji ceo broj (Npr. ako je po\u010detna snaga \u010darolije nekog malog \u010darobnjaka 14, u prvom bacanju \u010darolije on mo\u017ee Jetiju skinuti 14 energije, drugi put kada baca \u010daroliju mo\u017ee mu skinuti 7, tre\u0107i put 3, \u010detvrti put 1, a naon \u010dega bi mu se snaga smanjila na 0 i ne bi mogao vi\u0161e ovom \u010darolijom da skine energiju Jetiju).</p> <p>Ukoliko baci specijalnu magiju, Jetiju \u0107e skinuti onoliko energije kolika je njegova ja\u010dina specijalne magije, ali on \u0107e se time previ\u0161e umoriti, i ne\u0107e mo\u0107i vi\u0161e da baca \u010dini na Jetija (ni obi\u010dnu \u010daroliju, kao ni specijalnu magiju).</p> <p>Kada se Jetiju energija smanji na 0 ili manje, on \u0107e se ponovo uspavati i voz \u0107e biti spa\u0161en. Ipak, Kiki nije uspeo da uvidi jednu stvar, a to je da na Jetija mo\u017ee da deluje samo jedno bacanje \u010dini u jednoj sekundi (odnosno, u svakoj sekundi, samo jedan mali \u010darobnjak mo\u017ee baciti \u010daroliju ili magiju na njega), te vi\u0161e \u010darobnjaka ni\u0161ta ne zna\u010di ukoliko ne naprave dobar plan kojim redosledom \u0107e bacati \u010dini. </p> <p>Mali \u010darobnjaci \u010dekaju da im Kiki prenese plan, a Kiki vas je zamolio da mu pomognete u planiranju, i odredite minimalno vreme u sekundama za koje mali \u010darobnjaci mogu da uspavaju Jetija (snage magija i \u010darolija \u0107e uvek biti takve da je to mogu\u0107e).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Dragan Uro\u0161evi\u0107 Nikola Pe\u0161i\u0107 <p>Name\u0107e da \u0107e \u010darobnjaci potro\u0161iti manje vremena na uspavljivanje Jetija ako koriste vi\u0161e snage. Pored toga, bez obzira \u0161to se specijalna magija koristi na kraju (posle bacanja obi\u010dnih \u010darolija), mo\u017eemo ve\u0107 na po\u010detku \"ura\u010dunati\" specijalnu magiju (ako je ve\u0107a od obi\u010dne magije). Zbog toga formiramo niz sa svim mogu\u0107im \u010darolijama i magijama. Naime, ako su \\(S_i\\) i \\(M_i\\) po\u010detna ja\u010dina obi\u010dne \u010darolije i ja\u010dina specijalne magije \u010darobnjaka broj \\(i\\), onda u niz \\(a\\) sa svim (mogu\u0107im) magijama dodajemo slede\u0107e ja\u010dine: $$ M_i, S_i, \\frac{S_i}{2^1}, \\frac{S_i}{2^2}, \\frac{S_i}{2^3}, ..., \\frac{S_i}{2^k},  $$ gde je \\(k\\) broj sa osobinom da je  $$ \\frac{S_i}{2^k}\\geqslant 1 \\ \\ \\ \\ \\text{i}\\ \\ \\ \\ \\ \\frac{S_i}{2^{k+1}} &lt; 1. $$ Po formiranju niza \\(a\\), soritramo ga u nerastu\u0107em poretku, a zatim odre\u0111ujemo najmanji broj \\(m\\) takav da je $$ a_1 + a_2 + a_3 + \\dotsb + a_m \\geqslant E. $$</p> <p>Kako su sve mo\u0107i manje od ili jednake broju \\(10^6\\), to \u0107e i elementi niza \\(a\\) biti izme\u0111u \\(1\\) i milion, pa se taj niz mo\u017ee sortirati primenom sortiranja prebrajanjem (counting sort). Broj elemenata u nizu je \\(O(N\\log\\max\\{S_i, M_i|i=1, 2, ..., N\\}) = O(N\\log N)\\). Slo\u017eenost sortiranja je tako\u0111e \\(O(N\\log N)\\) . Odre\u0111ivanje broja \\(m\\) koji predstavlja broj dana potrebnih da se uspava Jeti ima slo\u017eenost \\(O(\\max\\{S_i,M_i\\})\\).</p> <p>Niz \\(a\\) se mo\u017ee sortirati primenom nekog brzog algoritma za sortiranje (npr. quick sort)  i tada  je slo\u017eenost samog sortiranja \\(O(N\\log N\\log(N\\log N))\\).</p> <p>Zadatak mo\u017eemo re\u0161iti i bez sortiranja niza sa magijama. Naime, magije mo\u017eemo smestiti u prioritetni red, a zatim iz reda brisati redom magije od najve\u0107e smanjiju\u0107i svaki put Jetijevu mo\u0107 za iznos te \u010darolije (magije) sve dok se Jeti ne uspava.</p> 03_carobnjak_iz_voza.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 1000555\n#define MAXSM 1000555\n\nint n;\nlong long e;\nint s[MAXN],m[MAXN],cnt[MAXSM];\n\nint main() {\n\n    scanf(\"%d%lld\", &amp;n, &amp;e);\n\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%d\", &amp;s[i]);\n    }\n\n    for(int i=0; i&lt;n; i++) {\n        scanf(\"%d\", &amp;m[i]);\n    }\n\n    for(int i=0; i&lt;n; i++) {\n        cnt[m[i]]++;\n        while(s[i] &gt; 0) {\n            cnt[s[i]]++;\n            s[i] /= 2;\n        }\n    }\n\n    int res = 0;\n    for(int i=MAXSM-1; i&gt;=1; i--) {\n        while(e &gt; 0 &amp;&amp; cnt[i] &gt; 0) {\n            e -= i;\n            cnt[i]--;\n            res++;\n        }\n    }\n\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva prirodna broja \\(N\\), \\(E\\) odvojena razmakom. Druga linija sadr\u017ei \\(N\\) prirodnih brojeva odvojenih razmakom - niz \\(S\\). Tre\u0107a linija sadr\u017ei \\(N\\) prirodnih brojeva odvojenih razmakom - niz \\(M\\).</p>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati minimalno vreme u sekundama za koje mali \u010darobnjaci mogu da uspavaju Jetija.</p>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#ulaz","title":"Ulaz","text":"<pre><code>4 53\n10 3 7 12\n4 5 15 8\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#ulaz_1","title":"Ulaz","text":"<pre><code>2 35\n10 2\n10 10\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru imamo 4 mala \u010darobnjaka i Jetija koji ima energiju 53. Jedan od na\u010dina na koji mali \u010darobnjaci mogu uspavati jetija za 6 sekundi je:</p> <ul> <li>u prvoj sekundi prvi \u010darobnjak baca obi\u010dnu \u010daroliju i tako skida Jetiju 10 energije</li> <li>u drugoj sekundi \u010detvrti \u010darobnjak baca obi\u010dnu \u010daroliju i tako skida Jetiju 12 energije</li> <li>u tre\u0107oj sekundi \u010detvrti \u010darobnjak opet baca obi\u010dnu \u010daroliju i tako skida Jetiju 6 energije</li> <li>u \u010detvrtoj sekundi tre\u0107i \u010darobnjak baca specijalnu magiju i tako skida Jetiju 15 energije</li> <li>u petoj sekundi \u010detvrti \u010darobnjak baca specijalnu magiju i skida Jetiju 8 energije</li> <li>u \u0161estoj sekundi prvi \u010darobnjak baca obi\u010dnu magiju i tako skida Jetiju jo\u0161 5 energije, i time ga uspavljuje.</li> </ul> <p>Ne postoji na\u010din da mali \u010darobnjaci uspavaju Jetija za manje od 6 sekundi.</p> <p>U drugom primeru \u0107e prvi \u010darobnjak u prve dve sekunde bacati obi\u010dnu \u010daroliju, zatim njegovu specijalnu magiju i time ukupno skinuti 25 energije Jetiju, a zatim \u0107e drugi \u010darobnjak u \u010detvrtoj skundi baciti specijalnu magiju i time skinuti jo\u0161 10 energije i uspavati Jetija.</p>"},{"location":"takprog/2019_2020/okr/03_carobnjak_iz_voza/#ogranicenja","title":"Ograni\u010denja","text":"<p>U svim test primerima va\u017ei:</p> <ul> <li>\\(1 \\leq N \\leq 5 \\cdot 10^5\\)</li> <li>\\(0 \\leq S_i, M_i \\leq 10^6\\)</li> <li>\\(1 \\leq E \\leq 10^{15}\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: za svako \\(i\\) va\u017ei \\(S_i = 0\\), odnosno, \u010darobnjaci mogu da koriste samo specijalnu magiju.</li> <li>U test primerima vrednim 25 poena: za svako \\(i\\) va\u017ei \\(M_i = 0\\), odnosno, \u010darobnjaci mogu da koriste samo obi\u010dnu \u010daroliju.</li> <li>U test primerima vrednim 35 poena: \\(N \\leq 1000\\).</li> <li>U test primerima vrednim 20 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/","title":"A1 - Dobitni listi\u0107","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 512MB <p>Rzanj je gradi\u0107 u Rusiji, koji je poznat po istoriji, kulturi, niskim temperaturama... i lutriji! Lutrija u Rzanju se odr\u017eava izvla\u010denjem \\(N\\) prirodnih brojeva, manjih od \\(10^{18}\\). U ovoj lutriji brojevi se mogu ponavljati, a va\u017ean je i njihov redosled.</p> <p>Aljoha, junak na\u0161e pri\u010de, kori\u0161\u0107enjem raznih opskurnih sredstava uspeo je da do\u0111e do nekih dodatnih informacija o narednoj dobitnoj kombinaciji. Neka su brojevi koji \u0107e biti izvu\u010deni na lutriji \\(L_{i}, 1 \\leq i \\leq N\\). Aljoha je saznao niz koji se sastoji od \\(N-1\\) broja, od kojih \\(i\\)-ti broj, \\(A_{i}\\), predstavlja najve\u0107i broj koji deli i \\(L_{i}\\) i \\(L_{i+1}\\).</p> <p>Sada Aljoha \u017eeli da popuni listi\u0107 i za to mu je potrebna pomo\u0107. Ispi\u0161ite jednu kombinaciju koja ispunjava uslove, ili \\(-1\\), ukoliko takva kombinacija ne postoji. Primetite da kombinacija koje ispunjavaju uslove mo\u017ee biti vi\u0161e. U tom slu\u010daju, ispi\u0161ite bilo koju. Tako\u0111e primetite da su validne samo one kombinacije u kojima je svaki broj manji od \\(10^{18}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalazi se broj \\(N\\), broj brojeva u lutriji. U narednom redu nalazi se \\(N-1\\) broj, koji predstavljaju dodatne informacije do kojih je do\u0161ao Aljoha.</p>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu ispisati \\(N\\) brojeva, manjih od \\(10^{18}\\), koji predstavljaju neku kombinaciju, koja mo\u017ee biti dobitna, ili \\(-1\\) ukoliko takva kombinacija ne postoji.</p>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#ulaz","title":"Ulaz","text":"<pre><code>4\n3 4 10\n</code></pre>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#izlaz","title":"Izlaz","text":"<pre><code>3 12 20 10\n</code></pre>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n3 4 6\n</code></pre>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Primetimo da je najve\u0107i broj koji deli \\(3\\) i \\(12\\) ba\u0161 \\(3\\), najve\u0107i broj koji deli \\(12\\) i  \\(20\\) je ba\u0161 \\(4\\), a najve\u0107i broj koji deli \\(10\\) i \\(20\\) je ba\u0161 \\(10\\). U drugom primeru ne postoji kombinacija koja ispunjava uslove.</p>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 10^{5}\\)</li> <li>\\(1 \\leq A_{i} &lt; 10^9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 15 poena: \\(N = 3\\).</li> <li>U test primerima vrednim 10 poena: Brojevi \\(A_{i}\\) su prosti.</li> <li>U test primerima vrednim 10 poena: Brojevi \\(A_{i}\\) su stepeni dvojke.</li> <li>U test primerima vrednim 25 poena: \\(N \\leq 10^3\\) i \\(A_{i} \\leq 10^6\\).</li> <li>U test primerima vrednim 40 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#napomena","title":"Napomena","text":"<p>Jovan Cviji\u0107 je ro\u0111en u Loznici, godinu dana po\u0161to je izgra\u0111ena pruga izme\u0111u Rzanja i Moskve.</p>"},{"location":"takprog/2019_2020/okr/04_dobitni_listic/#analiza","title":"Analiza","text":"<p>Ozna\u010dimo sa \\(nzd(a,b)\\) najve\u0107i broj koji deli i \\(a\\) i \\(b\\), a sa \\(nzs(a,b)\\) najmanji broj kojeg dele i \\(a\\) i \\(b\\). Primetimo da je jedino ograni\u010denje na \\(L_{1}\\) i \\(L_{N}\\) da ih \\(A_{1}\\) i \\(A_{N-1}\\) dele redom. Dalje, primetimo da za svaki broj \\(L_{i}, 1 &lt; i &lt; N\\) va\u017ei \\(A_{i-1} | L_{i}\\) i \\(A_{i} | L_{i}\\), tj. \\(nzs(A_{i-1},A_{i}) | L_{i}\\) . Posmatrajmo niz: </p> \\[K_{1} = A_1, K_{2} = nzs(A_{1},A_{2}),...,K_{i}=nzs(A_{i-1},A_{i}),...,K_{N-1}=nzs(A_{N-2},A_{N-1}),K_{N}=A_{N-1}\\] <p>Primetimo da za ovakav niz \\(K_{i}\\) va\u017ei da \\(A_{i} | K_{i}\\) i \\(A_{i} | K_{i+1}\\), tj. \\(A_{i} | nzd(K_{i},K_{i+1})\\).  Primetimo, tako\u0111e, da za svaki niz \\(M_{i}\\) koji ispunjava ograni\u010denja va\u017ei da: </p> \\[K_{i} | M_{i}, 1 \\leq i \\leq N\\] <p>Zbog toga, va\u017ei da \\(nzd(K_{i},K_{i+1}) \u2223 nzd(M_{i},M_{i+1})\\), tj. \\(A_{i} \\leq nzd(K_{i},K_{i+1}) \\leq nzd(M_{i},M_{i+1})\\). Dakle dovoljno je proveriti da li niz \\(K_{i}\\) ispunjava ograni\u010denja, tj. proveriti da li va\u017ei \\(A_{i} = nzd(K_{i},K_{i+1})\\) za svako \\(i\\).</p> 04_dobitni_listic.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 300000\nusing namespace std;\nint n;\nlong long b[maxn];\nlong long a[maxn];\nint main () {\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;n;i++) {\n        scanf(\"%lld\",&amp;b[i]);\n    }\n    a[1]=b[1];\n    a[n]=b[n-1];\n    for(int i=2;i&lt;n;i++) {\n        a[i]=b[i-1]*b[i]/__gcd(b[i-1],b[i]);\n    }\n    for(int i=1;i&lt;n;i++) {\n        if(__gcd(a[i],a[i+1])!=b[i]) {\n            printf(\"-1\");\n            return 0;\n        }\n    }\n    for(int i=1;i&lt;=n;i++) printf(\"%lld \",a[i]);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/","title":"A2 - Bezbedna podmatrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Pa\u0161a je nedavno kupio ku\u0107u u Rzanju. Me\u0111utim, nakon kupovine je shvatio da ova ku\u0107a ima jednu stra\u0161nu manu: ona nema ogradu! Sada Pa\u0161a ne mo\u017ee mirno da spava jer strahuje od ruskih mafija\u0161a i programera koji u svakom trenutku mogu da napadnu na njegovu neza\u0161ti\u0107enu ku\u0107u. Stoga, Pa\u0161a je preuzeo pravljenje ograde u sopstvene ruke.</p> <p>Pa\u0161in plac se mo\u017ee zamisliti kao matrica dimenzija \\(N\\times M\\), gde \\((i,j)\\) predstavlja polje u preseku \\(i\\)-te vrste (od vrha) i \\(j\\)-te kolone (od leva) i svako polje predstavlja jedan kvadratni metar. Njegova ku\u0107a se nalazi kompletno u polju \\((A,B)\\) (niko nikad nije rekao da je Pa\u0161ina ku\u0107a ne\u0161to velika, ku\u0107e u Rzanju su skupe). Svako polje \\((i,j)\\) ima neku bezbednost \\(C_{ij}\\). Pa\u0161a ho\u0107e da izgradi ogradu u obliku pravougaonika tako da ograda prati linije matrice (u prevodu, Pa\u0161a \u0107e ograditi jednu podmatricu po\u010detne matrice) i da u svojoj unutra\u0161njosti sadr\u017ei njegovu ku\u0107u. U Rusiji imaju malo nestandardnu definiciju bezbednosti pa se smatra da je bezbednost ograde \u010dije je gornje levo polje \\((x,y)\\), donje desno polje \\((z,t)\\) i obim \\(O\\) metara upravo \\(C_{xy}+C_{zt}+O\\).</p> <p>Pa\u0161a ne \u017eeli ni\u0161ta da rizikuje, stoga \u017eeli da izgradi \u0161to je mogu\u0107e bezbedniju ogradu, ali se previ\u0161e pla\u0161i ruskih programera da bi njima zatra\u017eio pomo\u0107. Zato je pitao vas da mu ka\u017eete kolika je najve\u0107a mogu\u0107a bezbednost ograde koju on mo\u017ee da izgradi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei \u010detiri broja, broj vrsta \\(N\\), broj kolona \\(M\\) i vrednosti \\(A,B\\) koje opisuju lokaciju njegove ku\u0107e. Narednih \\(N\\) linija sadr\u017ee po \\(M\\) prirodnih brojeva: gde \\(j\\)-ti broj u \\((i+1)\\)-voj liniji predstavlja broj \\(C_{ij}\\), koji ozna\u010dava bezbednost polja \\((i,j)\\).</p>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju standardnog izlaza ispisati jedan broj: najve\u0107u mogu\u0107u bezbednost ograde koju Pa\u0161a mo\u017ee da izgradi.</p>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#ulaz","title":"Ulaz","text":"<pre><code>3 3 2 2\n8 8 1\n7 9 5\n3 4 7\n</code></pre>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#izlaz","title":"Izlaz","text":"<pre><code>27\n</code></pre>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3 2 2\n1 1 1\n1 9 1\n1 1 1\n</code></pre>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#izlaz_1","title":"Izlaz","text":"<pre><code>22\n</code></pre>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Za prvi primer, najve\u0107a vrednost bezbednosti ograde je u slu\u010daju da postavi ogradu oko celog placa koji ima obim \\(12\\) i stoga je bezbednost \\(8+7+12=27\\).</p> <p>U drugom primeru je optimalno da se izgradi ograda samo oko Pa\u0161ine ku\u0107e koja se nalazi u polju \\((2,2)\\), tada ograda ima obim \\(4\\) i njena bezbednost je \\(9+9+4\\) (polje \\((2,2)\\) se ra\u010duna i kao gornje levo i kao donje desno polje).</p>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 1000\\)</li> <li>\\(1 \\leq A \\leq N\\)</li> <li>\\(1 \\leq B \\leq M\\)</li> <li>\\(1 \\leq C_{ij} \\leq 1000\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(N,M \\leq 50\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(C_{ij} \\leq 50\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(N,M \\leq 400\\).</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#napomena","title":"Napomena","text":"<p>Ivan Pavlov je ro\u0111en u Rzanju.</p>"},{"location":"takprog/2019_2020/okr/05_bezbedna_podmatrica/#analiza","title":"Analiza","text":"<p>Primetimo da ako smo izgradili ogradu \u010dije je gornje levo polje \\((x,y)\\), a donje desno je \\((z,t)\\) mora da va\u017ei \\(x\\leq a\\leq z\\) i \\(y\\leq b\\leq t\\) da bi sadr\u017ealo polje koje sadr\u017ei ku\u0107u. Tako\u0111e vidimo da je u tom slu\u010daju obim podmatrice upravo \\(2\\cdot(z+t-x-y)+4\\). Sada vidimo da treba da maksmiziramo vrednost \\(C_{xy}+C_{zt}+2\\cdot(z+t-x-y)+4\\), za \\(x\\leq a\\leq z\\) i \\(y\\leq b\\leq t\\). Prostom proverom po svim \u010detvorkama daje lako \\(O((NM)^2)\\). Da bi se ovo dalje optimizovalo, izvr\u0161i\u0107emo zamenu redosleda sabiraka: treba da maksimiziziramo izraz \\((C_{xy}-2\\cdot x-2\\cdot y)+(C_{zt}+2\\cdot z+2\\cdot t)+4\\). Ozna\u010dimo \\(G_{xy}=C_{xy}-2\\cdot x-2\\cdot y\\) i \\(H_{zt}=C_{zt}+2\\cdot z+2\\cdot t\\). Sada vidimo da tra\u017eimo maksimum \\(G_{xy}+H_{zt}+4\\), pri \u010demu va\u017ei \\(x\\leq a\\leq z\\), \\(y\\leq b \\leq t\\) i sabirci \\(G_{xy}\\) i \\(H_{zt}\\) su potpuno nezavisni. Stoga mo\u017eemo da na\u0111emo maksimum \\(G_{xy}\\) pod uslovom \\(x\\leq a, y\\leq b\\) (neka je ovaj maksimum \\(M_1\\)) i maksimum \\(H_{zt}\\) po uslovom \\(z\\geq a, t\\geq b\\) (neka je ovaj maksimum \\(M_2\\)), i zatim ispi\u0161emo re\u0161enje \\(M_1+M_2+4\\). Ra\u010dunanje matrica \\(G\\) i \\(H\\), kao i tra\u017eenje \\(M_1\\) i \\(M_2\\) se rade lakom pretragom u \\(O(NM)\\).</p> 05_bezbedna_podmatrica.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 1007\nusing namespace std;\nint a[MAXN][MAXN];\nint main()\n{\n    int n,m,x,y;\n    scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;x,&amp;y);\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(\"%d\",&amp;a[i][j]);\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) {if(a[i][j]&gt;1000 || a[i][j]&lt;=0) printf(\"%d %d %d\\n\",i,j,a[i][j]); assert(a[i][j]&gt;0 &amp;&amp; a[i][j]&lt;1001);}\n    int mx1=-2000000000,mx2=-2000000000;\n    for(int i=1;i&lt;=x;i++) for(int j=1;j&lt;=y;j++) mx1=max(mx1,a[i][j]-2*i-2*j);\n    for(int i=x;i&lt;=n;i++) for(int j=y;j&lt;=m;j++) mx2=max(mx2,a[i][j]+2*i+2*j);\n    printf(\"%d\",mx1+mx2+4);\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/06_moj_broj/","title":"A3 - Moj broj","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 512MB <p>Sanja iz Rzanja (pa normalno, odakle bi ina\u010de bio?) je veliki fan kviza Slagalica, posebno igre \"Moj broj\". Ovaj put je napisao niz \\(A\\) od \\(n\\) elemenata. On \u017eeli da prona\u0111e niz \\(B\\) pomo\u0107u kog \u0107e mo\u0107i da predstavi sve brojeve iz niza \\(A\\). Pravila predstaljanja su slede\u0107a:</p> <ul> <li>niz \\(B\\) se sastoji od \\(k\\) (ne nu\u017eno razli\u010ditih) prirodnih brojeva, koji nisu ve\u0107i od \\(10^8\\)</li> <li>svaki \u010dlan niza \\(A\\) morate predstaviti kao kombinaciju elemenata niza \\(B\\) (prilikom predstaljanja jednog \u010dlana niza \\(A\\), svaki element niza \\(B\\) smete koristi najvi\u0161e onoliko puta koliko se javlja u nizu \\(B\\))</li> <li>pored \u010dlanova niza \\(B\\), smete koristiti operacije sabiranja (<code>+</code>), oduzimanja (<code>-</code>) i mno\u017eenja (<code>*</code>). Deljenje nije dozvoljeno</li> <li>dozvoljeno je koristiti otvorene i zatvorene zagrade (<code>(</code>, <code>)</code>)</li> <li>va\u0161i bodovi zavise od broja \\(k\\) (du\u017eine niza \\(B\\)), pro\u010ditajte sekciju Bodovanje za vi\u0161e detalja</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Zlateski Aleksa Plav\u0161i\u0107 Aleksa Milojevi\u0107 Aleksandar Zlateski <p>Ideja u ovom zadatku jeste distancirati se od konkretnih brojeva koji su dati u nizu \\(A\\). Konstruisa\u0107emo niz od \\(12\\) brojeva \\(B\\) takav da se svi brojevi od \\(1\\) do \\(10^8\\) mogu predstaviti kao kombinacija brojeva iz \\(B\\) pomo\u0107u ra\u010dunskih operacija.</p> <p>Jedan primer ovakvo skupa brojeva jesu svi stepeni dvojke \\(1, 2, 4, ..., 2^26\\). Samo sabiranjem ovih brojeva mogu se predstaviti svi brojevi u intervalu \\([1, 2^{27}-1]\\), \u0161to je dovoljno jer je \\(2^27&gt;10^8\\). Konkretno predstavljanje svakog broja i\u0455 niza \\(A\\) onda se mo\u017ee na\u0107i koriste\u0107i binarni zapis tog broja. Predvi\u0111eno je da ovo re\u0161enje nosi \\(30\\) bodova.</p> <p>O\u010digledno je da prethodna ideja nije optimalna jer ne koristi znakove \\(-\\) i \\(*\\). Da bismo mogli pravilno da iskoristimo znak \\(-\\), napravi\u0107emo malu promenu u prethodnoj ideji: umesto stepena dvojke, koristi\u0107emo stepene trojke. Za to imamo pomo\u0107no matemati\u010dko tvr\u0111enje:</p> <p>Lema: Svaki broj od \\(1\\) do \\(3^n\\) mo\u017ee se predstaviti u obliku \\(e_03^0+e_13^1+...+e_n3^n\\), gde su \\(e_i\\in \\{-1, 0, 1\\}\\). Dokaz: Ovakvo predstavljanje brojeva jako je sli\u010dno sa ternarnim zapisom, ali umesto cifre \\(2\\), koristimo cifru \\(-1\\). Do ovakvog zapisa dolazimo tako \u0161to prvo napi\u0161emo broj u ternarnom zapisu, a zatim po\u010dev\u0161i od cifre najmanje vrednosti proveravamo da li je ta cifra \\(2\\). Ako jeste, menjamo je u \\(-1\\), a slede\u0107oj cifri najmanje vrednosti dodajemo \\(1\\) (u su\u0161tini, \\(2*3^k\\) menjamo sa \\(3^{k+1}-3^k\\)).</p> <p>Koriste\u0107i predstavljanje opisano gore, mogu\u0107e je na\u0107i izraz oblika koji koristi znakove \\(+\\) i \\(-\\) i predstavlja svaki broj od \\(1\\) do \\(3^{17}\\) koriste\u0107i brojeve \\(1, 3, ..., 3^{17}\\). Ovo re\u0161enje nosi \\(70\\) bodova. Ovde je dobro prokomentarisati i slo\u017eenost ovog re\u0161enja. Naime, opisani algoritam za svaki broj nalazi predstavljanje u \\(O(\\)du\u017eina ternarnog zapisa\\()\\), \u0161to je \\(O(log A[i])\\). Ovo zna\u010di da je slo\u017eenost ukupnog re\u0161enja \\(O(n*log 10^8)\\).</p> <p>Pomo\u0107u ideja opisanih gore, lako je generalizovati postupak na baze ve\u0107e o tri. Na primer, ako uzmemo brojeve \\(1, 7^1, 7^2, ..., 7^9\\), mogu\u0107e je pokazati, istim algoritmom kao u dokazu leme, da se svaki broj od \\(1\\) do \\(10^8\\) mo\u017ee predstaviti kao \\(e_07^0+e_17^1+...+e_97^9\\), gde su \\(e_i\\) cifre \\(-3, -2, -1, 0, 1, 2, 3\\). Zato \u0107emo u na\u0161 niz \\(B\\) dodati i brojeve \\(2, 3\\), \u0161to daje niz \\(B\\) od ukupno \\(12\\) brojeva. Zatim \u0107emo grupisati sve stepene sedmice uz koje stoji +2 ili -2 u jednu zagradu i nju pomno\u017eiti sa \\(2\\) (analogno za \\(3\\)). To zna\u010di da bismo mogli dobiti izraz oblika npr. \\(2*(7^7-7^3)+3*(7^6+7^1)-7^5=1982561\\). Ovaj algoritam i dalje radi u gore navedenoj slo\u017eenosti $O(n*log 10^8) $. U opisanoj implementaciji samo treba biti pa\u017eljiv da svaka zagrada po\u010dinje sa pozitivnim sabirkom (ako neka zagrada sadr\u017ei samo negativne sabirke, treba izvu\u0107i minus ispred zagrade).</p> 06_moj_broj.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define pb push_back\n\nconst int maxN = 125;\nconst int maxE = 1e8;\n\nint n;\nint a[maxN];\nint b[maxN];\nstring expr[maxN];\nvector&lt;int&gt; base, mult;\n\nvoid ispis()\n{\n    cout&lt;&lt;12&lt;&lt;endl;\n\n    for (int i=0; i&lt;12; i++)\n        cout&lt;&lt;b[i]&lt;&lt;\" \";\n\n    cout&lt;&lt;endl;\n\n    for (int i=1; i&lt;=n; i++)\n        cout&lt;&lt;expr[i]&lt;&lt;endl;\n\n    fclose(stdout);\n}\n\nvoid mult_add(int idx)\n{\n    for (auto i = 0 ; i&lt; mult.size(); i++)\n    {\n        if (mult[i]&gt;0 &amp;&amp; i)\n            expr[idx]+='+';\n        expr[idx] = expr[idx] + to_string(mult[i]);\n    }\n}\n\nvoid solve(int x, int idx)\n{\n    int curId = 0;\n\n    for (int i = 0 ; i &lt; 10; i++)\n        base[i] = 0;\n\n    while(x&gt;0)\n    {\n        if (x%7&gt;3)\n        {\n            base[curId] = x%7 - 7;\n            x+=7;\n        }\n        else\n            base[curId] = x%7;\n        x/=7;\n        curId++;\n    }\n\n    int nasao = 0;\n    expr[idx] = \"\";\n\n    for (int i = 9 ; i&gt;=0; i--)\n        if (base[i])\n        {\n            mult.clear();\n\n            for (int j = i ; j&gt;=0; j--)\n                if (abs(base[i]) == abs(base[j]))\n                {\n                    if (base[i]*base[j] &lt; 0)\n                        mult.pb(-(b[j]));\n                    else\n                        mult.pb(b[j]);\n                    if (i&gt;j)\n                        base[j] = 0;\n                }\n\n            if (base[i]&lt;0 &amp;&amp; nasao)\n                expr[idx]+='-';\n            if (base[i]&gt;0 &amp;&amp; nasao)\n                expr[idx]+='+';\n\n            if (abs(base[i])&gt;1)\n            {\n                expr[idx] = expr[idx] + to_string(abs(base[i]));\n                expr[idx]+='*';\n            }\n\n            expr[idx]+='(';\n            mult_add(idx);\n            expr[idx]+=')';\n            nasao = 1;\n        }\n}\nvoid prepare_base()\n{\n    b[0] = 1;\n\n    for(int i = 1; i&lt;=9; i++)\n        b[i] = b[i-1]*7;\n\n    b[10] = 2;\n    b[11] = 3;\n\n    base.resize(10);\n}\nint main()\n{\n    cin&gt;&gt;n;\n\n    assert(n&gt;0 &amp;&amp; n&lt;maxN);\n\n    for (int i = 1; i&lt;=n; i++)\n    {\n        cin&gt;&gt;a[i];\n        assert(a[i]&gt;0 &amp;&amp; a[i]&lt;=maxE);\n    }\n\n    prepare_base();\n\n    for (int i = 1; i&lt;=n; i++)\n        solve(a[i], i);\n\n    ispis();\n}\n</code></pre>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei prirodan broj \\(n\\), du\u017einu niza \\(A\\). Druga linija standardnog ulaza sadr\u017ei \\(n\\) prirodnih brojeva, elemente niza \\(A\\).</p>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvoj liniji standardnog izlaza ispisati broj \\(k\\), du\u017einu niza \\(B\\). U drugoj liniji standardnog izlaza ispisati niz \\(B\\). U svakoj od narednih \\(n\\) linija predstaviti po jedan broj iz niza \\(A\\) korisite\u0107i pretohdno napisana pravila. Konkretno u \\(i\\)-toj liniji predstaviti broj \\(A_i\\), pomo\u0107u \u010dlanova niza \\(B\\), ra\u010dunskih operacija (sabiranje, oduzimanje, mno\u017eenje) i zagrada. Svaka linija ispisa ne sme biti du\u017ea od \\(1000\\) karaktera.</p> <ul> <li>Za sabiranje dve vrednosti koristite karakter <code>+</code> (vrednost u ascii tabeli \\(43\\))</li> <li>Za oduzimanje dve vrednosti koristite karakter <code>-</code> (vrednost u ascii tabeli \\(45\\))</li> <li>Za mno\u017eenje dve vrednosti koristite karakter <code>*</code> (vrednost u ascii tabeli \\(42\\))</li> <li>Za zagrade koristite karaktere <code>(</code> (vrednost u ascii tabeli \\(40\\)) i <code>)</code> (vrednost u ascii tabeli \\(41\\))</li> <li>Nije dozvoljeno koristiti znakove  <code>+</code> i <code>-</code> kao unarne operatore (npr. izrazi \\(-3+5\\) ili \\(5+(+9-3)\\) nisu pravilni).</li> <li>Osim navedenih karaktera, dozvoljeno je ispisivati samo \u010dlanove niza \\(B\\) i razmake (ascii vrednost \\(32\\)) - nije obavezno ispisivati razmake izme\u0111u brojeva i operatora i formatirati izlaz.</li> </ul>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/okr/06_moj_broj/#ulaz","title":"Ulaz","text":"<pre><code>6\n30 13 15 5 3 21\n</code></pre>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#izlaz","title":"Izlaz","text":"<pre><code>3\n2 5 3\n2*5*3\n5*3- 2\n5 *3\n   (5)\n5 -2\n3* (5+2 )\n</code></pre>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Dovoljno je \\(3\\) broja da predstavimo sve brojeve iz ulaza (\\(B = [2, 5, 3]\\)):</p> <ul> <li>\\(2*5*3=30\\)</li> <li>\\(5*3-2=13\\)</li> <li>\\(5*3=15\\)</li> <li>\\(5=5\\)</li> <li>\\(5-2=3\\)</li> <li>\\(3*(5+2)=21\\)</li> </ul>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq n \\leq 124\\)</li> <li> <p>\\(1 \\leq A_i \\leq 10^8\\)</p> </li> <li> <p>elementi niza \\(B\\) su prirodni brojevi u opsegu \\([1, 10^8]\\).</p> </li> </ul>"},{"location":"takprog/2019_2020/okr/06_moj_broj/#bodovanje","title":"Bodovanje","text":"<p>Broj poena na svakom test primeru zavisi od \\(k\\) (veli\u010dine niza \\(B\\) koji koristite za predstaljanje brojeva), po slede\u0107oj tabeli:</p> Veli\u010dina niza \\(B\\) (\\(k\\)) Broj poena u procenitima \\(\\leq 12\\) \\(100\\) \\(13\\) \\(90\\) \\(14-15\\) \\(80\\) \\(16-18\\) \\(70\\) \\(19-20\\) \\(60\\) \\(21-22\\) \\(50\\) \\(23-24\\) \\(40\\) \\(25-27\\) \\(30\\) \\(28-29\\) \\(20\\) \\(30-31\\) \\(10\\) $ &gt; 31$ \\(0\\)"},{"location":"takprog/2019_2020/okr/06_moj_broj/#napomena","title":"Napomena","text":"<p>Janis Adetokumbo nije ro\u0111en u Rzanju.</p>"},{"location":"takprog/2019_2020/sio/01_brojorb/","title":"1 - Brojorb","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 1024MB <p>Brojorb je pozitivan ceo broj koji u svom binarnom zapisu ima ta\u010dno onoliko razli\u010ditih potpalindroma koliko i cifara.</p> <p>Potpalindrom je niz uzastopnih cifara u binarnom zapisu koje se \u010ditaju isto i od napred i od nazad.</p> <p>Npr. \\(155 = (10011011)\\)<sub>2</sub> je brojorb zato \u0161to ima ta\u010dno 8 razli\u010ditih potpalindroma: ([1]0011011), ([1001]1011), (1[0]011011), (1[00]11011), (10[0110]11), (100[11]011), (100[11011]), (1001[101]1). Dok recimo \\(203 = (11001011)\\)<sub>2</sub> nije brojorb zbog toga \u0161to ima 7 razli\u010ditih potpalindroma.</p> <p>Potrebno je da odgovorite na pitanje koliko ima brojorba koji su manji od \\(N\\)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Du\u0161an Zdravkovi\u0107 Ivan Sto\u0161i\u0107 Ivan Sto\u0161i\u0107 <p>Za po\u010detak, doka\u017eimo da je broj razli\u010ditih potpalindroma nekog stringa manji ili jednak du\u017eini stringa. Dokaz indukcijom po du\u017eini stringa. Za stringove du\u017eine \\(1\\) tvr\u0111enje o\u010digledno va\u017ei. Neka je \\(S\\) string du\u017eine \\(n = |S| &gt; 1\\) i neka je \\(S' = S_1S_2\\ldots S_{n-1}\\). Posmatrajmo sve sufikse od \\(S\\) koji su palindromi. Svi osim najdu\u017eeg sufiksa se sigurno javljaju i u \\(S'\\) jer su oni ujedno pravi prefiksi najdu\u017eeg sufiks palindroma. Odavde sledi da \\(S\\) ima najvi\u0161e \\(1\\) potpalindrom vi\u0161e od \\(S'\\) \u0161to dokazuje tvr\u0111enje. Stringove koji zadovoljavaju jednakost ove teoreme zva\u0107emo punim.</p> <p>Korisno je primetiti da, ukoliko je \\(S\\) pun string, tada je i svaki njegov prefiks tako\u0111e pun string, \u0161to nam omogu\u0107ava da ovakve stringove generi\u0161emo rekurzivno, tako \u0161to na trenutni pun string dodajemo karakter \\(0\\) ili \\(1\\), sve dok vrednost ovog broja ne dostigne gornju granicu, kada izlazimo iz rekurzije. Ovu rekurziju mo\u017eemo ubrzati na slede\u0107i na\u010din:</p> <ul> <li>Umesto sa stringovima, raditi sa bit maskama. Sve potrebne operacije sa stringovima mogu se implementirati kao bitovske operacije na brojevima.</li> <li>Tokom rekurzije \u010duvati skup potpalindroma za trenutni broj. Unutar jednog koraka rekurzije ovaj skup \u0107e se promeniti za ta\u010dno jedan element.</li> <li>Proveravamo samo najdu\u017ei sufiks palindrom novogenerisanog broja. Iz dokaza teoreme znamo da je dovoljno posmatrati samo njega.</li> <li>Pored samog broja, \u010duvati i obrnut zapis tog broja u rekurziji kako bi se izbeglo njegovo obrtanje pri tra\u017eenju najdu\u017eeg sufiks palindroma.</li> </ul> <p>Sa ovim opservacijama, slo\u017eenost rekurzivne funkcije mo\u017ee se spustiti na \\(O(m)\\) po pozivu, gde je \\(m\\) najve\u0107a du\u017eina binarnog zapisa brojeva. Ukupna slo\u017eenost celog algoritma je onda \\(O(mk)\\), gde je \\(k\\) broj prona\u0111enih punih stringova. Kako je \\(k &lt; 10^{10}\\) \u010dak i za poslednji, najve\u0107i primer, vreme izvr\u0161enja celog programa je nekoliko desetina minuta.</p> 01_brojorb.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 100\n#define MAXMEM 1200555333\n\nint N;\nlong long res;\nlong long resN[MAXN];\nlong long maxV = 8796093532561LL;\n\nint brP = 16;\nlong long primeri[] = {-1, -1, 1748063LL, 13497742LL, 39374969LL, 375466538LL, 1809756849LL, 7676048889LL, 24323337576LL, \n35802962412LL, 146900865525LL, 287835581101LL, 681224605882LL, 1119584485997LL, 2199024540265LL, 4398047597508LL, 8796093532561LL};\nint trres = 2;\nlong long resP[MAXN];\n\nint startTime, endTime;\n\nvoid printTime(int time)\n{\n    printf(\"time = %02d:%02d\\n\", time % 3600 / 60, time % 60);\n}\n\nint s[MAXN];\n\nlong long palt[MAXN];\n\nchar iskorisceni[MAXMEM];\n\nvoid popLast(int p) {\n    iskorisceni[palt[p]] = 0;\n}\n\nbool proveriDalImaIUbaci(int p, long long t, int l) {\n    long long pt = (t&lt;&lt;1LL) + (l&amp;1);\n\n    if (!iskorisceni[pt]) {\n        iskorisceni[pt] = 1;\n        palt[p] = pt;\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint brp[MAXN];\nint plens[MAXN][MAXN];\nlong long plensT[MAXN][MAXN];\n\nbool addLast(int p) {\n\n    int sp = s[p];\n\n    brp[p] = 1;\n    plens[p][1] = 1;\n\n    long long t = 2LL + sp;\n\n    plensT[p][1] = t;\n\n    bool bb = false;\n\n    if (proveriDalImaIUbaci(p,t,1)) {\n        return true;\n    }\n\n    if (p&gt;0) {\n\n        if (sp == s[p-1]) {\n            plens[p][++brp[p]] = 2;\n            plensT[p][brp[p]] = t;\n            if (proveriDalImaIUbaci(p,t,2)) {\n                return true;\n            }\n        }\n\n        for(int i=1; i&lt;=brp[p-1]; i++) {\n\n            int l = plens[p-1][i];\n\n            if (p - l - 1 &gt;= 0 &amp;&amp; sp == s[p-l-1]) {\n\n                t = (plensT[p-1][i]&lt;&lt;1LL) + sp;\n\n                plens[p][++brp[p]] = l+2;\n                plensT[p][brp[p]] = t;\n\n                if (proveriDalImaIUbaci(p,t,l+2)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return bb;\n}\n\nvoid printbin(long long v) {\n    if (v/2 != 0) printbin(v/2);\n    printf(\"%lld\", v % 2);\n}\n\nvoid idar(int p, long long v, int tp) {\n\n    if (v &gt;= maxV) return;\n\n    for(int b=0; b&lt;2; b++) {\n        if (p==0 &amp;&amp; b==0) continue;\n        long long pv = (v&lt;&lt;1LL) + b;\n\n        if (pv &gt;= maxV) continue;\n\n        s[p] = b;\n        if (addLast(p)) {\n\n            //trres = upper_bound(primeri, primeri+brP, pv) - primeri;\n            while(pv &gt;= primeri[tp]) tp++;\n\n            res++;\n            resP[tp]++;\n            idar(p+1, pv, tp);\n            popLast(p);  \n        }\n    }\n}\n\nvoid ispisiRes() {\n    char pathin[555], pathout[555];\n\n    long long ressum = 0;\n\n    for(int i=2; i&lt;=brP; i++) {\n        sprintf(pathin, \"testcases/%d.in\", i);\n        sprintf(pathout, \"testcases/%d.out\", i);\n\n        FILE *fin = fopen(pathin, \"w\"), *fout = fopen(pathout, \"w\");\n\n        ressum += resP[i];\n\n        fprintf(fin,\"%lld\\n\", primeri[i]);\n        fprintf(fout,\"%lld\\n\", ressum);\n        fclose(fin); fclose(fout);\n    }\n}\n\n\nint main() {\n\n    startTime = time(0);\n\n    res = 0;\n\n    idar(0,0,2);\n\n    printf(\"%lld\\n\", res);\n    //printf(\"%lld\\n\", resN[N]);\n\n    ispisiRes();\n\n    endTime = time(0);\n    printTime(endTime - startTime);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2019_2020/sio/01_brojorb/#napomena","title":"Napomena","text":"<p>Ovo je zadatak sa poznatim ulazom (output-only zadatak). Vama su dati ulazni fajlovi (<code>2.in</code>, <code>3.in</code>, ... <code>16.in</code>) kao i opis u tabeli ispod, dok vi treba da po\u0161aljete samo odgovaraju\u0107e izlazne fajlove za njih (<code>2.out</code>, <code>3.out</code>, ... <code>16.out</code>).</p> <p>Va\u0161 izvorni kod kojim ste generisali izlazne fajlove i izra\u010dunali re\u0161enja potrebno je da po\u0161aljete kao re\u0161enje prvog primera (gde pi\u0161e \u201du\u010ditaj izlaz broj 01\")</p>"},{"location":"takprog/2019_2020/sio/01_brojorb/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu ulaznih fajlova nalazi se nalazi broj \\(N\\).</p>"},{"location":"takprog/2019_2020/sio/01_brojorb/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu ispi\u0161ite koliko ima brojorba koji su manji od \\(N\\).</p>"},{"location":"takprog/2019_2020/sio/01_brojorb/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2019_2020/sio/01_brojorb/#ulaz","title":"Ulaz","text":"<pre><code>212\n</code></pre>"},{"location":"takprog/2019_2020/sio/01_brojorb/#izlaz","title":"Izlaz","text":"<pre><code>209\n</code></pre>"},{"location":"takprog/2019_2020/sio/01_brojorb/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedini brojevi manji od 212 koji nisu brojorbi su 203 i 211.</p>"},{"location":"takprog/2019_2020/sio/01_brojorb/#bodovanje","title":"Bodovanje","text":"<p>U tabeli ispod su dati ulazni brojevi za koje treba izra\u010dunati re\u0161enje i broj poena koji donose.</p> Primer Broj poena Primer Broj poena 01 Po\u0161aljite va\u0161 kod 0 09 N = 35802962412 6 02 N = 1748063 5 10 N = 146900865525 7 03 N = 13497742 5 11 N = 287835581101 7 04 N = 39374969 5 12 N = 681224605882 7 05 N = 375466538 6 13 N = 1119584485997 8 06 N = 1809756849 6 14 N = 2199024540265 8 07 N = 7676048889 6 15 N = 4398047597508 9 08 N = 24323337576 6 16 N = 8796093532561 9"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/","title":"2 - \u0160a\u0161avo odelo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 512MB <p>Drva su jako interesantna \u017eiva vrsta. Uprkos tome \u0161ta su vam pri\u010dali na \u010dasovima biologije, ona zapravo su samo kolekcije \\(N\\) ta\u010daka i \\(N-1\\) du\u017ei izme\u0111u parova njih, tako da kre\u0107u\u0107i se samo po parovima ta\u010daka spojenih du\u017eima je mogu\u0107e sti\u0107i od svake ta\u010dke do svake druge.</p> <p>Ono \u0161to vas isto nisu nau\u010dili na \u010dasovima biologije je da drva imaju jako razvijen smisao za modu. Stabla se obla\u010de tako \u0161to svakoj njihovoj ta\u010dki pripi\u0161e jedan pozitivan ceo broj broj (njihov ekvivalent boja). Kroz istoriju razli\u010dita bojenja su bila popularna po\u010dev\u0161i od tradicionalnih monohromatskih do dana\u0161njih \"retro\" crno-belih (ono \u0161to mi \u010ditamo kao \\(1\\)-\\(2\\)).</p> <p>Me\u0111utim, na\u0161 heroj, Mirko, je jedno jako kreativno i nekonvencijalno drvo. Stoga, on \u017eeli da zapo\u010dne novi trend u svetu drvene mode i da svakoj ta\u010dki dodeli neki broj, tako da ako je nekoj ta\u010dki dodelio broj \\(x\\), onda je ta ta\u010dka du\u017eima povezana sa ta\u010dno \\(x\\) ta\u010daka kojima nije dodelio \\(x\\) (i mogu\u0107e jo\u0161 nekima kojima jeste dodelio \\(x\\)). Mirko je sasvim siguran da \u0107e promeniti svet drvene mode zauvek, ako uspe da dizajnira svoje odelo. Da bi to uradio potrebna mu je va\u0161a pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Lazar Milenkovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Oboji(N, U[\\ldots], V[\\ldots], C[\\ldots])\\)</li> </ul> <p>gde je \\(N\\)  broj koji predstavlja broj ta\u010daka koji ima Mirko,  nizovi \\(U\\) i \\(V\\), du\u017eine \\(N-1\\) predstavljaju da postoji du\u017e izme\u0111u ta\u010daka \\(U[i]\\) i \\(V[i]\\).  U niz \\(C\\) du\u017eine \\(N\\) treba da upi\u0161ete vrednosti brojeva koje Mirko treba da dodeli ta\u010dkama, ili da ceo niz bude jednak \\(-1\\) ukoliko to nije mogu\u0107e. Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#primer","title":"Primer","text":"<p>Neka je \\(N=4\\), i neka su nizovi \\(U=\\{1,1,1\\}\\) i \\(V=\\{2,3,4\\}\\): Tada je mogu\u0107e izabrati \\(C=\\{3,1,1,1\\}\\), jer je tada ta\u010dka \\(1\\) boje \\(3\\) spojena sa tri ta\u010dke boje \\(1\\), \u0161to opravdava njegovu boju, dok su svi ostali boje \\(1\\) i spojeni su samo sa jednom ta\u010dkom, koja je pri tome razli\u010dite boje.</p> <p>Neka je \\(N=4\\), i neka su nizovi \\(U=\\{1,2,3\\}\\) i \\(V=\\{2,3,4\\}\\): Tada re\u0161enje ne postoji i treba izabrati \\(C=\\{-1,-1,-1,-1\\}\\).</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 300.000\\)</li> <li>\\(1 \\leq U_i,V_i \\leq N\\)</li> <li>Garantuje se da je drvo</li> </ul>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[6 poena]: Svaka ta\u010dka je povezana sa najvi\u0161e dve druge ta\u010dke.</li> <li>[9 poena]: \\(N\\leq20\\)</li> <li>[24 poena]: \\(N\\leq500\\)</li> <li>[16 poena]: \\(N\\leq3000\\)</li> <li>[12 poena]: Svaka ta\u010dka je povezana sa najvi\u0161e \\(10\\) drugih ta\u010daka.</li> <li>[33 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>sasavo_odelo.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Oboji(int N, int* U, int* V, int* C);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\).</li> <li>U narednih \\(N\\) redova po \\(2\\) broja. U \\(i\\)-tom redu nalaze se brojevi \\(U_i, V_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa \\(N\\) brojeva koje predstavljaju bojenje koje vrati funkcija.</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#resenja-nekih-potproblema","title":"Re\u0161enja nekih potproblema","text":"<p>Najpre \u0107emo po\u010deti sa nekoliko potproblema koji ne vode nu\u017eno ka finalnom re\u0161enju.</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#svaka-tacka-je-povezana-sa-najvise-dve-druge-tacke","title":"Svaka ta\u010dka je povezana sa najvi\u0161e dve druge ta\u010dke.","text":"<p>Nije te\u0161ko videti da je ovo stablo zapravo prost put. Po\u0161to svaki \u010dvor ima najvi\u0161e dva suseda, boje koje dolaze u obzir su samo 1 ili 2. Znamo da oba kraja puta moraju imati boju 1, pa nije toliko te\u0161ko razmotriti sve slu\u010dajeve za ostale brojeve u zavisnosti od du\u017eine puta [Pomo\u0107 1].</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#nleq20","title":"\\(N\\leq20\\)","text":"<p>Ovaj potproblem mogu\u0107e je re\u0161iti jednostavnim bektrek algoritmom. Za svaki \u010dvor isprobamo sve mogu\u0107nosti za njegove boje. Probajte dokazati da je ukupna slo\u017eenost ovakve implementacije odozgo ograni\u010dena proizvodom stepeni \u010dvorova i da ovaj proizvod nikada ne prema\u0161uje \\(2^20\\) [Pomo\u0107 2].</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#resenja-potproblema-koriscenjem-dinamickog-programiranja","title":"Re\u0161enja potproblema kori\u0161\u0107enjem dinami\u010dkog programiranja","text":"<p>Ideja je ra\u010dunati matricu dinami\u010dkog programiranja gde su mogu\u0107a stanja ozna\u010dena sa \\(dp[r][i][c]\\). Prva dimenzija \\(r \\in \\{0, 1\\}\\) ozna\u010dava nulom da roditelja nije potrebno bojiti istom bojom, a jedinicom da je roditelja potrebno obojiti istom bojom. Druga dimenzija \\(1 \\le i \\le N\\) ozna\u010dava \u010dvor koji se trenutno razmatra, dok na kraju tre\u0107a dimenzija \\(1 \\le c \\le N\\) ozna\u010dava boju koja se trenutno razmatra. Vrednosti u matrici bi\u0107e 0 ukoliko je konfiguracija izvodljiva i 1 ukoliko nije. Pretpostavi\u0107emo da je stablo ukorenjeno u nekom \u010dvoru (recimo \u010dvoru \\(1\\)) i obilazi\u0107emo stablo rekurzivno, tako da se \\(dp\\) vrednost \u010dvora ra\u010duna nakon \\(dp\\) vrednosti njegovih naslednika. Ukoliko je stablo mogu\u0107e obojiti vrednost \\(dp[0][1][c]\\) bi\u0107e 1 za neku od boja \\(c\\).</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#nleq500","title":"\\(N\\leq500\\)","text":"<p>Za svaki \u010dvor \\(i\\) i svaku boju \\(c\\), prolazimo po svim naslednicima \u010dvora i proveravamo za svakog od njih da li ga je mogu\u0107e obojiti u \\(c\\) (ovaj tip naslednika zovemo istobojni naslednici za boju \\(c\\)), da li ga je mogu\u0107e obojiti u neku drugu boju (ovaj tip naslednika zovemo raznobojni naslednik za boju \\(c\\)), kao i da li ga je mogu\u0107e obojiti u istu i u razli\u010ditu boju (ovaj tip naslednika zovemo \u0161areni naslednik za boju \\(c\\)). Na osnovu broja istobojnih, raznobojnih i \u0161arenih naslednika, mogu\u0107e je utvriditi \\(dp[0][i][c]\\), kao i \\(dp[1][i][c]\\).</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#nleq3000","title":"\\(N\\leq3000\\)","text":"<p>Malo pa\u017eljivija implementacija ra\u010dunanja \\(dp\\) tabele dovoljna je za sve poene na ovom potproblemu. Naime, za svaki \u010dvor \\(i\\), prolazimo po svim bojama \\(c\\) i po svim susedima. Ukupna slo\u017eenost je \\(\\sum_{1 \\le i \\le N} \\deg(i)^2 = O(N^2)\\). Probajte videti za\u0161to [Pomo\u0107 3].</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#svaka-tacka-je-povezana-sa-najvise-10-drugih-tacaka","title":"Svaka ta\u010dka je povezana sa najvi\u0161e \\(10\\) drugih ta\u010daka.","text":"<p>Primetimo da najve\u0107a boja koju bilo koji \u010dvor mo\u017ee imati nije nikada ve\u0107a od njegovog stepena. Ukoliko znamo da najve\u0107i stepen nikada ne prema\u0161uje 10, tada tre\u0107a dimenzija \\(dp\\) tabele ima najvi\u0161e 10 kolona. Re\u0161enje iz prethodnog potproblema sada radi u slo\u017eenosti \\(N \\cdot d^2\\), gde je \\(d \\le 10\\) najve\u0107i stepen u stablu.</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#resenje-za-sve-poene","title":"Re\u0161enje za sve poene","text":"<p>Ideja iz prethodnog potproblema bi\u0107e korisna i u ovom potproblemu. Ukoliko za svaki \u010dvor \\(i\\) napravimo tre\u0107u kolonu \\(dp\\) tabele da bude veli\u010dine \\(\\deg(i)\\), tada \u0107e ukupna veli\u010dina ove matrice uvek biti linearna po \\(N\\). Tako\u0111e, primetimo da za svaki \u010dvor mo\u017eemo odrediti da li \u0107e biti istobojni, raznobojni ili \u0161areni naslednik za boju \\(c\\) odmah nakon \u0161to smo izra\u010dunali sve vrednosti njegove \\(dp\\) tabele. Pretpostavimo da svaki \u010dvor sadr\u017ei informaciju o broju naslednika svakog od tri mogu\u0107a tipa za svaku od mogu\u0107ih boja. Kada za neki \u010dvor odredimo kog je on tipa, jednostavno mo\u017eemo a\u017eurirati broja\u010d njegovog roditelja u stablu za svaku boju \\(c\\). Na taj na\u010din, roditelj mo\u017ee u konstantnoj vremenskoj slo\u017eenosti odrediti za svaku od boja koliko ima naslednika kog tipa pa samim tim i koja je \\(dp\\) vrednost za tu boju.</p>"},{"location":"takprog/2019_2020/sio/02_sasavo_odelo/#jos-jedno-interesantno-resenje","title":"Jo\u0161 jedno interesantno re\u0161enje","text":"<p>Primeti\u0107emo da boje koje su mogu\u0107e za svaki \u010dvor jesu samo one od \\(1\\) do \\(\\sqrt{N}\\), kao i od \\(N - \\sqrt{N}\\) do \\(N\\). Pa\u017eljivo implementirano re\u0161enje potproblema kada je stepen najvi\u0161e \\(10\\) i kori\u0161\u0107enje ove ideje bilo je dovoljno za sve poene na ovom zadatku.</p> <p>[Pomo\u0107 1]: Posmatrajte deljivost sa 3.</p> <p>[Pomo\u0107 2]: Koristite nejednakost izme\u0111u aritmeti\u010dke i geometrijske sredine.</p> <p>[Pomo\u0107 3]: Koliki je zbir stepenova svih \u010dvorova?</p> <p>[Pomo\u0107 4]: \u0160ta se de\u0161ava ako va\u017ei da boja nekog \u010dvora nije u tom opsegu? Koliko on ima istobojnih naslednika i koliko oni ukupno imaju istobojnih naslednika?</p> 02_sasavo_odelo.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 300007\nusing namespace std;\nvector&lt;int&gt; g[MAXN];\nvector&lt;int&gt; dp[2][MAXN];\nbool op[MAXN];\nint k[MAXN],co[MAXN];\nbool cmp(int x,int y) {return g[x].size()&lt;g[y].size();}\nvoid dfs(int s,int p)\n{\n    if(g[s].size()==1 &amp;&amp; s!=p) {dp[1][s][1]=true; op[s]=true; k[s]=1; return;}\n    int deg=g[s].size();\n    vector&lt;int&gt; v;\n    for(int i=0;i&lt;deg;i++) if(g[s][i]!=p) {dfs(g[s][i],s); v.push_back(g[s][i]);}\n    sort(v.begin(),v.end(),cmp);\n    int t=0;\n    bool fas=false;\n    for(int i=1;i&lt;=deg;i++)\n    {\n        int a=0,b=0,c=0;\n        while(t&lt;v.size() &amp;&amp; g[v[t]].size()&lt;i) {if(!op[v[t]]) fas=true; t++;}\n        if(fas)\n        {\n            for(int j=i;j&lt;=deg;j++) dp[0][s][j]=dp[1][s][j]=false;\n            break;\n        }\n        b=t;\n        for(int j=t;j&lt;v.size();j++)\n        {\n            bool gr=dp[0][v[j]][i],d=(op[v[j]] &amp;&amp; k[v[j]]!=i);\n            if(gr &amp;&amp; d) c++;\n            if(!gr &amp;&amp; d) b++;\n            if(gr &amp;&amp; !d) a++;\n        }\n        if(a+b+c==v.size())\n        {\n            if(b+c&gt;=i &amp;&amp; a+c&gt;=(int)v.size()-i) dp[0][s][i]=true;\n            if(b+c&gt;=i-1 &amp;&amp; a+c&gt;=(int)v.size()+1-i) dp[1][s][i]=true;\n        }\n    }\n    for(int i=1;i&lt;=deg;i++) if(dp[1][s][i])\n    {\n        if(op[s]) k[s]=-1;\n        else {op[s]=true; k[s]=i;}\n    }\n}\nvoid reconstruct(int s,int p,int x,int y)\n{\n    co[s]=x;\n    vector&lt;int&gt; a,b,c,v;\n    int deg=g[s].size();\n    for(int i=0;i&lt;deg;i++) if(g[s][i]!=p) v.push_back(g[s][i]);\n    for(int j=0;j&lt;v.size();j++)\n    {\n        bool gr=(x&lt;dp[0][v[j]].size() &amp;&amp; dp[0][v[j]][x]),d=(op[v[j]] &amp;&amp; k[v[j]]!=x);\n        if(gr &amp;&amp; d) c.push_back(v[j]);\n        if(!gr &amp;&amp; d) b.push_back(v[j]);\n        if(gr &amp;&amp; !d) a.push_back(v[j]);\n    }\n    for(int i=0;i&lt;a.size();i++) reconstruct(a[i],s,x,x);\n    for(int i=0;i&lt;b.size();i++)\n    {\n        int color;\n        for(int j=1;j&lt;=g[b[i]].size();j++) if(dp[1][b[i]][j] &amp;&amp; j!=x) color=j;\n        reconstruct(b[i],s,color,color-1);\n        y--;\n    }\n    for(int i=0;i&lt;c.size();i++)\n    {\n        if(!y) reconstruct(c[i],s,x,x);\n        else\n        {\n            int color;\n            for(int j=1;j&lt;=g[c[i]].size();j++) if(dp[1][c[i]][j] &amp;&amp; j!=x) color=j;\n            reconstruct(c[i],s,color,color-1);\n            y--;\n        }\n     }\n}\nvoid Oboji(int N,int* U,int* V,int* C)\n{\n    for(int i=1;i&lt;=N-1;i++) g[U[i]].push_back(V[i]);\n    for(int i=1;i&lt;=N-1;i++) g[V[i]].push_back(U[i]);\n    for(int i=1;i&lt;=N;i++) for(int j=0;j&lt;g[i].size()+1;j++) dp[0][i].push_back(false);\n    for(int i=1;i&lt;=N;i++) for(int j=0;j&lt;g[i].size()+1;j++) dp[1][i].push_back(false);\n    dfs(1,1);\n    for(int i=1;i&lt;=g[1].size();i++) if(dp[0][1][i])\n    {\n        reconstruct(1,1,i,i);\n        for(int i=1;i&lt;=N;i++) C[i]=co[i];\n        return;\n    }\n    for(int i=1;i&lt;=N;i++) C[i]=-1;\n}\n</code></pre>"},{"location":"takprog/2019_2020/sio/03_smestaj/","title":"3 - Sme\u0161taj","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 512MB <p>Postoji \\(N\\) osoba i \\(M\\) soba. Osobe mogu rezervisati sobe, ali ni u jednom trenutku ne\u0107e dve osobe imati rezervisanu istu sobu, dok svaka osoba uvek ima najvi\u0161e jednu rezervisanu sobu. Na po\u010detku niko nema ni\u0161ta rezervisano. U nekim momentima se vr\u0161i simuliranje raspore\u0111ivanja po sobama, na osnovu trenutnih rezervacija, i to funkcioni\u0161e na slede\u0107i na\u010din:</p> <ul> <li>Za svaku osobu, redom od \\(1\\) do \\(N\\), se odlu\u010duje koja \u0107e joj soba biti dodeljena, nakon \u010dega je do kraja raspore\u0111ivanja ta soba zauzeta.</li> <li>Ukoliko osoba \\(U\\) nije rezervisala sobu, ona dobija sobu sa najmanjim indeksom koja nije ni zauzeta ni rezervisana.</li> <li>Ukoliko je osoba \\(U\\) rezervisala sobu, ona dobija sobu sa manjim indeksom izme\u0111u sobe koju je rezervisala i sobe sa najmanjim indeksom koja nije ni zauzeta ni rezervisana. Ukoliko \\(U\\) nije dobila sobu koju je rezervisala, ta rezervacija prestaje da va\u017ei do kraja raspore\u0111ivanja i soba koju je \\(U\\) bila rezervisala postaje slobodna.</li> </ul> <p>Dato je i \\(Q\\) upita, svaki upit je jedan od slede\u0107a dva tipa:</p> <ul> <li> <p>\\(1\\) \\(U\\) \\(X\\). Osoba \\(U\\) rezervi\u0161e sobu \\(X\\). Ukoliko je \\(U\\) pre toga imala neku drugu rezervaciju, ta rezervacija se poni\u0161tava. Ukoliko je \\(X = 0\\), tada se samo poni\u0161tava rezervacija sobe osobe \\(U\\). Garantuje se da za \\(X \\neq 0\\) nijedna osoba nema rezervisanu sobu \\(X\\) u ovom trenutku. </p> </li> <li> <p>\\(2\\) \\(U\\). Simulira se raspore\u0111ivanje po sobama na opisani na\u010din. Treba odgovoriti na pitanje u kojoj sobi \u0107e zavr\u0161iti osoba \\(U\\), ukoliko bi se izvr\u0161ila simulacija raspore\u0111ivanja u sobe po opisanom algoritmu, uzev\u0161i u obzir sve upite tipa \\(1\\) do ovog upita, ali ne uzimaju\u0107i u obzir prethodne upite tipa \\(2\\). Dakle, nakon ovog upita su ponovo sve sobe prazne i va\u017ee iste rezervacije koje su va\u017eile neposredno pre upita. Ukoliko ne postoji soba u koju osoba \\(U\\) mo\u017ee da u\u0111e, odgovor je \\(-1\\).</p> </li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milenkovic"},{"location":"takprog/2019_2020/sio/03_smestaj/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Smestaj(N, M, Q, T[\\dots], U[\\dots], X[\\dots], Ans[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj osoba, \\(M\\) broj soba, \\(Q\\) broj upita, \\(T_i\\) tipovi upita, \\(U_i\\) osoba koja rezervi\u0161e sobu u upitu tipa \\(1\\), odnosno osoba za koju treba na\u0107i odgovor u upitu tipa \\(2\\), \\(X_i\\) soba koju osoba \\(U_i\\) rezervi\u0161e u upitu tipa \\(1\\), i \\(Ans\\) niz u koji treba upisati odgovore na upite tipa \\(2\\). Svi nizovi su indeksirani od \\(1\\). Niz \\(Ans\\) je tako\u0111e indeksiran od \\(1\\), odgovor na \\(i\\)-ti upit tipa \\(2\\) treba da bude u \\(Ans_i\\). Ako je \\(T_i = 2\\), garantuje se da va\u017ei \\(X_i = 0\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#primer","title":"Primer","text":"<p>Neka je \\(N=5\\), \\(M=8\\), \\(Q=7\\) i neka su dati upiti: <pre><code>2 2\n1 3 1\n2 2\n1 2 2\n2 2\n1 3 5\n2 3\n</code></pre> Tada:</p> <ul> <li>U prvom upitu treba prona\u0107i koju \u0107e sobu dobiti osoba \\(2\\):</li> <li>Osoba \\(1\\) dobija sobu, slobodne su \\(\\{1,2,3,4,5,6,7,8\\}\\). Kako osoba \\(1\\) nije rezervisala sobu, ona dobija sobu \\(1\\).</li> <li>Osoba \\(2\\) dobija sobu, slobodne su \\(\\{2,3,4,5,6,7,8\\}\\). Kako osoba \\(2\\) nije rezervisala sobu, ona dobija sobu \\(2\\). Dakle, \\(Ans_1 = 2\\).</li> <li>U drugom upitu osoba \\(3\\) rezervi\u0161e sobu \\(1\\).</li> <li>U tre\u0107em upitu treba prona\u0107i koju \u0107e sobu dobiti osoba \\(2\\):</li> <li>Osoba \\(1\\) dobija sobu, slobodne su \\(\\{2,3,4,5,6,7,8\\}\\). Kako osoba \\(1\\) nije rezervisala sobu, ona dobija sobu \\(2\\).</li> <li>Osoba \\(2\\) dobija sobu, slobodne su \\(\\{3,4,5,6,7,8\\}\\). Kako osoba \\(2\\) nije rezervisala sobu, ona dobija sobu \\(3\\). Dakle, \\(Ans_2 = 3\\).</li> <li>U \u010detvrtom upitu osoba \\(2\\) rezervi\u0161e sobu \\(2\\).</li> <li>U petom upitu treba prona\u0107i koju \u0107e sobu dobiti osoba \\(2\\):</li> <li>Osoba \\(1\\) dobija sobu, slobodne su \\(\\{3,4,5,6,7,8\\}\\). Kako osoba \\(1\\) nije rezervisala sobu, ona dobija sobu \\(3\\).</li> <li>Osoba \\(2\\) dobija sobu, slobodne su \\(\\{4,5,6,7,8\\}\\). Kako je osoba \\(2\\) rezervisala sobu \\(2\\), a soba koja je slobodna sa najmanjim indeksom je soba \\(4\\), ona dobija sobu \\(2\\). Dakle, \\(Ans_3 = 2\\).</li> <li>U \u0161estom upitu osoba \\(3\\) rezervi\u0161e sobu \\(5\\). Njena prethodna rezervacija sobe \\(1\\) se poni\u0161tava.</li> <li>U sedmom upitu treba prona\u0107i koju \u0107e sobu dobiti osoba \\(3\\):</li> <li>Osoba \\(1\\) dobija sobu, slobodne su \\(\\{1,3,4,6,7,8\\}\\). Kako osoba \\(1\\) nije rezervisala sobu, ona dobija sobu \\(1\\).</li> <li>Osoba \\(2\\) dobija sobu, slobodne su \\(\\{3,4,6,7,8\\}\\). Kako je osoba \\(2\\) rezervisala sobu \\(2\\), a soba koja je slobodna sa najmanjim indeksom je soba \\(3\\), ona dobija sobu \\(2\\).</li> <li>Osoba \\(3\\) dobija sobu, slobodne su \\(\\{3,4,6,7,8\\}\\). Kako je osoba \\(3\\) rezervisala sobu \\(5\\), a soba koja je slobodna sa najmanjim indeksom je soba \\(3\\), ona dobija sobu \\(3\\). Dakle, \\(Ans_4 = 3\\).</li> </ul> <p>Dakle, za ovaj primer va\u017ei:</p> <ul> <li>\\(T = [2,1,2,1,2,1,2]\\)</li> <li>\\(U = [2,3,2,2,2,3,3]\\)</li> <li>\\(X = [0,1,0,2,0,5,0]\\)</li> <li>\\(Ans = [2,3,2,3]\\)</li> </ul>"},{"location":"takprog/2019_2020/sio/03_smestaj/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M,Q \\leq 300.000\\)</li> <li>\\(N \\leq M\\)</li> <li>\\(1 \\leq U_i \\leq N\\)</li> <li>\\(0 \\leq X_i \\leq M\\)</li> <li>Garantuje se da ni u jednom trenutku dve osobe ne\u0107e imati rezervisanu istu sobu.</li> </ul>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(7\\) podzadatka:</p> <ul> <li>[5 poena]: \\(N,M,Q \\leq 500\\)</li> <li>[7 poena]: \\(N,M \\leq 1.000, Q \\leq 20.000\\)</li> <li>[6 poena]: \\(N,M \\leq 1.000, Q \\leq 200.000\\)</li> <li>[11 poena]: \\(N,M,Q \\leq 300.000, X_i \\leq 30\\) </li> <li>[14 poena]: \\(N,M \\leq 8.000, Q \\leq 300.000\\)</li> <li>[23 poena]: \\(N,M \\leq 100.000, Q \\leq 100.000\\)</li> <li>[34 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/sio/03_smestaj/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>smestaj.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Smestaj(int N, int M, int Q, int *T, int *U, int *X, int *Ans);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, M, Q\\),</li> <li>U narednih \\(Q\\) redova po jedan upit.</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa odgovre koje va\u0161a funkcija upi\u0161e u niz <code>Ans</code>.</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-1-nm-q-leq-500","title":"Podzadatak 1: \\(N,M, Q \\leq 500\\)","text":"<p>U ovom podzadatku dovoljno je simulirati re\u0161enje, tako \u0161to \u0107emo u svakom upitu pro\u0107i kroz svih \\(n\\) osoba i za svaku osobu proveriti koja je slobodna soba sa najmanjim indeksom. Slo\u017eenost: \\(O(NMQ)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-2-nm-leq-1000-q-leq-20000","title":"Podzadatak 2: \\(N,M \\leq 1.000, Q \\leq 20.000\\)","text":"<p>U ovom podzadatku mo\u017eemo da radimo sli\u010dnu simulaciju, kao i u prethodnom, samo \u0161to \u0107emo u \"std::set\" ubaciti sve slobodne sobe i potom za svaku osobu izabrati ili njenu rezervaciju (ukoliko je ima i manja je od prvog elementa seta) ili najmanji element u setu. Ukoliko izaberemo element iz seta, izbacujemo ga, a ubacujemo rezervaciju (ukoliko je ima). Slo\u017eenost: \\(O(QN \\log M)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-3-nm-leq-1000-q-leq-200000","title":"Podzadatak 3: \\(N,M \\leq 1.000, Q \\leq 200.000\\)","text":"<p>U ovom podzadatku mo\u017eemo da radimo sli\u010dnu simulaciju, ali tako \u0161to \u0107emo, umesto \u010duvanja skupa slobodnih soba, u svakom trenutku pamtiti pokaziva\u010d na poslednju slobodnu sobu. Slo\u017eenost: \\(O(QN)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#koju-sobu-ce-izabrati-osoba-x","title":"Koju sobu \u0107e izabrati osoba \\(X\\)?","text":"<p>Lema: Prvih \\(X\\) osoba \u0107e popuniti prvih \\(X\\) nerezervisanih soba, ukoliko samo posmatramo sobe koje su rezervisale osobe posle osobe \\(X\\).</p> <p>Ova lema se mo\u017ee lako pokazati indukcijom i razdvajanjem na slu\u010dajeve da li je osoba \\(X+1\\) rezervisala sobu i gde se ta soba nalazi u odnosu na poslednju zauzetu sobu. Sada lako vidimo da \u0107e osoba \\(X\\) da izabere ili \\(X\\)-tu slobodnu sobu, ukoliko posmatramo rezervacije soba posle osobe \\(X\\) ili sobu koju je ona rezervisala (ako je ima). Odavde vidimo i da \u0107e za svaku osobu uvek biti bar jedna slobodna soba, tj. odgovor nikada ne\u0107e biti \\(-1\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-4-nmq-leq-300000-x_i-leq-30","title":"Podzadatak 4:  \\(N,M,Q \\leq 300.000, X_i \\leq 30\\)","text":"<p>U ovom podzadatku je dovoljno za svaku sobu zapamtiti koja osoba ju je rezervisala. Potom u upitu za \\(U_i \\leq 30\\) simuliramo odabir sobe kao u podzadatku 3, a za preostale proverimo koliko soba su rezervisale osobe sa indeksima ve\u0107im od \\(U_i\\). Slo\u017eenost: \\(O(Q \\max X_i)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-5-nm-leq-8000-q-leq-300000","title":"Podzadatak 5:  \\(N,M \\leq 8.000, Q \\leq 300.000\\)","text":"<p>Za ovaj podzadatak je potrebna struktura podataka 2d segmentno stablo u kojem pamtimo za interval osoba \\([l,r]\\) i interval soba \\([x,y]\\) koliko soba iz tog intervala nije rezervisala ni jedna osoba iz intervala \\([l,r]\\). Potom binarno pretra\u017eujemo po re\u0161enju najmanje \\(t\\), tako da u intervalu \\([1,t]\\) ima bar \\(U_i\\) nerezervisanih soba, ukoliko posmatramo rezervacije osoba iz intervala \\([U_i + 1, N]\\). Slo\u017eenost: \\(O(Q \\log N \\log^2 M)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-6-nm-leq-100000-q-leq-100000","title":"Podzadatak 6:  \\(N,M \\leq 100.000, Q \\leq 100.000\\)","text":"<p>U ovom podzadatku koristimo istu ideju kao i u prethodnom, ali zbog velikog broja osoba i soba, moramo da koristimo implicitno 2d segmentno stablo. Slo\u017eenost: \\(O(Q \\log N \\log^2 M)\\).</p>"},{"location":"takprog/2019_2020/sio/03_smestaj/#podzadatak-7-nm-leq-300000-q-leq-300000","title":"Podzadatak 7:  \\(N,M \\leq 300.000, Q \\leq 300.000\\)","text":"<p>U ovom podzadatku optimizujemo ideju iz prethodnog zadatka. Naime, mo\u017eemo da primetimo da nam je \\(\\log\\) od binarne pretrage vi\u0161ak i da mo\u017eemo da se \"\u0161etamo\" po implicitnom 2d segmentnom stablu. Ovo radimo tako \u0161to zapamtimo skup segmentnih stabala koja se odnose na osobe posle osobe \\(U_i\\) i potom u se u njima \u0161etamo tako \u0161to prona\u0111emo sumu brojeva slobodnih soba u levom podstablu svakog. Ukoliko je ta suma ve\u0107a ili jednaka sa \\(k = U_i\\), onda idemo u to podstablo u svakom stablu iz skupa, u suprotnom idemo u desno i od \\(k\\) oduzmemo sumu iz levih. Slo\u017eenost: \\(O(Q \\log N \\log M)\\).</p> 03_smestaj.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#pragma GCC optimize(\"O3\")\n#define maxn 600000\nusing namespace std;\nstruct Segment {\n    int cnt;\n    int child_left;\n    int child_right;\n};\nint reser[maxn];\nSegment arr[182*maxn];\nSegment emp;\nint al=0;\nint segs[30];\ninline void erase_reservation(int o,int p,int N,int M) {\n    int len=0;\n    while(o&lt;=N) {\n        segs[len++]=o;\n        o+=(o&amp;(-o));\n    }\n    int l=1,r=M;\n    while(l&lt;r) {\n        int m=(l+r)&gt;&gt;1;\n        if(p&lt;=m) {\n            for(int i=0;i&lt;len;i++) {\n                arr[segs[i]].cnt--;\n                segs[i]=arr[segs[i]].child_left;\n            }\n            r=m;\n        }\n        else {\n            for(int i=0;i&lt;len;i++) {\n                arr[segs[i]].cnt--;\n                segs[i]=arr[segs[i]].child_right;\n            }\n            l=m+1;\n        }\n    }\n    for(int i=0;i&lt;len;i++) arr[segs[i]].cnt--;\n}\ninline void add_reservation(int o,int p,int N,int M) {\n    int len=0;\n    while(o&lt;=N) {\n        segs[len++]=o;\n        o+=(o&amp;(-o));\n    }\n    int l=1,r=M;\n    while(l&lt;r) {\n        int m=(l+r)&gt;&gt;1;\n        if(p&lt;=m) {\n            for(int i=0;i&lt;len;i++) {\n                arr[segs[i]].cnt++;\n                if(arr[segs[i]].child_left==0) arr[segs[i]].child_left=al++;\n                segs[i]=arr[segs[i]].child_left;\n            }\n            r=m;\n        }\n        else {\n            for(int i=0;i&lt;len;i++) {\n                arr[segs[i]].cnt++;\n                if(arr[segs[i]].child_right==0) arr[segs[i]].child_right=al++;\n                segs[i]=arr[segs[i]].child_right;\n            }\n            l=m+1;\n        }\n    }\n    for(int i=0;i&lt;len;i++) arr[segs[i]].cnt++;\n}\ninline int traverse(int o,int x,int M,int c) {\n    int len=0;\n    while(o&gt;0) {\n        segs[len++]=o;\n        o-=(o&amp;(-o));\n    }\n    int l=1,r=M;\n    while(l&lt;r) {\n        if(l&gt;=c) return l;\n        int m=(l+r)&gt;&gt;1;\n        int cfree=m-l+1;\n        for(int i=0;i&lt;len;i++) cfree-=arr[arr[segs[i]].child_left].cnt;\n        if(x&lt;=cfree) {\n            r=m;\n            if(l==r) return l;\n            for(int i=0;i&lt;len;i++) segs[i]=arr[segs[i]].child_left;\n        }\n        else {\n            l=m+1;\n            if(l==r) return l;\n            x-=cfree;\n            for(int i=0;i&lt;len;i++) segs[i]=arr[segs[i]].child_right;\n        }\n    }\n    return l;\n}\nvoid Smestaj(int N,int M,int Q,int *T,int *U,int *X,int *Ans) {\n    al=N+1;\n    int l=1;\n    for(int i=1;i&lt;=Q;i++) {\n        if(T[i]==1) {\n            int o=N+1-U[i];\n            if(reser[o]!=0) erase_reservation(o,reser[o],N,M);\n            reser[o]=X[i];\n            if(reser[o]!=0) add_reservation(o,reser[o],N,M);\n        }\n        else {\n            int o=N-U[i];\n            int vx=reser[o+1];\n            if(vx==0) vx=M+1;\n            Ans[l]=traverse(o,U[i],M,vx);\n            Ans[l]=min(Ans[l],vx);\n            l++;\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2019_2020/sio/04_dido/","title":"4 - Dido","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Kraljica Dido, tako\u0111e poznata i kao Eliza, je u strahu od svog nemilosrdnog brata, Pigmaliona, pobegla u severozapadnu Afriku. Tu je odlu\u010dila da osnuje svoje kraljevstvo, drevni grad Kartagu. To \u0107e uraditi tako \u0161to \u0107e ograditi neki deo zemlje i unutar njega osnovati kraljevstvo. </p> <p>Severozapadna Afrika se mo\u017ee predstaviti kao deo koordinatne ravni iznad \\(x\\)-ose. Dido je ve\u0107 izgradila deo ograde od ta\u010dke \\((0,0)\\) do \\((W,0)\\) i trenutno se nalazi u ta\u010dki \\((0,0)\\). Kako ima ograni\u010deno mnogo materijala za ogradu, ostatak ograde ne sme biti du\u017ei od \\(L\\) jedinica du\u017eine. U jednom potezu, Dido mo\u017ee da izgradi segment ograde od trenutne ta\u010dke do neke druge ta\u010dke tako da se \\(x\\) i \\(y\\) koordinate promene za najvi\u0161e \\(1\\) (za \u0161ta postoji 8 mogu\u0107nosti). Dido ho\u0107e da se novi deo ograde zavr\u0161i u ta\u010dki \\((W,0)\\) kako ne bi bilo delova ograde koji su beskorisni. Zbog toga \u0161to Dido ho\u0107e da osnuje mo\u0107no kraljevstvo, povr\u0161ina ogra\u0111ena ogradom treba da bude \u0161to ve\u0107a. Ograda (ra\u010dunaju\u0107i i nov i ve\u0107 izgra\u0111eni deo) ne sme da ima samopresecanja.</p> <p>Pomozite Dido i recite joj dvostruku najve\u0107u povr\u0161inu koje njeno kraljevstvo mo\u017ee da ima.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Nikola Pe\u0161i\u0107 Ivan Sto\u0161i\u0107 Nikola Milosavljevi\u0107 <p>Zajedni\u010dko za sve podzadatke jeste to \u0161to treba proveriti du\u017einu izlomljene linije koja ima oblik kao \u0161to je opisano u zadatku. Naime, neka se ta linija sastoji od \\(u\\) segmenata du\u017eine \\(1\\) i \\(v\\) dijagonalnih segmenata du\u017eine \\(\\sqrt{2}\\). Tada, treba da va\u017ei \\(u+v\\sqrt{2} \\leq L\\) odnosno \\(v \\sqrt{2} \\leq L-u\\), tj. \\(2v^2 \\leq (L-u)^2\\) i \\(u \\leq L\\).</p> <p>Tako\u0111e, potrebno je da za datu izlomljenu liniju odredimo dvostruku povr\u0161inu izme\u0111u nje i \\(x\\) ose. To mo\u017eemo uraditi pomo\u0107u metode ozna\u010denih trapeza. Za svaki segment te du\u017ei, izra\u010dunamo povr\u0161inu trapeza koji formiraju ta du\u017e i dve vertikalne du\u017ei koje je spajaju sa \\(x\\) osom. Pri tome, povr\u0161inu trapezoida uzimamo sa pozitivnim znakom ako du\u017e ide sleva na desno, u suprotnom je uzimamo sa negativnim znakom. Za du\u017e \\(((x_1,y_1),(x_2,y_2))\\), ta dvostruka povr\u0161ina iznosi \\((y_1+y_2)(x_2-x_1)\\). Povr\u0161ina ispod cele izlomljene linije jednaka je zbiru ozna\u010denih povr\u0161ina svih ovako dobijenih trapeza.</p> <p>U prvom podzadatku dovoljno je rekurzivno izgenerisati sve putanje du\u017eine do \\(L\\), a zatim proveriti da li one sti\u017eu u ciljnu ta\u010dku i zatim izra\u010dunati njihovu povr\u0161inu.</p> <p>Drugi podzadatak se mo\u017ee re\u0161iti ako se u rekurziju dodaju neki od slede\u0107ih uslova za rani izlazak: * Ako smo previ\u0161e udaljeni od ciljne ta\u010dke, * Ako smo iskoristili smer du\u017ei suprotan od prethodne.</p> <p>Tre\u0107i podzadatak se mo\u017ee re\u0161iti ako primetimo da je re\u0161enje uvek konveksna figura. Neformalam dokaz ovog tvr\u0111enja dat je na samom kraju re\u0161enja. Ovo zna\u010di da smer u kojem se kre\u0107emo po\u010dinje od \"levo\", zatim rotira u smeru kazaljke na satu i ponovo se zavr\u0161ava u \"levo\". Ovo zna\u010di da se svako re\u0161enje mo\u017ee opisati sa \\(9\\) nenegativnih celih brojeva, koji ozna\u010davaju du\u017eine dela puta na kojima se kre\u0107emo u gore opisanim smerovima. Ovakvi nizovu se mogu pa\u017eljivo rekurzivno generisati i za svaki mo\u017ee da se proveri povr\u0161ina dobijene figure. Vremenska slo\u017eenost re\u0161enja je \\(O(\\binom{L}{9}) = O(L^9)\\), \u0161to je dovoljno, s obzirom na jako malu skrivenu konstantu.</p> <p>\u010cetvrti podzadatak se mo\u017ee re\u0161iti primenom dinami\u010dkog programiranja. Neka je \\(d_{x,y,u,v}\\) najve\u0107i zbir ozna\u010denih povr\u0161ina trapeza koji se mo\u017ee dobiti nekom putanjom od \\((0,0)\\) do \\((x,y)\\) pri \u010demu smo iskoristili \\(u\\) segmenata du\u017eine \\(1\\) i \\(v\\) segmenata du\u017eine \\(\\sqrt{2}\\). Prelazi su jednostavni, za svaki od osam smerova, pove\u0107avamo \\(u\\) ili \\(v\\) za jedan i korigujemo \\(x,y\\) koordinate, dok novu povr\u0161inu ra\u010dunamo pomo\u0107u formule date u drugom pasusu. Redosled izra\u010dunavanja mo\u017ee biti rastu\u0107i po \\(u+v\\). Kona\u010dno re\u0161enje je maksimalna vrednost \\(d_{W,0,u,v}\\), gde \\(u,v\\) zadovoljavaju nejednakosti iz prvog pasusa. Vremenska slo\u017eenost re\u0161enja je \\(O(L^4)\\), ali sa relativno malom skrivenom konstantom.</p> <p>Peti podzadatak se mo\u017ee re\u0161iti primenom dinami\u010dkog programiranja sa druga\u010dijim na\u010dinom ra\u010dunanja povr\u0161ine. Da bi se smanjila slo\u017eenost, figura se mo\u017ee graditi sa oba kraja ograde odjednom. Neka je \\(d_{w,u,v}\\) najve\u0107a povr\u0161ina figure koja se mo\u017ee dobiti nekom putanjom od \\((0,0)\\) do \\((w,0)\\) pri \u010demu smo iskoristili \\(u\\) segmenata du\u017eine \\(1\\) i \\(v\\) segmenata du\u017eine \\(\\sqrt{2}\\). Za prelaze jedna opcija je da dodamo horizontalni segment du\u017eine \\(1\\) na neki kraj ograde i time pove\u0107amo ili smanjimo \\(w\\) za 1, druga opcija je da pove\u0107amo \\(y\\) koordinatu na oba kraja ograde dodavanjem segmenata i dodamo odgovaraju\u0107u povr\u0161inu koja se dobija izme\u0111u ta 2 segmenta. </p> <p>Svi mogu\u0107i prelazi iz stanja \\(d_{w,u,v}\\) su:</p> <ul> <li>U stanje \\(d_{w+1,u+1,v}\\), na povr\u0161inu se ne dodaje ni\u0161ta</li> <li>U stanje \\(d_{w-1,u+1,v}\\), na povr\u0161inu se ne dodaje ni\u0161ta</li> <li>U stanje \\(d_{w+2,u,v+2}\\), na povr\u0161inu se dodaje \\(2*w+2\\)</li> <li>U stanje \\(d_{w+1,u+1,v+1}\\), na povr\u0161inu se dodaje \\(2*w+1\\)</li> <li>U stanje \\(d_{w,u+2,v}\\), na povr\u0161inu se dodaje \\(2*w\\)</li> <li>U stanje \\(d_{w-1,u+1,v+1}\\), na povr\u0161inu se dodaje \\(2*w-1\\)</li> <li>U stanje \\(d_{w-2,u,v+2}\\), na povr\u0161inu se dodaje \\(2*w-2\\)</li> </ul> <p>Nama je potrebna maksimalna vrednost od ovih prelaza.  Redosled izra\u010dunavanja mo\u017ee biti opadaju\u0107i po \\(u+v\\). Kona\u010dno re\u0161enje je \\(d_{W,0,0}\\). Vremenska slo\u017eenost re\u0161enja je \\(O(L^3)\\).</p> <p>Izazov: Da li mo\u017eete da re\u0161ite zadatak u vremenskoj slo\u017eenosti \\(O(L^2)\\)?</p> <p>Dokaz: Neka je \\((p,q)\\) najkra\u0107a du\u017e \u010dija unutra\u0161njost cela le\u017ei van figure, dok ta\u010dke \\(p,q\\) le\u017ee na ivici figure tj. na putanji. Ukoliko ovu du\u017e zamenimo jednom najkra\u0107om putanjom (mereno u osmosmernoj metrici) koja je \"ispup\u010dena\" u odnosu na du\u017e \\(p,q\\), dobi\u0107emo putanju strogo manje du\u017eine a figuru strogo ve\u0107e povr\u0161ine.</p> 04_dido.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint Dido(int W,int L){\n    int M = L/sqrtl(2);\n    auto goodState=[&amp;](int dist,int a,int b){\n        if(dist&lt;0||dist&gt;=L||a&gt;L||b&gt;M)\n            return false;\n        if(L-a-dist&lt;0)\n            return false;\n        if(2*b*b&gt;(L-a-dist)*(L-a-dist))\n            return false;\n        return true;\n    };\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(L,vector&lt;vector&lt;int&gt;&gt;(L+1,vector&lt;int&gt;(M+1)));\n    for(int a=L;a&gt;=0;a--)\n        for(int b=M;b&gt;=0;b--)\n            for(int dist=0;dist&lt;L;dist++){\n                if(!goodState(dist,a,b))\n                    continue;\n                dp[dist][a][b]=0;\n\n                if(goodState(dist+1,a+1,b))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist+1][a+1][b]);\n\n                if(goodState(dist+2,a,b+2))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist+2][a][b+2]+dist+dist+2);\n\n                if(goodState(dist+1,a+1,b+1))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist+1][a+1][b+1]+dist+dist+1);\n\n                if(goodState(dist,a+2,b))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist][a+2][b]+dist+dist);\n\n                if(goodState(dist-1,a+1,b+1))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist-1][a+1][b+1]+dist+dist-1);\n\n                if(goodState(dist-2,a,b+2))\n                    dp[dist][a][b]=max(dp[dist][a][b],dp[dist-2][a][b+2]+dist+dist-2);\n            }\n    return dp[W][0][0];\n}\n</code></pre>"},{"location":"takprog/2019_2020/sio/04_dido/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Dido(W, L)\\)</li> </ul> <p>gde je \\(W\\) \\(x\\)-koordinata drugog kraja ograde, a \\(L\\) maksimalna du\u017eina novog dela ograde. Funkcija treba da vrati dvostruku najve\u0107u povr\u0161inu kraljevstva.</p>"},{"location":"takprog/2019_2020/sio/04_dido/#primer","title":"Primer","text":"<p>Neka je \\(W=1\\) i \\(L=6\\),</p> <p>Tada je najve\u0107a mogu\u0107a povr\u0161ina \\(3\\) (funkcija treba da vrati dvostruku najve\u0107u povr\u0161inu tj. \\(6\\)), i jedan na\u010din da se dobije ta povr\u0161ina je slede\u0107i:</p> <p>\\((0,0) \\rightarrow (-1,1) \\rightarrow (0,2) \\rightarrow (1,2) \\rightarrow (1,1) \\rightarrow (1,0)\\) </p> <p>Ukupna du\u017eina ograde je \\(5.8284271247\\dots\\)</p>"},{"location":"takprog/2019_2020/sio/04_dido/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0\\leq W, L\\leq300\\)</li> <li>Postoji bar jedan na\u010din da se ogradi kraljevstvo pozitivne povr\u0161ine.</li> </ul>"},{"location":"takprog/2019_2020/sio/04_dido/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(5\\) podzadatka:</p> <ul> <li>[21 poena]: \\(W, L \\leq 5\\)</li> <li>[16 poena]: \\(W, L \\leq 10\\)</li> <li>[18 poena]: \\(W, L \\leq 40\\)</li> <li>[22 poena]: \\(W, L \\leq 70\\)</li> <li>[23 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/sio/04_dido/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>dido.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Dido(int W,int L);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom i jedinom redu brojeve \\(W\\) i \\(L\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa broj koji vrati funkcija.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/","title":"5 - Mra\u010dna soba","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 64MB <p>Nekada, ne toliko davno, na jednom fakultetu ne toliko daleko, \u010duveni Isidor je uslikao pove\u0107i broj slika svojom \"MST\"-kamerom. Me\u0111utim, on sada ima \u017eelju da te fotografije sam razvije, a za to mu je potrebno da prostor bude taman (sa akcentom na prvo a). Da bi to uradio, ogradi\u0107e neki deo svoje dnevne sobe i u njemu \u0107e isklju\u010diti sva svetla i baciti se na posao.</p> <p>Isidorova dnevna soba se mo\u017ee zamisliti kao matrica \\(N\\times M\\), i ima pomalo neobi\u010dan raspored  lampi i prekida\u010da u njoj. Naime, u svakom polju te matrice se nalazi po jedna lampa, koja je na po\u010detku ili isklju\u010dena ili uklju\u010dena, \u0161to zna\u010di da ima ukupno \\(M\\cdot N\\) lampi. On tako\u0111e ima \\((M-1)\\cdot (N-1)\\) prekida\u010da koji se nalaze u ta\u010dkama preseka linija koje odre\u0111uju matricu, i oni menjaju stanje lampama u svim poljima u \u010dijem su \u0107o\u0161ku. Formalnije, za svako \\(1\\le i\\le N-1\\) i \\(1\\le j\\le M-1\\) postoji prekida\u010d koji menja stanja (isklju\u010deno u uklju\u010deno, i obrnuto) lampama \\((i,j), (i+1,j), (i,j+1), (i+1,j+1)\\). Isidor \u0107e ograditi jednu podmatricu kao svoju sobu za razvijanje slika.</p> <p>Isidor ka\u017ee da je podmatrica mra\u010dna soba ukoliko je mogu\u0107e da posle ogra\u0111ivanja koriste\u0107i prekida\u010de strogo unutar te sobe na\u010dini da su sve lampe u sobi isklju\u010dene. Ovo zna\u010di da ne sme da dira prekida\u010de koji menjaju stanje lampama van ogra\u0111ene podmatrice. On je to ve\u0107 odavno uradio i ve\u0107 uveliko razvija fotografije, ali ga ipak interesuje ta\u010dan broj na\u010dina na koji je mogao da ogradi takvu podmatricu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107 <p>U ovom zadatku je potrebno izbrojati sve podmatrice date matrice jedinica i nula koje imaju svojstvo mra\u010dne sobe. Matrica ima svojstvo mra\u010dne sobe je da nizom poteza gde u svakom potezu uzmemo \\(2\\times2\\) podmatricu i promenimo svaki broj u njoj, mo\u017eemo da dovedemo da ona sadr\u017ei samo nule. </p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Prebroj(N, M, A[\\ldots][\\ldots])\\)</li> </ul> <p>gde su \\(M\\) i \\(N\\) brojevi koji predstavljaju broj kolona i vrsta u \\(A\\), a \\(A\\) je matrica u \u010dijem polju \\((i,j)\\) pi\u0161e broj \\(0\\) ukoliko je lampa na polju \\((i,j)\\) po\u010detku isklju\u010dena, a \\(1\\) ukoliko je na po\u010detku uklju\u010dena. Indeksi matrice po\u010dinju od 1.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#primer","title":"Primer","text":"<p>Neka je \\(N=2\\), \\(M=3\\) i neka je \\(A\\): <pre><code>0 1 1\n0 1 1\n</code></pre> Tada je ukupan broj mra\u010dnih soba \\(5\\), i to su sobe - Samo polje \\((1,1)\\) - Samo polje \\((2,1)\\) - Podmatrica od polja \\((1,1)\\) i \\((2,1)\\) - Podmatrica od polja \\((1,2)\\), \\((2,2)\\), \\((1,3)\\) i \\((2,3)\\) - Cela matrica</p> <p>Prve tri ve\u0107 na po\u010detku imaju sve uga\u0161ene lampe, dok za druge dve je mogu\u0107e aktivitirati prekida\u010d koji menja stanje lampama na poljima \\((1,2)\\), \\((2,2)\\), \\((1,3)\\) i \\((2,3)\\).</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 500\\)</li> <li>\\(0 \\leq A_i \\leq 1\\)</li> </ul>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(7\\) podzadatka:</p> <ul> <li>[4 poena]: \\(N=1\\)</li> <li>[7 poena]: \\(N=2\\)</li> <li>[6 poena]: \\(N,M\\leq5\\)</li> <li>[12 poena]: \\(N,M\\leq50\\)</li> <li>[16 poena]: \\(N,M\\leq100\\)</li> <li>[29 poena]: \\(N,M\\leq300\\)</li> <li>[26 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>mracna_soba.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>long long Prebroj(int N, int M, int** A);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, M\\),</li> <li>U narednih \\(N\\) redova po \\(M\\) brojeva. U \\(i\\)-tom redu nalaze se brojevi \\(A_{i,1}, A_{i,2}, \\ldots, A_{i,M}\\)</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa broj koji vrati funkcija.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-1-n1","title":"Podzadatak 1: \\(N=1\\)","text":"<p>U ovom podzadatku, kakvu god pod podmatricu izabrao, nije mogu\u0107e izvr\u0161iti nijedan potez, pa je dovoljno samo na\u0107i koliko ima podmatrica sa svim nulama. Ovo se lako implementira.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-3-nmleq5","title":"Podzadatak 3: \\(N,M\\leq5\\)","text":"<p>Da bi se re\u0161io ovaj podzadatak,  potrebno je primetiti da ako re\u0161enje postoji, postoji i re\u0161enje gde se svaka \\(2\\times2\\) podmatrica aktivira najvi\u0161e jednom. Ovo va\u017ei, jer ako neku \\(2\\times2\\) podmatricu aktiviramo dvaput, posti\u017eemo isti efekat kao da nismo nijednom. Sada kada znamo ovo, mo\u017eemo proveriti svaku podmatricu u \\(O(MN\\cdot2^{(M-1)(N-1)})\\), proveravaju\u0107i sve mogu\u0107e kombinacije aktiviranih \\(2\\times2\\) podmatrica. Ovime nalazimo re\u0161enje u \\(O(M^2N^2\\cdot2^{(M-1)(N-1)})\\).</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-2-n2","title":"Podzadatak 2: \\(N=2\\)","text":"<p>U ovom podzadatku \u0107emo ve\u0107 dobiti ose\u0107aj kako treba da izgleda mra\u010dna soba. Na po\u010detku mo\u017eemo da re\u0161imo slu\u010daj \\(N=1\\) za obe vrste, kao u prvom podzadatku i sada nam ostaju jo\u0161 samo podmatice koje sadr\u017ee obe vrste. O\u010digledno da bi matrica \\(2\\times P\\) bila mra\u010dna soba, ne smemo imati nijednu kolonu sa razli\u010ditim brojevima, jer \u0107e oni ostati razli\u010diti i kroz poteze. Stoga mo\u017eemo te podmatrice koje preostaju da gledamo kao niz du\u017eine \\(P\\) sa jedinicama i nulama, gde u jednom potezu menjamo dva uzastopna broja. </p> <p>Primetimo da operacijama menjamo broj jedinica za \\(-2,0\\) ili \\(2\\). Iz ovoga zaklju\u010dujemo da se parnost broja jedinica ne menja kroz operacije, \u0161to zna\u010di da nam niz mora imati parno mnogo jedinica da bi odgovarao mra\u010dnoj sobi. Ovo je i dovoljan uslov i to mo\u017eemo dokazati slede\u0107im algoritmom: idemo redom po svim parovima uzastopnih i ukoliko je prvi broj jedan aktiviramo taj par u suprotnom ne aktiviramo. Indukcijom se lako poka\u017ee da kad zavr\u0161imo prvih \\(k\\) parova, prvih \\(k\\) brojeva u nizu \u0107e biti \\(0\\). Na kraju znamo da \u0107e nam svi \u010dlanovi niza, osim mo\u017eda poslednjeg, biti \\(0\\). Me\u0111utim kako se parnost broja jedinica nije menjala kroz operacije, ako smo na po\u010detku imali parno mnogo jedinica, poslednji \u010dlan isto mora biti \\(0\\) jer bi u suprotnom imali ta\u010dno jednu jedinicu, \u0161to je neparan broj jedinica.</p> <p>Kada smo na\u0161li uslov, samo re\u0161enje se trivijalno implementira.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#kako-izgleda-mracna-soba","title":"Kako izgleda mra\u010dna soba?","text":"<p>Sada \u0107emo nadograditi dokaz iz prethodnog dela na potreban i dovoljan uslov da je matrica mra\u010dna soba za svaku matricu. Ispostavlja se da je potreban i dovoljan uslov da u svakoj vrsti i svakoj koloni ima paran broj jedinica. </p> <p>Dokaz da je potreban uslov je jako sli\u010dan dokazu malo\u010das. U jednom potezu u svakoj vrsti i svakoj koloni promenimo broj jedinica za \\(-2,0\\) ili \\(2\\), a na kraju treba da ih je \\(0\\) u svakoj koloni i vrsti. </p> <p>Dokaz da je ovo dovoljan uslov prati sli\u010dan \u0161ablon kao prethodni tako\u0111e, ali je malo komplikovaniji. Naime, prolazi\u0107emo kroz sve \\(2\\times2\\) redom, krenuv\u0161i od gornjeg-levog ugla i idu\u0107i redom po kolonama pa po vrstama (obradi\u0107emo prvo celu jednu kolonu, pa slede\u0107u kolonu itd). U svakom trenutku \u0107emo gledati da li je gornje-levo polje na\u0161e matrice \\(2\\times2\\) i aktivirati matricu ako i samo ako je na tom polju jedinica. Opet se indukcijom relativno lako mo\u017ee dokazati da \u0107emo imati nule na svim pozicijama koje nisu poslednja vrsta ili poslednja vrsta. Me\u0111utim, jer znamo da su u svakom redu i svakoj vrsti broj jedinica paran, mo\u017eemo da zaklju\u010dimo da su i na ovim poljima nule, \u010dime smo zavr\u0161ili dokaz. </p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-4-nmleq50","title":"Podzadatak 4:  \\(N,M\\leq50\\)","text":"<p>Sada kada smo dokazali prethodno tvr\u0111enje re\u0161enje u \\(O(M^3N^3)\\) se prirodno name\u0107e, gde svaku matricu pro\u0111emo i vidimo jel ispunjava uslov. S obzirom na malu konstantu ovog re\u0161enja, ono je dovoljno brzo za ovaj podzadatak.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-5-nmleq100","title":"Podzadatak 5:  \\(N,M\\leq100\\)","text":"<p>Optimizacija na \\(O(M^2N^2(M+N))\\) nije te\u0161ka. Dovoljno je ubrzati proveru matrice \\(X\\times Y\\) iz \\(O(XY)\\) u \\(O(X+Y)\\). Ovo je mogu\u0107e uraditi pam\u0107enjem prefiksnih suma u svakom redu i svakoj koloni i onda vr\u0161e\u0107i proveru za svaku vrstu/kolonu u \\(O(1)\\) oduzimaju\u0107i dve parcijalne sume. Opet zbog male konstante ovo re\u0161enje je dovolljno brzo za ovaj podzadatak.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-6-nmleq-300","title":"Podzadatak 6:  \\(N,M\\leq 300\\)","text":"<p>Jedan na\u010din da se ovaj podzadatak re\u0161i je da se prethodni podzadatak ubrza pomo\u0107u \"std::bitset\". Alternativni na\u010din je da fiksiramo gornju i donju vrstu matrice koje \u0107emo da brojimo. Mo\u017eemo kao iz prethodnog podzadatka u \\(O(1)\\) da odredimo koje kolone su dobre i da to podelimo u klase uzastopnih dobrih kolona. Da bi sve vrste izme\u0111u njih bile dobre treba da kada sra\u010dunamo prefiksne sume po modulu \\(2\\) treba da daju isti niz. Ovo u su\u0161tini zna\u010di kad zamenimo matricu prefiksnim sumama po modulu \\(2\\) treba da nam se ram poklapa. Da bismo videli da li se levi i desni deo rama poklapaju brzo, mogu\u0107e je koristiti he\u0161 koji se unapred izra\u010duna. Sada za svaki mogu\u0107i he\u0161 treba videti kolko ga ima da okdgovara nekom datom bloku uzastopnih dobrih kolona. Sada ako za neki blok dobrih uzastopnih imamo \\(X\\) njih koji imaju dati he\u0161, treba na reultat da dodamo \\(\\binom{X}{2}\\). Da bismo ovo uradili potrebno je he\u0161eve podeliti u skupove istih, \u0161to je najlak\u0161e sortom u \\(O(N\\log N)\\). Ovo nam daje \\(O(N^3\\log N)\\) re\u0161enje.</p>"},{"location":"takprog/2019_2020/sio/05_mracna_soba/#podzadatak-7-nmleq-500","title":"Podzadatak 7:  \\(N,M\\leq 500\\)","text":"<p>Re\u0161enje za ovaj podzatak je sli\u010dan prethodnom, sa jednom klju\u010dnom optimizacijom. Naime, podelu kolona u skupove koju smo ranije radili he\u0161om i sortiranjem, \u0107emo raditi strukturom podataka \"trie\". Fiksira\u0107emo samo donju vrstu, dok \u0107emo gornju pomerati nagore za jedan po jedan, i sve iz jednog skupa istih prefiksnih suma propagiramo niz \"trie\" razdvajaju\u0107i ih u \\(1\\) ili \\(2\\) skupa. Ovo je dosta sli\u010dno sortiranju nizova putem \"radix-sort\". Ovako ubrzavamo re\u0161enje na \\(O(N^3)\\), \u0161to je dovoljno brzo za \\(100\\) poena.</p> 05_mracna_soba.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 507\nusing namespace std;\nint v[MAXN][MAXN],h[MAXN][MAXN],nz[MAXN];\nvector&lt;int&gt; w[2][MAXN];\nlong long cl[MAXN];\nlong long Prebroj(int N, int M, int** A)\n{\n    long long sol=0;\n    for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++) h[i][j]=h[i][j-1]^A[i][j];\n    for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++) v[i][j]=v[i-1][j]^A[i][j];\n    for(int i=1;i&lt;=N;i++)\n    {\n        for(int j=0;j&lt;M;j++) w[0][j].clear();\n        for(int j=0;j&lt;M;j++) w[1][j].clear();\n        for(int j=0;j&lt;=M;j++) w[0][0].push_back(j);\n        int t=0,cc=1,cp;\n        for(int k=i-1;k&gt;=0;k--)\n        {\n            cp=cc; cc=0;\n            for(int j=0;j&lt;cp;j++)\n            {\n                if(w[t][j].size()==1) {w[t][j].clear(); continue;}\n                bool z[2]={false,false};\n                for(int x=0;x&lt;w[t][j].size();x++) z[h[k+1][w[t][j][x]]]=true;\n                for(int y=0;y&lt;2;y++) if(z[y]) \n                {\n                    for(int x=0;x&lt;w[t][j].size();x++) if(h[k+1][w[t][j][x]]==y) w[t^1][cc].push_back(w[t][j][x]);   \n                    cc++;\n                }\n                w[t][j].clear();\n            } \n            t^=1;\n            int p=-1;\n            nz[0]=-1;\n            for(int j=1;j&lt;=M;j++)\n            {\n                if(v[i][j]!=v[k][j]) p=-1;\n                else if(p==-1) p=j;\n                nz[j]=p;\n            }\n            for(int j=1;j&lt;=M;j++) cl[j]=0;\n            for(int j=0;j&lt;cc;j++) \n            {\n                for(int x=0;x&lt;w[t][j].size();x++) \n                {\n                    if(nz[w[t][j][x]]!=-1) sol+=cl[nz[w[t][j][x]]];\n                    if(nz[w[t][j][x]+1]!=-1) cl[nz[w[t][j][x]+1]]++;\n                }\n                for(int x=0;x&lt;w[t][j].size();x++) if(nz[w[t][j][x]+1]!=-1) cl[nz[w[t][j][x]+1]]--;\n            }\n        }\n    }\n    return sol;\n}\n</code></pre>"},{"location":"takprog/2019_2020/sio/06_metro/","title":"6 - Metro","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>U toku je planiranje prve faze beogradskog metroa, koja radi jednostavnosti vozi isklju\u010divo sa juga na sever (ko \u017eeli da se vozi nazad ide tramvajem). Postoji \\(N\\) stanica metroa, i one se mogu podeliti u tri grupe: ju\u017ene (ju\u017eno od Save), severne (severno od Save), i sredi\u0161nje (koje se nalaze ba\u0161 ispod korita Save). Jedna od ju\u017enih stanica je glavna polazna stanica i ima redni broj 1, a jedna od severnih stanica je glavna dolazna stanica i ima redni broj 2.</p> <p>\\(M\\) jednosmernih metro tuneli povezuje stanice. Va\u017ei slede\u0107e:</p> <ul> <li>Tuneli koje kre\u0107u iz ju\u017enih stanica idu do ju\u017enih ili sredi\u0161njih stanica.</li> <li>Tuneli koje kre\u0107u iz sredi\u0161njih ili severnih stanica idu do severnih stanica.</li> <li>Ju\u017ene stanice imaju ta\u010dno jedan ulazni tunel, osim glavne polazne stanice, u koju ne ulazi nijedan tunel.</li> <li>Severne stanice imaju ta\u010dno jedan izlazni tunel, osim glavne dolazne stanice, iz koje ne izlazi nijedan tunel.</li> <li>Sredi\u0161nje stanice imaju ta\u010dno jedan ulazni i jedan izlazni tunel.</li> <li>Mapa metroa se mo\u017ee nacrtati tako da se tuneli ne seku, pri \u010demu je redosled stanica na ulazu isti kao redosled na mapi sa istoka na zapad (svaka stanica je isto\u010dno od onih sa ve\u0107im indeksom) i va\u017ei da ukoliko postoji tunel od stanice \\(u\\) do stanice \\(v\\), onda je na mapi stanica \\(u\\) ju\u017enije od stanice \\(v\\).</li> <li>Garantuje da se u svaku stanicu mo\u017ee sti\u0107i iz glavne polazne stanice, i da se iz svake stanice mo\u017ee sti\u0107i u glavnu dolaznu stanicu.</li> </ul> <p>Data vam je mapa metroa i vreme potrebno da se pro\u0111e kroz svaki od tunela. Potrebno je da odgovorite na \\(Q\\) upita slede\u0107ih tipova:</p> <ul> <li>Promeni vreme potrebno da se pro\u0111e kroz dati tunel na \\(t\\).</li> <li>Odredi vreme potrebno da se stigne od glavne polazne do glavne dolazne stanice \\(K\\)-tim najbr\u017eim putem (garantuje se da \u0107e postojati bar \\(K\\) puteva).</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Du\u0161an Zdravkovi\u0107 Dimitrije Erdeljan Tadija \u0160ebez Aleksa Milisavljevi\u0107 i Pavle Martinovi\u0107"},{"location":"takprog/2019_2020/sio/06_metro/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{Resi}(N, M, U[\\dots], V[\\dots], C[\\dots], Q, A[\\dots],   B[\\dots], R[\\dots])\\)</li> </ul> <p>gde je:</p> <ul> <li>\\(N\\) broj stanica.</li> <li>\\(M\\) broj tunela.</li> <li>\\(U\\), \\(V\\), \\(C\\) nizovi du\u017eine \\(M\\) koji opisuju tunele: \\(i\\)-ti tunel ide od stanice \\(U[i]\\) do \\(V[i]\\) i potrebno je \\(C[i]\\) sekundi da se pro\u0111e.</li> <li>\\(Q\\) broj upita.</li> <li>\\(A\\) i \\(B\\) nizovi du\u017eine \\(Q\\) koji sadr\u017ee upite, a \\(R\\) niz du\u017eine \\(Q\\) u koji je potrebno zapisati rezultate upita. Konkretno, za \\(i\\)-ti upit:<ul> <li>Ako \\(A[i] = -1\\), potrebno je u \\(R[i]\\) zapisati vreme potrebno da se stigne od glavne polazne do glavne dolazne stanice \\(B[i]\\)-tim najbr\u017eim putem.</li> <li>U suprotnom, potrebno je promeniti vreme prolaska kroz \\(A[i]\\)-ti tunel na \\(B[i]\\) i ostaviti vrednost \\(R[i]\\) nepromenjenu.</li> </ul> </li> </ul> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#primer","title":"Primer","text":"<p>Neka je \\(N = 6\\), \\(M = 7\\), \\(U = [1, 1, 5, 5, 3, 4, 6]\\), \\(V = [5, 6, 3, 4, 2, 2, 2]\\), \\(C = [1, 8, 2, 4, 5, 5, 2]\\), \\(Q = 4\\), \\(A = [-1, -1, 6, -1]\\) i \\(B = [1, 3, 7, 3]\\).</p> <p>Ovaj ulaz opisuje metro u kom su stanice \\(1\\) (glavna polazna) i \\(5\\) ju\u017ene, stanice \\(3\\), \\(4\\) i \\(6\\) sredi\u0161nje i stanica \\(2\\) (glavna dolazna) severna. Mogu\u0107i putevi su:</p> <ul> <li>\\(1 \\to 5 \\to 3 \\to 2\\), sa vremenom \\(8\\),</li> <li>\\(1 \\to 5 \\to 4 \\to 2\\), sa vremenom \\(10\\), i </li> <li>\\(1 \\to 6 \\to 2\\), sa vremenom \\(10\\).</li> </ul> <p>Odgovor na prvi upit je vreme kroz najbr\u017ei put (\\(8\\)), a na drugi vreme kroz tre\u0107i najbr\u017ei put (\\(10\\)). Nakon tre\u0107eg upita vreme kroz poslednji put postaje \\(12\\) (jer je du\u017eina tunela \\(4 \\to 2\\) pove\u0107ana), \u0161to je i odgovor na poslednji upit.</p> <p>Dakle, o\u010dekivan izlaz je \\(R = [8, 10, ?, 12]\\), gde \\(?\\) predstavlja \u010dlan koji odgovara upitu u kom se menja vreme prolaska kroz tunel.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 50000\\).</li> <li>\\(1 \\leq Q \\leq 20000\\).</li> <li>\\(N-1 \\leq M \\leq 2N-4\\).</li> <li>Du\u017eine tunela (i originalne, i nakon promene) su u intervalu \\([0, 10^4]\\).</li> </ul>"},{"location":"takprog/2019_2020/sio/06_metro/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \u0161est podzadataka:</p> <ul> <li>[3 poena]: \\(Q = 1\\).</li> <li>[6 poena]: \\(N, Q \\leq 1000\\).</li> <li>[14 poena]: Postoji najvi\u0161e \\(1000\\) sredi\u0161njih stanica.</li> <li>[21 poena]: Sve promene vremena se odnose na tunele koji kre\u0107u iz   sredi\u0161nje stanice ili sti\u017eu u sredi\u0161nju stanicu.</li> <li>[23 poena]: U svim upitima u kojima se tra\u017ei vreme, va\u017ei \\(B[i] =   1\\).</li> <li>[33 poena]: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2019_2020/sio/06_metro/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>metro.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int M, int *U, int *V, int *C, int Q, int *A, int *B, long long *R);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova/matrica, ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N, M\\).</li> <li>U narednih \\(M\\) redova po tri broja. U \\(i\\)-tom redu nalaze se brojevi \\(U_i, V_i, C_i\\).</li> <li>U narednom redu broj \\(Q\\).</li> <li>U narednih \\(Q\\) redova po dva broja: \\(A_i\\) i \\(B_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa odgovore na upite koje funkcija popuni u nizu \\(R\\).</p>"},{"location":"takprog/2019_2020/sio/06_metro/#izgled-metroa","title":"Izgled metroa","text":"<p>Stanice i tunele mo\u017eemo smatrati \u010dvorovima i granama usmerenog grafa. Prvo treba da zaklju\u010dimo nekoliko stvari o tome kako ovaj graf izgleda. </p> <p>Posmatrajmo prvo samo ju\u017ene stanice i tunele izme\u0111u njih. Ove stanice imaju ta\u010dno jedan ulazni tunel, osim glavne polazne stanice u koju ne ulazi nijedan tunel. Prema tome, ju\u017ene stanice formiraju usmereno stablo sa korenom u glavnoj polaznoj stanici tako da su sve grane usmerene od korena ka listovima. Sli\u010dno, i severne stanice formiraju usmereno stablo sa korenom u glavnoj dolaznoj stanici, ali grane su suprotno usmerene, tj. od listova ka korenu. </p> <p>Ova dva stabla su povezana preko sredi\u0161njih stanica i za svaku sredi\u0161nju stanicu postoji ta\u010dno jedan put koji vodi od glavne polazne stanice do gravne dolazne stanice preko nje. Prema tome, broj razli\u010ditih puteva jednak je broju sredi\u0161njih stanica. Treba nekako da odr\u017eavamo du\u017eine puteva od glavne polazne stanice do svake sredi\u0161nje, i od svake sredi\u0161nje do glavne dolazne stanice. Ako srednje stanice smatramo zajedni\u010dkim listovima za dva stabla, ove udaljenosti su ustvari dubine listova u stablima.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#preprocesiranje-grafa","title":"Preprocesiranje grafa","text":"<p>U ulazu nam nije dato koje stanice su ju\u017ene, koje severne, a koje sredi\u0161nje, me\u0111utim, ovo mo\u017eemo sami da zaklju\u010dimo. </p> <p>Svaka stanica koja ima vi\u0161e od jedne izlazne grane je ju\u017ena stanica, a svaka stanica koja ima vi\u0161e od jedne ulazne grane je severna stanica. Ako krenemo DFS obilazak (pretragu u dubinu) od glavne polazne stanice, i ne prelazimo nijednu stanicu za koju ve\u0107 znamo da je severna, sve stanice do kojih nismo uspeli da do\u0111emo su severne. Srednje stanice su one od preostalih stanica koje imaju tunel ka nekoj od severnih stanica. I na kraju kada smo na\u0161li severne i srednje stanice znamo i koje su ju\u017ene.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#podzadaci-kada-je-q-1-i-n-q-leq-1000","title":"Podzadaci kada je \\(Q = 1\\) i \\(N, Q \\leq 1000\\)","text":"<p>Za svaki upit, prona\u0111imo najkra\u0107i put od glavne polazne stanice do svake sredi\u0161nje stanice, i najkra\u0107i put od svake sredi\u0161nje stanice do glavne dolazne stanice. Ovo se mo\u017ee realizovati primenom Dijkstrinog algoritma dva puta, jednom po\u010dev\u0161i od glavne polazne stanice i drugi put iz glavne dolazne stanice, ali kada obrnemo smer svakog tunela. Kada za svaku sredi\u0161nju stanicu saberemo dve distance koje smo na\u0161li, lako mo\u017eemo da odgovorimo na upit sortiranjem dobijenih vrednosti.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#podzadatak-kada-se-sve-promene-vremena-odnose-na-tunele-koji-krecu-iz-sredisnje-stanice-ili-stizu-u-sredisnju-stanicu","title":"Podzadatak kada se sve promene vremena odnose na tunele koji kre\u0107u iz sredi\u0161nje stanice ili sti\u017eu u sredi\u0161nju stanicu","text":"<p>Na po\u010detku mo\u017eemo da na\u0111emo du\u017eine puteva od glavne polazne do glavne dolazne stanice preko svake sredi\u0161nje stanice. Svaka promena vremena menja ta\u010dno jedan od puteva. Treba nam na\u010din da brzo tra\u017eimo koja je \\(K\\)-ta najmanja du\u017eina puta, podr\u017eavaju\u0107i ove promene. Napravimo niz \\(C\\) gde je \\(C_i\\) broj puteva du\u017eine \\(i\\). Napravimo Fenvikovo stablo nad ovim nizom. Tako mo\u017eemo u \\(O(logD)\\) da promenimo vrednost niza \\(C\\), i da na\u0111emo koliko ima puteva ne du\u017eih od \\(x\\), gde je \\(D\\) najve\u0107a du\u017eina puta. Koriste\u0107i ovu strukturu mo\u017eemo binarnom pretragom da na\u0111emo du\u017einu \\(K\\)-tog puta. Kako du\u017eine puteva mogu biti dosta velike, a bi\u0107e manje od \\(N+Q\\) razli\u010ditih vrednosti du\u017eina puteva, mo\u017eemo da mapiramo ove vrednosti na interval \\([1, d]\\), gde je \\(d\\) broj razli\u010ditih du\u017eina puteva, koriste\u0107i \\(std::map\\) strukturu podataka.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#podzadatak-kada-postoji-najvise-1000-sredisnjih-stanica","title":"Podzadatak kada postoji najvi\u0161e \\(1000\\) sredi\u0161njih stanica","text":"<p>Posmatrajmo na koje sredi\u0161nje stanice uti\u010de promena vremena potrebnog da se pro\u0111e kroz neki tunel. Pore\u0111ajmo sredi\u0161nje stanice u niz po njihovom rasporedu od istoka ka zapadu. Ako se promena odnosi na dve sredi\u0161nje stanice onda se ona odnosi i na sve sredi\u0161nje stanice izme\u0111u njih. Dakle, svaka promena se odnosi na neki podniz sredi\u0161njih stanica. Za svaki tunel mo\u017eemo na\u0107i na koji podniz uti\u010de njegova promena ako pustimo DFS algoritam na severnom i ju\u017enom stablu. Sada u \\(O(S)\\), gde je \\(S\\) broj sredi\u0161njih stanica, mo\u017eemo da promenimo du\u017eine puteva, a \\(K\\)-ti najkra\u0107i put mo\u017eemo da na\u0111emo u \\(O(SlogS)\\) sortiranjem niza, ili u \\(O(S)\\) primenom quick select algoritma.</p>"},{"location":"takprog/2019_2020/sio/06_metro/#podzadatak-kada-se-uvek-trazi-samo-prvi-najkraci-put","title":"Podzadatak kada se uvek tra\u017ei samo prvi najkra\u0107i put","text":"<p>Kao kod pro\u0161log zadatka odr\u017eava\u0107emo niz puteva pore\u0111anih od istoka ka zapadu po njihovim sredi\u0161njim stanicama. Napravimo segmentno stablo nad ovim nizom. Koriste\u0107i lazy propagation tehniku na segmentnom stablu, mo\u017eemo da podr\u017eimo upite dodavanja neke vrednosti na ceo podniz, i upite tra\u017eenja minimuma na celom nizu. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N+QlogN)\\).</p>"},{"location":"takprog/2019_2020/sio/06_metro/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Umesto kori\u0161\u0107enja segmentnog stabla, izdelimo niz u uzastopne blokove od \\(SQ\\) puteva. Odr\u017eava\u0107emo sortirane puteve u svakom bloku. Svaka promena dodaje neku vrednost na nekoliko celih blokova i na neki deo najvi\u0161e jo\u0161 dva bloka. Primenimo lazy propagation na blokove tako da ne menjamo vrednosti svih puteva u bloku, ve\u0107 zapamtimo za koju vrednost treba promeniti ceo blok. Dva bloka koji se delom menjaju mo\u017eemo ponovo da izgradimo, tako \u0161to \u0107emo promeniti du\u017eine puteva koji se menjaju i spojiti deo bloka koji je promenjen sa delom bloka koji nije promenjen kao kod merge sort-a. Tra\u017eenje \\(K\\)-tog najkra\u0107eg puta mo\u017eemo uraditi binarnom pretragom po du\u017eini. Za neku du\u017einu mo\u017eemo na\u0107i koliko postoji puteva ne du\u017eih od te du\u017eine ako pro\u0111emo kroz sve blokove i jo\u0161 jednom binarnom pretragom na\u0111emo koliko takvih puteva postoji u svakom bloku. Vremenska slo\u017eenost operacije promene je \\(O(\\frac{N}{SQ} + SQ)\\), a tra\u017eenja re\u0161enja \\(O(\\frac{N}{SQ}logDlogSQ)\\). Ako uzmemo da je \\(SQ = \\sqrt{NlogNlogD}\\), ukupna slo\u017eenost ovog algoritma je \\(O(Q\\sqrt{NlogNlogD})\\).</p> 06_metro.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 51000\nusing namespace std;\n\nvector&lt;pair&lt;int,int&gt; &gt; a[maxn];\nvector&lt;pair&lt;int,int&gt; &gt; b[maxn];\n\nint cntu[maxn];\nint cntv[maxn];\n\nint bs;\n\nint si[maxn];\nint pos[maxn];\n\nbool posu[maxn];\nbool posv[maxn];\n\nbool sp[maxn];\nint lb[maxn];\nint rb[maxn];\n\nint paru[maxn];\nlong long valu[maxn];\nint parv[maxn];\nlong long valv[maxn];\n\nint arr[maxn];\nint parr1[maxn];\nint parr2[maxn];\nint ppermo1[maxn];\nint ppermo2[maxn];\npair&lt;int,int&gt; marr[maxn];\nint permo[maxn];\nint ad[maxn];\n\nint ch[maxn];\n\nint t=0;\nint bc=0;\n\nvector&lt;int&gt; spec;\n\nvoid dfsu(int u) {\n    if(cntu[u]&gt;1 || posu[u]) return;\n    posu[u]=true;\n    for(auto v:a[u]) dfsu(v.first);\n}\n\nvoid dfsv(int u) {\n    if(cntv[u]&gt;1 || posv[u]) return;\n    posv[u]=true;\n    for(auto v:b[u]) dfsv(v.first);\n}\n\nvoid dfsfu(int u) {\n    if(sp[u]) {\n        si[u]=++t;\n        pos[t]=u;\n        lb[u]=rb[u]=si[u];\n        return;\n    }\n    lb[u]=maxn;\n    rb[u]=0;\n    for(auto v:a[u]) {\n        paru[v.first]=u;\n        valu[v.first]=valu[u]+v.second;\n        ch[u]++;\n        dfsfu(v.first);\n        lb[u]=min(lb[u],lb[v.first]);\n        rb[u]=max(rb[u],rb[v.first]);\n    }\n}\n\nvoid dfsfv(int u) {\n    if(sp[u]) {\n        lb[u]=rb[u]=si[u];\n        return;\n    }\n    lb[u]=maxn;\n    rb[u]=0;\n    for(auto v:b[u]) {\n        parv[v.first]=u;\n        valv[v.first]=valv[u]+v.second;\n        ch[u]++;\n        dfsfv(v.first);\n        lb[u]=min(lb[u],lb[v.first]);\n        rb[u]=max(rb[u],rb[v.first]);\n    }\n}\nint lg[maxn],rg[maxn];\nvoid process_block(int b,int l,int r,int diff) {\n    if(ad[b]) {\n        for(int j=lg[b];j&lt;=rg[b];j++) arr[j]+=ad[b];\n        ad[b]=0;\n    }\n    int t1=0,t2=0;\n    for(int j=lg[b];j&lt;=rg[b];j++) {\n        int rj=permo[j];\n        if(l&lt;=rj &amp;&amp; rj&lt;=r) {\n            parr1[t1]=arr[j]+diff;\n            ppermo1[t1]=rj;\n            t1++;\n        }\n        else {\n            parr2[t2]=arr[j];\n            ppermo2[t2]=rj;\n            t2++;\n        }\n    }\n    int i1=0,i2=0;\n    int tr=0;\n    while(i1&lt;t1 &amp;&amp; i2&lt;t2) {\n        if(parr1[i1]&lt;parr2[i2]) {\n            arr[lg[b]+tr]=parr1[i1];\n            permo[lg[b]+tr]=ppermo1[i1];\n            i1++;\n        }\n        else {\n            arr[lg[b]+tr]=parr2[i2];\n            permo[lg[b]+tr]=ppermo2[i2];\n            i2++;\n        }\n        tr++;\n    }\n    while(i1&lt;t1) {\n        arr[lg[b]+tr]=parr1[i1];\n        permo[lg[b]+tr]=ppermo1[i1];\n        i1++;\n        tr++;\n    }\n    while(i2&lt;t2) {\n        arr[lg[b]+tr]=parr2[i2];\n        permo[lg[b]+tr]=ppermo2[i2];\n        i2++;\n        tr++;\n    }\n}\nvoid Resi(int N, int M, int *U, int *V, int *C, int Q, int *A, int *B, long long *R) {\n    for(int i=1;i&lt;=M;i++) {\n        cntu[V[i]]++;\n        cntv[U[i]]++;\n        a[U[i]].push_back({V[i],C[i]});\n        b[V[i]].push_back({U[i],C[i]});\n    }\n    for(int i=1;i&lt;=N;i++) sort(a[i].begin(),a[i].end()),sort(b[i].begin(),b[i].end());\n    dfsu(1);\n    dfsv(2);\n    for(int i=3;i&lt;=N;i++) if(posu[i] &amp;&amp; posv[i] &amp;&amp; !posu[a[i][0].first]) sp[i]=true,spec.push_back(i);\n    dfsfu(1);\n    dfsfv(2);\n    for(int i=1;i&lt;=t;i++) marr[i]={valu[pos[i]]+valv[pos[i]],i};\n    bs=(sqrt(t)*log(t)/log(2)+1);\n    bool ok=false;\n    for(int i=0;i*bs&lt;t;i++) {\n        bc++;\n        lg[i]=i*bs+1;\n        rg[i]=min((i+1)*bs,t);\n        sort(marr+lg[i],marr+rg[i]+1);\n        for(int j=lg[i];j&lt;=rg[i];j++) {\n            arr[j]=marr[j].first;\n            permo[j]=marr[j].second;\n        }\n    }\n    for(int i=1;i&lt;=Q;i++) {\n        if(A[i]==-1) {\n            int l=0;\n            int r=5e8;\n            int k=B[i];\n            while(l&lt;r) {\n                int m=(l+r)&gt;&gt;1;\n                int cnt=0;\n                for(int j=0;j&lt;bc;j++) {\n                    int lb=lg[j];\n                    int rb=rg[j];\n                    while(lb&lt;rb) {\n                        int mb=(lb+rb+1)&gt;&gt;1;\n                        if(arr[mb]+ad[j]&lt;=m) lb=mb;\n                        else rb=mb-1;\n                    }\n                    while(lb&gt;=lg[j] &amp;&amp; arr[lb]+ad[j]&gt;m) lb--;\n                    cnt+=(lb-lg[j]+1);\n                }\n                if(cnt&gt;=k) r=m;\n                else l=m+1;\n            }\n            R[i]=l;\n        }\n        else {\n            int u=U[A[i]];\n            int v=V[A[i]];\n            int diff=B[i]-C[A[i]];\n            C[A[i]]=B[i];\n            int l,r;\n            if(u==paru[v] || u==parv[v]) l=lb[v],r=rb[v];\n            else l=lb[u],r=rb[u];\n            int b1=(l-1)/bs;\n            int b2=(r-1)/bs;\n            for(int j=b1+1;j&lt;b2;j++) ad[j]+=diff;\n            process_block(b1,l,r,diff);\n            if(b1!=b2) process_block(b2,l,r,diff);\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/","title":"B1 - Kvadrati uzvra\u0107aju udarac","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Mile je video \\(N\\) ta\u010daka u ravni, od kojih \\(i\\)-ta ima koordinate \\((x_i,y_i)\\). Odmah je sebi postavio najprirodnije pitanje: \"Na koliko na\u010dina se mogu izabrati dve razli\u010dite ta\u010dke, tako da prva bude donje levo teme, a druga gornje desno teme nekog kvadrata sa stranicama paralelnim koordinatnim osama?\". </p> <p>Pri tome se pod donjim levim temenom kvadrata smatra ono teme koje ima najmanju \\(x\\) koordinatu i najmanju \\(y\\) koordinatu, a pod gornjim desnim temenom ono teme koje ima najve\u0107u \\(x\\) i najve\u0107u \\(y\\) koordinatu.</p> <p>Me\u0111utim, ta\u010daka ima puno i Mile je brzo odustao. Pomozite mu i odgovorite na pitanje umesto njega.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milojevi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se ceo broj \\(N\\), broj ta\u010daka u ravni. U narednih \\(N\\) redova, nalaze se po dva cela broja, \\(x_i\\) i \\(y_i\\), koji predstavljaju koordinate \\(i\\)-te ta\u010dke. </p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedini red standardnog izlaza ispisati jedan broj - koliko razli\u010ditih parova ta\u010daka mo\u017eemo izabrati, tako da prva bude donje levo teme, a druga gornje desno teme nekog kvadrata sa stranicama paralelnim koordinatnim osama.</p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 100.000\\)</li> <li>\\(0 \\leq x_i, y_i \\leq 1.000.000.000\\), za svako \\(1 \\leq i \\leq N\\)</li> <li>Garantuje se da va\u017ei \\(x_i \\neq x_j\\) ili \\(y_i \\neq y_j\\) za svako \\(i \\neq j\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#podzadaci","title":"Podzadaci","text":"<ol> <li>(18 poena) \\(x_i = y_i\\), za svako \\(1 \\leq i \\leq N\\), \\(1 \\leq N \\leq 20.000\\).</li> <li>(16 poena) \\(1 \\leq N \\leq 1.000\\).</li> <li>(29 poena) \\(0 \\leq x_i, y_i \\leq 1.000\\), za svako \\(1 \\leq i \\leq N\\).</li> <li>(37 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#ulaz","title":"Ulaz","text":"<pre><code>4\n0 0\n2 3\n5 6\n4 4\n</code></pre>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ukoliko izaberemo prvu i \u010detvrtu ta\u010dku, postoji kvadrat stranice du\u017eine \\(4\\), kojem je donje levo teme ba\u0161 prva ta\u010dka, a gornje desno ba\u0161 \u010detvrta ta\u010dka.  Sli\u010dno, ukoliko izaberemo drugu i tre\u0107u ta\u010dku, postoji kvadrat stranice du\u017eine \\(3\\), kojem je donje levo teme ba\u0161 druga ta\u010dka, a gornje desno ba\u0161 tre\u0107a ta\u010dka. Dakle, odgovor je \\(2\\). </p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n0 0\n0 2\n2 0\n</code></pre>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Koje god dve ta\u010dke da izaberemo, ne postoji kvadrat kojem je donje levo teme prva od tih ta\u010daka, a gornje desno teme druga od tih ta\u010daka. Zbog toga je odgovor \\(0\\).</p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#podzadatak-1","title":"Podzadatak 1","text":"<p>U ovom podzadatku svake dve ta\u010dke mogu formirati kvadrat opisan u zadatku, pa treba izbrojati broj svih parova ta\u010daka. Odgovor je \\(\\frac{N(N-1)}{2}\\). </p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#podzadatak-2","title":"Podzadatak 2","text":"<p>Nije te\u0161ko primetiti da ta\u010dke \\((x_1, y_1)\\) i \\((x_2, y_2)\\) mogu biti donje levo i gornje desno teme kvadrata \u010dije su stranice paralelne osama ako i samo ako du\u017e koja spaja ove dve ta\u010dke gradi ugao od \\(45\\) stepeni sa \\(x\\) osom u pozitivnom smeru (tj. paralelna je pravoj \\(y=x\\) u koordinatnom sistemu). Ako pretvorimo izrazimo ovaj uslov pomo\u0107u koordinata, vidimo da opisani kvadrat postoji ako i samo ako va\u017ei \\(x_1-y_1=x_2-y_2\\).</p> <p>Dakle, neophodno je izra\u010dunati broj parova ta\u010daka \\(\\{(x_i, y_i), (x_j, y_j)\\}\\) datog skupa za koje va\u017ei \\(x_i-y_i=x_j-y_j\\). Da bismo ovo efikasno uradili, imamo vi\u0161e pristupa. Da bismo re\u0161ili ovaj podzadatak, nije neophodno biti previ\u0161e pa\u017eljiv, pa za svaki par ta\u010daka mo\u017eemo proveriti da li va\u017ei dati uslov. Slo\u017eenost ovog re\u0161enja je \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#podzadatak-3","title":"Podzadatak 3","text":"<p>U ovom podzadatku moramo pa\u017eljivije izbrojati parove za koje va\u017ei gornji uslov. Dovoljno je napraviti matricu \\(A\\) dimenzija \\(1001\\times 1001\\) takvu da \\(A_{i, j}=1\\) ako i samo ako je ta\u010dka \\((i, j)\\) u skupu zadatih ta\u010daka, gde su \\(i, j=0, 1, \\dots, 1000\\). Tada, za svaku mogu\u0107u vrednost \\(x_i-y_i\\), mo\u017eemo izbrojati koliko se ta\u010daka nalazi na odgovaraju\u0107oj dijagonali matrice. Neka je za dijagonalu sa \\(x_i-y_i=t\\) ovaj broj jednak \\(k_t\\). Tada je odgovor \\(\\sum_{t=-1000}^{1000}\\frac{k_t(k_t-1)}{2}\\).</p> <p>Alternativno, ne moramo formirati matricu, ve\u0107 je dovoljno da za svaku mogu\u0107u razliku \\(x_i-y_i\\) pro\u0111emo kroz sve ta\u010dke skupa, za svaku od njih proveravaju\u0107i da li ima odgovaraju razliku koordinata, i na taj na\u010din odredimo broj \\(k_t\\). Odgovor je isti kao i u prethodnom pasusu. Slo\u017eenost ovog pristupa je \\(O(\\max\\{|x_i-y_i|\\}\\times N)\\).</p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#podzadatak-4","title":"Podzadatak 4","text":"<p>U ovom delu zadatka moramo efikasno odrediti brojeve \\(k_t\\) definisane gore. Ovo mo\u017eemo uraditi sortiraju\u0107i niz ta\u010daka po razlici \\(x_i-y_i\\), a zatim prolaskom kroz niz utvrditi koliko ta\u010daka me\u0111usobno ima istu razliku \\(x_i-y_i\\) (pri \u010demu nije od naro\u010ditog zna\u010daja konkretna vrednost te razlike). Odgovor je isti kao i u prethodnom podzadatku.</p>"},{"location":"takprog/2020_2021/drz/01_kvadrati_uzvracaju_udarac/#smernice-za-implementaciju","title":"Smernice za implementaciju","text":"<p>Zbog veli\u010dine brojeva u zadatku (a i potencijalne veli\u010dine odgovora), potrebno je koristiti 64-bitne brojeve, da ne bi do\u0161lo do prekora\u010denja i pogre\u0161nog odgovora.</p> 01_kvadrati_uzvracaju_udarac.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nlong long ans=0;\nint n;\nint x,y;\nmap&lt;long long,int&gt; m;\nint main() {\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++) {\n        scanf(\"%d %d\",&amp;x,&amp;y);\n        ans+=m[x-y];\n        m[x-y]++;\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/02_preduzece/","title":"B2 - Preduze\u0107e","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>U jednom preduze\u0107u za proizvodnju sira nalazi se \\(N\\) zaposlenih rapore\u0111enih u hijerarhiji tako da svaki zaposleni osim \u0161efa preduze\u0107a (zaposlenog sa rednim brojem 1) ima ta\u010dno jednog nadre\u0111enog.</p> <p>Za svakog zaposlenog je poznat njegov doprinos preduze\u0107u, \\(a_{i}\\), koji predstavlja zbir razlika njegove kompetentnosti \\(k_{i}\\) i kompetentnosti suseda. Dakle, \\(a_{i}=\\sum_{j}(k_{i}-k_{s_{j}})\\),  gde je \\(s\\) niz suseda zaposlenog \\(i\\). Dva zaposlena su susedna ako je jedan od njih nadre\u0111en onom drugom.</p> <p>Poznato je da je kompetentnost \u0161efa preduze\u0107a jednaka nuli (\\(k_{1}=0\\)), i da kompetentnosti nekih zaposlenih mogu biti negativne.</p> <p>Va\u0161 zadatak je da na osnovu hijerarhije preduze\u0107a i doprinosa svakog zaposlenog odredite kompetentnost svakog zaposlenog, ili da ispi\u0161ete \\(-1\\) ukoliko zaposlenima nije mogu\u0107e dodeliti kompetentnosti koje zadovoljavaju sve uslove.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Igor Pavlovi\u0107 Igor Pavlovi\u0107 Igor Pavlovi\u0107 Aleksa Milojevi\u0107"},{"location":"takprog/2020_2021/drz/02_preduzece/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(N\\) - broj zaposlenih u preduze\u0107u.  U narednom  redu nalazi se niz od \\(N\\) brojeva \\(a_{i}\\) - doprinos svakog od zaposlenih.  U slede\u0107em redu nalazi se niz od \\(N-1\\) brojeva \\(h_{i}\\) - zaposleni \\(h_{i}\\) je nadre\u0111en zaposlenom \\(i+1\\) i va\u017ei \\(h_{i}\\leq i\\).</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#opis-izlaza","title":"Opis izlaza","text":"<p>U jednoj liniji standardni izlaz ispi\u0161ite niz od \\(N\\) brojeva \\(k_{i}\\) odvojenih razmakom - kompetentnosti svakog od zaposlenih, ili ispi\u0161ite <code>-1</code> ukoliko takav niz ne postoji.</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N\\leq 200.000\\)</li> <li>\\(1 \\leq h_{i}\\leq i\\leq N-1\\)</li> <li>\\(-10^{9} \\leq a_{i} \\leq 10^{9}\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/02_preduzece/#podzadaci","title":"Podzadaci","text":"<ol> <li>(17 poena)  \\(h_{i}=i\\)</li> <li>(26 poena)  \\(h_{i}=(i+1)/2\\)</li> <li>(23 poena)  \\(N\\leq 2000\\)</li> <li>(34 poena)  Nema dodatnih ograni\u010denja</li> </ol>"},{"location":"takprog/2020_2021/drz/02_preduzece/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/02_preduzece/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/02_preduzece/#ulaz","title":"Ulaz","text":"<pre><code>4\n2 -3 1 0\n1 2 2\n</code></pre>"},{"location":"takprog/2020_2021/drz/02_preduzece/#izlaz","title":"Izlaz","text":"<pre><code>0 -2 -1 -2\n</code></pre>"},{"location":"takprog/2020_2021/drz/02_preduzece/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Zaposleni (1,2), (2,3), (2,4) su susedni.</p> <p>\\(a_{1}=k_{1}-k_{2}=0-(-2)=2\\)</p> <p>\\(a_{2}=k_{2}-k_{1}+k_{2}-k_{3}+k_{2}-k_{4}=-2-0+(-2)-(-1)+(-2)-(-2)=-3\\)</p> <p>\\(a_{3}=k_{3}-k_{2}=-1-(-2)=1\\)</p> <p>\\(a_{4}=k_{4}-k_{2}=-2-(-2)=0\\)</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/drz/02_preduzece/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n2 -3 1 1\n1 2 2\n</code></pre>"},{"location":"takprog/2020_2021/drz/02_preduzece/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2020_2021/drz/02_preduzece/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Ne postoji niz koji zadovoljava sve uslove.</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#podzadatak-1","title":"Podzadatak 1","text":"<p>U ovom podazadatku mo\u017eemo iskoristiti \u010dinjenicu da va\u017ei \\(k_{i+1}=2*k_{i}-k_{i-1}-a_{i}\\) (osim \u0455a \u0455aposlene 1 i \\(n\\) koji imaju samo jednog suseda). Dakle da bismo na\u0161li kompetentnost \\(i+1\\)-og zaposlenog dovoljno je da na\u0111emo kompetentnost prvih \\(i\\) zaposlenih. Po\u010dev od \\(k_{1}=0\\) mo\u017eemo rekostruisati \u010ditav niz. Nakon toga je potrebno proveriti da li dobijeni niz zadovoljava svih \\(n\\) jedna\u010dina i ispisati -1 ukoliko one nisu zadovoljene.</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#podzadatak-2","title":"Podzadatak 2","text":"<p>U ovom podzadatku treba primetiti da nam je dovoljno samo da kontrui\u0161emo niz razlika kompetentosti susednih zaposlenih. Na osonovu tih razlika i uslova \\(k_{1}=0\\) mo\u017eemo rekostruisati tra\u017eeni niz. Posmatrajmo doprinos nekog para zaposlenih \\(x\\) i \\(y\\) kao protok intenziteta \\(k_{x}-k_{y}\\) koji te\u010de od zaposlenog \\(x\\) ka zaposlenom \\(y\\). Ako zamislimo da u svakog zaposlenog \\(x\\) ulazi neki protok intenziteta \\(a_{x}\\) sa strane mo\u017eemo obezbediti da je ukupan protok svakog zaposlenog nula.</p> <p>Vrednosti svih protoka mo\u017eemo odrediti tako \u0161to iz svakog zaposlenog pustimo da te\u010de protok intenziteta \\(a_{x}\\) od njega pa sve do \u0161efa. Protok kroz neki par susednih zaposlenih je ukupan protok koji prelazi preko te grane na kraju. Primetimo tako\u0111e da je ukupan protok kroz zaposlenog 1 jednak zbiru doprinosa svih zaposlenih. Na osnovu toga se mo\u017ee pokazati da re\u0161enje postoji ako i samo ako je zbir svih doprinosa nula. Po\u0161to je udaljenost svakog zaposlenog od \u0161efa u ovom podzadatku najvi\u0161e \\(log(N)\\) ukupna slo\u017eenost je \\(O(N*log(N))\\).</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#podzadatak-3","title":"Podzadatak 3","text":"<p>U ovom podzadatku mo\u017eemo primeniti isti algoritam kao za pro\u0161li podzadatak. U ovom podzadatku slo\u017eenost takvog algoritma je \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/drz/02_preduzece/#podzadatak-4","title":"Podzadatak 4","text":"<p>Za maksimalan broj poena potrebno je rekostruisati niz razlika kompetentnosti susednih zaposlenih u linearnoj slo\u017eenosti. Ovo mo\u017eemo uraditi tako \u0161to za svakog zaposlenog zapamtimo one zaposlene kojima je on nadre\u0107en i tra\u017eeni niz razlika rekostrui\u0161emo sa desna na levo. Ako razliku zaposlenog \\(i\\) ozna\u010dimo sa \\(r_{i}=k_{i}-k_{h_i}\\) mo\u017eemo primetiti da va\u017ei \\(r_{i}=a_{i}-s\\) gde je \\(s\\) suma razlika svih zaposlenih kojima je on nadre\u0111en. Po\u0161to se njegovi podre\u0111eni nalaze posle njega u nizu mo\u017eemo smatrati da su njihove razlike ve\u0107 izra\u010dunate (jer razlike ra\u010dunamo sa desna na levo) pa je mogu\u0107e odrediti \\(r_{i}\\). Primetimo da je svaki zaposleni podre\u0111en najvi\u0161e jednom zaposlenom pa je ukupna slo\u017eenost ovog algoritma \\(O(N)\\).</p> 02_preduzece.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxN 2000005\n\nusing namespace std;\n\nlong long a[maxN],p[maxN],d[maxN],ans[maxN],n,i,j;\nvector&lt;int&gt; adj[maxN];\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);\n    cin&gt;&gt;n;\n    for(i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n    for(i=1;i&lt;n;i++){\n        cin&gt;&gt;p[i];\n        p[i]--;\n        adj[p[i]].push_back(i);\n    }\n    for(i=n-1;i&gt;=0;i--){\n        d[i]=a[i];\n        for(j=0;j&lt;adj[i].size();j++){\n            d[i]+=d[adj[i][j]];\n        }\n    }\n    ans[0]=d[0];\n    for(i=1;i&lt;n;i++) ans[i]=ans[p[i]]+d[i];\n    if(ans[0]!=0) cout&lt;&lt;-1&lt;&lt;endl;\n    else{\n        for(i=0;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;\" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/","title":"B3 - Proslava ro\u0111endana","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Katarina planira proslavu ro\u0111endana. Postoji \\(N\\) ljudi koje razmatra da pozove u goste. Katarina je veoma popularna i zna da \u0107e joj na ro\u0111endan do\u0107i svi gosti koje pozove. Ona tako\u0111e zna i da bi joj \\(i\\)-ti od tih gostiju doneo \\(a_i\\) poklona, ukoliko ga pozove. Me\u0111utim Katarina je sujeverna i \u017eelela bi da i broj gostiju i broj poklona bude deljiv sa brojem \\(M\\). Koliko najvi\u0161e poklona Katarina mo\u017ee dobiti?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Mladen Puzi\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se celi brojevi \\(N\\) i \\(M\\), gde je \\(N\\) broj ljudi koje Katarina razmatra da pozove. U narednom redu, nalazi se \\(N\\) celih brojeva, od kojih je \\(i\\)-ti broj ba\u0161 \\(a_i\\), broj poklona koje bi joj doneo \\(i\\)-ti gost ukoliko ga pozove na ro\u0111endan.</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jedan broj - koliko najvi\u0161e poklona Katarina mo\u017ee dobiti, ukoliko pozove broj gostiju deljiv sa \\(M\\), tako da oni zajedno donesu broj poklona deljiv sa \\(M\\).</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 1.000.000\\)</li> <li>\\(1 \\leq M \\leq 100\\)</li> <li>\\(0 \\leq a_i \\leq 1.000.000.000\\), za svako \\(1 \\leq i \\leq N\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#podzadaci","title":"Podzadaci","text":"<ol> <li>(7 poena) \\(1 \\leq N \\leq 20\\)</li> <li>(12 poena) \\(M = 2\\)</li> <li>(12 poena) \\(1 \\leq a_i \\leq 2\\), za svako \\(1 \\leq i \\leq N\\).</li> <li>(23 poena) \\(1 \\leq N \\leq 10.000\\)</li> <li>(46 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#ulaz","title":"Ulaz","text":"<pre><code>3 2\n5 4 1\n</code></pre>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ukoliko pozovemo prvog i tre\u0107eg gosta, pozva\u0107emo ukupno \\(2\\) gosta, koji \u0107e ukupno doneti \\(5+1 = 6\\) poklona. Kako su brojevi \\(2\\) i \\(6\\) deljivi sa \\(2\\), to je ovo jedno validno re\u0161enje. Mo\u017ee se proveriti da ne postoji na\u010din da dobijemo vi\u0161e poklona.</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#napomena","title":"Napomena","text":"<p>Katarina ne mora da pozove ni jednog gosta, u tom slu\u010daju smatramo da je i broj gostiju i broj poklona \\(0\\).  Primetite da je ovo jedno validno re\u0161enje za svako \\(M\\).</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#resenje-za-n-leq-20","title":"Re\u0161enje za \\(N \\leq 20\\):","text":"<p>Mo\u017eemo probati svaki podskup gostiju. Uzmemo maksimalan odgovaraju\u0107i podskup. Vremenska slo\u017eenost: \\(O(2^N\\cdot N)\\), memorijska slo\u017eenost: \\(O(N)\\). </p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#resenje-za-m2","title":"Re\u0161enje za \\(M=2\\):","text":"<p>\u017delimo da odaberemo paran broj ljudi i da oni ukupno donesu paran broj poklona. Podelimo ljude u dve grupe, one koje donose paran broj poklona i one koji donose neparan broj poklona. Sortirajmo ljude u obe grupe opadaju\u0107e po broju poklona. Ako imamo najmanje dve osobe u nekoj grupi, sigurno \u0107emo mo\u0107i bez konflikta da pozovemo dve osobe iz te grupe, a naravno mi \u0107emo odabrati dve osobe sa najvi\u0161e poklona. Ovaj proces ponavljamo dok nam u obe grupe ostane \\(0\\) ili \\(1\\) osoba. Tada stajemo, jer te ljude ne mo\u017eemo pozvati - ili broj zvanica ne\u0107e biti paran, ili ukupan broj njihovih poklona. Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(N)\\).</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#resenje-za-1leq-a_ileq-2","title":"Re\u0161enje za \\(1\\leq a_i\\leq 2\\):","text":"<p>Postoje samo dve vrste ljudi: ljudi koji donose jedan poklon i ljudi koji donose dva poklona. Ozna\u010dimo sa \\(k\\) broj pozvanih ljudi koji donose jedan poklon, a sa \\(t\\) broj pozvanih ljudi koji donose dva poklona. Mora va\u017eiti da su \\(t+k\\) i \\(2\\cdot t + k\\) deljivi sa \\(M\\). Fiksirajmo ostatak pri deljenju \\(t\\) sa \\(M\\) i ostatak pri deljenju \\(k\\) sa \\(M\\). Ukoliko va\u017ee na\u0161i uslovi, uze\u0107emo \u0161to ve\u0107e \\(t\\) i \\(k\\) koje zadovoljava date ostatke. Uzimamo maksimum od svih kombinacija ostataka. Vremenska slo\u017eenost: \\(O(M^2)\\), memorijska slo\u017eenost: \\(O(1)\\).</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#resenje-za-1leq-nleq-10000","title":"Re\u0161enje za \\(1\\leq N\\leq 10000\\):","text":"<p>Koristimo dinami\u010dko re\u0161enje, stanje je \\(dp[i][j][k]\\) i ozna\u010dava najbolje re\u0161enje posmatraju\u0107i prvih \\(i\\) ljudi, tako da je ostatak pri deljenju broja odabranih ljudi sa \\(M\\) ba\u0161 \\(j\\), a ostatak pri deljenju zbira njihovih poklona sa \\(M\\) ba\u0161 \\(k\\). Za \\(i\\)-ti element va\u017ei da mo\u017eemo ili da ga uzmemo ili ne, pa je rekurentna veza: $$ dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-a_i] + a_i). $$ Bitno je napomenuti da je oduzimanje u ovoj rekurentnoj vezi sprovedeno po modulu \\(M\\), na primer \\(2-5\\) po modulu \\(7\\) je \\(4\\). Poslednji korak nam je da re\u0161enje optimizujemo memorijski, po\u0161to nam trenutno zauzima previ\u0161e memorije. To mo\u017eemo uraditi tako \u0161to primetimo da kad ra\u010dunamo stanja za \\(i\\), koristimo isklju\u010divo stanja za \\(i-1\\), pa je uvek dovoljno \u010duvati samo prethodna stanja. Vremenska slo\u017eenost: \\(O(NM^2)\\), memorijska slo\u017eenost: \\(O(M^2)\\).</p>"},{"location":"takprog/2020_2021/drz/03_proslava_rodjendana/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Odvojimo goste u grupe po ostatku pri deljenju njihovog broj poklona sa \\(M\\). Imamo \\(M\\) takvih grupa, jednu za ostatak \\(0\\), jednu za ostatak \\(1\\), ..., jednu za ostatak \\(M-1\\). Sortirajmo opadaju\u0107e po broju poklona svaku grupu. </p> <p>Za svaku grupu, najvi\u0161e \\(M-1\\) ljudi ne\u0107e biti pozvani (ukoliko je makar \\(M\\) ljudi nepozvano, mo\u017eemo da pozovemo bilo kojih \\(M\\) nepozvanih ljudi, a da ne naru\u0161imo ostatke pri deljenju). To nam govori da \u0107e svi gosti u grupi koji nisu u najmanjih \\(M-1\\) sigurno biti pozvani, za ostale moramo na\u0107i optimalno re\u0161enje.</p> <p>U svakoj grupi imamo najvi\u0161e \\(M-1\\) elemenata koje posmatramo, ukupno nemamo vi\u0161e od \\(M^2\\) elemanata. Na tom broju elemenata mo\u017eemo primeniti re\u0161enje za prethodni podzadatak. Vremenska slo\u017eenost: \\(O(NlogN + M^4)\\), memorijska slo\u017eenost: \\(O(M^2)\\).</p> 03_proslava_rodjendana.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 2000000\n#define maxm 200\nusing namespace std;\nvector&lt;int&gt; v[maxm];\nlong long dp[maxm][maxm];\nlong long ndp[maxm][maxm];\nlong long ans=0;\nint n,m;\nint a[maxn];\nint x,y;\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;m);\n    for(int i=0;i&lt;n;i++) {\n        scanf(\"%d\",&amp;a[i]);\n        v[a[i]%m].push_back(a[i]);\n        ans+=a[i];\n    }\n    x=n%m;\n    y=ans%m;\n    n=0;\n    for(int i=0;i&lt;m;i++) {\n        sort(v[i].begin(),v[i].end());\n        for(int j=0;j&lt;min((int)v[i].size(),m);j++) {\n            a[n++]=v[i][j];\n        }\n    }\n    for(int i=0;i&lt;m;i++) {\n        for(int j=0;j&lt;m;j++) {\n            dp[i][j]=1e18;\n        }\n    }\n    dp[0][0]=0;\n    for(int k=0;k&lt;n;k++) {\n        for(int i=0;i&lt;m;i++) {\n            for(int j=0;j&lt;m;j++) {\n                ndp[i][j]=dp[i][j];\n            }\n        }\n        int dif=a[k]%m;\n        for(int i=0;i&lt;m;i++) {\n            int ni=i+1;\n            if(ni==m) ni=0;\n            for(int j=0;j&lt;m;j++) {\n                int nj=j+dif;\n                if(nj&gt;=m) nj-=m;\n                ndp[ni][nj]=min(ndp[ni][nj],dp[i][j]+a[k]);\n            }\n        }\n        for(int i=0;i&lt;m;i++) {\n            for(int j=0;j&lt;m;j++) {\n                dp[i][j]=ndp[i][j];\n            }\n        }\n    }\n    printf(\"%lld\",ans-dp[x][y]);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/04_zice/","title":"A1 - \u017dice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Nespretni Igor se sapleo u \u0161koli i ispustio kutiju punu \u017eica. Po\u0161to je Igor veoma poseban, i na\u010din na koji su \u017eice pale na pod je veoma poseban. Pod mo\u017eemo posmatrati kao koordinatni sistem, gde svaka ta\u010dka na podu ima svoju koordinatu. Svaka \u017eica \\(i\\) je pala tako da je predstavljena preko du\u017ei koja spaja ta\u010dke \\((a_i, 1)\\) i \\((b_i, 2)\\), odnosno, jedan kraj svake du\u017ei je na pravi \\(y = 1\\), a drugi na pravi \\(y = 2\\).</p> <p>Kada je Igor ovo video, zaboravio je \u0161ta je po\u0161ao da uradi i krenuo da se igra sa \u017eicama. Doneo je izvor struje i \u017eeli da vidi koliko najmanje \u017eica mora dodirnuti kako bi naelektrisao sve \u017eice. \u017dice nisu izolovane, pa se struja prenosi sa jedne na drugu ako se te \u017eice dodiruju, odnosno ako se njihove du\u017ei seku.</p> <p>No, po\u0161to se nikad nije bavio takmi\u010darskim programiranjem, a ima previ\u0161e \u017eica, nije u mogu\u0107nosti da to uradi sam, pa je tra\u017eio va\u0161u pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107 <p>Jednom komponentom \u017eica zva\u0107emo skup svih \u017eica do kojih stigne struja ako dodirnemo neku od njih.</p>"},{"location":"takprog/2020_2021/drz/04_zice/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza nalazi se prirodan broj \\(N\\) -- broj \u017eica. U drugom redu nalazi se niz \\(N\\) prirodnih brojeva \\(a_1, a_2, ..., a_N\\) -- koordinate krajeva du\u017ei sa prave \\(y = 1\\). U tre\u0107em redu nalazi se niz \\(N\\) prirodnih brojeva \\(b_1, b_2, ..., b_N\\) -- koordinate krajeva du\u017ei sa prave \\(y = 2\\).</p>"},{"location":"takprog/2020_2021/drz/04_zice/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati minimalan broj du\u017ei koje Igor mora dodirnuti izvorom struje kako bi struja do\u0161la do svih \u017eica.</p>"},{"location":"takprog/2020_2021/drz/04_zice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 3\\cdot10^5\\)</li> <li>\\(1 \\leq a_i, b_i \\leq 10^9\\)</li> <li>\\(a_i \\neq a_j\\) za \\(i \\neq j\\)</li> <li>\\(b_i \\neq b_j\\) za \\(i \\neq j\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/04_zice/#podzadaci","title":"Podzadaci","text":"<ol> <li>(20 poena) \\(N \\leq 5000\\). </li> <li>(20 poena) Ako dodirnuv\u0161i \u017eicu \\(i\\) struja sti\u017ee do \u017eice \\(j\\), onda se \u017eice \\(i\\) i \\(j\\) dodiruju.</li> <li>(20 poena) Koju god \u017eicu Igor dodirne strujom, struja \u0107e se pro\u0161iriti na najvi\u0161e jo\u0161 \\(5\\) \u017eica.</li> <li>(40 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2020_2021/drz/04_zice/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/04_zice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/04_zice/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 3 7 9\n7 1 2 8\n</code></pre>"},{"location":"takprog/2020_2021/drz/04_zice/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2020_2021/drz/04_zice/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Potrebno je dodirnuti najmanje dve \u017eice, na primer drugu i \u010detvrtu. Struja sa druge \u017eice \u0107e se preneti prvo na prvu \u017eicu, pa odatle i na tre\u0107u:</p> <p></p>"},{"location":"takprog/2020_2021/drz/04_zice/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/drz/04_zice/#ulaz_1","title":"Ulaz","text":"<pre><code>6\n7 9 8 5 4 6 \n9 7 8 2 3 6\n</code></pre>"},{"location":"takprog/2020_2021/drz/04_zice/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2020_2021/drz/04_zice/#resenje-za-n-leq-5000","title":"Re\u0161enje za \\(N \\leq 5000\\):","text":"<p>Konstrui\u0161imo graf gde su \u010dvorovi \u017eice, a grana izme\u0111u dva \u010dvora postoji ako se \u017eice seku. Nakon ovoga dovoljno je primeniti bilo koji grafovski algoritam koji mo\u017ee brojati broj komponentni, na primer DFS (pretragu u dubinu). Vremenska i memorijska slo\u017eenost: \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/drz/04_zice/#resenje-kada-se-zice-seku-sa-svakom-zicom-do-koje-stize-struja","title":"Re\u0161enje kada se \u017eice seku sa svakom \u017eicom do koje sti\u017ee struja:","text":"<p>Druga\u010dije re\u010deno, u svakoj komponenti \u017eica se svaka \u017eica se\u010de sa svakom. Za ovaj podzadatak nam je bila potrebna glavna ideja u zadatku: kada sortiramo \u017eice po \\(A_i\\) svaka komponenta \u017eica \u0107e se sastojati od uzastopnih \u017eica. Ovo mo\u017eemo dokazati tako \u0161to pretpostavimo suprotno: postoji komponenta koja se sastoji od makar dva (odvojena) uzastopna niza \u017eica. Da bi one bile u istoj komponenti, moraju se se\u0107i neka \u017eica iz 'levog' intervala i neka iz 'desnog' intervala. Mo\u017eemo videti ipak (najbolje ako ovo nacrtamo), da \u0107e bilo koja \u017eica izme\u0111u ta dva intervala tako\u0111e morati da se\u010de makar jednu od \u017eica iz ta dva intervala, da bi stigla do druge strane. </p> <p>Kada znamo ovo, mo\u017eemo da sortiramo \u017eice po \\(A_i\\), pa idemo sa levo na desno. Nova komponenta po\u010dinje na indeksu \\(i\\) ako se \u017eice \\(A_i\\) i \\(A_{i-1}\\) ne seku. Vremenska slo\u017eenost: \\(O(NlogN)\\),  memorijska slo\u017eenost: \\(O(N)\\). </p>"},{"location":"takprog/2020_2021/drz/04_zice/#resenje-kada-se-struja-siri-na-jos-najvise-5-zica","title":"Re\u0161enje kada se struja \u0161iri na jo\u0161 najvi\u0161e 5 \u017eica:","text":"<p>Druga\u010dije re\u010deno, svaka komponenta je veli\u010dine najvi\u0161e \\(6\\). Ponovo sortiramo \u017eice po \\(A_i\\). Mo\u017eemo re\u0161iti podzadatak da vi\u0161e na\u010dina. Idemo opet sa leva na desno, i proveravamo za narednih \\(6\\) \u017eica da li pripadaju istoj komponenti, ako ne, proverimo umesto toga za \\(5\\) \u017eica, itd... Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(N)\\).</p> <p>Mo\u017ee se re\u0161iti i grafovski sli\u010dno re\u0161enju za \\(N \\leq 5000\\).</p>"},{"location":"takprog/2020_2021/drz/04_zice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ponovo sortirajmo \u017eice po \\(A_i\\). Numeri\u0161imo ih sa leva na desno brojevima od \\(1\\) do \\(N\\). Sada sortirajmo \u017eice po \\(B_i\\), i dodelimo im prethodne vrednosti (redni broj \u017eice pri sortiranju po \\(A_i\\)). Tako dobijamo permutaciju brojeva od \\(1\\) do \\(N\\). Ozna\u010dimo sa \\(maxx_i\\) maksimum prvih \\(i\\) elemenata u permutaciji. </p> <p>Tra\u017eimo kraj prve komponente: to je najmanje \\(i\\), tako da su prvih \\(i\\) elemenata permutacije, permutacija brojeva od \\(1\\) do \\(i\\). To je u stvari najmanje \\(i\\) za koje va\u017ei da je \\(maxx_i = i\\). Sli\u010dnim rezonovanjem, dolazimo do zaklju\u010dka da se svaka komponenta zavr\u0161ava indeksom takav da va\u017ei \\(maxx_{index} = index\\), pa je samo potrebno da izbrojimo takve indekse. Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(N)\\).</p> 04_zice.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n#define MAXN 300010\nint A[MAXN], B[MAXN];\nvector&lt;pair&lt;int, int&gt; &gt; p;\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int N; cin &gt;&gt; N;\n    for(int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; A[i];\n    }\n    for(int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; B[i];\n    }\n    for(int i = 1; i &lt;= N; i++) p.push_back({A[i], B[i]});\n    sort(p.begin(), p.end());\n    sort(B+1, B+1+N);\n    int maxx = 0, rez = 0, idxx = 0;\n    for(auto x : p) {\n        ++idxx;\n        maxx = max(maxx, x.second);\n        if(maxx == B[idxx]) rez++;\n    }\n    cout &lt;&lt; rez;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/05_jakuze/","title":"A2 - Jakuze","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>U dalekom Japanu haraju mnogobrojne kriminalne grupe, poznate kao jakuza klanovi. Njihovi \u010dlanovi, jakuze, lede krv u \u017eilama svima koji su te lo\u0161e sre\u0107e da ih sretnu. U glavnom gradu Japana, Tokiju, se me\u0111u jakuzama trenutno odvija bitka za vlast. Od raznih stra\u0161nih kriminalaca, kao najja\u010di i najopasniji se izdvaja Moma, koji \u017eeli da osvoji ceo Tokio.</p> <p>Tokio se mo\u017ee zamisliti kao matrica dimenzija \\(M\\times N\\). Prvog dana \u0107e Moma zauzeti jedno (bilo koje) polje te matrice. U svakom narednom danu, on mo\u017ee zauzeti bilo koje polje koje je susedno nekom polju koje je ve\u0107 zauzeo. Dva polja su susedna ako dele stranu. Kako je Moma najopasniji jakuza, on svako polje mo\u017ee osvojiti za dan, pa \u0107e posle \\(MN\\) dana ceo Tokio biti njegov.</p> <p>Me\u0111utim, iako ga nijedna jakuza ne mo\u017ee pobediti, postoji jedna stvar koja mo\u017ee - njegovo sujeverje. On poseduje svoju mapu Tokija, i na svakom polju je napisao jedan broj od \\(1\\) do \\(MN\\), tako da je svaki broj napisan ta\u010dno jednom. On smatra da je jedini na\u010din da osvoji ceo Tokio da ba\u0161 u \\(i\\)-tom danu osvoji polje na kojem je napisao broj \\(i\\). Me\u0111utim, on je promenljivog raspolo\u017eenja, pa \u0107e \\(Q\\) puta promeniti brojeve na svojoj mapi tako \u0161to zameni brojeve u neka dva polja. Va\u0161 zadatak je da za svaih \\(Q+1\\) stanja mape (na po\u010detku i posle svakog upita) odredite da li je mogu\u0107e da Moma ispuni svoj cilj.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/drz/05_jakuze/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se tri prirodna broja \\(N,M,Q\\) - dimenzije Tokija i broj promena Momine mape. U \\(i\\)-toj od narednih \\(N\\) linija se nalazi po \\(M\\) prirodnih brojeva, gde \\(j\\)-ti predstavlja vrednost \\(A_{ij}\\) - broj koji stoji na po\u010detku u polju \\((i,j)\\) na Mominoj mapi. U \\(i\\)-toj od narednih \\(Q\\) linija se nalaze po \\(4\\) cela broja \\(xa\\), \\(ya\\), \\(xb\\), \\(yb\\) koji ozna\u010davaju da \u0107e u \\(i\\)-toj promeni zameniti vrednosti na poljima \\((xa,ya)\\) i \\((xb,yb)\\).</p>"},{"location":"takprog/2020_2021/drz/05_jakuze/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispi\u0161ite \\(Q+1\\) linija: u \\(i\\)-toj liniji treba da pi\u0161e <code>DA</code> ako Moma mo\u017ee da osvoji Tokio u \\(i\\)-tom stanju mape, a <code>NE</code> u suprotnom.</p>"},{"location":"takprog/2020_2021/drz/05_jakuze/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N\\cdot M\\leq 300.000\\)</li> <li>\\(1 \\leq Q\\leq 300.000\\)</li> <li>\\(1 \\leq A_{ij} \\leq NM\\)</li> <li>Svaka vrednost od \\(1\\) do \\(NM\\) se pojavljuje ta\u010dno jednom u nizu \\(A_{ij}\\).</li> <li> <p>Dodatno, za svaki od \\(Q\\) upita va\u017ei:</p> </li> <li> <p>\\(1 \\leq x_a,x_b \\leq N\\)</p> </li> <li>\\(1 \\leq y_a,y_b \\leq M\\)</li> <li>\\((x_a,y_a)\\neq(x_b,y_b)\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/05_jakuze/#podzadaci","title":"Podzadaci","text":"<ol> <li>(11 poena)  \\(N=1\\), \\(Q\\leq200\\)</li> <li>(17 poena)  \\(Q\\leq200\\)</li> <li>(34 poena)  \\(N=1\\)</li> <li>(38 poena)  Nema dodatnih ograni\u010denja</li> </ol>"},{"location":"takprog/2020_2021/drz/05_jakuze/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/05_jakuze/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/05_jakuze/#ulaz","title":"Ulaz","text":"<pre><code>3 3 1\n1 2 3\n4 5 6\n7 8 9\n1 2 2 2\n</code></pre>"},{"location":"takprog/2020_2021/drz/05_jakuze/#izlaz","title":"Izlaz","text":"<pre><code>DA\nNE\n</code></pre>"},{"location":"takprog/2020_2021/drz/05_jakuze/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U po\u010detnom izgledu Tokija Moma \u0107e u prvom danu osvojiti polje \\((1,1)\\). Narednih dana \u0107e osvajati polja \\((1,2)\\), \\((1,3)\\), \\((2,1)\\), \\((2,2)\\), \\((2,3)\\), \\((3,1)\\), \\((3,2)\\), \\((3,3)\\), koja su redom susedna poljima \\((1,1)\\), \\((1,2)\\), \\((1,1)\\), \\((1,2)\\), \\((1,3)\\), \\((2,1)\\), \\((2,2)\\), \\((2,3)\\), koja ve\u0107 poseduje u tom trenutku. Me\u0111utim, nakon zamene ne\u0107e mo\u0107i posle osvajanja polja ozna\u010denog sa \\(1\\) da u slede\u0107em potezu osvoji polje ozna\u010deno sa \\(2\\).</p>"},{"location":"takprog/2020_2021/drz/05_jakuze/#n1qleq200","title":"\\(N=1,Q\\leq200\\)","text":"<p>Ovaj podzadatak je samo najprostija simulacija. Primetimo da je Moma u svakom trenutku osvojio neki interval i da su jedina nova polja koje mo\u017ee osvojiti ona dva na krajevima intervala. Sada u svakom trenutku vidimo da li je jedno od ta dva susedna polja ba\u0161 ono koje nam treba i ako jeste osvojimo ga. Slo\u017eenost \\(O(QMN)\\).</p>"},{"location":"takprog/2020_2021/drz/05_jakuze/#qleq200","title":"\\(Q\\leq200\\)","text":"<p>I ovaj podzadatak je obi\u010dna simulacija, ali se mora generalizovati na dvodimenzione table. Pamti\u0107emo za svako \\(i\\) da li je polje ozna\u010deno sa tim brojem susedno nekome od trenutno osvojenih polja. Onda, kada to polje osvojimo ozna\u010di\u0107emo njegove susede kao mogu\u0107e za osvajanje. Tako, iteriraju\u0107i po vrednostima od \\(2\\) do \\(MN\\) mo\u017eemo da utvrdimo da li je mogu\u0107e da Moma ispuni zadatak. Slo\u017eenost \\(O(QMN)\\).</p>"},{"location":"takprog/2020_2021/drz/05_jakuze/#puno-resenje","title":"Puno re\u0161enje","text":"<p>Primetimo slede\u0107i potreban i dovoljan uslov da Moma ispuni zadatak: Neka ka\u017eemo da je polje lo\u0161e ako su mu svi susedi ozna\u010deni sa vrednostima ve\u0107im od njegove vrednosti. Moma mo\u017ee da ispuni svoj zadatak ako i samo ako postoji ta\u010dno jedno lo\u0161e polje. Doka\u017eimo ovo. Primetimo da je polje ozna\u010deno sa brojem \\(1\\) svakako lo\u0161e. Ako je mogu\u0107e da Moma ispuni zadatak onda svako drugo polje ima nekog suseda kojeg je Moma ve\u0107 osvojio u tom trenutku - to jest. nekog suseda sa manjim indeskom od njega, pa je jedan smer dokazan. U drugom smeru, ako pretpostavimo da svako polje sa indeksom \\(&gt;1\\) ima suseda manjeg indeksa od njega, onda mo\u017eemo lakom indukcijom da doka\u017eemo da Moma mo\u017ee da ispuni svoj cilj: po hipotezi, Moma mo\u017ee da osvoji prvih \\(k\\) polja, a polje sa indeksom \\(k+1\\) ima nekog suseda sa manjim indeksom, to jest neko ve\u0107 osvojeno polje, stoga Moma mo\u017ee da nastavi osvajanje. Sada kad smo dokazali ovo, potrebno je u svakom trenutku paziti koliko postoji lo\u0161ih polja. Na po\u010detku prebrojimo koliko je lo\u0161ih polja i primetimo da kad zamenimo dva polja, to mo\u017ee jedino da promeni \"lo\u0161ost\"  najvi\u0161e \\(10\\) polja: ta dva \u0161to smo zamenili i njihovih suseda. Onda naprosto a\u017euriramo da li su ona postala lo\u0161a sad i ispi\u0161emo \"DA\" ukoliko imamo samo jedno lo\u0161e polje i \"NE\" u suprotnom. Slo\u017eenost \\(O(NM+Q)\\).</p> 05_jakuze.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nvector&lt;int&gt; a[300007];\nint cnt,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},n,m;\nvector&lt;bool&gt; bad[300007];\ninline bool valid(int x,int y) {return x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;m;}\ninline void check(int x,int y)\n{\n    if(!valid(x,y)) return;\n    if(bad[x][y]) cnt--;\n    bad[x][y]=false;\n    bool dobar = false;\n    for(int i=0;i&lt;4;i++) if(valid(x+dx[i],y+dy[i]) &amp;&amp; a[x+dx[i]][y+dy[i]]&lt;a[x][y]) dobar = true;\n    if(!dobar) {bad[x][y]=true; cnt++;}\n}\nint main()\n{\n    int q;\n    scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q);\n    for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)\n    {\n        int t;\n        scanf(\"%d\",&amp;t);\n        a[i].push_back(t);\n        bad[i].push_back(false);\n    }\n    for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) check(i,j);\n    if(cnt==1) printf(\"DA\\n\");\n    else printf(\"NE\\n\");\n    while(q--)\n    {\n        int xa,ya,xb,yb;\n        scanf(\"%d%d%d%d\",&amp;xa,&amp;ya,&amp;xb,&amp;yb);\n        xa--; xb--; ya--; yb--;\n        swap(a[xa][ya],a[xb][yb]);\n        check(xa,ya); check(xb,yb);\n        for(int i=0;i&lt;4;i++) check(xa+dx[i],ya+dy[i]);\n        for(int i=0;i&lt;4;i++) check(xb+dx[i],yb+dy[i]);\n        if(cnt==1) printf(\"DA\\n\");\n        else printf(\"NE\\n\");\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/","title":"A3 - NZD permutacije","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Dat je niz \\(A\\) od \\(N\\) prirodnih brojeva. Izra\u010dunati ostatak koji pri deljenju sa \\(10^9 + 7\\) daje zbir najve\u0107ih zajedni\u010dkih delilaca susednih \u010dlanova svih \\(N!\\) permutacija niza \\(A\\).</p> <p>Drugim re\u010dima, ako je \\(S_N\\) skup svih permutacija du\u017eine \\(N\\), izra\u010dunati \\(\\sum_{P \\in S_N} \\sum_{i=1}^{N-1} NZD(A_{P_i}, A_{P_{i+1}})\\) po modulu \\(10^9+7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Aleksa Plav\u0161i\u0107"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(N\\). U narednom redu nalazi se \\(N\\) prirodnih brojeva, niz \\(A\\).</p>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati re\u0161enje na standardni izlaz.</p>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\)</li> <li>\\(1 \\leq A_i \\leq 10^6\\)</li> </ul>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#podzadaci","title":"Podzadaci","text":"<ol> <li>(11 poena) \\(N \\leq 9\\). </li> <li>(17 poena) \\(N \\leq 1000\\).</li> <li>(21 poena) \\(A_i \\leq 1000\\).</li> <li>(6 poena) U nizu \\(A\\) ima najvi\u0161e dve razli\u010dite vrednosti.</li> <li>(45 poena) Nema dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#ulaz","title":"Ulaz","text":"<pre><code>3\n12 15 15\n</code></pre>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#izlaz","title":"Izlaz","text":"<pre><code>84\n</code></pre>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Tra\u017eimo zbir za \\(6\\) permutacija: - \\([12, 15, 15]\\), \\(3 + 15 = 18\\) - \\([12, 15, 15]\\), \\(3 + 15 = 18\\) - \\([15, 12, 15]\\), \\(3 + 3 = 6\\) - \\([15, 15, 12]\\), \\(15 + 3 = 18\\) - \\([15, 12, 15]\\), \\(3 + 3 = 6\\) - \\([15, 15, 12]\\), \\(15 + 3 = 18\\)</p> <p>Re\u0161enje je \\(18 + 18 + 6 + 18 + 6 + 18 = 84\\).</p>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#ulaz_1","title":"Ulaz","text":"<pre><code>7\n20 25 9 10 21 29 12\n</code></pre>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#izlaz_1","title":"Izlaz","text":"<pre><code>69120\n</code></pre>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#resenje-za-n-leq-9","title":"Re\u0161enje za \\(N \\leq 9\\)","text":"<p>Mo\u017eemo da izgeneri\u0161emo sve permutacije i na\u0111emo tra\u017eeni zbir.</p>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#resenje-za-ostale-podzadatke","title":"Re\u0161enje za ostale podzadatke","text":"<p>Primetimo da se svaka dva broja iz niza \\(A\\) pojavljuju kao susedni u ta\u010dno \\(2 (N-1)!\\) permutacija, pa je re\u0161enje zbir najve\u0107ih zajedni\u010dkih delilaca svih parova puta \\(2 (N-1)!\\). Kada je \\(N \\leq 1000\\) mo\u017eemo da pro\u0111emo kroz sve parove, dok je kod ostala dva podzadatka potrebno prvo prebrojati koliko se puta koja vrednost pojavljuje u nizu.</p>"},{"location":"takprog/2020_2021/drz/06_nzd_permutacije/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Neka je \\(cnt_i\\) broj pojavljivanja broja \\(i\\) u nizu, a \\(d_i\\) broj \u010dlanova niza koji su deljivi sa \\(i\\). Niz \\(d_i\\) se mo\u017ee na\u0107i po formuli \\(d_i = \\sum_{j=1}^{i*j \\leq M} cnt_{i*j}\\) u \\(O(M log M)\\) gde je \\(M\\) najve\u0107i broj u nizu. Neka je \\(dp_i\\) broj parova \u010diji je NZD jednak \\(i\\). Primetimo da je \\(\\binom{d_i}{2}\\) broj parova \u010diji je NZD deljiv sa \\(i\\), pa kada od toga oduzmemo broj parova \u010diji je NZD jednak \\(2i\\), \\(3i\\), ... dobijamo broj parova \u010diji je NZD jednak \\(i\\). Sada mo\u017eemo izra\u010dunati niz \\(dp\\) od \\(dp_n\\) do \\(dp_1\\) po formuli \\(dp_i = \\binom{d_i}{2} - \\sum_{j=2}^{i*j \\leq M} dp_{i*j}\\). Vremenska slo\u017eenost re\u0161enja je \\(O(M log M)\\), a memorijska \\(O(M)\\).</p> <p>Napomena: Ra\u010dunanje nizova \\(d_i\\) i \\(dp_i\\) je slo\u017eenosti \\(O(M log M)\\) jer se za njihovo izra\u010dunavanje prolazi kroz ceo niz, pa kroz svaki drugi \u010dlan, zatim kroz svaki tre\u0107i, ... U zbiru to je \\(\\sum_{i=1}^{M} \\lfloor \\frac{M}{i} \\rfloor\\) \u0161to je pribli\u017eno jednako \\(M\\) puta \\(H_M = \\sum_{i=1}^{M} \\frac{1}{i}\\). \\(H_n\\) su harmonijski brojevi i oni se pona\u0161aju kao prirodni logaritam.</p> 06_nzd_permutacije.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\nconst int mod=1e9+7;\nint add(int x,int y){x+=y;return x&gt;=mod?x-mod:x;}\nint sub(int x,int y){x-=y;return x&lt;0?x+mod:x;}\nint mul(int x,int y){return (ll)x*y%mod;}\n\nconst int N=1000050;\nll dp[N];\nint cnt[N],dv[N],a[N];\nint main(){\n    int n;\n    scanf(\"%i\",&amp;n);\n    for(int i=1;i&lt;=n;i++){\n        scanf(\"%i\",&amp;a[i]);\n        cnt[a[i]]++;\n    }\n    for(int i=1;i&lt;N;i++){\n        for(int j=i;j&lt;N;j+=i){\n            dv[i]+=cnt[j];\n        }\n    }\n    int ans=0;\n    for(int i=N-1;i&gt;=1;i--){\n        dp[i]=(ll)dv[i]*(dv[i]-1)/2;\n        for(int j=i*2;j&lt;N;j+=i){\n            dp[i]-=dp[j];\n        }\n        ans=add(ans,mul(dp[i]%mod,i));\n    }\n    ans=mul(ans,2);\n    for(int i=1;i&lt;=n-1;i++)ans=mul(ans,i);\n    printf(\"%i\\n\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/","title":"1 - Minimalan trud","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Mika je odlu\u010dio da neodgovorno pristupi kvalifikacijama, i da se potrudi \u0161to je manje mogu\u0107e oko prvog kruga, a da se ipak kvalifikuje za okru\u017eno takmi\u010denje. Oti\u0161ao je kod vra\u010dare i gledanjem u pasulj saznao koliko \u0107e bodova imati u drugom i tre\u0107em krugu kvalifikacija. Po\u0161to poku\u0161ava da izbegne \u0161to vi\u0161e posla, Mika je odlu\u010dio da vas pita koliki je minimalan broj bodova koje mora da osvoji u prvom krugu da bi se kvalifikovao?</p> <p>Podse\u0107amo da se na okru\u017eno takmi\u010denje kvalifikuju svi takmi\u010dari koji na dva najbolja kruga kvalifikacija imaju ukupno barem 256 bodova.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Ivan Sto\u0161i\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Aleksa Milojevi\u0107 <p>Ako Mika u drugom i tre\u0107em krugu zajedno ima barem 256 bodova, odnosno \\(B+C \\geq 256\\), sigurno \u0107e se kvalifikovati, tako da mo\u017ee da osvoji 0 bodova u prvom krugu.</p> <p>U suprotnom, u krajnjem zbiru \u0107e u\u010destvovati prvi krug i bolji od preostala dva, i minimalan broj bodova je onaj koji daje ukupno 256. Dakle, znamo da \\(A + \\text{max}(B, C) = 256\\), odnosno \\(A = 256 - \\text{max}(B, C)\\).</p> 01_minimalni_trud.cpp<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int b, c;\n    cin &gt;&gt; b &gt;&gt; c;\n    if(b + c &gt;= 256) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; 256 - max(b, c) &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu se nalaze dva cela broja \\(B\\) i \\(C\\): brojevi bodova koje \u0107e Mika osvojiti u drugom i tre\u0107em krugu kvalifikacija.</p>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati najmanji broj bodova koji Mika mora da osvoji u prvom krugu, tako da se kvalifikuje na okru\u017eno takmi\u010denje.</p>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq B, C \\leq 500\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(B + C &lt; 256\\).</li> <li>U test primerima vrednim 30 poena: \\(C = 0\\).</li> <li>U test primerima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#ulaz","title":"Ulaz","text":"<pre><code>100 150\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#izlaz","title":"Izlaz","text":"<pre><code>106\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ako Mika osvoji 106 bodova u prvom krugu, najbolja dva kruga \u0107e biti prvi i tre\u0107i, i u zbiru \u0107e na njima imati ta\u010dno potrebnih 256 bodova.</p>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#ulaz_1","title":"Ulaz","text":"<pre><code>300 0\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2020_2021/kv1/01_minimalni_trud/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Miki nisu potrebni dodatni bodovi, jer \u0107e ih osvojiti dovoljno u drugom krugu.</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/","title":"2 - Prijatelji","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Mika je uspe\u0161no sakupio 256 poena na kvalifikacijama i tako se kvalifikovao za Okru\u017eno takmi\u010denje. Kao i svakom drugom programeru, Miki je ovo jedna od retkih prilika da stekne nove prijatelje. Zato je odlu\u010dio da svrati do vra\u010dare Miljane koja \u0107e ga uputiti u to kako se stvaraju prijateljstva na Okru\u017enom takmi\u010denju. </p> <p>Na Okru\u017eno takmi\u010denje je pozvano \\(N\\) u\u010denika, numerisanih brojevima \\(1, 2, \u2026, N\\). Kako nisu svi u\u010denici podjednako dru\u017eeljubivi, za svakog u\u010denika mogu\u0107e je definisati koliko voli dru\u017eenje. Tako \u0107emo pretpostaviti da u\u010denik \\(i\\) ima odre\u0111enu dru\u017eeljubivost \\(A_i\\). Me\u0111u takmi\u010darima postoji \\(M\\) parova poznanika, pri \u010demu svaka dva u\u010denika koja se poznaju mogu biti prijatelji ili neprijatelji. Sre\u0107u takmi\u010dara \\(i\\) mo\u017eemo definisati kao proizvod njegove dru\u017eeljubivosti i razlike broja njegovih prijatelja i neprijatelja. Na primer, ako takmi\u010dar ima dru\u017eeljubivost \\(2\\), ima tri prijatelja i jednog neprijatelja, njegova sre\u0107a iznosi \\(2*(3-1)=4\\). Pri tome, neki takmi\u010dari mogu imati negativnu dru\u017eeljubivost, u kom slu\u010daju su sre\u0107niji kada imaju vi\u0161e neprijatelja, a manje prijatelja. Ukupnu sre\u0107u celog takmi\u010denja defini\u0161emo kao zbir sre\u0107a svih takmi\u010dara. </p> <p>Vra\u010dara je Malom Miki otkrila koji su parovi u\u010desnika poznanici, ali mu nije rekla da li su ti parovi prijatelji ili neprijatelji. Sada Miku interesuje koja je najve\u0107a mogu\u0107a ukupna sre\u0107a celog takmi\u010denja? Kako je Mika veoma zauzet pripremama za Okru\u017eno takmi\u010denje, zamolio vas je da mu pomognete.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Aleksa Milojevi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalaze se brojevi \\(N\\) i \\(M\\). Zatim sledi \\(N\\) linija, tako da se u \\((i+1)\\)-oj liniji nalazi dru\u017eeljubivost \\(i\\)-tog takmi\u010dara, \\(A_i\\). Zatim sledi jo\u0161 \\(M\\) linija koje opisuju poznanstva me\u0111u takmi\u010darima, tako da se u \\((N+1+i)\\)-om redu nalazi par poznanika \\(X_i, Y_i\\). </p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvu i jedinu liniju izlaza treba ispisati najve\u0107u mogu\u0107u sre\u0107u \u010ditavog takmi\u010denja.</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 100\\ 000\\)</li> <li>\\(1 \\leq M \\leq 100\\ 000\\)</li> <li>\\(A_i\\in [-10^9, 10^9]\\)</li> <li>\\(1\\leq X_i, Y_i\\leq N\\)</li> <li>\\(X_i\\neq Y_i\\), za \\(i\\in [1, M]\\)</li> <li>\\(\\{X_i, Y_i\\}\\neq \\{X_j, Y_j\\}\\), za \\(i, j\\in [1, M], i\\neq j\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(N, M \\leq 10\\).</li> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(A_i=1\\) za sve \\(i\\in [1, N]\\).</li> <li>U test primerima vrednim \\(60\\) poena nema dodatnih organi\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv1/02_prijatelji/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv1/02_prijatelji/#ulaz","title":"Ulaz","text":"<pre><code>3 2\n1\n1\n1\n1 2\n2 3\n</code></pre>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Svi takmi\u010dari su podjednako dru\u017eeljubivi, pa se maksimalna sre\u0107a posti\u017ee kada su svi takmi\u010dari prijatelji. Tada je sre\u0107a takmi\u010dara \\(1\\) jednaka \\(1\\), sre\u0107a takmi\u010dara \\(2\\) je \\(2\\) i sre\u0107a takmi\u010dara \\(3\\) je \\(1\\). Dakle, najve\u0107a mogu\u0107a ukupna sre\u0107a takmi\u010denja je \\(4\\).</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv1/02_prijatelji/#ulaz_1","title":"Ulaz","text":"<pre><code>3 2\n2\n-5\n5\n1 2\n2 3\n</code></pre>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Maksimalna sre\u0107a posti\u017ee se kada su svi poznanici neprijatelji. Tada sre\u0107a iznosi \\(2\\cdot(0-1)+(-5)\\cdot(0-2)+5\\cdot(0-1) = 3\\).</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#resenje-za-n-m-leq-10","title":"Re\u0161enje za \\(N, M \\leq 10\\):","text":"<p>Za svako poznanstvo pomo\u0107u rekurzije ili bitmaski fiksiramo da li je prijateljstvo ili neprijateljstvo. Probamo sve mogu\u0107nosti za sva poznanstva i uzmemo najbolju kombinaciju. Vremenska slo\u017eenost je \\(O(2^M\\cdot(N+M))\\)</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#resenje-za-a_i-1","title":"Re\u0161enje za \\(A_i = 1\\):","text":"<p>Po\u0161to su dru\u017eeljubivosti svih ljudi pozitivne, nikada nam se ne\u0107e isplatiti da imamo neprijateljstva, tj. sva poznanstva \u0107e biti prijateljstva. Dakle, ako sa \\(P_i\\) ozna\u010dimo broj poznanika (odnosno i prijatelja) osobe \\(i\\), na\u0161e re\u0161enje \u0107e biti \\(\\sum^{N}_{1} A_i\\cdot P_i\\). Po\u0161to va\u017ei \\(A_i = 1\\) za svako \\(i\\), ta suma je ekvivalentna \\(\\sum^{N}_{1} P_i\\). Detaljnijom analizom ove sume mo\u017eemo zaklju\u010diti da ona iznosi \\(2\\cdot M\\), jer svako poznanstvo pove\u0107ava na\u0161u sumu za 2. Vremenska slo\u017eenost je \\(O(N+M)\\) ili \\(O(1)\\) u zavisnosti od implementacije.</p>"},{"location":"takprog/2020_2021/kv1/02_prijatelji/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Ozna\u010dimo ponovo broj prijatelja osobe \\(i\\) sa \\(P_i\\), a broj neprijatelja sa \\(Q_i\\). Onda je na\u0161 krajnji rezultat \\(\\sum^{N}_{1} A_i \\cdot (P_i - Q_i)\\), po tekstu zadatka. Mo\u017eemo uo\u010diti da je ovo ekvivalentno tome da za svako prijateljstvo izme\u0111u osoba \\(x\\) i \\(y\\) doprinosi rezultatu \\(A_x + A_y\\), dok svako neprijateljstvo doprinosi rezultatu \\(-(A_x + A_y)\\). Po\u0161to \u017eelimo da maksimiziramo na\u0161 rezultat, svako poznanstvo za koje va\u017ei \\(A_x + A_y \\geq 0\\) \u0107emo postaviti kao prijateljstvo, a svako poznanstvo za koje va\u017ei \\(A_x + A_y &lt; 0\\) \u0107emo postaviti kao neprijateljstvo. Mo\u017ee se primetiti da je u tom slu\u010daju na\u0161e re\u0161enje \\(\\sum^{M}_{1} |A_{X_i} + A_{Y_i}|\\). Vremenska slo\u017eenost je \\(O(N+M)\\).</p> 02_prijatelji.cpp<pre><code>//Prijatelji 100\n#include &lt;bits/stdc++.h&gt;\n#define MAX_N 100005\n#define MAX_M 100005\n\nusing namespace std;\n\nint N, M;\nlong long A[MAX_N];\nint X[MAX_M], Y[MAX_M];\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin&gt;&gt;N&gt;&gt;M;\n    for(int i=1; i&lt;=N; i++){\n        cin&gt;&gt; A[i];\n    }\n    for(int i=1; i&lt;=M; i++){\n        cin&gt;&gt;X[i]&gt;&gt;Y[i];\n    }\n    long long max_sreca=0;\n    for(int i=1; i&lt;=M; i++){\n        max_sreca+=abs(A[X[i]]+A[Y[i]]);\n    }\n    cout&lt;&lt;max_sreca;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv1/03_zalbe/","title":"3 - \u017dalbe","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Vra\u010dara Miljana poznata je po svojim predskazanjima o takmi\u010denjima iz programiranja. Njena stru\u010dna oblast je poga\u0111anje da li \u0107e Tajna Komisija prihvatiti neku takmi\u010darsku \u017ealbu.</p> <p>Miljana ima svoju ludu teoriju: da postoji prirodan broj \\(X\\) koji ne zna, takav da Komisija prihvata \u017ealbe svakih \\(X\\) godina, tj. ako je Komisija prihvatila \u017ealbu u godini \\(A\\) prva slede\u0107a godina kada \u0107e prihvatiti \u017ealbu je \\(A+X\\), a tako\u0111e zna\u010di da je Komisija prihvatila \u017ealbu u godini \\(A-X\\).</p> <p>Ta\u010dno \\(T\\) takmi\u010dara je do\u0161lo da se posavetuje sa Miljanom. Ona je od svakog pojedina\u010dno tra\u017eila da prikupi informacije o ranijim \u017ealbama kako bi joj pomogli da na\u0111e \\(X\\). Svaki takmi\u010dar je izneo neke glasine koje je \u010duo na Algori. Za \\(N\\) razli\u010ditih godina \\(A_1, A_2, ..., A_N\\) takmi\u010dar tvrdi da je Tajna Komisija prihvatala \u017ealbe. Za \\(M\\) razli\u010ditih godina \\(B_1, B_2, ..., B_M\\) ta\u010dmi\u010dar tvrdi da Tajna Komisija nije prihvatala \u017ealbe.</p> <p>Kako ne bi gubila vreme, Vra\u010dara Miljana je pitala vas, takmi\u010dara koji se ne\u0107e \u017ealiti, da za svakog od \\(T\\) takmi\u010dara odredite da li postoji \\(X\\) tako da su sve glasine koje je \u010duo ta\u010dne, odnosno da su \u017ealbe prihva\u0107ene u godinama \\(A_1, A_2, ..., A_N\\), a nisu u godinama \\(B_1, B_2, ..., B_M\\), prate\u0107i Miljaninu teoriju da se \u017ealbe prihvataju svakih \\(X\\) godina.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107 <p>Prvo sortiramo niz \\(A\\) rastu\u0107e. Od sada sa \\(A_i\\) ozna\u010davamo \\(i\\)-ti najmanji element niza \\(A\\). </p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se broj \\(T\\) -- broj takmi\u010dara koji su se javili Vra\u010dari Miljani.</p> <p>Za svakog takmi\u010dara unose se po jo\u0161 tri linije: u prvoj liniji se nalaze \\(N\\) i \\(M\\) -- broj glasina u kojima su \u017ealbe prihva\u0107ene i broj glasina u kojima su \u017ealbe odbijene; u drugoj liniji nalazi se \\(N\\) celih brojeva, niz \\(A_1, A_2, ..., A_N\\) -- godine u kojima su, po glasinama, prihva\u0107ene \u017ealbe; u tre\u0107oj liniji nalazi se \\(M\\) celih brojeva, niz \\(B_1, B_2, ..., B_M\\) -- godine u kojima su, po glasinama, odbijene \u017ealbe.</p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispi\u0161ite \\(T\\) brojeva -- za svakog takmi\u010dara, u novom redu, ispisati \\(1\\) ako postoji \\(X\\) koje je u skladu sa njegovim glasinama, odnosno ispisati 0 u suprotnom.</p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 5\\)</li> </ul> <p>Za svakog od \\(T\\) takmi\u010dara va\u017ei:</p> <ul> <li>\\(2 \\leq N, M \\leq 75000\\)</li> <li>\\(1 \\leq A_i, B_i \\leq 10^{18}\\)</li> <li>\\(A_i \\neq A_j\\), za \\(i \\neq j\\)</li> <li>\\(B_i \\neq B_j\\), za \\(i \\neq j\\)</li> <li>\\(A_i \\neq B_j\\), za svako \\(i, j\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(A_i, B_i, N, M \\leq 3000\\)</li> <li>U test primerima vrednim \\(10\\) poena: \\(N = 2\\)</li> <li>U test primerima vrednim \\(30\\) poena: \\(A_i, B_i \\leq 10^6\\)</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv1/03_zalbe/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv1/03_zalbe/#ulaz","title":"Ulaz","text":"<pre><code>4\n4 3\n1 7 4 13\n3 11 9\n3 2\n9 5 3\n7 11\n2 3\n3 15\n1 7 2\n2 2\n5643634654354 12346544323565\n22341124534 7655867344\n</code></pre>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#izlaz","title":"Izlaz","text":"<pre><code>1\n0\n1\n1\n</code></pre>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Za prvog takmi\u010dara mogu\u0107e je uzeti \\(X = 3\\) tako da zadovolji sve glasine. Za drugog takmi\u010dara nemogu\u0107e je na\u0107i \\(X\\). Za tre\u0107eg takmi\u010dara mogu\u0107e je uzeti \\(X = 12\\).</p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#resenje-za-a_i-b_i-n-m-leq-3000","title":"Re\u0161enje za \\(A_i, B_i, N, M \\leq 3000\\):","text":"<p>Dovoljno nam je da proverimo svako mogu\u0107e \\(X\\) (sve brojeve od \\(1\\) do \\(3000\\)).  Neko \\(X\\) je mogu\u0107e samo ako deli \\(A_{i+1}-A_i\\) za svako \\(1 \\leq i \\leq N-1\\), a ne deli \\(|B_i-A_1|\\) ni za jedno \\(1 \\leq i \\leq M\\). Vremenska slo\u017eenost je \\(O(T \\cdot maxA \\cdot (N+M))\\).</p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#resenje-za-n-2","title":"Re\u0161enje za \\(N = 2\\):","text":"<p>Znamo da \\(X\\), ako postoji, mora da deli \\(A_2 - A_1\\), ali po\u0161to ta razlika mo\u017ee da bude velika, ne mo\u017eemo da proverimo sve delioce. Mo\u017eemo da primetimo da ako broj \\(p\\) deli broj \\(q\\), svaki delilac od \\(p\\) tako\u0111e deli \\(q\\). To nam govori da nam je dovoljno proveriti da li je \\(A_2 - A_1\\) dobar kandidat za \\(X\\), jer ako ne deli nijedno od \\(|B_i-A_1|\\) onda je u redu, u suprotnom i svi njegovi delioci dele neki od \\(|B_i-A_1|\\), pa re\u0161enje ne postoji. Vremenska slo\u017eenost je \\(O(T \\cdot (N+M))\\).</p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#resenje-za-a_i-leq-106","title":"Re\u0161enje za \\(A_i \\leq 10^6\\):","text":"<p>Po\u0161to \\(X\\) mora da deli sve razlike \\(A_{i+1}-A_i\\), jedini kandidati su delioci najmanjeg zajedni\u010dkog delioca tih razlika, odnosno, ako \\(X\\) postoji, va\u017ei \\(X \\mid NZD(A_2-A_1, A_3-A_2, ..., A_N-A_{N-1})\\). NZD mo\u017eemo na\u0111i Euklidovim algoritmom, a po\u0161to delioca ima \\(O(\\sqrt{maxA})\\), ukupna vremenska slo\u017eenost je \\(O(T \\cdot (NlogN + M\\sqrt{maxA}))\\). </p>"},{"location":"takprog/2020_2021/kv1/03_zalbe/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Ako spojimo re\u0161enja za prethodna dva podzadatka mo\u017eemo videti da je dovoljno proveriti da li \\(X\\) mo\u017ee biti \\(NZD(A_2-A_1, A_3-A_2, ..., A_N-A_{N-1})\\). Ukoliko ne, ne mo\u017ee nijedan njegov delilac. Vremenska slo\u017eenost je \\(O(T \\cdot (NlogN + M))\\).</p> 03_zalbe.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 100010\nusing namespace std;\n#define lld long long\nint N, M;\nlld A[MAXN], B[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T; cin &gt;&gt; T;\n    while(T--) {\n        cin &gt;&gt; N &gt;&gt; M;\n        for(int i = 1; i &lt;= N; i++) cin &gt;&gt; A[i];\n        for(int i = 1; i &lt;= M; i++) cin &gt;&gt; B[i];\n        sort(A+1, A+1+N);\n        lld X = A[2]-A[1];\n        int rez = 1;\n        for(int i = 3; i &lt;= N; i++) X = __gcd(X, A[i]-A[i-1]);\n        for(int i = 1; i &lt;= M; i++) {\n            if(abs(B[i]-A[1])%X == 0) rez = 0;\n        }\n        cout &lt;&lt; rez &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/","title":"4 - \u010cvrsti brojevi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Vra\u010dara Miljana je posle dugogodi\u0161njeg putovanja po svetu na svojoj svetskoj turi odlu\u010dila da se vrati ku\u0107i. Posle svih upoznatih obo\u017eavalaca, ludih predskazanja i nezaboravnih vragolija, shvatila je da joj je trenutno samo potrebna toplina sopstvenog doma i porodice. Tako je, posle opro\u0161tajnog predskazanja u Vuhanu, gde je predvidela neki viru\u0161\u010di\u0107, spakovala kofere i uputila se ka domovini svih vra\u010dara - Vra\u010daru.</p> <p>Kod ku\u0107e su je svi do\u010dekali sa rado\u0161\u0107u, slavljem i raznim poklonima. Kako to obi\u010dno biva, od jednog starog druga iz \u0161kolske klupe je dobila omiljen poklon svih protagonista informati\u010dkih zadataka - jedan broj. Kada je videla ovo odmah se setila da je negde na svojoj turi nau\u010dila o \u010dvrstim brojevima. Broj je \u010dvrst ukoliko va\u017ei slede\u0107i uslov: ako su cifre na \\(i\\)-toj i \\(j\\)-toj poziciji, pri \u010demu \\(j&gt;i\\), jednake \\(c\\), tada je cifra na \\(k\\)-toj poziciji tako\u0111e jedanka \\(c\\), za svako \\(i\\leq k\\leq j\\). Tako su na primer brojevi \\(233441\\) i \\(335\\) \u010dvrsti, dok \\(121\\) nije.</p> <p>Da bi pokazala \u0161ta je nau\u010dila, odlu\u010dila je da promeni neke cifre poklonjenom broju tako da postane \u010dvrst. Specijalno, ona mo\u017ee promeniti broj tako da ima vode\u0107e nule, ali te cifre se jo\u0161 uvek ra\u010dunaju u uslov da je broj \u010dvrst. To zna\u010di da ako je na poklon dobila broj \\(1210\\), nije validno re\u0161enje da prebaci prvu cifru u \\(0\\) i dobije \\(0210\\). Pomozite Miljani da na\u0111e najmanji broj cifara koje je neophodno promeniti da bi broj bio \u010dvrst.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Tadija \u0160ebez <p>U ovom zadatku je potrebno  na\u0107i \u010dvrst broj koji se na najmanje mesta razlikuje od zadatog broja. Broj je \u010dvrst ako su sva pojavljivanja neke cifre uzastopna.</p> <p>Neka je u svim podzadacima \\(M\\) broj cifara broja \\(N\\), a \\(d\\) broj razli\u010ditih cifara.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva i jedina linija ulaza sadr\u017ei prirodan broj \\(N\\), koji predstavlja broj koji je Miljana dobila. Garantuje se da \\(N\\) nema vode\u0107ih nula.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinu liniju izlaza ispi\u0161ite najmanji broj cifara koje je potrebno promeniti da bi dobijeni broj postao \u010dvrst.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N &lt; 10^{100.000}\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N \\leq 10^6\\)</li> <li>U test primerima vrednim \\(10\\) poena: sve cifre po\u010detnog broja su \\(0\\) ili \\(1\\).</li> <li>U test primerima vrednim \\(30\\) poena: \\(N \\leq 10^{100}\\)</li> <li>U test primerima vrednim \\(30\\) poena: \\(N \\leq 10^{10.000}\\)</li> <li>U test primerima vrednim \\(20\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#ulaz","title":"Ulaz","text":"<pre><code>202201\n</code></pre>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Mogu\u0107e je promeniti drugu cifru u \\(2\\), nakon \u010dega broj postaje \\(222201\\), koji je \u010dvrst.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#ulaz_1","title":"Ulaz","text":"<pre><code>10001\n</code></pre>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Mogu\u0107e je promeniti prvu cifru u \\(0\\) tako da broj postane \\(00001\\), koji je \u010dvrst. Primetimo da ovde nakon zamene i dalje ra\u010dunamo vode\u0107e nule.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#podzadatak-1-nle106","title":"Podzadatak 1: \\(N\\le10^6\\)","text":"<p>Prostim prolaskom kroz sve brojeve sa \u0161est ili manje cifara mo\u017eemo da vidimo za svaki da li je \u010dvrst i, ukoliko jeste, na koliko se pozicija razlikuje od po\u010detnog broja.</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#podzadatak-2-sve-cifre-su-0-ili-1","title":"Podzadatak 2: Sve cifre su \\(0\\) ili \\(1\\)","text":"<p>Za svaki prefiks i sufiks je mogu\u0107e jednim prolaskom kroz niz da odredimo broj poteza da bi sve cifre postale \\(0\\) ili \\(1\\), pa onda za svaku poziciju prelamanja mo\u017eemo da vidimo koliko nam treba poteza (postoji samo \\(2M\\) \u010dvrstih brojeva sa samo jedinicima i nulama, proverimo koji od njih je optimalan).</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#podzadatak-3-nle-10100","title":"Podzadatak 3: \\(N\\le 10^{100}\\)","text":"<p>Ovaj podzatak slu\u017ei da se na njemu osvoje poeni koje koriste ideje u naredna dva, ali nisu dovoljno brza za ve\u0107a ograni\u010denja (npr. \\(O(M^2\\cdot d\\cdot2^d)\\) ili \\(O(M\\cdot d^2\\cdot2^d)\\))</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#podzadatak-4-nle1010000","title":"Podzadatak 4:  \\(N\\le10^{10.000}\\)","text":"<p>Ovaj zadatak \u0107emo uraditi putem dinami\u010dkim programiranjem po bitmaskama. Neka je \\(dp[i][c][mask]\\) najbolje re\u0161enje za prvih \\(i\\) cifara, tako da je poslednja cifra \\(c\\) i u \\(mask\\) su na \\(1\\) postavljene cifre koje odgovaraju ciframa koje smo ve\u0107 iskoristili (uklju\u010duju\u0107i \\(c\\)).  Ima\u0107emo i pomo\u0107ni niz \\(aux[i][mask]\\) koji nam ka\u017ee najve\u0107u vrednost \\(dp[i][c][mask]\\) za neko \\(0\\le c\\le 9\\). Sada lako mo\u017eemo ra\u010dunati vrednost \\(dp[i][c][mask]\\) kao maksimum od \\(dp[i-1][c][mask]\\) i \\(aux[i-1][mask \\text{ xor } 2^c]\\) i na to dodamo \\(1\\) ako trenutna cifra nije \\(c\\). Tako svako stanje \\(dp[i][c][mask]\\) ra\u010dunamo u \\(O(1)\\) i svaku od vrednosti \\(aux[i][mask]\\) u \\(O(d)\\), \u0161to nam daje re\u0161enje u \\(O(M\\cdot d\\cdot 2^d)\\).</p>"},{"location":"takprog/2020_2021/kv1/04_cvrsti_brojevi/#podzadatak-5-100-poena","title":"Podzadatak 5:  100 poena","text":"<p>U ovom podzadatku za sve poene \u0107emo promeniti perspektivu. Umesto \u0161to tra\u017eimo najmanji broj promena, tra\u017ei\u0107emo najve\u0107i broj cifara da ne menjamo. Da bismo to postigli, \u010duva\u0107emo dva niza \\(a[c][mask]\\), koji je pandan nizu \\(dp\\) iz prethodnog re\u0161enja (kad obradimo \\(i\\)-tu cifru tu \u0107e se nalaziti najbolje re\u0161enje za prvih \\(i\\) cifara) i niz \\(max[mask]\\) koji je pandan prethodnom nizu \\(aux\\). Glavna razlika je \u0161to se ve\u0107ina ovih nizova sada ne\u0107e menjati i onda mo\u017eemo samo da ih pustimo da naslede vrednosti iz prethodne iteracije. Na primer: \\(a[c][mask]\\) ima smisla ponovo ra\u010dunati za trenutnu cifru (\\(a[c][mask]\\) postane maksimum od \\(a[c][mask]+1\\) i \\(max[mask\\text{ xor } 2^c]+1\\)), i pri tome promeniti \\(max[mask]\\). Ovo nam dosta smanji broj operacija, tako da nam je slo\u017eenost sada \\(O(M\\cdot2^d)\\) \u0161to lako prolazi za \\(100\\) poena.</p> 04_cvrsti_brojevi.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint dp[10][1024],mx[1024];\nint main()\n{\n    string s;\n    cin&gt;&gt;s;\n    for(int i=0;i&lt;1024;i++) {mx[i]=-1000000000; for(int j=0;j&lt;10;j++) dp[j][i]=-1000000000;}\n    mx[0]=0;\n    for(int i=0;i&lt;s.size();i++)\n    {\n        int c=s[i]-'0';\n        for(int j=0;j&lt;1024;j++) if((1&lt;&lt;c)&amp;j)\n        {\n            dp[c][j]=max(dp[c][j],mx[j^(1&lt;&lt;c)])+1;\n            mx[j]=max(mx[j],dp[c][j]);\n        }\n    }\n    int x=0; for(int i=0;i&lt;1024;i++) x=max(x,mx[i]);\n    cout&lt;&lt;s.size()-x;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/","title":"5 - SIO stablo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>Kao \u0161to svi znamo, vra\u010dare mogu da predvide neke nepredvidive doga\u0111aje kao \u0161to je prolazak nekog takmi\u010dara na Srpsku informati\u010dku olimpijadu (SIO). Za tu namenu koristi se SIO stablo.</p> <p>SIO stablo je drvo u dvori\u0161tu vra\u010dare Miljane (niko nije siguran za\u0161to se ova \u010dudna biljka ne zove SIO drvo). Ovo drvo se sastoji iz \\(N\\) mesta grananja, koje \u0107emo zvati \u010dvorovima, i \\(N-1\\) grana. \u010cvorovi su numerisani brojevima od \\(1\\) do \\(N\\). Naravno, mogu\u0107e je do\u0107i od svakog \u010dvora do svih drugih \u010dvorova kre\u0107u\u0107i se samo po granama. Na svakoj grani urezano je po jedno slovo iz skupa \\(\\{\\text{\"S\", \"I\", \"O\"}\\}\\).</p> <p>Par \u010dvorova \\((U, V)\\) je SIO par ako je na granama na najkra\u0107em putu (putu koji ne prelazi preko iste grane vi\u0161e puta) izme\u0111u \u010dvorova \\(U\\) i \\(V\\) svako od slova \\(\\text{\"S\"}\\), \\(\\text{\"I\"}\\) i \\(\\text{\"O\"}\\) urezano isti broj puta.</p> <p>Vra\u010dara Miljana tvrdi da \u0107e na SIO pro\u0107i osoba koja uspe da izra\u010duna broj SIO parova \u010dvorova \\((U, V)\\) za koje va\u017ei \\(1 \\leq U &lt; V \\leq N\\). Napi\u0161ite program koji izra\u010dunava ovaj broj kako biste proverili da li je vra\u010dara Miljana u pravu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Igor Pavlovi\u0107"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza nalazi se jedan ceo broj \\(N\\). U narednih \\(N-1\\) redova nalaze se opisi grana. U svakom redu po dva cela broja \\(U\\) i \\(V\\), i po jedno slovo iz skupa \\(\\{\\text{\"S\", \"I\", \"O\"}\\}\\), razdvojeni razmacima.</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispi\u0161ite broj SIO parova \u010dvorova \\((U, V)\\) za koje va\u017ei \\(1 \\leq U &lt; V \\leq N\\).</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 3 \\times 10^5\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(8\\) poena: slovo \\(\\text{\"S\"}\\) je urezano na ta\u010dno jednoj grani.</li> <li>U test primerima vrednim \\(12\\) poena: \\(N \\leq 1000\\).</li> <li>U test primerima vrednim \\(20\\) poena: za svako \\(1 \\leq k &lt; N\\) postoji grana izme\u0111u \\(k\\) i \\(k+1\\).</li> <li>U test primerima vrednim \\(20\\) poena: za svaki \\(2 \\leq k \\leq N\\) postoji grana izme\u0111u \\(k\\) i \\(\\lfloor \\frac{k}{2} \\rfloor\\).</li> <li>U test primerima vrednim \\(40\\) poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#ulaz","title":"Ulaz","text":"<pre><code>6\n4 1 S\n5 6 O\n1 5 I\n1 2 S\n3 1 S\n</code></pre>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Parovi \\((2, 6)\\), \\((3, 6)\\), \\((4, 6)\\) su SIO par.</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#resenje-kada-je-n-leq-1000","title":"Re\u0161enje kada je \\(n \\leq 1000\\)","text":"<p>Vremenska slo\u017eenost: \\(O(N^2)\\)</p> <p>Pokrenimo algoritam pretrage u dubinu (DFS) od svakog \u010dvora. \u010cuvajmo koliko se puta koje slovo pojavljuje na trenutnom putu i sa tim informacijama lako mo\u017eemo da pove\u0107amo re\u0161enje za svaki SIO par.</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#resenje-kada-je-slovo-texts-urezano-na-tacno-jednoj-grani","title":"Re\u0161enje kada je slovo \\(\\text{\"S\"}\\) urezano na ta\u010dno jednoj grani","text":"<p>Vremenska slo\u017eenost: \\(O(N)\\)</p> <p>Re\u0161enje je broj puteva du\u017eine 3 na kojima se svako od tri slova pojavljuje po jednom. Prona\u0111imo granu na kojoj je urezano slovo \\(\\text{\"S\"}\\) i zapamtimo njene krajeve. Neka su to \u010dvorovi \\(U\\) i \\(V\\). Prebrojimo koliko ima puteva du\u017eine \\(2\\), \u010diji je jadan kraj neki od \u010dvorova \\(U\\) i \\(V\\), takve da je na njima urezano po jedno slovo \\(\\text{\"I\"}\\) i \\(\\text{\"O\"}\\). Na re\u0161enje jo\u0161 dodajmo broj parova grana tako da jedna kre\u0107e iz \\(U\\), a druga iz \\(V\\) i na jednoj je urezano slovo \\(\\text{\"I\"}\\), a na drugoj slovo \\(\\text{\"O\"}\\).</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#resenje-kada-je-sio-stablo-lanac","title":"Re\u0161enje kada je SIO stablo lanac","text":"<p>Vremenska slo\u017eenost: \\(O(N log N)\\)</p> <p>Napravimo string od svih slova koja se pojavljuju na granama od jednog do drugog kraja lanca, u tom poretku. Re\u0161enje se svodi na broj podstringova u kojima se svako od 3 slova pojavljuje jednak broj puta. Neka je \\(\\text{X(i)}\\) broj pojavljivanja slova \\(X\\) u prvih \\(i\\) slova. Za svaki prefiks od du\u017eine \\(0\\) do \\(N-1\\) (imamo \\(N-1\\) grana pa samim tim isto toliko slova), zapamtimo par \\(P(i) = (\\text{S(i)}-\\text{I(i)}, \\text{S(i)}-\\text{O(i)})\\). Posmatrajmo podstring od \\(L\\)-tog do \\(R\\)-tog slova. Ako se slova \\(\\text{S}\\) i \\(\\text{I}\\) pojavljuju isti broj puta onda mora da va\u017ei \\((\\text{S(R)}-\\text{S(L-1)}) - (\\text{I(R)}-\\text{I(L-1)}) = (\\text{S(R)}-\\text{I(R)}) - (\\text{S(L-1)}-\\text{I(L-1)}) = 0\\) odnosno prve vrednosti iz parova \\(P(R)\\) i \\(P(L-1)\\) moraju biti jednake. Sli\u010dno se dobija i da druge vrednosti iz ovih parova moraju biti jednake, odnosno parovi \\(P(R)\\) i \\(P(L-1)\\) moraju biti jednaki. Sada ostaje jo\u0161 da prebrojimo koliko imamo parova prefiksa sa jednakim \\(P\\). Ovo mo\u017eemo uraditi sortiranjem niza parova ili pomo\u0107u \\(\\text{std::map}\\). </p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#resenje-kada-je-sio-stablo-kompletno-binarno-stablo","title":"Re\u0161enje kada je SIO stablo kompletno binarno stablo","text":"<p>Vremenska slo\u017eenost: \\(O(N log^2 N)\\)</p> <p>Na\u0111imo prvo za koliko SIO parova se koren stabla nalazi na putu izme\u0111u njih. To moraju biti \u010dvorovi iz razli\u010ditih podstabala. Sli\u010dno kao u re\u0161enju za lanac na\u0111imo vrednosti \\(X(i)\\) koliko se puta pojavljuje slovo \\(X\\) na putu od korena do \u010dvora \\(i\\). Tako\u0111e za svaki \u010dvor zapamtimo par \\(P(i) = (\\text{S(i)}-\\text{I(i)}, \\text{S(i)}-\\text{O(i)})\\). U \\(\\text{std::map}\\) zapamtimo koliko se puta koji par pojavljuje u levom podstablu. Za \u010dvor \\(i\\) u desnom podstablu ako ga uparimo sa \u010dvorom \\(j\\) u levom podstablu tako da va\u017ei \\(P(j) = (\\text{I(i)}-\\text{S(i)}, \\text{O(i)}-\\text{S(i)})\\), svako od tri slova \u0107e se pojavljivati isti broj puta na putu izme\u0111u \\(i\\) i \\(j\\). Za svaki \u010dvor \\(i\\) u desnom podstablu pomo\u0107u \\(\\text{std::map}\\) na\u0111imo koliko ima takvih \u010dvorova \\(j\\) u levom podstablu i to dodajmo na re\u0161enje. Sada kada smo u obzir uzeli sve puteve koji prelaze preko korena stabla, znamo da su svi ostali putevi izme\u0111u \u010dvorova iz istog podstabla pa mo\u017eemo rekurzivno da re\u0161imo problem za levo i desno podstablo. Podstablo veli\u010dine \\(M\\) re\u0161avamo u vremenskoj slo\u017eenosti \\(O(M log M)\\). Kako je visina stabla \\(O(log N)\\) zbir veli\u010dina podstabala je \\(O(N log N)\\) pa je vremenska slo\u017eenost celog algoritma \\(O(N log^2 N)\\).</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Vremenska slo\u017eenost: \\(O(N log^2 N)\\)</p> <p>Re\u0161enje je sli\u010dno kao za kompletno binarno stablo. U svakom stablu postoji \u010dvor takav da kada izbri\u0161emo njega i sve njegove grane, svaka povezana komponenta koja ostane mora imati barem dva puta manji broj \u010dvorova nego stablo pre brisanja.  Ovaj \u010dvor se naziva centroid i mogu\u0107e ga je na\u0107i pomo\u0107u algoritma pretrage u dubinu (DFS). Na\u0111imo za koliko SIO parova se centroid nalazi na putu izme\u0111u njih, na sli\u010dan na\u010din kao u prethodnom re\u0161enju, zatim obri\u0161imo centroid i sve njegove grane. Rekurzivno re\u0161imo problem za povezane komponente koje su nam ostale. Zbog osobina centroida dubina ove rekurzije je \\(O(log N)\\) pa je vremenska slo\u017eenost celog algoritma \\(O(N log^2 N)\\).</p>"},{"location":"takprog/2020_2021/kv1/05_sio_stablo/#alternativno-resenje-za-100-poena","title":"Alternativno re\u0161enje za 100 poena","text":"<p>Vremenska slo\u017eenost: \\(O(N log^2 N)\\)</p> <p>Kao u re\u0161enju za kompletno binarno stablo, na\u0111imo vrednosti \\(P(i)\\) za svaki \u010dvor. Ovaj put prvo rekurzivno re\u0161avamo podstabla, a zatim tra\u017eimo broj SIO parova tako da se koren nalazi na putu izme\u0111u njih. Svaki rekurzivni poziv \u0107e napraviti \\(\\text{std::map}\\)-u u kojoj su prebrojane vrednosti \\(P(i)\\) za sve \u010dvorove \\(i\\) u trenutnom podstablu. Kako bismo napravili \\(\\text{std::map}\\) za trenutno podstablo potrebno je da spojimo \\(\\text{std::map}\\)-e za podstabla koja ostanu kada se izbaci koren ovog podstabla, a zatim da ubacimo \\(P(koren)\\). Kako bismo dobili dobru vremensku slo\u017eenost, kada spajamo \\(\\text{std::map}\\)-e uvek prolazimo kroz manju i prebacujemo sve iz nje u ve\u0107u. Prilikom spajanja prebrojavamo SIO parove. Posmatrajmo put od \u010dvora \\(U\\) do \\(V\\). Neka je \\(W\\) \u010dvor na najmanjem rastojanju od korena koji se nalazi na putu izme\u0111u \\(U\\) i \\(V\\). Par \\((U, V)\\) je SIO par ako i samo ako va\u017ei \\(P(U) + P(V) - 2 P(W) = (0, 0)\\). Ako se \\(U\\) nalazi u manjoj \\(\\text{std::map}\\)-i, na re\u0161enje dodajemo broj \u010dvorova u ve\u0107oj, takvih da je \\(P(V) = 2 P(W) - P(U)\\). Ostaje jo\u0161 da analiziramo vremensku slo\u017eenost ovog algoritma. Posmatrajmo za neki \u010dvor koliko puta je bio preba\u010den iz jedne u drugu \\(\\text{std::map}\\)-u. Svaki put kada je preba\u010den, veli\u010dina \\(\\text{std::map}\\)-e u kojoj je pove\u0107ala se bar dva puta jer je veli\u010dina nove \\(\\text{std::map}\\)-e zbir veli\u010dina \\(\\text{std::map}\\)-e u kojoj je bio i ve\u0107e \\(\\text{std::map}\\)-e. Zbog toga jedan \u010dvor nije mogao biti preba\u010den vi\u0161e od \\(log N\\) puta. Sledi da je ukupan broj prebacivanja \\(O(N log N)\\), pa kako je za svaku operaciju nad \\(\\text{std::map}\\)-om potrebno \\(O(log N)\\) vremena, ukupna vremenska slo\u017eenost ovog algoritma je \\(O(N log^2 N)\\)</p> 05_sio_stablo.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define pb push_back\n#define ll long long\nconst int N=300050;\nvector&lt;pair&lt;int,char&gt;&gt; E[N];\nbool was[N];\nint sz[N];\nvoid DFS(int u,int p){sz[u]=1;for(auto e:E[u])if(e.first!=p&amp;&amp;!was[e.first])DFS(e.first,u),sz[u]+=sz[e.first];}\nint Find(int u,int p,int n){for(auto e:E[u])if(e.first!=p&amp;&amp;!was[e.first]&amp;&amp;sz[e.first]*2&gt;n)return Find(e.first,u,n);return u;}\nint FindCentroid(int u){DFS(u,u);return Find(u,u,sz[u]);}\nvector&lt;pair&lt;int,int&gt;&gt; push;\nmap&lt;pair&lt;int,int&gt;,int&gt; cnt;\nll ans=0;\nvoid Solve(int u,int p,int S,int I,int O){\n    push.pb({S-I,S-O});\n    ans+=cnt[{I-S,O-S}];\n    for(auto e:E[u])if(e.first!=p&amp;&amp;!was[e.first]){\n        Solve(e.first,u,S+(e.second=='S'),I+(e.second=='I'),O+(e.second=='O'));\n    }\n}\nvoid Decompose(int u){\n    u=FindCentroid(u);\n    was[u]=1;\n    cnt.clear();\n    cnt[{0,0}]++;\n    for(auto e:E[u])if(!was[e.first]){\n        Solve(e.first,u,e.second=='S',e.second=='I',e.second=='O');\n        for(auto p:push)cnt[p]++;\n        push.clear();\n    }\n    for(auto e:E[u])if(!was[e.first]){\n        Decompose(e.first);\n    }\n}\nint main(){\n    int n;scanf(\"%i\",&amp;n);\n    for(int i=1;i&lt;n;i++){\n        int u,v;char c;\n        scanf(\"%i %i %c\",&amp;u,&amp;v,&amp;c);\n        E[u].pb({v,c});\n        E[v].pb({u,c});\n    }\n    Decompose(1);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/","title":"1 - Kvadrati","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Takmi\u010dari nas \u010desto pitaju \u0160ta je kvadrat?, ali retko ko pita Kako je kvadrat?  U ovom zadatku tra\u017eimo odgovor na tre\u0107e pitanje: ako imamo koordinate dve razli\u010dite ta\u010dke, koliko postoji kvadrata kojima su te dve ta\u010dke temena, a stranice kvadrata su paralelne nekoj od koordinatnih osa (pravi \\(x = 0\\) ili \\(y = 0\\))? </p> <p>\u010cesto postavljena pitanja:</p> <ul> <li>Pitanje: Kako je kvadrat?</li> <li>Odgovor: Dobro je, hvala na pitanju.</li> <li>Pitanje: \u0160ta je kvadrat?</li> <li>Odgovor: Kako vas nije sramota.</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Lazar Milenkovi\u0107 Pavle Martinovi\u0107 <p>Primetimo najpre da ako su zadata dva temena na istoj stranici kvadrata, tada mora va\u017eiti da je \\(x_1 = x_2\\) ili \\(y_1 = y2\\). Tada postoje dva kvadrata koji ispunjavaju uslove, a oni su centralno simetri\u010dni u odnosu na zadatu stranicu. Ako su zadata dva antipodalna (dijametralno suprotna) temena, neophodno je proveriti da va\u017ei da je \\(|x_1 - x_2| = |y_1 - y_2|\\). U ovom slu\u010daju postoji ta\u010dno jedan kvadrat. U svim ostalim slu\u010dajevima re\u0161enje je \\(0\\).</p> 01_kvadrati.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main() {\n    int x1, y1, x2, y2;\n    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n\n    if(x1 == x2 || y1 == y2) cout &lt;&lt; 2 &lt;&lt; endl;\n    else if(abs(x1-x2) == abs(y1-y2)) cout &lt;&lt; 1 &lt;&lt; endl;\n    else cout &lt;&lt; 0 &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalaze se dva cela broja \\(x_1\\) i \\(y_1\\) -- koordinate prve ta\u010dke. U drugoj liniji ulaza nalaze se jo\u0161 dva cela broja \\(x_2\\) i \\(y_2\\) -- koordinate druge ta\u010dke.</p>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji izlaza ispisati broj kvadrata kojima su stranice paralelne koordinatnim osama i date ta\u010dke su im temena. </p>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(-10^9 \\leq x_1, y_1, x_2, y_2 \\leq 10^9\\)</li> <li>date ta\u010dke \u0107e biti razli\u010dite, odnosno ne\u0107e va\u017eiti i \\(x_1 = x_2\\) i \\(y_1 = y_2\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(-50 \\leq x_1, y_1, x_2, y_2 \\leq 50\\)</li> <li>U test primerima vrednim \\(30\\) poena: \\(-200 \\leq x_1, y_1, x_2, y_2 \\leq 200\\)</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv2/01_kvadrati/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv2/01_kvadrati/#ulaz","title":"Ulaz","text":"<pre><code>1 1\n3 3\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Jedini odgovaraju\u0107i kvadrat koji postoji je \\(\\{(1, 1), (3, 3), (1, 3), (3, 1)\\}\\):</p> <p></p>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv2/01_kvadrati/#ulaz_1","title":"Ulaz","text":"<pre><code>56 34\n105 34\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2020_2021/kv2/01_kvadrati/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Dva odgovaraju\u0107a kvadrata koja postoje su \\(\\{(56, 34), (105, 34), (56, 83), (105, 83)\\}\\) i \\(\\{(56, 34), (105, 34), (56, -15), (105, -15)\\}\\):</p> <p></p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/","title":"2 - Uzgajiva\u010di jabuka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Mo\u017eda niste znali, ali uzgajanje jabuka je postalo vrlo isplativ i unosan biznis u svetu. Na svetu postoji \\(N\\) uzgajiva\u010da jabuka, \\(i\\)-ti uzgajiva\u010d zara\u0111uje \\(A_i\\) dolara godi\u0161nje. Ipak stvari nisu tako jednostavne zbog Svetske poreske agencije uzgajiva\u010da jabuka (u nastavku teksta SPAUJ). SPAUJ \u017eeli da uvede fiksan godi\u0161nji porez za sve uzgajiva\u010de jabuka (fiksan procenat od zarade koji bi uzgajiva\u010di pla\u0107ali). Uzgajiva\u010di su shvatili da ako porez bude suvi\u0161e visok oni uop\u0161te ne\u0107e raditi, samo da SPAUJ ne bi zaradio neki dolar od njih. Konkretnije, ako porez bude striktno ve\u0107i od \\(P_i\\) procenata, \\(i\\)-ti uzgajiva\u010d \u0107e odustati od posla.</p> <p>Nas interesuje koliko najvi\u0161e mo\u017ee zaraditi SPAUJ godi\u0161nje u dolarima ako optimalno postavi porez. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Aleksa Plav\u0161i\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 <p>Glavna ideja u ovom zadatku je da \u0107e SPAUJ uvek odabrati kao stopu poreza jedan od elemenata niza \\(P\\). Da bismo to dokazali, pretpostavimo suprotno, da nam je optimalno uzeti za porez \\(x\\) posto, gde je \\(x\\) razli\u010dito od svih elemenata niza \\(P\\). Uzmimo prvi ve\u0107i element niza \\(P\\) i ozna\u010dimo ga sa \\(y\\). Mo\u017ee se lako primetiti da \u0107e za oba ta izbora (i \\(x\\) i \\(y\\)) isti uzgajiva\u010di nastaviti da rade, ali po\u0161to va\u017ei \\(x &lt; y\\), SPAUJ \u0107e uzeti ve\u0107i procenat novca od tih uzgajiva\u010da ako izabere \\(y\\). Samim tim, \\(x\\) nije optimalno \u0161to je u kontradikciji sa na\u0161om pretpostavkom. Dakle, jedine opcije za porez su elementi niza \\(P\\).</p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#opis-ulaza","title":"Opis ulaza","text":"<ul> <li> <p>U prvoj liniji standardnog ulaza nalazi se prirodan broj \\(N\\), broj uzgajiva\u010da javuka u svetu.</p> </li> <li> <p>U svakoj od narednih \\(N\\) linija standardnog ulaza nalazi se po dva broja, \\(A_i\\) i \\(P_i\\), po\u010detna zarada \\(i\\)-tog uzgajiva\u010da i maksimalan porez u procentima koji \\(i\\)-ti uzgajiva\u010d \u017eeli prihvatiti.   </p> </li> </ul>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati maksimalnu godi\u0161nju zaradu SPAUJ-a.</p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq A_i \\leq 10^6\\)</li> <li>\\(0 \\leq P_i \\leq 100\\)</li> <li>Elementi niza \\(P\\) su nenegativni realni brojevi sa najvi\u0161e dve decimale.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(N \\leq 1000\\)</li> <li>U test primerima vrednim \\(20\\) poena: elementi niza \\(P\\) su celi brojevi  </li> <li>U test primerima vrednim \\(20\\) poena: svi elementi niza \\(A\\) su jednaki</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv2/02_jabuke/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv2/02_jabuke/#ulaz","title":"Ulaz","text":"<pre><code>4\n100001 83.2\n40001 20\n90001 77.32\n300001 1.88\n</code></pre>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#izlaz","title":"Izlaz","text":"<pre><code>146909.5464\n</code></pre>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Za SPAUJ je optimalno da postavi porez od \\(77.32\\%\\). U tom slu\u010daju bi drugi i \u010detvrti uzgajiva\u010d odustali od posla, dok bi prvi i tre\u0107i dali \\(77.32\\%\\) od svoje zarade. Na ovaj na\u010din, SPAUJ bi zaradio \\((100001 + 90001) \\cdot 77.32\\% = 146909.5464\\) dolara godi\u0161nje. </p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#napomene","title":"Napomene","text":"<ul> <li>Da bi se rezultat priznao kao ta\u010dan, apsolutna gre\u0161ka mora biti manja od \\(10^{-2}\\).</li> <li>Zbog veli\u010dine rezultata, koristite 64-bitne tipove realnih brojeva (npr. u C++ tip <code>double</code>).</li> </ul>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#resenje-kad-su-elementi-niza-p-celi-brojevi","title":"Re\u0161enje kad su elementi niza \\(P\\) celi brojevi:","text":"<p>Na osnovu prethodnog zaklju\u010dka mo\u017eemo videti da je potrebno proveriti samo sve celobrojne procente, odnosno da porez bude ceo broj od \\(0\\) do 100. To zna\u010di da \u0107emo najvi\u0161e \\(101\\) put pro\u0107i kroz niz, \u0161to je svakako dovoljno brzo. Vremenska slo\u017eenost je \\(O(N)\\). </p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#resenje-za-n-leq-1000","title":"Re\u0161enje za \\(N \\leq 1000\\):","text":"<p>Proverimo prolaskom kroz niz svaki od \\(N\\) elemenata niza \\(P\\). Vremenska slo\u017eenost je \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#resenje-kad-su-svi-elementi-niza-a-jednaki","title":"Re\u0161enje kad su svi elementi niza \\(A\\) jednaki:","text":"<p>Za re\u0161enje ovog podzadatka morate pitati vra\u010daru Miljanu.</p>"},{"location":"takprog/2020_2021/kv2/02_jabuke/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sortiramo sve uzgajiva\u010de po vrednosti niza \\(P\\) opadaju\u0107e (dakle, sortiramo nizove \\(A\\) i \\(P\\) zajedno). Sada za dati element niza \\(P\\) mo\u017eemo u \\(O(1)\\) proveriti koliko bi SPAUJ zaradio za takav porez koriste\u0107i prefiksnu sumu nad nizom \\(A\\) (niz u kojem za svako \\(i\\) \u010duvamo sumu prvih \\(i\\) elemenata). Vremenska slo\u017eenost je \\(O(NlogN)\\), zbog sortiranja.</p> 02_jabuke.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxN = 2e5 + 10;\n\nint id[maxN], a[maxN];\ndouble p[maxN];\n\nbool cmp(int x, int y)\n{\n    return p[x] &gt; p[y];\n}\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\",&amp;n);\n\n    for (int i = 1;i&lt;=n;i++){\n        scanf(\"%d%lf\",&amp;a[i], &amp;p[i]);\n        id[i] = i;\n    }\n\n   sort(id + 1, id + n + 1, cmp);\n\n   long long sum = 0;\n   double ans = 0;\n\n   for (int i = 1;i&lt;=n;i++)\n   {\n       sum+=a[id[i]];\n       ans = max(ans, p[id[i]] * sum);\n   }\n\n   printf(\"%.3lf\", ans/100.00);\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv2/03_slova/","title":"3 - Slova","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>\u0160etaju\u0107i gradom, nai\u0161li ste na natpis sa\u010dinjen od \\(N\\) slova engleskog alfabeta. Iz nekog razloga, zapitali ste se na koliko je na\u010dina mogu\u0107e obrisati sva slova osim 26, tako da su preostala slova sva razli\u010dita i pore\u0111ana redom?</p> <p>Po\u0161to ovaj broj mo\u017ee biti veoma velik, potrebno je ispisati samo njegov ostatak pri deljenju sa \\(10^9 + 7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Dimitrije Erdeljan Lazar Milenkovi\u0107 Tadija \u0160ebez"},{"location":"takprog/2020_2021/kv2/03_slova/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalazi se broj slova u natpisu \\(N\\).</p> <p>U drugom redu nalazi se \\(N\\) velikih slova koja (redom) \u010dine natpis.</p>"},{"location":"takprog/2020_2021/kv2/03_slova/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati broj na\u010dina da se iz natpisa obri\u0161u sva slova osim 26, tako da su preostala slova pore\u0111ana redom (tj. tako da ostane <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>) po modulu \\(10^9 + 7\\).</p>"},{"location":"takprog/2020_2021/kv2/03_slova/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^6\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 10 poena: \\(N \\leq 26\\)</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 27\\)</li> <li>U test primerima vrednim 30 poena: \\(N \\leq 3000\\)</li> <li>U test primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv2/03_slova/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv2/03_slova/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv2/03_slova/#ulaz","title":"Ulaz","text":"<pre><code>29\nAABACDEFGHIJKLMNOPQRSTUVWXYZZ\n</code></pre>"},{"location":"takprog/2020_2021/kv2/03_slova/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2020_2021/kv2/03_slova/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Mogu\u0107i na\u010dini su:</p> <ul> <li>Obrisati prvo i tre\u0107e <code>A</code> i prvo <code>Z</code>.</li> <li>Obrisati prvo i tre\u0107e <code>A</code> i drugo <code>Z</code>.</li> <li>Obrisati drugo i tre\u0107e <code>A</code> i prvo <code>Z</code>.</li> <li>Obrisati drugo i tre\u0107e <code>A</code> i drugo <code>Z</code>.</li> </ul>"},{"location":"takprog/2020_2021/kv2/03_slova/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv2/03_slova/#ulaz_1","title":"Ulaz","text":"<pre><code>78\nAAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ\n</code></pre>"},{"location":"takprog/2020_2021/kv2/03_slova/#izlaz_1","title":"Izlaz","text":"<pre><code>865810542\n</code></pre>"},{"location":"takprog/2020_2021/kv2/03_slova/#resenja-za-male-primere","title":"Re\u0161enja za male primere","text":"<p>Ako je du\u017eina stringa \\(26\\), potrebno je jednostavno proveriti da je zadati string zaista sa\u010dinjen od svih slova 'A' do 'Z' u rastu\u0107em poretku. Kada je du\u017eina \\(27\\), isti uslov treba da je ispunjen kada se izbaci jedno slovo.</p>"},{"location":"takprog/2020_2021/kv2/03_slova/#kvadratno-resenje","title":"Kvadratno re\u0161enje","text":"<p>Problem mo\u017eemo posmatrati kao prebrojavanje (ne nu\u017eno uzastopnih) podnizova zadatog natpisa koji \u010dine rastu\u0107i niz slova od A do Z. Mogu\u0107i pristup jeste posmatrati jednostavniji potproblem koji se sastoji od prebrojavanja kra\u0107ih rastu\u0107ih podnizova koji se zavr\u0161avaju nekim slovom. Neka \\(dp_{i, j}\\) predstavlja broj rastu\u0107ih podnizova koji se zavr\u0161avaju na poziciji \\(i\\) i koji su du\u017eine \\(j\\).</p> <p>Broj podnizova koji se zavr\u0161avaju na poziciji \\(i\\) i imaju du\u017einu \\(1\\) je \\(1\\) ako je slovo na toj poziciji u natpisu A i \\(0\\) u suprotnom. Ako pretpostavimo da znamo re\u0161enje za sve pozicije pre trenutne, lako mo\u017eemo izra\u010dunati \\(dp\\) vrednosti za trenutnu poziciju. Naime, \\(dp_{i, j}\\) je \\(0\\) za svako \\(j\\) sem za redni broj slova koji je na \\(i\\)-tom mestu u natpisu. Za ovo \\(j\\) potrebno je prebrojati sve natpise du\u017eine \\(j-1\\) koji se zavr\u0161avaju pre pozicije \\(i\\). Drugim re\u010dima \\(dp_{i, j} = \\sum_{1\\le k &lt;i}dp_{k, j-1}\\). Kona\u010dno re\u0161enje je suma svih sekvenci koje su du\u017eine 26, odnosno \\(\\sum_{1\\le i \\le n}dp_{i, 26}\\).</p>"},{"location":"takprog/2020_2021/kv2/03_slova/#resenje-u-linearnom-vremenu","title":"Re\u0161enje u linearnom vremenu","text":"<p>Prethodno re\u0161enje mo\u017eemo optimizovati \u010duvanjem sume svih prethodnih vrednosti. Vrednosti u tabeli bile bi odre\u0111ene na slede\u0107i na\u010din.</p> \\[ dp_{i, j} =   \\begin{cases} dp_{i-1, j} + dp_{i-1, j-1}, &amp; \\text{ako je na $i$-toj poziciji $j$-to slovo alfabeta}\\\\ dp_{i-1, j}, &amp; \\text{u suprotnom samo prepisujemo prethodnu vrednost} \\end{cases} \\] <p>Ovakva tabela mo\u017ee se odr\u017eavati u linearnom vremenu. Primetimo na kraju da po\u0161to uvek ispitujemo samo prethodno polje, memoriju mo\u017eemo smanjiti kori\u0161\u0107enjem samo jednog niza du\u017eine 26.</p> 03_slova.cpp<pre><code>#include &lt;cstdio&gt;\n\nconst int N = 1000005;\nconst int MOD = 1000000007;\n\nint ways[26];\nchar s[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    scanf(\"%s\", &amp;s);\n\n    for(int i = 0; i &lt; 26; i++)\n        ways[i] = 0;\n\n    for(int i = 0; i &lt; n; i++) {\n        int j = s[i] - 'A';\n        ways[j] += (j &gt; 0) ? ways[j - 1] : 1;\n        if(ways[j] &gt;= MOD) ways[j] -= MOD;\n    }\n\n    printf(\"%d\\n\", ways['Z' - 'A']);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv2/04_bug/","title":"4 - BUG","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Posle velikog uspeha igre JAG\u2122, kompanija \"Najbolji ltd.\" je napravila jo\u0161 bolji nastavak, BUG\u2122.</p> <p>U ovoj u\u010destvuje \\(10^9 + 7\\) igra\u010da i pobednik se odlu\u010duje slu\u010dajnim izborom. Da bi izbor bio slu\u010dajan, kompanija je postavila stroga pravila za biranje tog igra\u010da. Prvo numeri\u0161u igra\u010de sa identifikacionim brojevima od \\(0\\) do \\(10^9+6\\). Zatim izaberu niz \\(A\\) sa \\(N\\) elemenata i broj \\(k\\). Potom defini\u0161u pobednika kao igra\u010da koji ima identifikacioni broj \\(f(A,k) \\mod (10^9 + 7)\\), gde je:</p> <ul> <li>\\(f(T,k) = \\sum_{i=1}^{i \\leq len(T)} T_i\\), za \\(k=0\\), gde je \\(len(T)\\) du\u017eina niza \\(T\\).</li> <li>\\(f(T,k) = \\sum_{i=1}^{i \\leq len(T)} \\sum_{j=i}^{j\\leq len(T)} f(T[i...j],k-1)\\) za \\(k&gt;0\\), gde je \\(len(T)\\) du\u017eina niza \\(T\\) i \\(T[i...j]\\) podniz niza \\(T\\) sa elementima od \\(i\\)-te do \\(j\\)-te pozicije, tj. niz sa elementima \\(T_i, T_{i+1}, ..., T_{j-1}, T_{j}\\).</li> </ul> <p>Pomozite kompaniji \"Najbolji ltd.\" i odredite pobednika igre.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Aleksa Milisavljevi\u0107 Vladimir Milenkovi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2020_2021/kv2/04_bug/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se brojevi \\(N\\), du\u017eina niza \\(A\\) i \\(k\\). U narednom redu nalazi se \\(N\\) brojeva, elementi niza \\(A\\). </p>"},{"location":"takprog/2020_2021/kv2/04_bug/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jednu vrednost, pobednika igre, tj. vrednost \\(f(A,k) \\mod (10^9 + 7)\\).</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\cdot 10^{5}\\).</li> <li>\\(0 \\leq k \\leq 2 \\cdot 10^{5}\\).</li> <li>\\(0 \\leq A_i \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena: \\(N \\leq 10^3\\), \\(k=1\\).</li> <li>U test primerima vrednim 15 poena: \\(N \\leq 5\\), \\(k \\leq 5\\).</li> <li>U test primerima vrednim 25 poena: \\(N \\leq 300\\), \\(k \\leq 300\\).</li> <li>U test primerima vrednim 40 poena: \\(N \\leq 2000\\), \\(k \\leq 2000\\).</li> <li>U test primerima vrednim 10 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv2/04_bug/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv2/04_bug/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv2/04_bug/#ulaz","title":"Ulaz","text":"<pre><code>5 0\n1 6 3 4 7\n</code></pre>"},{"location":"takprog/2020_2021/kv2/04_bug/#izlaz","title":"Izlaz","text":"<pre><code>21\n</code></pre>"},{"location":"takprog/2020_2021/kv2/04_bug/#objasnjenje","title":"Obja\u0161njenje","text":"<p>\\(f(A,k) = f([1,6,3,4,7],0) = 1 + 6 + 3 + 4 + 7 = 21\\), pa je \\(f(A,k) \\mod (10^9 + 7) = 21\\)</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv2/04_bug/#ulaz_1","title":"Ulaz","text":"<pre><code>5 1\n1 6 3 4 7\n</code></pre>"},{"location":"takprog/2020_2021/kv2/04_bug/#izlaz_1","title":"Izlaz","text":"<pre><code>147\n</code></pre>"},{"location":"takprog/2020_2021/kv2/04_bug/#objasnjenje_1","title":"Obja\u0161njenje","text":"\\[ f(A,k) = f([1,6,3,4,7],1) = f([1],0) + f([1,6],0) + f([1,6,3],0) + f([1,6,3,4],0) + f([1,6,3,4,7],0) + f([6],0) + f([6,3],0) + f([6,3,4],0) + f([6,3,4,7],0) + f([3],0) + f([3,4],0) + f([3,4,7],0) + f([4],0) + f([4,7],0) + f([7],0) = 1 + 1 + 6 + 1 + 6 + 3 + 1 + 6 + 3 + 4 + 1 + 6 + 3 + 4 + 7 + 6 + 6 + 3 + 6 + 3 + 4 + 6 + 3 + 4 + 7 + 3 + 3 + 4 + 3 + 4 + 7 + 4 + 4 + 7 + 7 = 147, \\] <p>pa je </p> \\[ f(A,k) \\mod (10^9 + 7) =147 \\]"},{"location":"takprog/2020_2021/kv2/04_bug/#prvi-potproblem","title":"Prvi potproblem","text":"<p>Ovaj potproblem nas pita da na\u0111emo zbir zbirova svakog podniza niza \\(A\\), \u0161to mo\u017eemo uraditi iteriranjem po svakom podnizu, ra\u010dunaju\u0107i zbir koriste\u0107i niz prefiksnih suma. Slo\u017eenost ovog algoritma je \\(\\mathcal{O}(N^2)\\), \u0161to je dovoljno dobro.</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#drugi-potproblem","title":"Drugi potproblem","text":"<p>\u010cistom simulacijom izra\u010dunavanja funkcije \\(f\\), na na\u010din opisan u tekstu zadatka, mo\u017eemo u eksponencijalnom vremenu uraditi ovaj potproblem.</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#ostali-potproblemi","title":"Ostali potproblemi","text":"<p>Mo\u017eemo lako uo\u010diti da \u0107e vrednost funkcije \\(f(A, k)\\) biti jednako izrazu \\(\\sum_{i=1}^{n} c_i \\cdot A_i\\) za neki niz koeficijenata \\(c\\) -- hajde da vidimo koliki su ti koeficijenti. Koeficijent uz \\(A_i\\) \u0107e biti jednak broju finalnih podnizova u kojima se pojavljuje taj element. </p> <p>Skup svih podniza \u010diji \u0107e se zbirovi sabirati u fazama kada je \\(k = 0\\) u kojima se sadr\u017ei element \\(A_i\\) je u bijekciji sa skupom parova nizova \\(l\\) i \\(r\\) od \\(k\\) elemenata, za koje va\u017ei \\(1 \\leq l_1 \\leq l_2 \\leq \\dots \\leq l_k \\leq i \\leq r_k \\leq r_{k-1} \\leq \\dots \\leq r_1 \\leq n\\). Ovo lako mo\u017eemo proveriti tako \u0161to posmatramo da je taj podniz u prvoj fazi bio podniz niza \\(A[1..n] = A\\), u drugoj podniz niza \\(A[l_1 .. r_1]\\), itd. Tako\u0111e, primetimo da su nizovi \\(l\\) i \\(r\\) na neki na\u010din nezavisni, broj ovakvih parova nizova \\((l, r)\\) je jednak proizvodu broja adekvatnih \\(l\\) i \\(r\\) nizova.</p> <p>Treba da izra\u010dunamo koliko ovakvih podnizova postoji (simetri\u010dno ra\u010dunamo za \\(l\\) i \\(r\\) nizove). Ra\u010dunaju\u0107i za \\(l\\) nizove prvo, uvo\u0111enjem \\(d_i = l_i - l_{i-1}\\) (uz \\(l_0 = 1\\)), mo\u017eemo videti da nizova \\(l\\) ima koliko i re\u0161enja jedna\u010dine \\(d_1 + d_2 + \\cdots + d_k = i - 1\\) (gde \\(d_i \\geq 0\\)), \u010diji je broj re\u0161enja \\({k + i - 1 \\choose k}\\). </p> <p>Koriste\u0107i sli\u010dnu analizu za broj nizova \\(r\\), dobijamo da je \\(c_i = {k + i - 1 \\choose k} \\cdot {k + n - i \\choose k}\\). Sve \u0161to nam ostaje je da izra\u010dunamo ove binomne koeficijente.</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#podzadaci-3-i-4","title":"Podzadaci 3 i 4","text":"<p>Sve binomne koeficijente mo\u017eemo izra\u010dunati koriste\u0107i Paskalov trougao, i ukupna vremenska slo\u017eenost je \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/kv2/04_bug/#podzadatak-5","title":"Podzadatak 5","text":"<p>Ovde moramo koristiti br\u017ei na\u010din izra\u010dunavanja binomnih koeficijenata, koriste\u0107i segmentno stablo nad prostim \u010diniocima. Alternativno, mo\u017eemo prekalkulisati faktorijele i ra\u010dunati binomne koeficijente deljenjem, koriste\u0107i modularni inverz.</p> 04_bug.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 500000\nusing namespace std;\nlong long mod=1000000007;\ninline long long step(long long a,long long b) {\n    if(b==0ll) return 1ll;\n    if(b&amp;1ll) return (a*step(a,b-1ll))%mod;\n    else return step((a*a)%mod,b&gt;&gt;1ll);\n}\nint lp[maxn];\nlong long seg[4*maxn];\ninline void set_seg(int id,int l,int r) {\n    seg[id]=1;\n    if(l==r) return;\n    int m=(l+r)/2;\n    set_seg(id*2+1,l,m);\n    set_seg(id*2+2,m+1,r);\n}\nint pos[maxn];\ninline void update_seg(int id,int l,int r,int p) {\n    if(l==r) {\n        seg[id]=step(p,pos[p]);\n        return;\n    }\n    int m=(l+r)/2;\n    if(p&lt;=m) update_seg(id*2+1,l,m,p);\n    else update_seg(id*2+2,m+1,r,p);\n    seg[id]=(1ll*seg[id*2+1]*seg[id*2+2]);\n    if(seg[id]&gt;=mod) seg[id]%=mod;\n}\nlong long a[maxn];\nlong long val[maxn];\nint n,k;\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;k);\n    for(int i=0;i&lt;n;i++) scanf(\"%lld\",&amp;a[i]);\n    set_seg(0,0,maxn-1);\n    for(int i=2;i&lt;maxn;i++) {\n        if(!lp[i]) {\n            lp[i]=i;\n            for(long long j=1ll*i*i;j&lt;maxn;j+=i) {\n                if(!lp[j] || lp[j]&gt;i) lp[j]=i;\n            }\n        }\n    }\n    int nf=0;\n    val[0]=1;\n    for(int i=1;i&lt;n;i++) {\n        int x=k+i;\n        int y=i;\n        while(x&gt;1) {\n            int p=lp[x];\n            int c=0;\n            while(lp[x]==p) {\n                c++;\n                x=x/lp[x];\n            }\n            pos[p]+=c;\n            update_seg(0,0,maxn-1,p);\n        }\n        while(y&gt;1) {\n            int p=lp[y];\n            int c=0;\n            while(lp[y]==p) {\n                c++;\n                y=y/lp[y];\n            }\n            pos[p]-=c;\n            update_seg(0,0,maxn-1,p);\n        }\n        val[i]=seg[0];\n    }\n    long long ans=0;\n    for(int i=0;i&lt;n;i++) {\n        ans=(ans+((((a[i]*val[i])%mod)*val[n-1-i])%mod))%mod;\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv2/05_01_niz/","title":"5 - 01 niz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>\\(N\\) nov\u010di\u0107a pore\u0111ano je u niz. Svaki nov\u010di\u0107 ima broj \\(0\\) napisan na jednoj strani i broj \\(1\\) na drugoj. Ta\u010dno jedna strana svakog nov\u010di\u0107a je vidljiva. String \\(S\\) predstavlja vidljive cifre nov\u010di\u0107a pro\u010ditane od po\u010detka do kraja niza. Nad ovim nizom nov\u010di\u0107a treba izvr\u0161iti \\(Q\\) promena, gde je \\(i\\)-ta promena opisana sa dva broja \\(L_i\\) i \\(R_i\\), \u0161to zna\u010di da je potrebno okrenuti sve nov\u010di\u0107e na podnizu od \\(L_i\\) do \\(R_i\\).</p> <p>Na primer ako je \\(S=0101101\\), \\(L_1=2\\) i \\(R_1=6\\) posle prve promene \\(S=0010011\\).</p> <p>Posle svake promene ispisati najmanju mogu\u0107u ukupnu cenu da se svi nov\u010di\u0107i okrenu tako da im je broj 0 na vidljivoj strani, ako je mogu\u0107e primenjivati slede\u0107e dve operacije prizvoljan broj puta u proizvoljnom redosledu: - Okreni jedan nov\u010di\u0107 za cenu \\(1\\). - Okreni sve nov\u010di\u0107e na nekom podnizu uzastopnih nov\u010di\u0107a za cenu \\(C\\).</p> <p>Obratite pa\u017enju na to da se samo \\(Q\\) zadatih promena zapravo primenjuje na niz, dok se operacije kojima bismo okrenuli sve nov\u010di\u0107e tako da im je \\(0\\) na vidljivoj strani, ne primenjuju na niz nov\u010di\u0107a, ve\u0107 je samo potrebno na\u0107i njihovu najmanju mogu\u0107u ukupnu cenu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/kv2/05_01_niz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza nalaze se 3 cela broja \\(N\\), \\(C\\) i \\(Q\\). U slede\u0107em redu nalazi se string \\(S\\). U narednih \\(Q\\) redova nalaze se po 2 cela broja \\(L_i\\) i \\(R_i\\).</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispi\u0161ite \\(Q\\) redova, u \\(i\\)-tom redu tra\u017eenu najmanju cenu posle \\(i\\)-te promene.</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq C \\leq N \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq Q \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\leq N\\)</li> <li>\\(|S|=N\\)</li> <li>String \\(S\\) se sastoji samo od cifara \\(0\\) i \\(1\\).</li> </ul> <p>Test primeri su podeljeni u 9 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(2\\) poena: \\(N, Q \\leq 4000\\), \\(C=N\\)</li> <li>U test primerima vrednim \\(2\\) poena: \\(L_i=R_i\\) za svako \\(i\\), \\(C=N\\)</li> <li>U test primerima vrednim \\(12\\) poena: \\(C=N\\)</li> <li>U test primerima vrednim \\(4\\) poena: \\(N, Q \\leq 4000\\), \\(C=1\\)</li> <li>U test primerima vrednim \\(6\\) poena: \\(C=1\\)</li> <li>U test primerima vrednim \\(8\\) poena: \\(N \\leq 1000\\), \\(Q=1\\)</li> <li>U test primerima vrednim \\(18\\) poena: \\(Q=1\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(L_i=R_i\\) za svako \\(i\\)</li> <li>U test primerima vrednim \\(28\\) poena: nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv2/05_01_niz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv2/05_01_niz/#ulaz","title":"Ulaz","text":"<pre><code>7 2 3\n0111011\n1 2\n1 2\n2 6\n</code></pre>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#izlaz","title":"Izlaz","text":"<pre><code>4\n3\n2\n</code></pre>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#objasnjenje","title":"Obja\u0161njenje","text":"<ul> <li>Posle prve pomene \\(S=1011011\\) i optimalno je okrenuti ceo niz nov\u010di\u0107a za cenu \\(2\\) i zatim okrenuti drugi i peti nov\u010di\u0107. Ukupna cena je \\(2+1*2=4\\).</li> <li>Posle druge promene \\(S=0111011\\) i optimalno je okrenuti nov\u010di\u0107e od drugog do poslednjeg za cenu \\(2\\) i zatim okrenuti peti nov\u010di\u0107. Ukupna cena je \\(2+1=3\\).</li> <li>Posle tre\u0107e promene \\(S=0000101\\) i optimalno je okrenuti peti i sedmi nov\u010di\u0107. Ukupna cena je \\(1+1=2\\).</li> </ul>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv2/05_01_niz/#ulaz_1","title":"Ulaz","text":"<pre><code>16 3 5\n0111001111011001\n16 16\n1 1\n3 3\n5 5\n7 7\n</code></pre>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n6\n7\n6\n7\n</code></pre>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#resenje-kada-je-cn","title":"Re\u0161enje kada je \\(C=N\\)","text":"<p>Ne isplati se okretati podnizove nov\u010di\u0107a za cenu \\(C\\) jer mo\u017eemo pojedina\u010dno da ih okrenemo za manju ili jednaku cenu. Re\u0161enje se svodi na najmanji broj okretanja po jednog onov\u010di\u0107a tako da se dobiju sve nule. Nema razloga da ikada okrenemo nov\u010di\u0107 na kom je 0, a svaki nov\u010di\u0107 na kom je 1 okre\u0107emo po jednom, odnosno re\u0161enje je broj jedinica u nizu. Za 2 poena mo\u017eemo posle svake promene da pro\u0111emo kroz niz i prebrojimo jedinice. Vremenska slo\u017eenost je \\(O(QN)\\). Za 4 poena treba da primetimo da se posle svake promene za koju je \\(L_i=R_i\\) menja ta\u010dno jedan nov\u010di\u0107 u nizu pa mo\u017eemo lako da izra\u010dunamo za koliko se promenio broj jedinica posmatraju\u0107i samo taj nov\u010di\u0107. Vremenska slo\u017eenost je \\(O(N+Q)\\). Za 16 poena treba da izra\u010dunavamo broj jedinica pomo\u0107u segmentnog stabla sa lenjom propagacijom. Vremenska slo\u017eenost je \\(O(QlogN)\\).</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#resenje-kada-je-c1","title":"Re\u0161enje kada je \\(C=1\\)","text":"<p>Mo\u017eemo da okre\u0107emo podnizove za istu cenu kao i pojedina\u010dne nov\u010di\u0107e, tako da je re\u0161enje najmanji broj okretanja podnizova tako da dobijemo sve nule. Zamislimo da smo na po\u010detak i kraj niza dodali po jedan nov\u010di\u0107 sa nulom na vidljivoj strani. Prebrojmo sve parove susednih nov\u010di\u0107a tako da su im razli\u010diti brojevi na vidljivim stranama. Ako je ovaj broj 0 u nizu su sve nule. Okretanje podniza menja stanje ta\u010dno 2 od pomenutih parova i za svaka dva para postoji podniz koji menja njihova stanja. Zato je re\u0161enje broj parova susednih nov\u010di\u0107a \u010diji su vidljivi brojevi razli\u010diti podeljen sa 2. Ako se ovo prebrojavanje radi prolaskom kroz ceo niz posle svake promene dobija se 4 poena. Vremenska slo\u017eenost je \\(O(QN)\\). Ve\u0107 znamo da svaka promena menja stanje ta\u010dno dva para pa ako to iskoristimo mo\u017eemo lako da na\u0111emo za koliko se promenio broj parova koje brojimo. Ovo re\u0161enje je vremenske slo\u017eenosti \\(O(N+Q)\\) i nosi 10 poena.</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#resenje-kada-je-q1","title":"Re\u0161enje kada je \\(Q=1\\)","text":"<p>Ovaj slu\u010daj mo\u017eemo da re\u0161imo dinami\u010dkim programiranjem. Potrebna nam je slede\u0107a opservacija. U nekom od optimalnih re\u0161enja, obrnu\u0107emo neke disjunktne podnizove i zatim sve jedinice pojedina\u010dno. Neka je \\(dp_i\\) minimalna cena za prvih \\(i\\) nov\u010di\u0107a. Poslednji nov\u010di\u0107 mo\u017ee biti obrnut za cenu \\(C\\) sa nekim podnizom ili ne, pa je \\(dp_i = max(dp_{i-1} + S_i, max_{j=1}^i(dp_{j-1} + C + broj_nula(j,i)))\\). Ovo re\u0161enje je vremenske slo\u017eenosti \\(O(N^2)\\) i nosi 8 poena. Za 26 poena potrebno je re\u0161enje u boljoj vremenskoj slo\u017eenosti. Neka je \\(dp_{i, 0}\\) re\u0161enje za prvih \\(i\\) nov\u010di\u0107a ako \\(i\\)-ti nov\u010di\u0107 nije bio obrnut kao \u010dlan podniza, a \\(dp_{i, 1}\\) re\u0161enje ako jeste. Onda je \\(dp_{i, 0}=max(dp_{i-1, 0}, dp_{i-1, 1})+S_i\\) i \\(dp_{i, 1}=max(dp_{i-1, 0}+C, dp_{i-1, 1})+(1-S_i)\\). Ovo re\u0161enje je vremenske slo\u017eenosti \\(O(N)\\).</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#resenje-kada-je-l_ir_i","title":"Re\u0161enje kada je \\(L_i=R_i\\)","text":"<p>Ako bismo \\(Q\\) puta iskoristili re\u0161enje za \\(Q=1\\) dobili bismo re\u0161enje u vremenskoj slo\u017eenosti \\(O(NQ)\\) \u0161to je previ\u0161e sporo za ovaj podzadatak. Ipak treba da primetimo da veliki deo niza ostaje isti i da to treba nekako da iskoristimo. Mo\u017eemo da napravimo segmentno stablno nad nizom nov\u010di\u0107a i da u svakom \u010dvoru \u010duvamo neke \\(dp\\) vrednosti. Za svaki segment \u010duvamo 4 re\u0161enja \\(dp_{l,r}\\), gde je \\(l=1\\) ako je prvi nov\u010di\u0107 bio obrnut kao \u010dlan podniza i \\(r=1\\) ako je poslednji nov\u010di\u0107 bio obrnut kao \u010dlan podniza. Sa ovim informacijama mo\u017eemo da spojimo \\(dp\\) vrednosti za dva podniza i re\u0161enje zadatka \u0107e biti u korenu segmentnog stabla. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(QlogN)\\).</p>"},{"location":"takprog/2020_2021/kv2/05_01_niz/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Za svih 100 poena potrebno je da na segmentnom stablu primenomo lazy propagation tehniku. Za svaki \u010dvor \u010duva\u0107emo \\(dp\\) vrednosti za segment i \\(dp\\) vrednosti za segment ako bismo obrnuli sve nov\u010di\u0107e na njemu. Kada treba da obrnemo podniz, zameni\u0107emo ove \\(dp\\) vrednosti za neke segmente i obrnuti njihove lazy tagove. Vremenska slo\u017eenost ostaje \\(O(QlogN)\\).</p> 05_01_niz.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=200050;\nconst int M=2*N;\nconst int inf=1e9+7;\n\nint ls[M],rs[M],tsz,root;\nint dp[M][2][2][2],lzy[M];\n\nchar s[N];\nint C;\nvoid init(int c){for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)dp[c][i][j][k]=inf;}\nvoid pull(int c){\n    for(int t=0;t&lt;2;t++){\n        for(int l=0;l&lt;2;l++){\n            for(int r=0;r&lt;2;r++){\n                dp[c][t][l][r]=inf;\n                for(int a=0;a&lt;2;a++){\n                    for(int b=0;b&lt;2;b++){\n                        dp[c][t][l][r]=min(dp[c][t][l][r],dp[ls[c]][t][l][a]+dp[rs[c]][t][b][r]+(a==1&amp;&amp;b==1?-C:0));\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid Flip(int c){\n    for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)swap(dp[c][0][i][j],dp[c][1][i][j]);\n    lzy[c]^=1;\n}\n\nvoid push(int c){\n    if(lzy[c]){\n        Flip(ls[c]);\n        Flip(rs[c]);\n        lzy[c]=0;\n    }\n}\n\nvoid Build(int&amp;c,int ss,int se){\n    c=++tsz;init(c);\n    if(ss==se){\n        if(s[ss]=='1'){\n            dp[c][0][0][0]=1;\n            dp[c][0][1][1]=C;\n            dp[c][1][0][0]=0;\n            dp[c][1][1][1]=C+1;\n        }else{\n            dp[c][0][0][0]=0;\n            dp[c][0][1][1]=C+1;\n            dp[c][1][0][0]=1;\n            dp[c][1][1][1]=C;\n        }\n        return;\n    }\n    int mid=ss+se&gt;&gt;1;\n    Build(ls[c],ss,mid);\n    Build(rs[c],mid+1,se);\n    pull(c);\n}\n\nvoid Flip(int c,int ss,int se,int qs,int qe){\n    if(qs&gt;qe||qs&gt;se||ss&gt;qe)return;\n    if(qs&lt;=ss&amp;&amp;qe&gt;=se){Flip(c);return;}\n    int mid=ss+se&gt;&gt;1;\n    push(c);\n    Flip(ls[c],ss,mid,qs,qe);\n    Flip(rs[c],mid+1,se,qs,qe);\n    pull(c);\n}\n\nint Ans(){return min({dp[root][0][0][0],dp[root][0][0][1],dp[root][0][1][0],dp[root][0][1][1]});}\n\nint main(){\n    int n,q;\n    scanf(\"%i %i %i\",&amp;n,&amp;C,&amp;q);\n    assert(1&lt;=n &amp;&amp; n&lt;=200000);\n    assert(1&lt;=C &amp;&amp; C&lt;=200000);\n    assert(1&lt;=q &amp;&amp; q&lt;=200000);\n\n    scanf(\"%s\",s+1);\n    assert(strlen(s+1)==n);\n    for(int i=1;i&lt;=n;i++)assert(s[i]=='0' || s[i]=='1');\n\n    Build(root,1,n);\n\n    for(int i=1;i&lt;=q;i++){\n        int l,r;\n        scanf(\"%i %i\",&amp;l,&amp;r);\n        assert(1&lt;=l &amp;&amp; l&lt;=r &amp;&amp; r&lt;=n);\n        Flip(root,1,n,l,r);\n        printf(\"%i\\n\",Ans());\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/","title":"1 - \u0160ampion","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Sedmostruki svetski \u0161ampion, D\u017eonas Njubauer sprema se za slede\u0107e svetsko prvenstvo u Klasi\u010dnom Tetrisu. Po\u0161to zna da njegova konkurencija vredno ve\u017eba, uklju\u010duju\u0107i i njegovog mladog rivala D\u017eozefa koji se skoro pojavio na Tetris sceni, slobodnom procenom je zaklju\u010dio da mu je potrebno jo\u0161 ukupno \\(T\\) minuta igranja kako bi obezbedio svoju osmu titulu. Smislio je slede\u0107i plan treniranja.</p> <p>Naizmeni\u010dno \u0107e igrati Tetris \\(X\\) minuta, pa \\(Y\\) minuta odmarati o\u010di i piti kafu. Kada zavr\u0161i sa odmorom, ponovo \u0107e se vratiti na igranje Tetrisa i tako u krug dok ukupno ne odigra ta\u010dno planiranih \\(T\\) minuta (prestaje da trenira u trenutku kada zavr\u0161i \\(T\\)-ti minut igranja).</p> <p>Koliko mu je ukupno potrebno minuta od po\u010detka treninga (ra\u010dunaju\u0107i i vreme za odmor izme\u0111u igranja) kako bi odigrao \\(T\\) minuta Tetrisa?</p> <p>Bum! Tetris za D\u017eonasa! &lt;3</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2020_2021/kv3/01_sampion/#opis-ulaza","title":"Opis ulaza","text":"<p>U jedinoj liniji ulaza nalaze se tri cela pozitivna broja \\(X\\), \\(Y\\) i \\(T\\). </p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji izlaza ispisati koliko minuta je potrebno od po\u010detka treninga kako bi D\u017eonas odigrao \\(T\\) minuta Tetrisa.</p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq X, T \\leq 10^{15}\\) (D\u017eonas je vrlo posve\u0107en Tetrisu, pogledajte napomenu)</li> <li>\\(1 \\leq Y \\leq 1000\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(T \\leq 2\\cdot X\\), \\(1 \\leq X, T \\leq 10^9\\)</li> <li>U test primerima vrednim \\(30\\) poena: \\(1 \\leq X, T \\leq 1000\\)</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv3/01_sampion/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv3/01_sampion/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv3/01_sampion/#ulaz","title":"Ulaz","text":"<pre><code>5 4 8\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#izlaz","title":"Izlaz","text":"<pre><code>12\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#objasnjenje","title":"Obja\u0161njenje","text":"<p>D\u017eonas \u0107e odigrati \\(5\\) minuta Tetrisa, nakon \u010dega \u0107e odmoriti \\(4\\) minuta. Posle toga, odigra\u0107e jo\u0161 \\(3\\) minuta Tetrisa i time zavr\u0161iti \\(8\\) minuta igranja.</p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv3/01_sampion/#ulaz_1","title":"Ulaz","text":"<pre><code>3456 1 1800\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#izlaz_1","title":"Izlaz","text":"<pre><code>1800\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>D\u017eonas \u0107e odigrati svih \\(1800\\) minuta pre nego \u0161to mu bude bila potrebna pauza. </p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2020_2021/kv3/01_sampion/#ulaz_2","title":"Ulaz","text":"<pre><code>305 534 13413413003\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#izlaz_2","title":"Izlaz","text":"<pre><code>36897880205\n</code></pre>"},{"location":"takprog/2020_2021/kv3/01_sampion/#napomena","title":"Napomena","text":"<ul> <li>Zbog veli\u010dine brojeva, koristite 64-bitne tipove celih brojeva (npr. u C++ tip <code>long long</code>).</li> </ul>"},{"location":"takprog/2020_2021/kv3/01_sampion/#resenje-za-t-leq-2cdot-x-i-1-leq-x-t-leq-109","title":"Re\u0161enje za \\(T \\leq 2\\cdot X\\) i \\(1 \\leq X, T \\leq 10^9\\):","text":"<p>Postoje samo dve mogu\u0107e situacije: ako va\u017ei \\(T \\leq X\\), onda \u0107e D\u017eonas ne\u0107e morati da pauzira i re\u0161enje je \\(T\\). Ako \\(X&lt; T \\leq 2\\cdot X\\), D\u017eonas \u0107e morati da napravi jednu pauzu, pa je re\u0161enje u tom slu\u010daju \\(T+Y\\).</p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#resenje-za-1-leq-x-t-leq-1000","title":"Re\u0161enje za \\(1 \\leq X, T \\leq 1000\\):","text":"<p>Mo\u017eemo simulirati D\u017eonasovo igranje, ili minut po minut ili u blokovima od \\(X+Y\\) minuta. Ovo re\u0161enje je presporo da bi radilo za \\(100\\) poena.</p>"},{"location":"takprog/2020_2021/kv3/01_sampion/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Primetimo da \u0107e za svakih odigranih punih \\(X\\) minuta, D\u017eonas pauzirati \\(Y\\) minuta. Takvih blokova \u0107e biti \\(\\lfloor \\frac{T}{X} \\rfloor\\), gde je \\(\\lfloor x \\rfloor\\) ceo deo od \\(x\\). Onda \u0107e re\u0161enje biti \\(\\lfloor \\frac{T}{X} \\rfloor \\cdot (X+Y) + T\\%X\\), gde je \\(T\\%X\\) ostatak pri deljenju \\(T\\) sa \\(X\\) (odnosno ono \u0161to mu ostane da odigra nakon poslednje pauze). Jedini izuzetak ovoj formuli jeste situacija kada \\(X\\) deli \\(T\\). Tada ne\u0107emo imati pauzu u poslednjem bloku, pa je potrebno da od prethodne formule oduzmemo \\(Y\\).</p> 01_sampion.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    long long X, Y, T; cin &gt;&gt; X &gt;&gt; Y &gt;&gt; T;\n    long long rez = 0;\n    if(T%X == 0) rez = (T/X)*(X+Y)-Y;\n    else rez = (T/X)*(X+Y) + T%X;\n    cout &lt;&lt; rez;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/","title":"2 - Gejm \u0161ou","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Upravo je zavr\u0161en tre\u0107i krug ve\u010dera\u0161nje epizode poznate emisije Nokskru Gejm \u0160ou, i va\u0161 omiljeni tro\u010dlani tim, \"Sanjive Zanatlije\", gubi rezultatom 2-1, i time je pred ispadanjem. Zbog toga, moraju odneti pobedu u slede\u0107oj igri: Sprint 4.</p> <p>Igra Sprint 4 je trka koja se sastoji iz \\(N-1\\) delova, u kojima dva igra\u010da tr\u010de po brojevnoj pravoj, brzinom najvi\u0161e \\(1\\). Na po\u010detku trke, igra\u010di se nalaze na pozicijama \\(a_0\\) i \\(b_0\\). U \\(i\\)-tom delu trke, trka\u010di treba da stignu od svoje trenutne pozicije, do pozicija \\(a_i\\) i \\(b_i\\). Ra\u010duna se da su pre\u0161li \\(i\\)-ti deo kada se na\u0111u na pozicijama \\(a_i\\) i \\(b_i\\) u nekom rasporedu (nije bitno koji igra\u010d stoji na kojoj od dve pozicije). Kada se trenutni deo zavr\u0161i, slede\u0107i odmah otpo\u010dinje i takmi\u010dari kre\u0107u sa trenutnih pozicija ka novim ciljevima. Trka se zavr\u0161ava kada se zavr\u0161i \\(N-1\\)-vi deo trke.</p> <p>Kako je trka jako neizvesna, Zanatlijama je potrebna va\u0161a pomo\u0107. Na vama je da odredite najmanje mogu\u0107e vreme da bi zavr\u0161ili trku.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza se nalazi prirodan broj \\(N\\), du\u017eina nizova \\(a\\) i \\(b\\). U svakom narednom redu se nalaze po dva prirodna broja \\(a_i\\) i \\(b_i\\), koji opisuju pozicije ciljeva za \\(i\\)-ti deo trke.</p>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati jedan broj: najmanje vreme potrebno da bi zavr\u0161ili trku.</p>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^{5}\\)</li> <li>\\(-10^9\\le a_i,b_i \\le10^9\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(20\\) poena: \\(N \\leq 20\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(a_i=b_i\\) va\u017ei za svako \\(0\\le i\\le N-1\\).</li> <li>U test primerima vrednim \\(15\\) poena: \\(N \\leq 1000\\)</li> <li>U test primerima vrednim \\(45\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 5\n6 2\n3 7\n8 4\n5 8\n</code></pre>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Za prva \\(3\\) dela trke, svaki igra\u010d treba da se pomeri jedno mesto udesno. U poslednjem delu, prvi igra\u010d treba da se pomeri jedno mesto udesno (\\(4\\rightarrow5\\)), dok drugi treba da ostane na svojoj poziciji \\(8\\).</p>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#nleq-20","title":"\\(N\\leq 20\\)","text":"<p>Mo\u017eemo da fiksiramo po svih \\(2^n\\) kombinacija, na koji cilj ide koji trka\u010d. Zatim za svaku fazu vidimo vreme koje je potrebno kao maksimum od dve distance koji trka\u010di treba da pre\u0111u.</p>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#a_ib_i","title":"\\(a_i=b_i\\)","text":"<p>U ovom slu\u010daju oboje pra te istu jedinstvenu putanju i mi nemamo nikakvu odluku da pravimo. Samo pro\u0111emo kroz niz destinacija i sumiramo distance susednih.</p>"},{"location":"takprog/2020_2021/kv3/02_gejm_sou/#kompletno-resenje","title":"Kompletno re\u0161enje","text":"<p>Ono \u0161to je klju\u010dno primetiti u ovom zadatku je da su nama trka\u010di sasvim simetri\u010dni u svakoj fazi. U prevodu nije bitno koji je igra\u010d na \\(a_i\\), a koji na \\(b_i\\),  samo da treba da stignu na pozicije \\(a_{i+1}\\) i \\(b_{i+1}\\) u nekom poretku. To zna\u010di zapravo da u svakoj fazi trke imamo \\(2\\) mogu\u0107nosti: onog na poziciji \\(a_i\\) \u0161aljemo na ili poziciju \\(a_{i+1}\\) ili poziciju \\(b_{i+1}\\). Za obe ove mogu\u0107nosti mo\u017eemo izra\u010dunati vreme potrebno i samo prosumirati minimume po svim fazama.</p> 02_gejm_sou.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 100007\nusing namespace std;\nlong long a[MAXN],b[MAXN];\nint main()\n{\n    int n;\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++) scanf(\"%lld%lld\",&amp;a[i],&amp;b[i]);\n    long long sol=0;\n    for(int i=1;i&lt;n;i++) sol+=min(max(abs(a[i]-a[i-1]),abs(b[i]-b[i-1])),max(abs(a[i]-b[i-1]),abs(b[i]-a[i-1])));\n    printf(\"%lld\",sol);\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/03_karte2/","title":"3 - Karte 2","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 256MB <p>Koca se setio da, kao \u0161to je obi\u010daj, iza ba\u0161tenskog rekvizita koji je dobio na poklon od drugara dr\u017ei \u0161pil karata. Ovaj \u0161pil je pomalo neobi\u010dan, i sastoji se od \\(N\\) karata obele\u017eenih prirodnim brojevima \\(A_1, A_2, \\dots, A_N\\).</p> <p>Odlu\u010dio je da sa drugovima igra slede\u0107u igru:</p> <ul> <li>Koca, kao prvi igra\u010d, uzima koliko god \u017eeli karata sa vrha \u0161pila (a barem jednu). Za broj poena koji je osvojio, \\(P_1\\), uzima se zbir brojeva na kartama koje je uzeo.</li> <li>Ukoliko je prebacio granicu \\(K\\), odnosno \\(P_1 &gt; K\\), Koca gubi igru.</li> <li>U suprotnom, protivnik uzima koliko god \u017eeli karata sa vrha ostatka \u0161pila (mo\u017ee i nijednu), i dobija \\(P_2\\) poena, koliko iznosi zbir karata koje je uzeo.</li> <li>Ukoliko je protivnik prebacio granicu, odnosno \\(P_2 &gt; K\\), Koca pobe\u0111uje.</li> <li>U suprotnom, pobe\u0111uje onaj igra\u010d koji ima vi\u0161e poena. Ukoliko \\(P_1 = P_2\\), pobe\u0111uje Koca.</li> </ul> <p>Koca ne planira da prome\u0161a \u0161pil, tako da \u0107e karte koje uzimaju on i protivnik biti izvu\u010dene redom: \\(A_1\\), pa \\(A_2\\), i tako dalje, do \\(A_N\\). Zanima ga da li postoji broj karata koji treba da izvu\u010de tako da sigurno pobe\u0111uje, ma koliko karata njegov protivnik odlu\u010di da izvu\u010de.</p> <p>Koca je veoma radoznao, tako da u svakom primeru, umesto za jednu situaciju, treba dati odgovor za \\(T\\) razli\u010ditih situacija (svaka situacija je novi \u0161pil karata).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Dimitrije Erdeljan Mladen Puzi\u0107 Aleksandar Zlateski"},{"location":"takprog/2020_2021/kv3/03_karte2/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza nalazi se jedan ceo broj \\(T\\): broj situacija za koje je potrebno odrediti da li Koca sigurno pobe\u0111uje. U nastavku ulaza je dato \\(T\\) opisa situacija, gde se svaka sastoji iz dva reda:</p> <p>U prvom redu opisa nalaze se dva cela broja \\(N\\) i \\(K\\): broj karata u \u0161pilu i granica u poenima koju igra\u010di ne smeju prema\u0161iti.</p> <p>U drugom redu opisa nalazi se \\(N\\) celih brojeva \\(A_1, A_2, \\dots, A_N\\): brojevi na kartama, redom od prve do poslednje u \u0161pilu.</p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaku od \\(T\\) situacija (redom) ispisati po jedan red izlaza: <code>da</code> ako Koca mo\u017ee da odabere broj karata koje izvla\u010di tako da sigurno pobedi, i <code>ne</code> u suprotnom.</p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 20\\)</li> <li>\\(1 \\leq N \\leq 100000\\)</li> <li>\\(1 \\leq K \\leq 10^9\\)</li> <li>\\(1 \\leq A_i \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(?\\) poena: \\(1 \\leq N \\leq 1000\\).</li> <li>U test primerima vrednim \\(?\\) poena: unutar svake situacije, sve karte su obele\u017eene istim brojem.</li> <li>U test primerima vrednim \\(?\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv3/03_karte2/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv3/03_karte2/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv3/03_karte2/#ulaz","title":"Ulaz","text":"<pre><code>2\n5 10\n2 5 3 4 8\n2 1000\n100 200\n</code></pre>"},{"location":"takprog/2020_2021/kv3/03_karte2/#izlaz","title":"Izlaz","text":"<pre><code>da\nda\n</code></pre>"},{"location":"takprog/2020_2021/kv3/03_karte2/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvoj situaciji, Koca mo\u017ee da uzme prve dve karte i osvoji \\(7\\) poena. To je manje od \\(10\\), tako da je na potezu njegov protivnik, koji \u0107e ako izvu\u010de manje od tri karte imati manje ili isto poena kao Koca, a ako izvu\u010de sve tri imati vi\u0161e od dozvoljenih \\(10\\). Dakle, Koca sigurno pobe\u0111uje.</p> <p>U drugoj situaciji, Koca mo\u017ee da uzme sve karte i time sigurno ima vi\u0161e poena od protivnika.</p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv3/03_karte2/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n5 30\n11 12 13 14 15\n</code></pre>"},{"location":"takprog/2020_2021/kv3/03_karte2/#izlaz_1","title":"Izlaz","text":"<pre><code>ne\n</code></pre>"},{"location":"takprog/2020_2021/kv3/03_karte2/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Koca mo\u017ee da izvu\u010de najvi\u0161e dve karte bez prema\u0161ivanja \\(30\\) poena. \u0160ta god da uradi, protivnik mo\u017ee da uzme naredne dve karte i pobedi.</p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#resenje-za-1-leq-n-leq-1000","title":"Re\u0161enje za \\(1 \\leq N \\leq 1000\\):","text":"<p>Po\u0161to je \\(N\\) malo, \\(O(N^2)\\) re\u0161enje je dovoljno brzo. Mo\u017eemo fiksirati koliko prvih karata uzima Koca, osvojiv\u0161i \\(P_1\\) poena (naravno, tako da \\(P_1 \\leq K\\)). Nakon toga idemo kroz preostale karte i gledamo da li je mogu\u0107e izabrati nekoliko slede\u0107ih karata sa zbirom brojeva \\(P_2\\) tako da \\(P_1 &lt; P_2\\) i \\(P_2 \\leq K\\). Ako je to nemogu\u0107e, onda Koca sigurno pobe\u0111uje ako izvu\u010de taj broj karata. </p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#resenje-kad-su-sve-karte-obelezene-istim-brojem","title":"Re\u0161enje kad su sve karte obele\u017eene istim brojem:","text":"<p>Ozna\u010dimo taj broj sa \\(A\\). Dakle, ako Koca uzme \\(k\\) karata, onda \u0107e va\u017eiti \\(P_1 = k\\cdot A\\). Kako bi njegov protivnik osvojio vi\u0161e od \\(P_1\\) poena, mora uzeti vi\u0161e od \\(k\\) karata, odnosno makar \\(k+1\\). Ako va\u017ei \\((k+1)\\cdot A &gt; K\\), onda ako uzme vi\u0161e od \\(k\\) karata, prebaci\u0107e granicu. Samim tim nema pobedni\u010dki potez, pa Koca uvek pobe\u0111uje (ukoliko \\(k\\cdot A \\leq K\\)). Ako ipak va\u017ei \\((k+1)\\cdot A \\leq K\\) i njegov protivnik zaista mo\u017ee da uzme \\(k+1\\) karata (ostalo je dovoljno karata u \u0161pilu), onda protivnik ima pobedni\u010dku strategiju i Koca ne sme da uzme \\(k\\) karata ako \u017eeli da pobedi (a \u017eeli).</p>"},{"location":"takprog/2020_2021/kv3/03_karte2/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Sli\u010dno re\u0161enju kad \\(1 \\leq N \\leq 1000\\), fiksiramo koliko prvih karata uzima Koca, osvojiv\u0161i \\(P_1\\) poena. Sada treba da proverimo da li postoji prefiks preostalih karata tako da mu je zbir \\(P_2\\) ve\u0107i od \\(P_1\\), a nije ve\u0107i od \\(K\\). Po\u0161to se na kartama nalaze isklju\u010divo pozitivni brojevi, \u0161to vi\u0161e karata protivnik izvu\u010de, to \u0107e zbir biti ve\u0107i. Na\u0111imo koriste\u0107i binarnu pretragu najmanji prefiks ostatka \u0161pila \u010diji je zbir ve\u0107i od \\(P_1\\) (zbir prefiksa mo\u017eemo na\u0107i koriste\u0107i prefiksne sume). Nijedan manji prefiks ne mo\u017ee dovesti do pobede protivnika, jer ne zadovoljava uslov \\(P_1 &lt; P_2\\). Za taj prefiks proverimo da li je zbir ve\u0107i od \\(K\\). Ako jeste, svi ve\u0107i prefiksi su tako\u0111e ve\u0107i od \\(K\\), pa samim tim ne postoji potez kojim protivnik pobe\u0111uje, pa je odgovor da. Ako mu zbir nije ve\u0107i od \\(K\\), on zadovoljava oba uslova, pa je samim tim i pobedni\u010dki potez za protivnika. Onda moramo probati slede\u0107i mogu\u0107 Kocin potez, dok ne proverimo sve mogu\u0107e. Vremenska slo\u017eenost: \\(O(NlogN)\\), memorijska slo\u017eenost: \\(O(N)\\).</p> 03_karte2.cpp<pre><code>#include &lt;cstdio&gt;\n\nconst int N = 100005;\nint a[N];\n\nvoid single_test() {\n    int n, k;\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;a[i]);\n\n    int j = 1, first = 0, second = 0;\n    bool can_win = false;\n\n    for(int i = 0; i &lt; n; i++) {\n        first += a[i];\n        if(first &gt; k) break;\n\n        if(i &gt; 0) second -= a[i];\n        while(j &lt; n &amp;&amp; second &lt;= first) {\n            second += a[j++];\n        }\n\n        if(!(second &gt; first &amp;&amp; second &lt;= k)) {\n            can_win = true;\n            break;\n        }\n    }\n\n    printf(\"%s\\n\", can_win ? \"da\" : \"ne\");\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &amp;t);\n    while(t--) single_test();\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/04_pitanja/","title":"4 - Pitanja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 1024MB <p>Poznato je da profesori programiranja ne vole da odgovaraju na pitanja studentima. Oni od svojih studenata o\u010dekuju da sami naprave razumnu pretpostavku o svemu \u0161to nije jasno definisano u zadatku koji su dobili, pa su zato odlu\u010dili da odgovore samo na ona pitanja studenata koja pristignu onim danima kada za to budu imali vremena.</p> <p>Profesori su zbog toga odlu\u010dili da oslobode svoj raspored svakog \\(k\\)-tog dana po\u010dev od dana \\(x\\) pa sve do dana \\(y\\). Da bi izabrali ove brojeve potrebno je da za \\(Q\\) upita oblika \\(x\\), \\(y\\) i \\(k\\) odrede na koliko pitanja treba odgovoriti u tom slu\u010daju. Po\u0161to su zbog previ\u0161e posla profesori zaboravili koliko dana ima u godini ovi brojevi mogu biti jako veliki.</p> <p>Zbog toga su ovaj zadatak ostavili vama kako bi imali dovoljno vremena da odgovore na pitanja studenata.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Igor Pavlovi\u0107 Igor Pavlovi\u0107 Aleksa Plav\u0161i\u0107 Aleksandar Zlateski <p>Defini\u0161imo sa \\(d_i = \\frac{y_i - x_i}{k_i} + 1\\). U \\(i\\)-tom upitu je potrebno izra\u010dunati sumu ta\u010dno \\(d_i\\) brojeva.</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se broj \\(N\\) - broj dana kada studenti mogu postavljati pitanja. U drugoj liniji nalazi se \\(N\\) celih brojeva, niz \\(A_{1},A_{2},\\ldots,A_{N}\\) - o\u010dekivani broj pitanja svakog dana. U tre\u0107oj liniji nalazi se ceo broj \\(Q\\) - broj upita na koje treba odgovoriti. U narednih \\(Q\\) linija slede brojevi \\(x_{i}\\), \\(y_{i}\\) i \\(k_{i}\\) - granice intervala i korak tog upita, (pri \u010demu \\(k_{i}\\) uvek deli \\(y_{i}-x_{i}\\)).</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(Q\\) celih brojeva - za svaki upit, u novom redu, ispisati ukupan broj pitnja na koje \u0107e biti odgovoreno.</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 200000\\)</li> <li>\\(1 \\leq Q \\leq 200000\\)</li> <li>\\(1 \\leq A_{i} \\leq 5*10^{10}\\)</li> <li>\\(1 \\leq k_{i} \\leq N\\)</li> <li>\\(1 \\leq x_{i} \\leq y_{i} \\leq N\\)</li> <li>\\(k_{i}\\) deli \\(y_{i}-x_{i}\\)</li> </ul> <p>Test primeri su podeljeni u \\(4\\) disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(8\\) poena: \\(A_{i}=i\\)</li> <li>U test primerima vrednim \\(12\\) poena: \\(A_{i}=i^2\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(N,Q \\leq 10000\\)</li> <li>U test primerima vrednim \\(60\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv3/04_pitanja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv3/04_pitanja/#ulaz","title":"Ulaz","text":"<pre><code>6\n17 31 14 23 9 27\n5\n2 6 2\n2 5 3\n3 5 1\n3 3 5\n1 3 2\n</code></pre>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#izlaz","title":"Izlaz","text":"<pre><code>81\n40\n46\n14\n31\n</code></pre>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#objasnjenje","title":"Obja\u0161njenje","text":"<p>\\(A_2 + A_4 + A_6 = 81\\) \\(A_2 + A_5 = 40\\) \\(A_ 3 + A_4 + A_5 = 46\\) \\(A_3 = 14\\) \\(A_1 + A_3 = 31\\)</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/kv3/04_pitanja/#ulaz_1","title":"Ulaz","text":"<pre><code>10\n1 2 3 4 5 6 7 8 9 10\n5\n2 8 3\n4 9 1\n1 9 2\n5 10 5\n1 9 8\n</code></pre>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#izlaz_1","title":"Izlaz","text":"<pre><code>15\n39\n25\n15\n10\n</code></pre>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Kao pomo\u0107 potrebno je koristiti formulu za sumu prvih \\(n\\) prirodnih brojeva \\(\\sum_{i=1}^{n} i= \\frac{n\\cdot(n+1)}{2}\\)</p> <p>Re\u0161enje za \\(i\\)-ti upit mo\u017eemo zapisati u oblikz \\(\\sum_{j = 0}^{d_i -1} (x_i + j \\cdot k_i) = \\sum_{j = 0}^{d_i-1} x_i + k_i \\cdot \\sum_{j = 0}^{d_i-1} j =  d_i \\cdot x_i + k_i \\cdot \\frac{(d_i - 1)\\cdot d_i}{2}\\). Poslednje napisanu formulu mo\u017eemo izra\u010dunati u vremenskoj i memorijskoj slo\u017eenosti \\(O(1)\\) po upitu.</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Pored formule iz prvog podzadatka potrebno je iskoristiti formulu za sumu prvih \\(n\\) kvadrata prirodnih brojeva  \\(\\sum_{i=1}^{n} i^2= \\frac{n \\cdot(n+1) \\cdot(2n+1)}{6}\\)</p> <p>Na sli\u010dan na\u010din mo\u017eemo re\u0161iti i drugi podzadatak, uz malo ve\u0107u manipulaciju sa matemati\u010dkim formulama. Tako da re\u0161enje mo\u017eemo predstaviti u obliku \\(\\sum_{j = 0}^{d_i -1} (x_i + j\\cdot k_i)^2 = \\sum_{j = 0}^{d_i -1} (x_i^2 + 2\\cdot x_i \\cdot k_i \\cdot j + (j\\cdot k_i)^2) = \\sum_{j = 0}^{d_i -1} x_i^2 + 2\\cdot x_i \\cdot k_i \\cdot \\sum_{j = 0}^{d_i -1} j + k_i^2 \\cdot \\sum_{j = 0}^{d_i -1} j^2 = d_i \\cdot x_i^2 + 2 \\cdot x_i \\cdot k_i \\cdot \\frac{d_i\\cdot (d_i - 1)}{2} + k_i^2 \\cdot \\frac{(d_i -1)\\cdot d_i \\cdot (2 \\cdot d_i - 1)}{6}\\). Sli\u010dno kao i u prvom podzadatku, navedeni izraz mo\u017eemo izra\u010dunati u vremenskoj i memorijskoj slo\u017eenosti \\(O(1)\\) po upitu.</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#treci-podzadatak","title":"Tre\u0107i podzadatak:","text":"<p>U \\(i\\)-tom upitu mo\u017eemo pro\u0107i kroz svih \\(d_i\\) brojeva i izra\u010dunati njihovu sumu. U najgorem slu\u010daju za na\u0161 program potrebno je \\(N\\) iteracija po upitu (na primer \\(x_i=1, y_i=N, k_i=1\\)). Vremenska slo\u017eenost opisanog algoritma je \\(O(NQ)\\).</p>"},{"location":"takprog/2020_2021/kv3/04_pitanja/#cetvrti-podzadatak","title":"\u010cetvrti podzadatak:","text":"<p>Algoritam opisan u tre\u0107em podzadatku je efiksan za upite \u010dija je vrednost \\(d_i\\) relativno mala. Postavi\u0107emo granicu \\(B\\), i svaki upit za koji va\u017ei \\(d_i \\leq B\\) obradi\u0107emo kao i u tre\u0107em podzadatku. U slu\u010daju \\(d_i &gt; B\\), vrednost broja \\(k\\) ne mo\u017ee biti ve\u0107a od \\(\\frac{N}{B}\\). Napravi\u0107emo matricu \\(D\\) dimenzije \\(\\frac{N}{B} \\times N\\), gde vrednost \\(D[i][j]\\) predstavlja \\(\\sum A_x\\) tako da va\u017ei \\(x \\mod i = j \\mod i\\) i \\(x\\leq j\\). Opisanu matricu mo\u017eemo izra\u010dunati u vremenskoj slo\u017eenosti \\(O(\\frac{N^2}{B})\\), sli\u010dno postupku prera\u010dunavanja prefiksnih suma. Kada izra\u010dunamo matricu \\(D\\) odgovor na upit \\((x_i, y_i, k_i)\\), za koji va\u017ei \\(d_i &gt; B\\) mo\u017eemo dobiti kao \\(D[k_i][y_i] - D[k_i][x_i] + A_{x_i}\\) y vremenskoj slo\u017eenosti \\(O(1)\\). Kona\u010dan algoritam koji kombinuje prethodna dva u zavisnosti od vrednosti \\(d_i\\) ima vremensku slo\u017eenost \\(O(\\frac{N^2}{B} + Q \\cdot B)\\) i memorijsku \\(O(\\frac{N^2}{B})\\). Ako konstantu \\(B\\) postavimo na vrednost \\(B\\)~\\(\\sqrt N\\) dobili smo algoritam vremenske slo\u017eenosti \\(O(N \\sqrt N + Q \\sqrt N)\\) i memorijske \\(O(N\\sqrt N)\\).</p> <p>Primetiti da memorijsku slo\u017eenost algoritma mo\u017eemo pobolj\u0161ati ako upite za koje va\u017ei \\(d_i &gt; B\\) obra\u0111ujemo u grupama po istoj vrednosti \\(k_i\\) (npr. prvo obradimo sve upite za koje va\u017ei \\(k_i = 1\\), zatim \\(k_i = 2\\) itd). U ovom slu\u010daju je dovoljno pamtiti samo jedan niz \\(D\\) koji bi se nakon svake grupe jednakih resetovao na \\(0\\). Postoje i mnogi drugi na\u010dini optimizacije memorije na linearnu, me\u0111utim to se ne zahteva za maksimalan broj bodova u zadatku.</p> 04_pitanja.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxN 200005\n#define maxQ 200005\n\nusing namespace std;\n\nstruct upit{\nlong long x,y,k,id;\n};\n\nupit u[maxQ],tmp;\nlong long n,q,i,a[maxN],x,y,k,s[maxN],ans[maxQ];\nvector&lt;int&gt; v;\n\nbool poredi(upit a,upit b){\nreturn a.k&lt;b.k;\n}\n\nvoid resetuj(){\nfor(int i=0;i&lt;v.size();i++) s[v[i]]=-1;\nv.clear();\n}\n\nlong long resi(int x,int k){\nif(s[x]!=-1) return s[x];\nv.push_back(x);\nif(x&lt;k) s[x]=a[x];\nelse s[x]=a[x]+resi(x-k,k);\nreturn s[x];\n}\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);\n    //ifstream fin(\"27.in.txt\");\n    //ofstream fout(\"27.out.txt\");\n    cin&gt;&gt;n;\n    for(i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n    cin&gt;&gt;q;\n    for(i=0;i&lt;q;i++){\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;\n        tmp.x=x-1;\n        tmp.y=y-1;\n        tmp.k=k;\n        tmp.id=i;\n        u[i]=tmp;\n    }\n    for(i=0;i&lt;n;i++) s[i]=-1;\n    sort(u,u+q,poredi);\n    for(i=0;i&lt;q;i++){\n        if(i!=0 &amp;&amp; u[i].k!=u[i-1].k) resetuj();\n        ans[u[i].id]=resi(u[i].y,u[i].k)-resi(u[i].x,u[i].k)+a[u[i].x];\n    }\n    for(i=0;i&lt;q-1;i++) cout&lt;&lt;ans[i]&lt;&lt;\"\\n\";\n    cout&lt;&lt;ans[q-1];\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/","title":"5 - Novogodi\u0161nje stablo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Jovan je odlu\u010dio da okiti stablo koje mu raste u dvori\u0161tu za novu godinu. Jovanovo stablo ima \\(N\\) \u010dvorova i \\(N-1\\) granu, tako da se od svakog \u010dvora mo\u017ee do\u0107i do svakog drugog na jedinstven na\u010din kori\u0161\u0107enjem nekog skupa grana. Od tih \\(N\\) \u010dvorova, \u010dvor numerisan brojem \\(1\\) je poseban, i njega nazivamo koren stabla. Podstablo \u010dvora \\(u\\) je skup svih \u010dvorova \\(v\\), takvih da \\(u\\) pripada skupu \u010dvorova koji su na putu izme\u0111u \u010dvora \\(v\\) i korena stabla. Specijalno, \u010dvor \\(u\\) pripada podstablu \u010dvora \\(u\\).</p> <p>Na \u010dvoru \\(i\\) visi ukras boje \\(b_i\\). Raznobojnost stabla defini\u0161emo kao broj razli\u010ditih komponenti iste boje. Dva \u010dvora pripadaju istoj komponenti ukoliko je mogu\u0107e do\u0107i od jednog do drugog tako da svi \u010dvorovi na tom putu imaju istu boju (uklju\u010duju\u0107i i po\u010detni i krajnji). </p> <p>Jovan jo\u0161 uvek nije siguran kako da okiti stablo. On \u0107e na stablu izvr\u0161iti \\(Q\\) promena oblika:</p> <p>\\(u\\) \\(c\\) - Jovan \u0107e zameniti sve ukrase na \u010dvorovima koji pripadaju podstablu \u010dvora \\(u\\) sa ukrasima boje \\(c\\).</p> <p>Pomozite Jovanu da okiti stablo i ispi\u0161ite raznobojnost stabla posle svake izmene.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Mladen Puzi\u0107 Tadija \u0160ebez <p>Nazovimo roditeljem \u010dvora \\(x\\) (koji nije koren) prvi \u010dvor na koji nai\u0111emo kada od \\(x\\) krenemo ka korenu (\u010dvoru \\(1\\)). Najbitniji zaklju\u010dak je onda da je broj komponenti iste boje jednak broju \u010dvorova koji su druga\u010dije obojeni od svog roditelja, plus jedan. Ovakve \u010dvorove \u0107emo od sad zvati lepi \u010dvorovi. Ovo va\u017ei, jer ako za svaku komponentu uzmemo \u010dvor koji je najbli\u017ee korenu, znamo da je njegov roditelj druge boje. Samim tim postoji bijekcija izme\u0111u broja komponenti i lepih \u010dvorova (plus jedan dodajemo zbog komponente u kojoj se nalazi sam koren).</p> <p>Na po\u010detku, potrebno je da jednim prolaskom kroz stablo na\u0111emo roditelja svakom \u010dvoru (DFS obilaskom iz korena) i izbrojimo koliko na po\u010detku ima lepih \u010dvorova. Sada posmatrajmo \u0161ta se desi kada podstablo \u010dvora \\(u\\) obojimo bojom \\(c\\). Svi lepi \u010dvorovi unutar strogog podstabla \\(u\\) (podstabla ne ra\u010dunaju\u0107i \u010dvor \\(u\\)) nestaju (jer svi \u010dvorovi u tom podstablu sad imaju istu boju), a sam \u010dvor \\(u\\) je lep \u010dvor ukoliko je \\(c\\) razli\u010dito od boje njegovog roditelja. </p> <p>Skup lepih \u010dvorova mo\u017eemo odr\u017eavati na primer koriste\u0107i binarno pretra\u017eivo stablo (odnosno set u C++). Tako\u0111e se mo\u017ee koristiti segmentno stablo sa lenjom propagacijom. Za \u010duvanje podataka o tome koji \u010dvor je koje boje moramo koristiti segmentno stablo sa lenjom propagacijom (ili sli\u010dnu strukturu). Ovo \u0107emo raditi nad DFS obilaskom stabla, odnosno spljo\u0161tenim stablom. Krajnja vremenska slo\u017eenost je \\(O(N+QlogN)\\) ili \\(O((N+Q)logN))\\), u zavisnosti od implementacije.</p> 05_novogodisnje_stablo.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\nusing namespace std;\nint n,q;\nint col[4*maxn];\nint c[maxn];\nint par[maxn];\nint lb[maxn];\nint rb[maxn];\nvector&lt;int&gt; a[maxn];\nint ord[maxn];\nint pos[maxn];\nint seg[4*maxn];\nint laz[4*maxn];\nint cv=1;\nvoid dfs(int u,int p) {\n    pos[u]=cv;\n    ord[cv]=u;\n    lb[u]=rb[u]=cv;\n    cv++;\n    for(int v:a[u]) {\n        if(v!=p) {\n            par[v]=u;\n            dfs(v,u);\n            lb[u]=min(lb[u],lb[v]);\n            rb[u]=max(rb[u],rb[v]);\n        }\n    }\n}\nvoid propagate_color(int id,int l,int r) {\n    if(col[id]!=0 &amp;&amp; l!=r) {\n        col[id*2+1]=col[id*2+2]=col[id];\n        col[id]=0;\n    }\n}\nint get_color(int id,int l,int r,int x) {\n    propagate_color(id,l,r);\n    if(l==r) return col[id];\n    int m=(l+r)/2;\n    if(x&lt;=m) return get_color(id*2+1,l,m,x);\n    else return get_color(id*2+2,m+1,r,x);\n}\nvoid set_color(int id,int l,int r,int x,int y,int v) {\n    propagate_color(id,l,r);\n    if(y&lt;l || r&lt;x) return;\n    if(x&lt;=l &amp;&amp; r&lt;=y) {\n        col[id]=v;\n        propagate_color(id,l,r);\n        return;\n    }\n    int m=(l+r)/2;\n    set_color(id*2+1,l,m,x,y,v);\n    set_color(id*2+2,m+1,r,x,y,v);\n}\nvoid propagate_val(int id,int l,int r) {\n    if(laz[id]==-1) return;\n    if(l!=r) {\n        laz[id*2+1]=laz[id*2+2]=laz[id];\n    }\n    seg[id]=laz[id]*(r-l+1);\n    laz[id]=-1;\n}\nvoid set_val(int id,int l,int r,int x,int y,int v) {\n    propagate_val(id,l,r);\n    if(y&lt;l || r&lt;x) return;\n    if(x&lt;=l &amp;&amp; r&lt;=y) {\n        laz[id]=v;\n        propagate_val(id,l,r);\n        return;\n    }\n    int m=(l+r)/2;\n    set_val(id*2+1,l,m,x,y,v);\n    set_val(id*2+2,m+1,r,x,y,v);\n    seg[id]=seg[id*2+1]+seg[id*2+2];\n}\nvoid init_seg(int id,int l,int r) {\n    laz[id]=-1;\n    if(l==r) {\n        col[id]=c[ord[l]];\n        if(ord[l]!=1) {\n            //cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;ord[l]&lt;&lt;\" \"&lt;&lt;c[par[ord[l]]]&lt;&lt;\" \"&lt;&lt;c[ord[l]]&lt;&lt;endl;\n            if(c[par[ord[l]]]!=c[ord[l]]) seg[id]=1;\n        }\n        return;\n    }\n    int m=(l+r)/2;\n    init_seg(id*2+1,l,m);\n    init_seg(id*2+2,m+1,r);\n    seg[id]=seg[id*2+1]+seg[id*2+2];\n}\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;q);\n    for(int i=0;i&lt;n-1;i++) {\n        int u,v;\n        scanf(\"%d %d\",&amp;u,&amp;v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int u=1;u&lt;=n;u++) {\n        scanf(\"%d\",&amp;c[u]);\n    }\n    dfs(1,-1);\n    init_seg(0,1,n);\n    while(q--) {\n        int u,c;\n        scanf(\"%d %d\",&amp;u,&amp;c);\n        set_color(0,1,n,lb[u],rb[u],c);\n        set_val(0,1,n,lb[u],rb[u],0);\n        if(u!=1) {\n            int v=par[u];\n            if(get_color(0,1,n,pos[u])!=get_color(0,1,n,pos[v])) {\n                set_val(0,1,n,pos[u],pos[u],1);\n            }\n        }\n        printf(\"%d\\n\",seg[0]+1);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu nalaze se brojevi \\(N\\) i \\(Q\\). U narednih \\(N-1\\) linija, nalaze se po dva broja \\(u\\) i \\(v\\), koji predstavljaju grane stabla. U narednoj liniji, nalazi se \\(N\\) brojeva, od kojih je \\(i\\)-ti broj \\(b_i\\) - boja ukrasa koji visi na \u010dvoru \\(i\\). U poslednjih \\(Q\\) linija nalaze se po dva broja \\(u\\) i \\(c\\), koji predstavljaju izmene na stablu.</p>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaku od \\(Q\\) izmena ispisati raznobojnost stabla posle te izmene.</p>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 2 \\cdot 10^{5}\\).</li> <li>\\(1 \\leq b_i, u, c \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 5 poena: \\(N, Q \\leq 10^3\\).</li> <li>U test primerima vrednim 15 poena: \\(c = 1\\), tj. svaka izmena ima istu boju.</li> <li>U test primerima vrednim 15 poena: Postoji grana izme\u0111u \\(i\\) i \\(i-1\\) za svako \\(2 \\leq i \\leq N\\).</li> <li>U test primerima vrednim 20 poena: Postoji grana izme\u0111u \\(i\\) i \\(\\lfloor \\frac{i}{2} \\rfloor\\) za svako \\(2 \\leq i \\leq N\\).</li> <li>U test primerima vrednim 45 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#ulaz","title":"Ulaz","text":"<pre><code>6 4\n1 2\n1 3\n2 4\n2 5\n3 6\n1 2 1 1 3 3\n4 3\n4 2\n1 1\n2 2\n</code></pre>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#izlaz","title":"Izlaz","text":"<pre><code>5\n4\n1\n2\n</code></pre>"},{"location":"takprog/2020_2021/kv3/05_novogodisnje_stablo/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Nakon prve izmene, istobojne komponente se sastoje od \u010dvorova: \\(\\{1,3\\},\\{2\\},\\{4\\},\\{5\\},\\{6\\}\\).</p> <p>Nakon druge izmene, istobojne komponente se sastoje od \u010dvorova: \\(\\{1,3\\},\\{2,4\\},\\{5\\},\\{6\\}\\).</p> <p>Nakon tre\u0107e izmene, istobojne komponente se sastoje od \u010dvorova: \\(\\{1,2,3,4,5,6\\}\\).</p> <p>Nakon \u010detvrte izmene, istobojne komponente se sastoje od \u010dvorova: \\(\\{1,3,6\\},\\{2,4,5\\}\\).</p>"},{"location":"takprog/2020_2021/okr/01_takmicar/","title":"B1 - Takmi\u010dar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Mladi Ivan je odlu\u010dio da postane ozbiljan takmi\u010dar iz programiranja i njegov plan da to ostvari se sastoji iz toga da imitira likove iz tekstova zadataka sa takmi\u010denja. Ba\u0161 zbog toga je za ro\u0111endan od roditelja tra\u017eio niz prirodnih brojeva du\u017eine \\(N\\), a po\u0161to je dobar de\u010dak i vredan u\u010denik, dobio je ba\u0161 takav niz, niz \\(A_1, A_2, ..., A_N\\).  </p> <p>Uz niz je dobio i \u0161pil od \\(Q\\) kartica. Postoje dva tipa kartica: </p> <ul> <li>Na prvom tipu kartice nalaze se \u010detiri broja: \\(1\\) \\(l\\) \\(r\\) \\(x\\). Kada se kartica ovog tipa iskoristi elementi niza sa indeksima od \\(l\\) do \\(r\\) se promene za \\(x\\) (ako je \\(x\\) pozitivno onda se pove\u0107aju, ako je negativno onda se smanje), tj. element \\(A_l\\) postaje \\(A_l + x\\), element \\(A_{l+1}\\) postaje \\(A_{l+1} + x\\) i tako do \\(A_r\\) koji postaje \\(A_r + x\\).</li> <li>Na drugom tipu kartice nalazi se samo broj \\(2\\). Kada se kartica ovog tipa iskoristi, Ivan zapisuje trenutni zbir svih elemenata niza na papir</li> </ul> <p>Za svaku karticu, vi znate brojeve koji su zapisani na njoj.  Ivan se igra tako da iskoristi svaku karticu ta\u010dno jednom, ali mo\u017ee ih iskoristiti u bilo kom redosledu. Njegova \u017eelja je da ukupan zbir svih brojeva koji su zapisani na papir (usled kori\u0161\u0107enja kartice drugog tipa) bude \u0161to je ve\u0107i mogu\u0107. Po\u0161to je jo\u0161 uvek takmi\u010dar u treningu, zamolio je vas, iskusne takmi\u010dare, da mu pomognete da to uradi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Milojevi\u0107"},{"location":"takprog/2020_2021/okr/01_takmicar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza se nalazi prirodan broj \\(N\\) -- du\u017eina niza.  U drugom redu se nalazi niz \\(N\\) prirodnih brojeva \\(A_1, A_2, ...  ,A_N\\) -- po\u010detne vrednosti niza \\(A\\).  U tre\u0107em redu se nalazi prirodan broj \\(Q\\) -- broj kartica.  U narednih \\(Q\\) linija nalaze se opisi kartica: ukoliko red po\u010dinje sa \\(1\\), u pitanju je kartica prvog tipa i u istom redu slede prirodni brojevi \\(l\\), \\(r\\) i \\(x\\) tim redom; ukoliko red po\u010dinje sa \\(2\\), u pitanju je kartica drugog tipa.</p>"},{"location":"takprog/2020_2021/okr/01_takmicar/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati najve\u0107i mogu\u0107i zbir zapisanih brojeva. </p>"},{"location":"takprog/2020_2021/okr/01_takmicar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 2\\cdot10^5\\)</li> <li>\\(1 \\leq A_i \\leq 1000\\)</li> <li>Za kartice prvog tipa va\u017ei\u0107e \\(1 \\leq l \\leq r \\leq N\\) i \\(-1000 \\leq x \\leq 1000\\).</li> <li>Postoja\u0107e bar jedna kartica drugog tipa.</li> <li>Mogu\u0107e je da nakon kori\u0161\u0107enja nekih kartica prvog tipa elementi niza budu negativni ili ve\u0107i od \\(1000\\).</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: Za kartice prvog tipa va\u017ei\u0107e \\(x \\geq 1\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(N, Q\\leq 9\\).</li> <li>U test primerima vrednim \\(30\\) poena: \\(N, Q \\leq 5000\\).</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/01_takmicar/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/01_takmicar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/01_takmicar/#ulaz","title":"Ulaz","text":"<pre><code>5\n3 2 1 3 1\n3\n1 2 4 2\n2\n1 1 3 1\n</code></pre>"},{"location":"takprog/2020_2021/okr/01_takmicar/#izlaz","title":"Izlaz","text":"<pre><code>19\n</code></pre>"},{"location":"takprog/2020_2021/okr/01_takmicar/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Iskoristimo prvo karticu \\(1\\) \\(2\\) \\(4\\) \\(2\\), tada niz postaje \\(3\\) \\(4\\) \\(3\\) \\(5\\) \\(1\\). Nakon toga iskoristimo karticu \\(1\\) \\(1\\) \\(3\\) \\(1\\), tada niz postaje \\(4\\) \\(5\\) \\(4\\) \\(5\\) \\(1\\). Na kraju iskoristimo karticu \\(2\\), i na papir zapisujemo zbir \\(4+5+4+5+1=19\\).</p>"},{"location":"takprog/2020_2021/okr/01_takmicar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/okr/01_takmicar/#ulaz_1","title":"Ulaz","text":"<pre><code>7\n33 11 73 78 12 62 84\n5\n1 2 5 3\n2\n1 2 6 -5\n2\n1 1 7 1\n</code></pre>"},{"location":"takprog/2020_2021/okr/01_takmicar/#izlaz_1","title":"Izlaz","text":"<pre><code>744\n</code></pre>"},{"location":"takprog/2020_2021/okr/01_takmicar/#napomena","title":"Napomena","text":"<ul> <li>Zbog veli\u010dine brojeva, koristite 64-bitne tipove celih brojeva (npr. u C++ tip <code>long long</code>).</li> </ul>"},{"location":"takprog/2020_2021/okr/01_takmicar/#analiza","title":"Analiza","text":"<p>Da bi zbir odgovora na upite bio \u0161to ve\u0107i, potrebno je da suma elemenata niza bude \u0161to ve\u0107a. Suma elemenata je najve\u0107a onda kada elementi niza imaju najve\u0107u mogu\u0107u vrednost. Najve\u0107a mogu\u0107a vrednost se dobija nakon \u0161to se primene svi upiti tipa \\(1\\) u kojima se elementi niza uve\u0107avaju za neku pozitivnu vrednost. Zbog toga je potrebni prvo izvr\u0161iti upite tipa \\(1\\) kod kojih se vrednost elemenata uve\u0107avaju za pozitivvnu vrednost, a zatim sve upite tipa \\(2\\) i na kraju upite tipa \\(1\\) kod kojih se vrednosti elemenata uve\u0107avaju za negativnu vrednost.</p> <p>Ako je suma elemenata niza iznosila \\(S\\), onda nakon primene upita \\(1\\  l\\  r\\  x\\) suma elemenata niza iznosi </p> \\[ S_n = S + (r - l + 1) \\cdot x. \\] <p>Prema tome, potrebno je odrediti sumu svih elemenata nakon primene svih upita tipa \\(1\\) kod kojih se neki elementi uve\u0107avaju za neku pozitivnu vrednost (neka ta suma iznosi \\(S_m\\)) i broj upita tipa \\(2\\) (neka je to \\(n_2\\)). Tada \u0107e suma odgovora na upite iznoositi </p> \\[ n_2 \\cdot S_m. \\] <p>Lako se pokazuje da je slo\u017eenost algoritma \\(\\Theta(n+m)\\), gde je \\(n\\) broj elemenata u nizu, \\(m\\) ukupan broj upita. </p> 01_takmicar.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 200010\nusing namespace std;\nlong long A[MAXN], zbir;\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int N; cin &gt;&gt; N;\n    for(int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; A[i];\n        zbir += A[i];\n    }\n    int Q; cin &gt;&gt; Q;\n    long long cnt = 0, sum = 0;\n    while(Q--) {\n        int tip; cin &gt;&gt; tip;\n        if(tip == 1) {\n            int l, r;\n            long long x;\n            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n            if(x &gt; 0) sum += (r-l+1)*x;\n        } else {\n            cnt++;\n        }\n    }\n    cout &lt;&lt; (zbir+sum)*cnt;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/","title":"B2 - Lepa matrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Vera je instalirala novu igricu na svom novom modernom mobilnom telefonu. U toj igrici je data matrica \\(A\\) sa \\(N\\) vrsta i \\(M\\) kolona. Cilj igrice je maksimizovati lepotu matrice. Lepota matrice se defini\u0161e kao kao suma apsolutnih vrednosti razlika susednih polja matrice, pri \u010demu su susedna polja ona koja dele zajedni\u010dku stranicu. Preciznije, lepota matrice \\(A\\) je</p> <p>\\(\\sum_{i=0}^{i&lt;N-1} \\sum_{j=0}^{j&lt;M} |A[i+1][j]-A[i][j]| + \\sum_{j=0}^{j&lt;M-1} \\sum_{i=0}^{i&lt;N} |A[i][j+1]-A[i][j]|\\), gde je \\(A[i][j]\\) element u \\(i\\)-toj  vrsti i \\(j\\)-toj koloni matrice \\(A\\).</p> <p>Vera mo\u017ee da promeni matricu na slede\u0107i na\u010din:</p> <ul> <li>Tako \u0161to nagne telefon na levo i time izvr\u0161i cikli\u010dno pomeranje elemenata svih vrsta matrice na levo za jedan, tj: \\(A[i][j]\\) postaje ono \u0161to je pre pomeranja bilo \\(A[i][(j+1) \\mod M]\\) (gde je \\(0 \\leq i &lt; N\\) i \\(0 \\leq j &lt; M\\)).</li> <li>Tako \u0161to nagne telefon na gore i time izvr\u0161i cikli\u010dno pomeranje elemenata svih kolona matrice na gore za jedan, tj: \\(A[i][j]\\) postaje ono \u0161to je pre pomeranja bilo \\(A[(i+1) \\mod N][j]\\) (gde je \\(0 \\leq i &lt; N\\) i \\(0 \\leq j &lt; M\\)).</li> </ul> <p>Vera mo\u017ee primenjivati ove operacije vi\u0161e puta i u proizvoljnom redosledu. Pomozite joj i ispi\u0161ite maksimalnu lepotu matrice koju mo\u017ee dobiti primenom ovih operacija.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Dragan Uro\u0161evi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se celi brojevi \\(N\\) i \\(M\\), gde je \\(N\\) broj vrsta, a \\(M\\) broj kolona matrice \\(A\\). U narednih \\(N\\) redova, nalazi se po \\(M\\) celih brojeva, gde je \\(j\\)-ti broj u \\(i\\)-tom redu ba\u0161 \\(A[i][j]\\).</p>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jedan broj - maksimalnu lepotu matrice koja se mo\u017ee dobiti.</p>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 1.000\\)</li> <li>\\(1 \\leq A[i][j] \\leq 10^9\\), za svako \\(0 \\leq i &lt; N\\) i \\(0 \\leq j &lt; M\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N = 1\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(N, M \\leq 100\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(N, M \\leq 500\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(A[i][j] \\leq 2\\), za svako \\(0 \\leq i &lt; N\\) i \\(0 \\leq j &lt; M.\\)</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#ulaz","title":"Ulaz","text":"<pre><code>3 3\n2 1 1\n1 1 1\n1 1 1\n</code></pre>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Prvo nagnemo telefon jednom na levo i dobijemo matricu: <pre><code>1 1 2\n1 1 1\n1 1 1\n</code></pre> Potom nagnemo telefon dva puta na gore i dobijemo matricu: <pre><code>1 1 1\n1 1 2\n1 1 1\n</code></pre> Na kraju nagnemo telefon jo\u0161 jednom na levo i dobijemo matricu lepote 4: <pre><code>1 1 1\n1 2 1\n1 1 1\n</code></pre></p>"},{"location":"takprog/2020_2021/okr/02_lepa_matrica/#analiza","title":"Analiza","text":"<p>Vrste sa rednim brojevima \\(i\\) i \\(i+1\\) \u0107emo nazvati susednim vrstama. Osim toga \u0107emo i vrste sa rednim brojevima \\(N\\) i \\(1\\) (pretpostavimo da su vrste numerisane brojevima od 1 do \\(N\\)) smatrati susednim. Sli\u010dno \u0107emo kolone sa rednim brojevima \\(j\\) i \\(j+1\\) smatrati susednim kolonama, a isto tako kolone sa rednim brojevima \\(M\\) i \\(1\\) \u0107emo smatrati susednim. Tako\u0111e \u0107emo re\u0107i da su elementi \\(A[i][j]\\) \\(A[i+1][j]\\) odgovaraju\u0107i elementi u susednim vrstama. Sli\u010dno \u0107emo elemente \\(A[i][j]\\) \\(A[i][j+1]\\)  smatrati odgovaraju\u0107im elementima u susednim kolonama.</p> <p>Pod ovim pretpostavkama, lepota matrice se mo\u017ee odrediti tako \u0161to se od zbirova apsolutnih vrednosti razlika odgovaraju\u0107ih elmenata u susenim vrstama i odgovaraju\u0107ih elemenata  u susednim kolonama oduzmu apsolutne razlike odgovaraju\u0107ih elemenata u poslednjoj i prvoj vrsti i apsolutne razlike  odgovaraju\u0107ih elemenata u poslednjoj i prvoj koloni. Kada se matrica rotira za \\(j\\) kolona ulevo, onda kolone \\(j\\) i \\(j+1\\) postaju poslednja i prva kolona (izuzetno, ako se rotira za nula kolona, onda su kolone \\(1\\) i \\(M\\), prva i poslednja kolona). Sli\u010dno, kada se matrica rotira za \\(i\\) vrsta na gore, vrste \\(i\\) i \\(i+1\\) postaju poslednja i prva vrsta (izuzetno, ako se rotira za nula vrsta, onda su vrste \\(1\\) i \\(N\\), prva i poslednja vrsta).</p> <p>Neka je \\(S\\) suma svih apsolutnih razlika odgovaraju\u0107ih elemenata u susednim vrstama i svih apsolunih razlika odgovaraju\u0107ih elemenata u susednim kolonama.  Ozna\u010dimo sa \\(SR[i]\\) sumu apsolutnih razlika odgovaraju\u0107ih elemenata u vrstama \\(i\\) i \\(i+1\\), a sa \\(SC[j]\\) sumu apsolutnih razlika odgovaraju\u0107ih elemenata u kolonama \\(j\\) i \\(j+1\\). </p> <p>Tada se lepota matrice koja se dobija nakon rotacije za \\(j\\) kolona ulevo i rotacije \u0455a \\(i\\) vrsta na gore dobija tako \u0161to se od \\(S\\) oduzme \\(SR[i]\\) i \\(SC[j]\\). Lepota matrice je najve\u0107a ako se oduzimaju  sume apsolutnih razlika odgovaraju\u0107ih elemenata susednih vrsta i susednih kolona za koje su te sume najmanje. Zbog toga je potrebno odrediti indekse \\(i\\) i \\(j\\), \u0455a koje su \\(SR[i]\\) i \\(SC[j]\\) najmanji i te dve sume oduzeti od \\(S\\).</p> <p>Lako se utvr\u0111uje da je slo\u017eenost opisanog algoritma \\(N\\cdot M\\).</p> 02_lepa_matrica.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 1005\nusing namespace std;\nint n,m;\nlong long a[maxn][maxn];\nlong long r[maxn];\nlong long c[maxn];\nint main() {\n    long long ans=0;\n    scanf(\"%d %d\",&amp;n,&amp;m);\n    for(int i=0;i&lt;n;i++) {\n        for(int j=0;j&lt;m;j++) {\n            scanf(\"%lld\",&amp;a[i][j]);\n        }\n    }\n    for(int i=0;i&lt;n;i++) {\n        for(int j=0;j&lt;m;j++) {\n            r[i]=r[i]+abs(a[(i+1)%n][j]-a[i][j]);\n            c[j]=c[j]+abs(a[i][(j+1)%m]-a[i][j]);\n            ans=ans+abs(a[i][(j+1)%m]-a[i][j]);\n            ans=ans+abs(a[(i+1)%n][j]-a[i][j]);\n        }\n    }\n    long long mv=r[0];\n    for(int i=0;i&lt;n;i++) mv=min(mv,r[i]);\n    ans-=mv;\n    mv=c[0];\n    for(int i=0;i&lt;m;i++) mv=min(mv,c[i]);\n    ans-=mv;\n    printf(\"%lld\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/","title":"B3 - Zlatnici 2: Elektri\u010dni Bugalu","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Nastavak nikad nije dobar koliko i original. Stalno vi\u0111amo nastavke koji ne uspeju da razumeju za\u0161to je original toliko voljen i ispadnu dosadni, standardni ili prosto lo\u0161i. Naravno, mi nastojimo da promenimo to i zato vam predstavljamo silno is\u010dekivani nastavak na kultni klasik pro\u0161logodi\u0161njeg ciklusa: \"Zlatnici 2: Elektri\u010dni Bugalu\"!</p> <p>Kralj Mida pred sobom ima brojevnu pravu i na nekih \\(N\\) razli\u010ditih celobrojnih koordinata ima po jedan zlatnik. On igra igru gde u jednom potezu mo\u017ee da premesti jedan zlatnik na susednu poziciju na brojevnoj pravoj (sa \\(x\\) ili na \\(x+1\\) ili na \\(x-1\\)), ali ni u jednom trenutku dva zlatnika ne smeju da se na\u0111u na istom mestu. Mida \u017eeli da postavi da se zlatnici nalaze jedan do drugog, ali ne zna jo\u0161 ta\u010dno gde. Zato \u0107e razmotriti \\(Q\\) razli\u010ditih scenarija za svoju igru. Svaki scenario \u0107e biti opisan jednim brojem \\(x\\), i u tom scenariju \u0107e Midin cilj da bude da premesti zlatnike tako da se nalaze na razli\u010ditim pozicijama iz skupa pozicija \\(\\{x,x+1,\\cdots,x+N-1\\}\\). Svi scenariji su nezavisni, to jest, zlatnici uvek kre\u0107u sa istih pozicija.</p> <p>Kralj Mida je od vas zatra\u017eio pomo\u0107 da na\u0111ete najmanji broj poteza da bi zavr\u0161io igru u svakom scenariju, jer ako bi vam on ve\u0107 znao odgovor na to pitanje, to i ne bi bio ne\u0161to dobar zadatak.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza se nalazi prirodan broj \\(N\\), broj zlatnika. U drugom redu se nalazi \\(N\\) prirodnih brojeva \\(a_1&lt;a_2&lt;\\cdots&lt;a_N\\) u rastu\u0107em poretku, koji predstavljaju po\u010detne pozicije zlatnika. U tre\u0107em redu se nalazi prirodan broj \\(Q\\), broj scenarija. U narednih \\(Q\\) linija se nalazi po jedan broj \\(x\\) kojim su opisani scenariji.</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati \\(Q\\) brojeva, gde \\(i\\)-ti predstavlja najmanji broj poteza da Mida zavr\u0161i igru u \\(i\\)-tom scenariju.</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 200.000\\)</li> <li>\\(0 &lt; a_1&lt;a_2&lt;\\cdots&lt;a_N \\le10^9\\)</li> <li>\\(0&lt;x\\le10^9\\) za svaki upit</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N = 1\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(N,Q\\leq 1000\\),  \\(a_i\\le 100.000\\) i \\(x\\le 100.000\\) za svaki scenario.</li> <li>U test primerima vrednim \\(30\\) poena: \\(a_i=p+i\\cdot d\\), to jest po\u010detne pozicije zlatnika formiraju aritmeti\u010dku progresiju.</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/03_zlatnici2/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/03_zlatnici2/#ulaz","title":"Ulaz","text":"<pre><code>2\n2 4\n2\n5\n2\n</code></pre>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#izlaz","title":"Izlaz","text":"<pre><code>5\n1\n</code></pre>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvom scenariju, drugi zlatnik mo\u017eemo da premestimo \\(2\\) mesta udesno (sa \\(4\\) na \\(6\\)), a prvi zlatnik \\(3\\) mesta udesno (sa \\(2\\) na \\(5\\)) i time smo zavr\u0161ili igru. U drugom scenariju, dovolljno je premestiti drugi zlatnik jedno mesto ulevo.</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#resenje-za-n-1","title":"Re\u0161enje za \\(N = 1\\):","text":"<p>Imamo samo jedan zlatnik koji je u svakom scenariju potrebno dovesti na odgovaraju\u0107u poziciju. Da bismo sa pozicije \\(a_1\\) do\u0161li do pozicije \\(x\\) potrebno je \\(|a_1 - x|\\) poteza. Vremenska slo\u017eenost je \\(O(N+Q)\\).</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#resenje-za-n-q-leq-1000-i-a_i-x-leq-105","title":"Re\u0161enje za \\(N, Q \\leq 1000\\) i \\(a_i, x \\leq 10^5\\):","text":"<p>Po\u0161to nije dozvoljeno da se dva zlatnika nalaze na istoj poziciji, tako\u0111e nije mogu\u0107e da se dva zlatnika mimoi\u0111u. Samim tim, zlatnik sa pozicije \\(a_1\\) \u0107e zavr\u0161iti na poziciji \\(x\\), zlatnik sa pozicije \\(a_2\\) na \\(x+1\\), ..., zlatnik sa pozicije \\(a_N\\) na \\(x+N-1\\).  Po\u0161to \u0107e u svakom trenutku postojati zlatnik koji mo\u017ee da se pribli\u017ei svojoj krajnjoj poziciji, re\u0161enje je \\(|a_1-x|+|a_2-x-1|+...+|a_N-x-N+1|\\), odnosno \\(\\sum_{i=0}^{N-1} |a_{i+1}-x-i|\\). Po\u0161to su \\(N\\) i \\(Q\\) mali, mo\u017eemo ru\u010dno izra\u010dunati ovu sumu za svaki scenario. Vremenska slo\u017eenost je \\(O(N\\cdot Q)\\).</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#resenje-za-a_i-p-icdot-d","title":"Re\u0161enje za \\(a_i = p + i\\cdot d\\):","text":"<p>Primetimo da va\u017ei \\(|a_{i+1}-i-x| = x-(a_{i+1}-i)\\) ako \\(a_{i+1}-i\\leq x\\), a \\(|a_{i+1}-i-x| = a_{i+1}-i-x\\) u suprotnom. Po\u0161to je niz \\(a_i\\) rastu\u0107i, za prvih nekoliko (potencijalno nula) \u017eetona va\u017ei\u0107e prvi slu\u010daj, dok  \u0107e za ostale va\u017eiti drugi slu\u010daj. Ozna\u010dimo sa \\(k\\) indeks poslednjeg \u017eetona za koji va\u017ei \\(a_{i+1}-i\\leq x\\) (ako ne postoji takav \u017eeton onda \\(k = 0\\), ina\u010de \\(k = i+1\\)). Primetimo da onda va\u017ei \\(\\sum_{i=0}^{N-1} |a_{i+1}-x-i| = \\sum_{i=0}^{k-1} (x-(a_{i+1}-i)) + \\sum_{i=k}^{N-1} ((a_{i+1}-i)-x)\\). Odnosno re\u0161enje je \\(k\\cdot x - \\sum_{i=0}^{k-1} (a_{i+1}-i) + \\sum_{i=k}^{N-1} (a_{i+1}-i) - (N-k)\\cdot x\\). Kada znamo \\(k\\), sume iz formule mo\u017eemo na\u0107i prefiksnim sumama. Sve ovo u stvari zna\u010di da \u0107emo nekoliko prvih nov\u010di\u0107a pomerati udesno, dok \u0107emo ostale pomerati ulevo. </p> <p>Ostalo nam je samo da na\u0111emo \\(k\\). Ako \\(a_i = p + i\\cdot d\\),  mo\u017eemo uzeti \\(p = a_1\\) i \\(d = a_2-a_1\\) (ako \\(N \\geq 2\\)). Tra\u017eimo najve\u0107e \\(k = i+1\\) tako da va\u017ei  \\(a_{i+1}-i\\leq x\\), tj. \\(p + (i+1)\\cdot d - i \\leq x\\). Va\u017ei \\(i+1 \\leq \\frac{x+i-p}{d}\\). Samim tim va\u017ei \\(k = \\lfloor\\frac{x+i-p}{d}\\rfloor\\), gde je \\(\\lfloor x \\rfloor\\) ceo deo od \\(x\\). Vremenska slo\u017eenost je \\(O(N+Q)\\).</p>"},{"location":"takprog/2020_2021/okr/03_zlatnici2/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Jedina razlika ovog re\u0161enja i re\u0161enja za prethodnu grupu test primera je nala\u017eenje \\(k\\). Za \\(100\\) poena potrebno je da koristimo binarnu pretragu nad nizom \\(a_{i+1}-i\\) (tra\u017eimo prvo \\(i\\) za koje je to ve\u0107e od \\(x\\)). Vremenska slo\u017eenost je \\(O(N+QlogN)\\).</p> 03_zlatnici2.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 200007\nusing namespace std;\nlong long a[MAXN],pr[MAXN],su[MAXN];\nlong long formula(long long x,long long k)\n{\n    return x*k+(k*(k-1))/2;\n}\nint binarna(int l,int r,long long x)\n{\n    if(l==r) return l;\n    int s=(l+r+1)/2;\n    if(a[s]-s&lt;x) return binarna(s,r,x);\n    return binarna(l,s-1,x);\n}\nint main()\n{   int n,q;\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++) scanf(\"%lld\",&amp;a[i]);\n    pr[0]=a[0];\n    for(int i=1;i&lt;n;i++) pr[i]=pr[i-1]+a[i];\n    su[n]=0;\n    for(int i=n-1;i&gt;=0;i--) su[i]=su[i+1]+a[i];\n    scanf(\"%d\",&amp;q);\n    while(q--)\n    {\n        long long x;\n        scanf(\"%lld\",&amp;x);\n        if(a[0]&gt;=x) {printf(\"%lld\\n\", pr[n-1]-formula(x,n)); continue;}\n        int t=binarna(0,n-1,x);\n        printf(\"%lld\\n\",(formula(x,t+1)-pr[t])+(su[t+1]-formula(x+t+1,n-t-1)));\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/","title":"A1 - Standardan zadatak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Osoba T je dobila niz \\(A\\) du\u017eine \\(N\\). Jedina dozvoljena operacija nad nizom je:</p> <ul> <li>Izabrati tri proizvoljna razli\u010dita indeksa \\((i, j, k)\\), \\(1 \\leq i &lt; j &lt; k \\leq N\\) i postaviti \u010dlanove niza \\(A_i, A_j\\) i \\(A_k\\) na srednji po vrednosti od ta tri elementa.</li> </ul> <p>Na\u0107i minimalan broj operacija koji osoba T mora napraviti tako da svi elementi niza \\(A\\) budu jednaki po vrednosti.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Vladimir Milenkovi\u0107 Vladimir Milenkovi\u0107 <p>Pretpostavimo da \u0107e nam na kraju svi elementi niza biti jednaki nekom broju \\(x\\), koji ve\u0107 postoji u ovom nizu. Ono \u0161to treba da uradimo je da pretvorimo sve brojeve koji nisu isprva jednaki \\(x\\) u \\(x\\)-eve. </p> <p>Neka imamo \\(l\\) brojeva strogo manjih od \\(x\\) u po\u010detnom nizu, i \\(r\\) brojeva koji su strogo ve\u0107i. Ukoliko su oba broja ve\u0107a od \\(0\\), mo\u017eemo izvr\u0161iti operaciju koja \u0107e umanjiti brojeve \\(l\\) i \\(r\\) za jedan, tako \u0161to \u0107emo uraditi operaciju na jednom broju manjem od \\(x\\), jednom jednakom i jednom ve\u0107em od njega. Ovo mo\u017eemo ponavljati dok god su i \\(l\\) i \\(r\\) pozitivni, dakle \\(\\min(l, r)\\) puta. Kada jedan od njih postane jednak nuli, bez umanjenja op\u0161tosti, neka je to \\(r\\) -- mo\u017eemo iskoristiti jo\u0161 \\(l\\) operacija u kojima stavljamo dva broja \\(x\\) i jedan manji broj, dok god svi brojevi ne budu jednaki broju \\(x\\).</p> <p>Broj operacija kojima smo smanjili zbir \\(l + r\\) za \\(2\\) je \\(\\min(l, r)\\), svim ostalim operacijama smo smanjivali zbir za 1, pa je ukupan broj operacija \\(l + r - \\min(l, r) = max(l, r)\\). </p> <p>Dakle, primetimo da nam je re\u0161enje zadatka jednako \\(\\min_{i = 1}^{n} \\max(l(a_i), r(a_i)\\), gde funkcije \\(l(\\cdot)\\) i \\(r(\\cdot)\\) vra\u0107aju broj manjih, odnosno ve\u0107ih brojeva od \\(a_i\\) u po\u010detnom nizu a \\(LIM\\) je maksimalni broj koji se mo\u017ee pojaviti u nizu.</p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#opis-ulaza","title":"Opis ulaza","text":"<ul> <li> <p>U prvom redu ulaza se nalazi pozitivan ceo broj \\(N\\) - broj elemenata u nizu \\(A\\). </p> </li> <li> <p>U drugom redu ulaza se nalazi \\(N\\) pozitivnih celih brojeva, elementi niza \\(A\\).</p> </li> </ul>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlazu ispisati minimalan broj operacija potreban da niz \\(A\\) sadr\u017ei sve jednake elemente po vrednosti.</p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 2\\cdot10^5\\)</li> <li>\\(1 \\leq A_i\\leq 10^6\\)</li> </ul> <p>Test primeri su podeljeni u \\(4\\) disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: Svi elementi niza \\(A\\) su razli\u010diti.</li> <li>U test primerima vrednim \\(10\\) poena: U nizu \\(A\\) se pojavljuje najvi\u0161e dve razli\u010dite vrednosti.</li> <li>U test primerima vrednim \\(20\\) poena: \\(N\\leq 2000\\).</li> <li>U test primerima vrednim \\(60\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 2 3 2 5\n</code></pre>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Osoba T prvu operaciju mo\u017ee primeniti nad indeksima \\((2, 3, 4)\\), niz se transformi\u0161e u \\(A = [1, 2, 2, 2, 5]\\). U drugom operaciji mo\u017ee izabrati indekse \\((1, 2, 5)\\) nakon \u010dega svaki element niza \\(A\\) ima vrednost \\(2\\). </p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 1 1\n</code></pre>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#podzadatak-1","title":"Podzadatak 1","text":"<p>U ovom podzadatku, nakon sortiranja niza trivijalno imamo vrednosti funkcija \\(l(\\cdot)\\) i \\(r(\\cdot)\\) za sve vrednosti. Slo\u017eenost: \\(\\mathcal{O}(N\\log N)\\).</p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#podzadatak-2","title":"Podzadatak 2","text":"<p>U ovom podzadatku, imamo samo dve mogu\u0107e vrednosti za na\u0161 \\(x\\). Slo\u017eenost: \\(\\mathcal{O}(N)\\).</p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#podzadatak-3","title":"Podzadatak 3","text":"<p>U ovom podzadatku mo\u017eemo, za svaki kandidat za re\u0161enje, \u201dru\u010dno\u201d izbrojati odgovaraju\u0107i broj ve\u0107ih odnosno manjih brojeva. Slo\u017eenost: \\(\\mathcal{O}(N^2)\\).</p>"},{"location":"takprog/2020_2021/okr/04_standardan_zadatak/#celo-resenje","title":"Celo re\u0161enje","text":"<p>Mo\u017eemo iterirati po vrednostima od najmanje do najve\u0107e, pamte\u0107i koliko manjih brojeva smo pro\u0161li do sad. Znaju\u0107i koliko ima manjih i koliko brojeva jednakih trenutnom broju, mo\u017eemo izra\u010dunati i koliko ima ve\u0107ih i samim tim dobiti re\u0161enje u linearnoj slo\u017eenosti. Slo\u017eenost: \\(\\mathcal{O}(N)\\) ili \\(\\mathcal{O}(N\\log N)\\), zavisno od implementacije.</p> 04_standardan_zadatak.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxN = 2e5;\nconst int maxA = 1e6;\n\nint a[maxN], cnt[maxA + 10];\nint n;\n\nint main()\n{\n    scanf(\"%d\",&amp;n);\n\n    assert(n &gt; 0 &amp;&amp; n &lt;= maxN);\n\n    for (int i = 1; i&lt;=n;i++)\n    {\n        scanf(\"%d\",&amp;a[i]);\n        assert(a[i] &gt; 0 &amp;&amp; a[i]&lt;=maxA);\n        cnt[a[i]]++;\n    }\n\n   int ans = n;\n   int bigger = 0;\n   for (int i = maxA; i&gt;0; i--) \n   if (cnt[i])\n   {   \n       ans = min(ans, max(bigger, n - bigger - cnt[i]));\n       bigger+=cnt[i];\n   }\n\n   printf(\"%d\\n\", ans);\n}\n</code></pre>"},{"location":"takprog/2020_2021/okr/05_velika_trka/","title":"A2 - Velika trka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>U Republici Izometriji najve\u0107i godi\u0161nji spekatkl je velika trka koja se odr\u017eava u srcu dr\u017eave - Centralgradu. Tu dolaze najbolji trka\u010di i najspremniji rekreativci iz svih ve\u0107ih gradova dr\u017eave i bore se za titulu Visokog Velemajstora Metrika.</p> <p>Centralgrad ima oblik dvodimenzionog koordinatnog sistema. Traka trke je odre\u0111ena startnom ta\u010dkom i sa \\(k\\) stubova na slede\u0107i na\u010din: u \\(i\\)-tom delu trke trka\u010di tr\u010de od trenutne pozicije do \\(i\\)-tog stuba, ali kad stignu do njega nastave da tr\u010de u istom pravcu i smeru tako da pre\u0111u jo\u0161 toliku distancu koliko su pre\u0161li do tad u tom delu trke, to jest \\(i\\)-ti stub treba da bude sredi\u0161te du\u017ei koja spaja po\u010detak i kraj \\(i\\)-tog dela trke. Drugim re\u010dima, zavr\u0161etak \\(i\\)-tog dela trke (i po\u010detak \\(i+1\\)-vog dela) je ta\u010dka centralno simetri\u010dna u odnosu na \\(i\\)-ti stub.   </p> <p>Organizatori su postavili \\(N\\) stubova numerisanih sa \\(1,2,\\ldots,N\\), ali nisu jo\u0161 odredili koje \u0107e koristiti u trci. Zbog toga \u017eele da razrade \\(Q\\) scenarija, gde je \\(i\\)-ti scenario odre\u0111en sa \u010detiri vrednosti: \\(x\\) i \\(y\\) koje predstavljaju koordinate po\u010detka trke i  \\(L\\) i \\(R\\) koje predstavljaju da \u0107e za trku biti iskori\u0161\u0107eni redom stubovi numerisani sa \\(L,L+1,\\ldots,R\\). Organizatori su malo smotani, pa tra\u017ee od vas da odredite za svaki scenario gde bi se nalazio kraj trke.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/okr/05_velika_trka/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu ulaza se nalazi prirodan broj \\(N\\)-broj stubova. U narednih \\(N\\) redova se nalaze po \\(2\\) prirodna brojeva \\(x_i\\) i \\(y_i\\) koje predstavljaju lokacije postavljenih stubova. U narednom redu se nalazi prirodan broj \\(Q\\)-broj scenarija. U narednih \\(Q\\) linija se nalazi po \u010detiri broja \\(x,y,L,R\\) kojim su opisani scenariji.</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#opis-izlaza","title":"Opis izlaza","text":"<p>Na izlaz ispisati \\(Q\\) redova sa po \\(2\\) broja, gde brojevi u \\(i\\)-tom redu predstavljaju koordinate cilja u \\(i\\)-tom scenariju.</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 200.000\\)</li> <li>\\(0\\le x_i,y_i\\le10^9\\)</li> <li>\\(0\\le x ,y\\le10^9\\) za svaki upit</li> <li>\\(1\\le L\\le R\\le N\\) za svaki upit</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena:  \\(N,Q\\leq 1000\\),  \\(x_i,y_i\\le 1.000.000\\) i \\(x,y\\le 1.000.000\\) za svaki upit.</li> <li>U test primerima vrednim \\(10\\) poena: Koordinate svih stubova su iste.</li> <li>U test primerima vrednim \\(30\\) poena: \\(y\\) koordinate svih stubova i startova su jednake \\(0\\)</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/05_velika_trka/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/05_velika_trka/#ulaz","title":"Ulaz","text":"<pre><code>2\n1 1\n3 3\n2\n0 0 1 1\n0 0 1 2\n</code></pre>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#izlaz","title":"Izlaz","text":"<pre><code>2 2\n4 4\n</code></pre>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvom scenariju, trka ima samo jedan deo koji vodi od \\((0,0)\\) do \\((2,2)\\), jer je \\((1,1)\\) sredi\u0161te te du\u017ei. U drugom scenariju, trka ima dva dela, prvi vodi od \\((0,0)\\) do \\((2,2)\\), kao u prvom scenariju, a drugi vodi od \\((2,2)\\) do \\((4,4)\\).</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#nqleq-1000","title":"\\(N,Q\\leq 1000\\)","text":"<p>U ovom podzadatku mo\u017eemo lako simulirati svaki deo trke, ako deo trke kre\u0107e u \\((x,y)\\) i ide preko stuba \\((x',y')\\), onda se zavr\u0161ava u ta\u010dki \\((2x'-x,2y'-y)\\) , i na\u0111emo gde se zavr\u0161ava u slo\u017eenosti \\(O(NQ)\\).</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#svi-stubovi-su-na-istom-mestu","title":"Svi stubovi su na istom mestu","text":"<p>Ono \u0161to treba primetiti u ovom podzadatku da \u0107e posle svaka dva dela trke da se trka\u010di vrate na startnu poziciju, pa je jedino zapravo bitna parnost broja \\(r-l\\), i u zavisnosti od njega mo\u017eemo da odredimo da li se trka zavr\u0161ava tamo gde i po\u010dinje ili centralno simetri\u010dno tome u odnosu na stubove.</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#sve-y-koordinate-su-0","title":"Sve \\(y\\) koordinate su \\(0\\)","text":"<p>Re\u0161avamo slu\u010daj na brojevnoj pravoj. Ako je po\u010detak trke na poziciji \\(x_0\\), a stubovi na \\(x_1,x_2\\cdots,x_n\\). Onda je kraj prvog dela trke na \\(2x_1-x_0\\), drugog dela trke na \\(2x_2-(2x_1-x_0)=2x_2-2x_1+x_0\\), \\(\\cdots\\), \\(n\\)-tog dela trke na \\(2x_n-2x_{n-1}+2x_{n-2}-\\cdots+2\\cdot(-1)^{n-1}x_{1}+(-1)^{n}x_0\\). Ovo zna\u010di da ako pamtimo parcijalne sume oblika \\(x_1-x_2+x_3-x_4+\\cdots\\), oduzimanjem dve parcijalne sume i obra\u0107anjem pa\u017enje na parnost mo\u017eemo da na\u0111emo kona\u010dnu poziciju trke u slo\u017eenosti \\(O(N+Q)\\)</p>"},{"location":"takprog/2020_2021/okr/05_velika_trka/#kompletno-resenje","title":"Kompletno re\u0161enje","text":"<p>U ovom slu\u010daju je dovoljno primetiti da mo\u017eemo razdvojiti problem ko koordinatama i obe koordinate nezavisno re\u0161imo kao u prethodnom podzadatku u slo\u017eenosti \\(O(N+Q)\\).</p> 05_velika_trka.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 200007\nusing namespace std;\nlong long x[MAXN],y[MAXN],px[MAXN],py[MAXN];\nint main()\n{\n    int n,q;\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;x[i],&amp;y[i]);\n    for(int i=1;i&lt;=n;i++) px[i]=px[i-1]+x[i]*((i&amp;1)?1:-1);\n    for(int i=1;i&lt;=n;i++) py[i]=py[i-1]+y[i]*((i&amp;1)?1:-1);\n    scanf(\"%d\",&amp;q);\n    while(q--)\n    {\n        long long xt,yt;\n        int l,r;\n        scanf(\"%lld%lld%d%d\",&amp;xt,&amp;yt,&amp;l,&amp;r);\n        printf(\"%lld %lld\\n\",2*(px[r]-px[l-1])*((r&amp;1)?1:-1)+xt*(((r-l)&amp;1)?1:-1),2*(py[r]-py[l-1])*((r&amp;1)?1:-1)+yt*(((r-l)&amp;1)?1:-1));\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/okr/06_altruizam/","title":"A3 - Altruizam","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Drevni Programer ide od sela do sela pogo\u0111enih nesta\u0161icom interneta i deli kriptovalute. Za\u0161to? Niko ne zna. Na njegovom putu na\u0161lo se \\(k\\) sela, u \\(i\\)-tom selu je \\(a_i\\) programera koji se, u nedostatku interneta, dive suncu, drve\u0107u i drugim \u010dudesima koja ih okru\u017euju. Drevni Programer je poneo \\(n\\) kilograma kriptovaluta i deli ih prema Zakonu velikih brojeva - selo sa ve\u0107im rednim brojem dobija ve\u0107i broj kriptovaluta. </p> <p>Formalnije, svaki programer prvog sela dobio je onoliko kilograma kriptovaluta koliki je zbir cifara broja \\(n\\); svaki programer drugog sela dobio je onoliko kilograma kriptovaluta koliki je zbir kvadrata cifara broja \\(n\\); itd.; svaki programer \\(k\\)-tog sela dobio je onoliko kilograma kriptovaluta koliki je zbir \\(k\\)-tih stepena cifara broja \\(n\\). Nakon \u0161to je Drevni Programer obi\u0161ao sva sela i odjahao u suton, shvatio je da je podelio ta\u010dno sve kriptovalute koje je poneo; i bi mu drago i pusti uzdah i dve suze radosnice.</p> <p>Odrediti koliko je kilograma kriptovaluta poneo Drevni Programer ukoliko je poznato da je taj broj izme\u0111u \\(x\\) i \\(y\\) (uklju\u010divo), kao i da omiljena kriptovaluta Drevnog Programera nije kriptonit.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/okr/06_altruizam/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se tri prirodna broja \\(x\\), \\(y\\) i \\(k\\) koji, redom, predstavljaju granice za broj \\(n\\) i broj sela. U narednom redu nalazi se \\(k\\) prirodnih brojeva \\(a_i\\) - broj programera po selima, redom.</p>"},{"location":"takprog/2020_2021/okr/06_altruizam/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan prirodan broj \\(n\\) - broj kilograma kriptovaluta koje je Drevni Programer poneo sa sobom. Ukoliko nema re\u0161enja u zadatom intervalu, ispisati <code>-1</code>; ukoliko ima vi\u0161e re\u0161enja (u zadatom intervalu) ispisati bilo koje.</p>"},{"location":"takprog/2020_2021/okr/06_altruizam/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq x \\leq y \\leq 10^{18}\\)</li> <li>\\(1 \\leq k \\leq 10^5\\)</li> <li>\\(1 \\leq a_i \\leq 10^{18}\\) za svako \\(i \\in \\{1,2,...,k\\}\\)</li> </ul> <p>Test primeri su podeljeni u \\(5\\) disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(|x-y| \\leq 10^3\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(|x-y| \\leq 10^7\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(k \\leq 2\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(k = 2021\\).</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/okr/06_altruizam/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/okr/06_altruizam/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/okr/06_altruizam/#ulaz","title":"Ulaz","text":"<pre><code>18000 25000 3\n30 65 21\n</code></pre>"},{"location":"takprog/2020_2021/okr/06_altruizam/#izlaz","title":"Izlaz","text":"<pre><code>20528\n</code></pre>"},{"location":"takprog/2020_2021/okr/06_altruizam/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ukoliko je Drevni Programer poneo \\(20528\\) kilograma kriptovaluta, tada svaki programer iz 1. sela dobija po \\(2+0+5+2+8=17\\) kilograma, svaki programer iz 2. sela dobija po \\(2^2+0^2+5^2+2^2+8^2=97\\) kilograma i svaki programer iz 3. sela dobija po \\(2^3+0^3+5^3+2^3+8^3=653\\) kilograma. Dakle, ukupno je podeljeno \\(30\\cdot17+65\\cdot97+21\\cdot653=20528\\) kilograma, tj. podeljene su sve kriptovalute kao \u0161to se i zahtevalo. Obratiti pa\u017enju da iako i broj \\(29630\\) zadovoljava prethodne uslove, on ne pripada opsegu \\([18000, 25000]\\) pa nije re\u0161enje.</p>"},{"location":"takprog/2020_2021/okr/06_altruizam/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/okr/06_altruizam/#ulaz_1","title":"Ulaz","text":"<pre><code>45 60 1\n7\n</code></pre>"},{"location":"takprog/2020_2021/okr/06_altruizam/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2020_2021/okr/06_altruizam/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Iako postoji nekoliko brojeva koji ispunjavaju uslove o podeli (npr. \\(21\\)) nijedan od njih ne pripada segmentu \\([45,60]\\) pa treba ispisati <code>-1</code>.</p>"},{"location":"takprog/2020_2021/okr/06_altruizam/#analiza","title":"Analiza","text":"<p>Ozna\u010dimo sa \\(S_i(n)\\) zbir \\(i\\)-tih stepena cifara broja \\(n\\) (npr. \\(S_3(2021)=2^3+0^3+2^3+1^3=17\\)). Potrebno je prona\u0107i prirodan broj \\(n\\) iz segmenta \\([x,y]\\) za koji va\u017ei</p> \\[n = a_1 \\cdot S_1(n)+a_2\\cdot S_2(n) + \\ldots + a_k \\cdot S_k(n)\\] <p>Najjednostavnije re\u0161enje je proveriti prethodnu jednakost za svaki broj iz \\([x,y]\\); direktna implementacija radi u slo\u017eenosti \\(O(|y-x|\\cdot k)\\) i re\u0161ava podzadatak 1. </p> <p>Malo bolje re\u0161enje (koje vodi kona\u010dnom re\u0161enju) je zapisati prethodnu jedna\u010dinu na druga\u010diji na\u010din. Za svaku cifru \\(i\\), \\(1 \\leq i \\leq 9\\) uvedimo oznaku \\(c_i = a_1 \\cdot i^1 + a_2\\cdot i^2 + \\ldots + a_k \\cdot i^k.\\) Tako\u0111e, ozna\u010dimo broj pojavljivanja cifre \\(i\\) (\\(1\\leq i \\leq 9\\)) u broju \\(n\\) sa \\(x_i(n)\\). Nije te\u0161ko uo\u010diti da je polazna jedna\u010dina ekvivalentna sa</p> \\[n = c_1 \\cdot x_1(n) + c_2 \\cdot x_2(n) + \\ldots + c_9 \\cdot x_9(n)\\] <p>Za konkretan broj \\(n\\) prethodnu jedna\u010dinu mo\u017eemo proveriti u \\(O(\\log n)\\) (broj cifara broja \\(n\\)) pa dolazimo do re\u0161enja slo\u017eenosti \\(O(|y-x|\\log y)\\) koje je dovoljno za podzadatak 2.</p> <p>U podzadatku 3 je \\(k \\leq 2\\); kako je \\(n \\leq 10^{18}\\), va\u017ei \\(S_1(n) \\leq 9\\cdot 18 = 162\\) i \\(S_2(n)\\leq 9^2 \\cdot 18 = 1458\\) pa mo\u017eemo isprobati svih \\(162 \\cdot 1458\\) mogu\u0107nosti za ove vrednosti i proveriti da li dobijeni broj \\(n\\) zadovoljava jedna\u010dinu.</p> <p>Primetimo da ako \\(n\\) sadr\u017ei bar jednu cifru vrednosti \\(c\\), tada va\u017ei \\(n \\geq c^1+c^2+\\ldots +c^k\\). Sada, iz \\(n \\leq 10^{18}\\), dobijamo da ako \\(n\\) sadr\u017ei bar jednu cifru ve\u0107u od \\(1\\) mora va\u017eiti da je \\(k \\leq 58\\). Kako u podzadatku 4 va\u017ei \\(k = 2021\\), sledi da su u ovom podzadatku jedini kandidati za re\u0161enje brojevi koji se sastoje od nula i jedinica. Sada na osnovu druge jedna\u010dine imamo \\(n = c_1 \\cdot x_1(n)\\) pa jednostavno isprobamo svih \\(18\\) mogu\u0107ih vrednosti za \\(x_1(n)\\) (ili, malo komplikovanije, generi\u0161emo svih \\(2^{18} - 1\\) takvih brojeva i proverimo ih).</p> <p>Klju\u010dno zapa\u017eanje, koje direktno sledi iz jedna\u010dine sa \\(c_i\\)-ovima, je da brojevi sa istim brojem pojavljivanja svake ne-nula cifre daju istu vrednost sa desne strane jedna\u010dine (npr. \\(35502, 2355, 5532, 20305050...\\)) pa proveru ne moramo vr\u0161iti po svim brojevima iz \\([x,y]\\) ve\u0107 po broju pojavljivanja cifara. Dovoljno je isprobati sve \\(9\\)-orke \\((x_1, x_2, ..., x_n)\\) nenegativnih celih brojeva za koje je \\(1 \\leq x_1 + x_2 + \\ldots  +x_9 \\leq 18\\) (broj cifara je izme\u0111u 1 i 18), izra\u010dunati desnu stranu jedna\u010dine i proveriti da li je dobijeni broj \\(n\\) iz \\([x,y]\\) i da li se u njemu svaka cifra \\(i\\) javlja ta\u010dno \\(x_i\\) puta.</p> <p>Za generisanje ovakvih \\(9\\)-orki koristimo backtracking tehniku. Jedan od na\u010dina je zapravo generisati brojeve sa nerastu\u0107im nizom cifara: sa \\(F(a,b)\\) ozna\u010dimo poziv rekurzivne funkcije u kome treba fiksirati \\(a\\)-tu cifru pri \u010demu je prethodna cifra \\(b\\); rekurzivni pozivi su \\(F(a+1, b)\\) (\\(a\\)-ta cifra je \\(b\\), uz pove\u0107anje \\(x_b\\)) i \\(F(a, b-1)\\) (\\(a\\)-ta cifra je manja od \\(b\\)) . Broj pomenutih devetorki se mo\u017ee odrediti pokretanjem ovog algoritma ili koriste\u0107i malo kombinatorike; taj broj je \\(\\binom{27}{9}-1=4686825\\) tj. dovoljno je mali da ovaj algoritam re\u0161ava ceo zadatak u zadatom vremenskom ograni\u010denju.</p> 06_altruizam.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nconst long long MAX_VAL = 1000000000000000000LL;\nconst int MAX_DIGITS = 18;\nconst int MAX_K = 100000;\n\nlong long X, Y;\nint k;\nlong long a[MAX_K + 10];\n\nlong long c[10];\nint x[10];\nbool found;\nlong long solution;\n\nvoid precalc()\n{\n    for (int val = 1; val &lt;= 9; val++)\n    {\n        long long curr = 1LL;\n        c[val] = 0LL;\n        int i = 1;\n\n        while (i &lt;= k)\n        {\n            curr = curr * val;\n            if (curr &gt; MAX_VAL / a[i])\n            {\n                c[val] = MAX_VAL + 1;\n                break;\n            }\n            c[val] = c[val] + curr * a[i];\n            if (c[val] &gt; MAX_VAL)\n            {\n                c[val] = MAX_VAL + 1;\n                break;\n            }\n            i++;\n        }\n    }\n}\n\nlong long calc(int x[])\n{\n    long long ret = 0LL;\n    for (int i = 1; i &lt;= 9; i++)\n    {\n        if (x[i] &gt; MAX_VAL / c[i])\n            return MAX_VAL + 1;\n        ret = ret + c[i] * x[i];\n        if (ret &gt; MAX_VAL)\n            return MAX_VAL + 1;\n    }\n\n    return ret;\n}\n\nbool check(int x[])\n{\n    long long n = calc(x);\n    if (n &lt; X || n &gt; Y)\n        return false;\n\n    int x1[10];\n    for (int i = 0; i &lt;= 9; i++)\n        x1[i] = 0;\n\n    long long n1 = n;\n    while (n &gt; 0)\n    {\n        x1[n % 10]++;\n        n = n / 10;\n    }\n    for (int i = 1; i &lt;= 9; i++)\n        if (x[i] != x1[i])\n            return false;\n\n    solution = n1;\n    return true;\n}\n\nvoid F(int n, int currDigit)\n{\n    if (found)\n        return;\n\n    if (n &gt; MAX_DIGITS || currDigit == 0)\n    {\n        found = check(x);\n        return;\n    }\n\n    x[currDigit]++;\n    F(n + 1, currDigit);\n    x[currDigit]--;\n    F(n, currDigit - 1);\n}\n\nint main()\n{\n    scanf(\"%lld%lld%d\", &amp;X, &amp;Y, &amp;k);\n    for (int i = 1; i &lt;= k; i++)\n        scanf(\"%lld\", &amp;a[i]);\n\n    precalc();\n\n    for (int i = 0; i &lt;= 9; i++)\n        x[i] = 0;\n    found = false;\n    solution = -1LL;\n\n    F(1, 9);\n\n    printf(\"%lld\\n\", solution);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2020_2021/sio/01_rnk/","title":"1 - RNK","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Nekako ste se na\u0161li uposleni na projektu proizvodnje najnovije RNK vakcine, gde radite na prototipu koji se mo\u017ee opisati kao niz od \\(N\\) kodona, odnosno karaktera koji mogu biti <code>A</code>, <code>C</code>, <code>G</code>, i <code>U</code>. Proizvedena vakcina \u0107e biti stabilna samo ako ne sadr\u017ei previ\u0161e istih kodona. Konkretno, smatramo je stabilnom ako se ni jedan kodon ne pojavljuje strogo vi\u0161e od \\(\\frac{N}{2}\\) puta.</p> <p>Na raspolaganju vam je RNKpopravlja\u010d, ure\u0111aj koji treba iskoristiti ta\u010dno jednom i koji \u0107e obrnuti sve kodone u datom intervalu tako \u0161to <code>A</code> pretvori u <code>U</code> i obrnuto, a <code>C</code> u <code>G</code> i obrnuto. Va\u0161 zadatak je da odredite da li je ovim putem mogu\u0107e od prototipa dobiti stabilnu vakcinu (i kako).</p> <p>Na\u017ealost, izgubili ste bele\u0161ke, tako da ne znate kako prototip izgleda. Na raspolaganju vam je skener, kojim mo\u017eete da ispitate koliko puta se neki kodon pojavljuje u nekom intervalu prototipa. Po\u0161to ste u \u017eurbi, skener mo\u017eete koristiti ograni\u010den broj puta.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Dimitrije Erdeljan Mladen Puzi\u0107 Tadija \u0160ebez"},{"location":"takprog/2020_2021/sio/01_rnk/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{Resi}(N, L, R)\\)</li> </ul> <p>gde je:</p> <ul> <li>\\(N\\) broj kodona u prototipu.</li> <li>\\(L\\) i \\(R\\) promenljive u koje treba da upi\u0161ete indekse prvog i   poslednjeg kodona koje \u0107ete obrnuti RNKpopravlja\u010dem. Ukoliko nije   mogu\u0107e dobiti stabilnu vakcinu ovim putem, upi\u0161ite \\(L = R = -1\\).</li> </ul> <p>Va\u0161 program mo\u017ee da koristi funkciju</p> <p>\\(\\text{Skener}(L, R, C)\\)</p> <p>koja \u0107e vratiti broj pojavljivanja kodona \\(C\\) u intervalu \\([L, R]\\) prototipa (uklju\u010duju\u0107i i \\(L\\)-ti i \\(R\\)-ti).</p> <p>Nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/01_rnk/#ogranicenja","title":"Ograni\u010denja","text":"<p>Test primeri su podeljeni u nekoliko podzadataka. U svakom podzadatku je dato ograni\u010denje \\(Q\\), koje predstavlja dozvoljen broj poziva funkcije \\(\\text{Skener}\\).</p> <ul> <li>[10 poena]: \\(N \\leq 1000\\), \\(Q = 4000\\)</li> <li>[15 poena]: \\(N \\leq 10^5\\), \\(Q = 3 \\times 10^5 + 10\\)</li> <li>[15 poena]: \\(N \\leq 10^5\\), \\(Q = 2 \\times 10^5 + 10\\)</li> <li>[20 poena]: \\(N \\leq 10^5\\), \\(Q = 1.5 \\times 10^5 + 50\\)</li> <li>[40 poena]: \\(N \\leq 10^5\\), \\(Q = 36\\)</li> </ul>"},{"location":"takprog/2020_2021/sio/01_rnk/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>rnk.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int *L, int *R)</code></p> <p>Va\u0161 program mora uklju\u010divati header <code>code.h</code>, u kom je definisana funkcija \\(\\text{Skener}\\) slede\u0107eg potpisa:</p> <p><code>int Skener(int L, int R, char C)</code></p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(Q\\).</li> <li>U narednom redu string du\u017eine \\(N\\) koji predstavlja prototip (sa\u010dinjen   isklju\u010divo od velikih slova <code>A</code>, <code>C</code>, <code>T</code> i <code>U</code>).</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa vrednosti \\(L\\) i \\(R\\) koje je funkcija popunila u jednom redu, i broj poziva funkcije \\(\\text{Skener}\\) u drugom. Ukoliko va\u0161e re\u0161enje koristi skener vi\u0161e od \\(Q\\) puta, bi\u0107e prekinuto sa statusom <code>RTE</code> (runtime error).</p>"},{"location":"takprog/2020_2021/sio/01_rnk/#podzadatak-1","title":"Podzadatak 1","text":"<p>Koriste\u0107i \\(4N\\) upita, mo\u017eemo odrediti ceo prototip (za svaku poziciju mo\u017eemo da pitamo koliko ima svakog slova na toj poziciji). Nakon toga mo\u017eemo probati svaki interval za promenu, videti da li daje validnu vakcinu. Vremenska/memorijska slo\u017eenost: \\(O(N^2)\\), broj poziva funkciji: \\(4N\\). </p>"},{"location":"takprog/2020_2021/sio/01_rnk/#podzadatak-2","title":"Podzadatak 2","text":"<p>Sli\u010dno prethodnom podzadatku, mo\u017eemo otkriti ceo prototip, ali ovaj put smemo koristiti najvi\u0161e \\(3\\) upita po poziciji. To nije problem, jer mo\u017eemo pitati za tri kodona, ako nijedan ne va\u017ei, znamo da je u pitanju \u010detvrti kodon.  Odredimo kodon koji se pojavljuje vi\u0161e od \\(\\frac{N}{2}\\) puta, recimo da se pojavljuje \\(x\\) puta, dok se njegov komplement pojavljuje \\(y\\) puta. \u017delimo da se naj\u010de\u0161\u0107i kodon u na\u0161em intervalu pojavljuje makar \\(\\frac{x-y}{2}\\) puta vi\u0161e od komplementa. Ne sme da se pojavljuje ni previ\u0161e puta, jer onda njegov komplement postaje element koji se pojavljuje vi\u0161e od \\(\\frac{N}{2}\\) puta, sre\u0107om u ve\u0107ini slu\u010dajeva mo\u017eemo na\u0107i ba\u0161 interval u kom se naj\u010de\u0161\u0107i kodon pojavljuje ta\u010dno \\(\\lceil\\frac{x-y}{2}\\rceil\\) puta vi\u0161e od komplementa. Jedini slu\u010daj u kojem to nije mogu\u0107e je ukoliko je \\(N\\) neparan broj i va\u017ei \\(x+y=N\\), u tom slu\u010daju koji god interval da izaberemo, postoja\u0107e element koji se pojavljuje vi\u0161e od \\(\\frac{N}{2}\\) puta, pa re\u0161enje ne postoji. </p> <p>Ukoliko to nije slu\u010daj, postoji odgovaraju\u0107i interval, i to odgovaraju\u0107i interval koji je i prefiks. Nazovimo sa \\(f(i)\\) razliku broja pojavljivanja   naj\u010de\u0161\u0107eg elementa i njegovog komplementa u prvih \\(i\\) elemenata. Jasno je da va\u017ei \\(f(0) = 0\\) i \\(f(N) = x-y\\). Kako se \\(f(i)\\) i \\(f(i+1)\\) razlikuju za najvi\u0161e \\(1\\), mo\u017eemo re\u0107i da je u nekom smislu ova funkcija neprekidna, tj. postoje indeksi za koje iznosi \\(0\\) i \\(x-y\\), postoje i indeksi gde iznosi i bilo \u0161ta izme\u0111u toga, uklju\u010duju\u0107i i \\(\\lceil\\frac{x-y}{2}\\rceil\\). Samim tim, postoji prefiks koji nam odgovara, i mo\u017eemo ga jednostavno na\u0107i. </p> <p>Vremenska/memorijska slo\u017eenost: \\(O(N)\\), broj poziva funkciji: \\(3N\\). </p>"},{"location":"takprog/2020_2021/sio/01_rnk/#podzadatak-3","title":"Podzadatak 3","text":"<p>Ovaj podzadatak veoma je sli\u010dan prethodnom, ne\u0107emo direktno odrediti ceo prototip, nego \u0107emo iskoristiti \\(3\\) poziva funkciji da za svaki kodon odredimo koliko puta se pojavljuje, tj. da odredimo koji kodon se pojavljuje najvi\u0161e puta. Kada imamo tu informaciju, mo\u017eemo da izra\u010dunamo \\(f(i)\\) sa dva poziva funkciji. Mo\u017eemo da izra\u010dunamo \\(f(i)\\) i odaberemo ono koje nam odgovara. Vremenska/memorijska slo\u017eenost: \\(O(N)\\), broj poziva funkciji: (najvi\u0161e) \\(2N+3\\). </p>"},{"location":"takprog/2020_2021/sio/01_rnk/#podzadatak-4","title":"Podzadatak 4","text":"<p>Na\u0111imo koliko se koji kodon pojavljuje, odnosno koji se pojavljuje naj\u010de\u0161\u0107e. Na\u0111imo sva pojavljivanja njegovog komplementa u nizu koriste\u0107i do sad ukupno \\(N+3\\) poziva funkciji. Tih pojavljivanja mo\u017ee biti najvi\u0161e \\(\\frac{N}{2}\\). Za svaki prefiks koji se zavr\u0161ava na jednom od ovih pojavljivanja, otkrijmo koliko se puta do njega pojavljuje naj\u010de\u0161\u0107i kodon. Ova informacija nam, zbog neprekidnosti na\u0161e funkcije, poma\u017ee da odredimo izme\u0111u koja dva pojavljivanja se nalazi prefiks koji tra\u017eimo. Kada na\u0111emo tu informaciju, mo\u017eemo uraditi binarnu pretragu, da na\u0111emo ta\u010dan potreban indeks. Vremenska/memorijska slo\u017eenost: \\(O(N)\\), broj poziva funkciji: (najvi\u0161e) \\(1.5N+\\lceil logN\\rceil+3\\). </p>"},{"location":"takprog/2020_2021/sio/01_rnk/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Koristi\u0107emo binarnu pretragu da na\u0111emo \\(i\\) za koje va\u017ei \\(f(i) = \\lceil\\frac{x-y}{2}\\rceil\\). Znamo \\(f(0) = 0\\) i \\(f(N) = x-y\\), proveravamo \\(f(mid)\\). Va\u017ei\u0107e da \u0107e se \\(\\lceil\\frac{x-y}{2}\\rceil\\) nalaziti ili izme\u0111u \\(f(l)\\) i \\(f(mid)\\) ili izme\u0111u \\(f(mid)\\) i \\(f(r)\\) (mo\u017eda i na oba mesta, ali nama je dovoljno jedno). Ovo va\u017ei po neprekidnosti na\u0161e funkcije. Onda nastavljamo binarnu pretragu u delu koji sadr\u017ei vrednost koju tra\u017eimo.  Vremenska/memorijska slo\u017eenost: \\(O(logN)\\), broj poziva funkciji: (najvi\u0161e) \\(2\\lceil logN\\rceil+3\\).</p> 01_rnk.cpp<pre><code>#include \"code.h\"\n#include &lt;cstdio&gt;\n\nint delta(char a, char b, int k) {\n    return Skener(1, k, a) - Skener(1, k, b);\n}\n\nvoid solve(int n, char a, int na, char b, int nb, int *L, int *R) {\n    if(na + nb == n &amp;&amp; n % 2 == 1) {\n        *L = *R = -1;\n    } else {\n        int mindelta = na - n/2;\n        int maxdelta = n/2 - nb;\n\n        int lo = 1, hi = n;\n        while(lo &lt; hi) {\n            int mid = (lo + hi) / 2;\n            int d = delta(a, b, mid);\n\n            if(mindelta &lt;= d &amp;&amp; d &lt;= maxdelta) {\n                *L = 1; *R = mid;\n                return;\n            } else {\n                if(d &lt; mindelta) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n\n        *L = 1; *R = lo;\n    }\n}\n\nvoid Resi(int N, int *L, int *R) {\n    int a, c, g, u;\n    a = Skener(1, N, 'A');\n    c = Skener(1, N, 'C');\n    g = Skener(1, N, 'G');\n    u = N - a - c - g;\n\n    if(a + u &gt; c + g) {\n        if(a &gt; u) {\n            solve(N, 'A', a, 'U', u, L, R);\n        } else {\n            solve(N, 'U', u, 'A', a, L, R);\n        }\n    } else {\n        if(c &gt; g) {\n            solve(N, 'C', c, 'G', g, L, R);\n        } else {\n            solve(N, 'G', g, 'C', c, L, R);\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/","title":"2 - Marsko","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Kao \u0161to svi znamo, ljudi su odavno kolonizovali Mars i na njemu izgradili \\(N\\) gradova i \\(M\\) puteva. Kako do povr\u0161ine Marsa dopire velika doza jonizuju\u0107eg zra\u010denja iz svemira, oko gradova i puteva izgra\u0111ene su za\u0161titne kupole. Me\u0111utim, nisu svi putevi napravljeni i odr\u017eavani po propisima (kao i na Zemlji). Poznato je da je koli\u010dina zra\u010denja koju propu\u0161ta za\u0161tita puta \\(i\\) jednaka \\(W_i\\). Vozila koja se koriste na Marsu imaju dodatnu za\u0161titu od zra\u010denja. Vozilom koje ima za\u0161titu \\(A\\), bezbedno je voziti se po putu \\(i\\) ako je \\(W_i \\leq A\\). U svakom gradu nalazi se po jedno vozilo. Vozilo koje se nalazi u \\(i\\)-tom gradu ima za\u0161titu \\(A_i\\). Junak na\u0161eg zadatka, Marsko, planira da se preseli na Mars, ali jo\u0161 uvek nije odlu\u010dio u koji grad. Kako bi doneo odluku, za svaki grad \\(i\\) zanima ga do koliko gradova mo\u017ee bezbedno da stigne ako krene odatle i sme da menja vozila. Pomozite Marsku da se preseli na Mars tako \u0161to \u0107ete re\u0161iti ovaj problem umesto njega.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Aleksa Plav\u0161i\u0107"},{"location":"takprog/2020_2021/sio/02_marsko/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{Resi}(N, A[\\dots], M, U[\\dots], V[\\dots], W[\\dots], R[\\dots])\\)</li> </ul> <p>gde je:</p> <ul> <li>\\(N\\) broj gradova.</li> <li>\\(A\\) niz celih brojeva gde \\(i\\)-ti broj predstavlja za\u0161titu vozila koje se nalazi u gradu \\(i\\).</li> <li>\\(M\\) broj puteva.</li> <li>\\(U\\), \\(V\\) i \\(W\\) nizovi du\u017eine \\(M\\) koji opisuju puteve: \\(i\\)-ti put povezuje gradove \\(U_i\\) i \\(V_i\\), dok je koli\u010dina zra\u010denja koju propu\u0161ta za\u0161tita ovog puta \\(W_i\\).</li> <li>\\(R\\) niz u koji treba da upi\u0161ete re\u0161enje za svaki grad.</li> </ul> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq A_i, W_i \\leq 10^9\\)</li> <li>\\(1 \\leq U_i, V_i \\leq N\\)</li> <li>\\(U_i \\neq V_i\\)</li> <li>Postoji najvi\u0161e jedan put koji direktno povezuje neki par gradova.</li> </ul>"},{"location":"takprog/2020_2021/sio/02_marsko/#podzadaci","title":"Podzadaci","text":"<ul> <li>[7 poena]: Sve vrednosti u nizu \\(A\\) su jednake.</li> <li>[7 poena]: Sve vrednosti u nizu \\(W\\) su jednake.</li> <li>[12 poena]: \\(N, M \\leq 250\\).</li> <li>[33 poena]: \\(N, M \\leq 2500\\).</li> <li>[41 poena]: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/sio/02_marsko/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>marsko.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int *A, int M, int *U, int *V, int *W, int *R);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova, ali ne smeju da pristupaju van njihovih granica</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(M\\).</li> <li>U narednom redu niz \\(A\\).</li> <li>U narednih \\(M\\) redova po tri broja. U \\(i\\)-tom redu nalaze se brojevi \\(U_i\\), \\(V_i\\) i \\(W_i\\).</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa niz \\(R\\) koji je funkcija popunila, u jednom redu.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#primeri","title":"Primeri","text":""},{"location":"takprog/2020_2021/sio/02_marsko/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2020_2021/sio/02_marsko/#ulaz","title":"Ulaz","text":"<pre><code>5 7\n7 7 7 7 7\n1 2 3\n1 3 8\n2 5 7\n4 5 10\n1 5 6\n2 3 9\n3 5 8\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#izlaz","title":"Izlaz","text":"<pre><code>3 3 1 1 3\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Vozilom sa za\u0161titom \\(7\\) mogu\u0107e je bezbedno se voziti po prvom, tre\u0107em i petom putu. Iz prvog, drugog i petog grada mogu\u0107e je bezbedno sti\u0107i u prvi, drugi i peti grad. Iz tre\u0107eg i \u010detvrtog grada nije mogu\u0107e bezbedno sti\u0107i u neki drugi grad.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2020_2021/sio/02_marsko/#ulaz_1","title":"Ulaz","text":"<pre><code>5 4\n1 7 8 5 3\n1 3 7\n1 5 7\n3 5 7\n2 4 7\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#izlaz_1","title":"Izlaz","text":"<pre><code>1 2 3 1 1\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Iz prvog, \u010detvrtog i petog grada nije mogu\u0107e bezbedno sti\u0107i u neki drugi grad. Iz drugog grada mogu\u0107e je bezbedno sti\u0107i u drugi i \u010detvrti grad. Iz tre\u0107eg grada mogu\u0107e je bezbedno sti\u0107i u prvi, tre\u0107i i peti grad.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2020_2021/sio/02_marsko/#ulaz_2","title":"Ulaz","text":"<pre><code>5 5\n5 9 6 1 3\n1 5 7\n1 2 4\n2 5 9\n4 3 2\n3 5 6\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#izlaz_2","title":"Izlaz","text":"<pre><code>5 5 3 1 1\n</code></pre>"},{"location":"takprog/2020_2021/sio/02_marsko/#objasnjenje_2","title":"Obja\u0161njenje","text":"<p>Iz prvog grada mogu\u0107e je bezbedno sti\u0107i u drugi grad. Kada u drugom gradu zamenimo vozilo mo\u017eemo bezbedno da stignemo do svih gradova.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#resenje-kada-su-sve-vrednosti-u-nizu-a-jednake","title":"Re\u0161enje kada su sve vrednosti u nizu \\(A\\) jednake","text":"<p>Kako sva vozila imaju istu za\u0161titu, mo\u017eemo da izbacimo puteve kojima Marsko ne mo\u017ee bezbedno da se vozi. Nakon toga mo\u017eemo DFS algoritmom da na\u0111emo povezane komponente i njihove veli\u010dine. Re\u0161enje za svaki grad je veli\u010dina njegove povezane komponente.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#resenje-kada-su-sve-vrednosti-u-nizu-w-jednake","title":"Re\u0161enje kada su sve vrednosti u nizu \\(W\\) jednake","text":"<p>Za svako vozilo va\u017ei da Marsko mo\u017ee bezbedno da se vozi po bilo kom putu ili uop\u0161te ne mo\u017ee bezbedno da se vozi. U prvom slu\u010daju je re\u0161enje veli\u010dina povezane komponente u kojoj se grad nalazi, a u drugom slu\u010daju re\u0161enje je 1. I ovaj podzadatak re\u0161avamo DFS algoritmom.</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#resenje-za-n-m-leq-250","title":"Re\u0161enje za \\(N, M \\leq 250\\)","text":"<p>Za svaki grad \\(i\\) na\u0111imo skup gradova koje Marsko mo\u017ee da poseti krenuv\u0161i iz \\(i\\)-tog grada ako koristi samo vozilo koje je zatekao u po\u010detnom gradu. Napravimo usmereni graf tako \u0161to \u0107emo dodati granu od \\(i\\)-tog grada do svakog grada iz prethodno pomenutog skupa. Re\u0161enje za grad \\(i\\) je broj \u010dvorova koje mo\u017eemo da posetimo krenuv\u0161i od \u010dvora \\(i\\) u usmerenom grafu. Ovaj podzadatak tako\u0111e mo\u017eemo da re\u0161imo primenom DFS algoritma. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N^3)\\).</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#resenje-za-n-m-leq-2500","title":"Re\u0161enje za \\(N, M \\leq 2500\\)","text":"<p>Krenimo iz grada \\(i\\) i pamtimo najve\u0107u vrednost \\(A\\) za gradove koje smo posetili. Ubacimo sve puteve od pose\u0107enih gradova u heap strukturu podataka. Uzmimo put sa najmanjim \\(W\\) i ako je ova vrednost manja od najve\u0107eg \\(A\\) za pose\u0107ene gradove, mo\u017eemo da pre\u0111emo preko tog puta i posetimo novi grad ako ve\u0107 nije pose\u0107en. Ako smo posetili novi grad a\u017euriramo maksimalno \\(A\\) i dodajemo nove puteve na heap. Kada vi\u0161e nemamo puteva ili svi putevi na heap-u imaju preveliku vrednost \\(W\\), prekidamo i pamtimo broj pose\u0107enih \u010dvorova kao re\u0161enje za grad \\(i\\). Ovo re\u0161enje pokre\u0107emo za svaki grad pa je vremenska slo\u017eenost \\(O(NMlogM)\\)</p>"},{"location":"takprog/2020_2021/sio/02_marsko/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Re\u0161enje za neki grad jednako je re\u0161enju grada sa najve\u0107im \\(A_i\\) me\u0111u gradovima koje mo\u017ee da poseti. Posmatrajmo grad \\(i\\) i skup \\(S\\) svih gradova koji ne mogu da posete grad sa ve\u0107im \\(A\\) od svog. Neka je \\(j\\) grad sa najmanjim \\(A\\) me\u0111u gradovima iz skupa \\(S\\) koji mogu da posete grad \\(i\\). Re\u0161enje za \\(i\\) je isto kao re\u0161enje za \\(j\\). Dokaza\u0107emo prethodno tvr\u0111enje tako \u0161to \u0107emo pokazati da \\(i\\) mo\u017ee da poseti \\(j\\). Ako \\(i\\) mo\u017ee da poseti neki grad \\(k\\) sa \\(A_k \\geq A_j\\), mo\u017ee i da poseti \\(j\\) tako \u0161to ode do \\(k\\), pre\u0111e u vozilo iz tog grada, vrati se u \\(i\\) i ode u \\(j\\) obrnutim putem kojim bi se od \\(j\\) do\u0161lo do \\(i\\) (znamo da su na tom putu svi \\(W_e \\leq A_j \\leq A_k\\) jer \\(j\\) ne mo\u017ee da poseti grad sa ve\u0107im \\(A\\)). Ako je \\(A_k &lt; A_j\\) za sve gradove koje \\(i\\) mo\u017ee da poseti, onda postoji grad u skupu \\(S\\) koji mo\u017ee da poseti \\(i\\) i ima manje \\(A\\) nego grad \\(j\\), \u0161to je kontradikcija. Sada znamo da je re\u0161enje za svaki grad jednako re\u0161enju za najmanji grad po vrednosti \\(A\\) u skupu \\(S\\) koji mo\u017ee da poseti taj grad i mo\u017eemo da re\u0161imo zadatak na slede\u0107i na\u010din. Procesirajmo gradove rastu\u0107e po njihovim vrednostima \\(A\\). Kada procesiramo neki grad \\(i\\) dodajemo sve grane \\(e\\) koje imaju \\(W_e\\) manje ili jednako \\(A_i\\). Za svaku povezanu komponentu \u010duvajmo najve\u0107e \\(A\\) za \u010dvorove u njoj. Ako je najve\u0107e \\(A\\) za \u010dvorove u komponenti \u010dvora \\(i\\) jednako \\(A_i\\), \u010dvor \\(i\\) je u skupu \\(S\\) i njegovo re\u0161enje je veli\u010dina povezane komponente. Tako\u0111e je to i re\u0161enje za svaki \u010dvor u ovoj komponenti koji se ve\u0107 nije na\u0161ao u komponenti nekog \u010dvora iz skupa \\(S\\). Mo\u017eemo da odr\u017eavamo ove gradove za svaku komponentu u nizu i da ih prebacujemo iz manje u ve\u0107u komponentu kada se dogodi spajanje dve komponente. Na ovaj na\u010din dobijamo re\u0161enje koje radi u vremenskoj slo\u017eenosti \\(O(NlogN + MlogM)\\).</p> 02_marsko.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=200005;\n\nint edge_order[N],node_order[N];\n\nstruct Component{\n    int size,max_a;\n    vector&lt;int&gt; alive,all_nodes;\n    Component(){}\n    void init(int u,int A){\n        size=1;\n        max_a=A;\n        alive=all_nodes={u};\n    }\n}components[N];\nint my_component[N];\n\nvoid Merge(int a,int b){\n    if(a==b)return;\n\n    if(components[a].size&lt;components[b].size)swap(a,b);\n\n    components[a].size+=components[b].size;\n    components[a].max_a=max(components[a].max_a,components[b].max_a);\n\n    for(int i:components[b].alive){\n        components[a].alive.push_back(i);\n    }\n    for(int i:components[b].all_nodes){\n        components[a].all_nodes.push_back(i);\n        my_component[i]=a;\n    }\n}\n\nvoid Resi(int N, int *A, int M, int *U, int *V, int *W, int *R){\n\n    for(int i=1;i&lt;=M;i++)edge_order[i]=i;\n    sort(edge_order+1,edge_order+1+M,[&amp;](int i,int j){return W[i]&lt;W[j];});\n\n    for(int i=1;i&lt;=N;i++)node_order[i]=i;\n    sort(node_order+1,node_order+1+N,[&amp;](int i,int j){return A[i]&lt;A[j];});\n\n    for(int i=1;i&lt;=N;i++){\n        components[i].init(i,A[i]);\n        my_component[i]=i;\n    }\n\n    int ptr=1;\n    for(int i=1;i&lt;=N;i++){\n        while(ptr&lt;=M &amp;&amp; W[edge_order[ptr]]&lt;=A[node_order[i]]){\n            Merge(my_component[U[edge_order[ptr]]],my_component[V[edge_order[ptr]]]);\n            ptr++;\n        }\n\n        if(components[my_component[node_order[i]]].max_a==A[node_order[i]]){\n\n            for(int j:components[my_component[node_order[i]]].alive){\n                R[j]=components[my_component[node_order[i]]].size;\n            }\n\n            components[my_component[node_order[i]]].alive.clear();\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/sio/03_tacke/","title":"3 - Ta\u010dke","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Dat vam je niz \\(A\\) od \\(N\\) ta\u010daka u koordinatnoj ravni. Data je i ta\u010dka \\(P\\). Potrebno je da odgovorite na \\(Q\\) upita. Svaki upit je opisan sa po dva broja \\(L\\) i \\(R\\). Neka je \\(S\\) skup ta\u010daka \\(\\{A_L, A_{L+1}, \\dots A_R\\}\\). Dozvoljeno je primenjivati slede\u0107u operaciju proizvoljan broj puta: uzeti dve ta\u010dke \\(H\\) i \\(K\\) iz skupa \\(S\\) i u skup dodati jednu od ta\u010daka koje se nalaze na du\u017ei \\(HK\\). Odgovor na upit je <code>Da</code> ako ta\u010dka \\(P\\) mo\u017ee da se na\u0111e u skupu \\(S\\) nakon nula ili vi\u0161e poteza, ili <code>Ne</code> u suprotnom.</p> <p>Obratite pa\u017enju na to da se koordinate ta\u010daka u nizu \\(A\\) mogu poklapati kao i da se koordinate ta\u010dke \\(P\\) mogu poklapati sa koordinatama ta\u010dkaka iz niza \\(A\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Aleksa Milisavljevi\u0107 <p>Odgovor na upit je <code>Da</code> ako se ta\u010dka \\(P\\) nalazi u unutra\u0161njosti ili na konveksnom omota\u010du podniza ta\u010daka od \\(L\\) do \\(R\\) (sa specijalnim slu\u010dajem kada su sve ta\u010dke kolinearne i konveksni omota\u010d je zapravo du\u017e ili jedna ta\u010dka).</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{Resi}(N, Px, Py, X[\\dots], Y[\\dots], Q, L[\\dots], R[\\dots], O[\\dots])\\)</li> </ul> <p>gde je:</p> <ul> <li>\\(N\\) broj ta\u010daka u nizu.</li> <li>\\(Px\\) i \\(Py\\) koordinate ta\u010dke \\(P\\).</li> <li>\\(X\\) i \\(Y\\) nizovi koji opisuju ta\u010dke iz niza \\(A\\): \\(i\\)-ta ta\u010dka ima koordinate \\(X_i\\) i \\(Y_i\\).</li> <li>\\(Q\\) broj upita.</li> <li>\\(L\\) i \\(R\\) nizovi koji opisuju upite.</li> <li>\\(O\\) niz <code>boolean</code> vrednosti u koji za svaki upit treba upisati <code>true</code> ako je odgovor <code>Da</code>, i <code>false</code> ako je odgovor <code>Ne</code>.</li> </ul> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 3 \\times 10^5\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\leq N\\)</li> <li>Sve koordinate su celi brojevi iz intervala \\([-10^9, 10^9]\\)</li> </ul>"},{"location":"takprog/2020_2021/sio/03_tacke/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u 7 podzadataka:</p> <ul> <li>[9 poena]: \\(N, Q \\leq 100\\).</li> <li>[14 poena]: \\(N, Q \\leq 2500\\).</li> <li>[12 poena]: \\(N, Q \\leq 10^5\\), sve ta\u010dke su na X osi, odnosno, \\(Y_i = 0\\), \\(Py = 0\\).</li> <li>[16 poena]: \\(N, Q \\leq 10^5\\), postoje dve prave tako da se svaka ta\u010dka iz niza \\(A\\) nalazi na bar jednoj od njih.</li> <li>[17 poena]: \\(N, Q \\leq 6 \\times 10^4\\), sve koordinate su celi brojevi iz intervala \\([-500, 500]\\).</li> <li>[11 poena]: \\(N, Q \\leq 6 \\times 10^4\\).</li> <li>[21 poena]: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2020_2021/sio/03_tacke/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>tacke.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int Px, int Py, int *X, int *Y, int Q, int *L, int *R, bool *O);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova, ali ne smeju da pristupaju van njihovih granica.</p> <p>Uz zadatak obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\), \\(Px\\) i \\(Py\\).</li> <li>U narednih \\(N\\) redova po dva broja. U \\(i\\)-tom redu nalaze se brojevi \\(X_i\\) i \\(Y_i\\).</li> <li>U narednom redu nalazi se broj \\(Q\\).</li> <li>U narednih \\(Q\\) redova nalazi se po dva broja: \\(L_i\\) i \\(R_i\\).</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa odgovore na upite na standardni izlaz, po jedan u svakom redu. Ako je va\u0161a funkcija upisala <code>true</code> kao vrednost \\(O_i\\), u \\(i\\)-tom redu \u0107e se od\u0161tampati <code>Da</code>, a u suprotnom, u \\(i\\)-tom redu \u0107e se od\u0161tampati <code>Ne</code>.</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#primer","title":"Primer","text":""},{"location":"takprog/2020_2021/sio/03_tacke/#ulaz","title":"Ulaz","text":"<pre><code>5 1 2\n0 0\n0 3\n3 3\n3 0\n0 0\n4\n1 3\n3 5\n2 4\n1 5\n</code></pre>"},{"location":"takprog/2020_2021/sio/03_tacke/#izlaz","title":"Izlaz","text":"<pre><code>Da\nNe\nDa\nDa\n</code></pre>"},{"location":"takprog/2020_2021/sio/03_tacke/#objasnjenje","title":"Obja\u0161njenje","text":"<ol> <li>upit: Po\u010dinjemo od skupa \\(S=\\{(0, 0), (0, 3), (3, 3)\\}\\). Mo\u017eemo da dodamo ta\u010dku \\((1.5, 1.5)\\) koja se nalazi na du\u017ei \\(HK\\) za \\(H=(0, 0)\\) i \\(K=(3, 3)\\). Nakon toga mo\u017eemo da dodamo ta\u010dku \\(P(1, 2)\\) koja se nalazi na du\u017ei \\(HK\\) za \\(H=(1.5, 1.5)\\) i \\(K=(0, 3)\\), pa je odgovor <code>Da</code>.</li> <li>upit: Po\u010dinjemo od skupa \\(S=\\{(3, 3), (3, 0), (0, 0)\\}\\). Nikako nije mogu\u0107e dodati ta\u010dku \\(P\\), pa je odgovor <code>Ne</code>.</li> <li>upit: Po\u010dinjemo od skupa \\(S=\\{(0, 3), (3, 3), (3, 0)\\}\\). Ta\u010dka \\(P(1, 2)\\) se nalazi na du\u017ei \\(HK\\) za \\(H=(0, 3)\\) i \\(K=(3, 0)\\), pa je odgovor <code>Da</code>.</li> <li>upit: Mo\u017eemo dodati ta\u010dku \\(P\\) na isti na\u010din kao kod prvog upita, pa je odgovor <code>Da</code>.</li> </ol>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-kada-je-n-q-leq-100","title":"Re\u0161enje kada je \\(N, Q \\leq 100\\)","text":"<p>Za svaki upit mo\u017eemo u \\(O(N^2)\\) da na\u0111emo konveksni omota\u010d i proverimo da li se ta\u010dka \\(P\\) nalazi unutar ili na omota\u010du. Vremenska slo\u017eenost je \\(O(QN^2)\\).</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-kada-je-n-q-leq-2500","title":"Re\u0161enje kada je \\(N, Q \\leq 2500\\)","text":"<p>Re\u0161enje je isto kao za pro\u0161li podzadatak samo \u0161to je potreban efikasniji algoritam za nala\u017eenje konveksnog omota\u010da. Sa algoritmom u \\(O(NlogN)\\) dobijamo vremensku slo\u017eenost \\(O(QNlogN)\\).</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-kada-je-n-q-leq-105-i-sve-tacke-su-na-x-osi","title":"Re\u0161enje kada je \\(N, Q \\leq 10^5\\) i sve ta\u010dke su na X osi.","text":"<p>Konveksni omota\u010d je zapravo du\u017e na \\(X\\) osi pa su nam bitne ta\u010dka sa najmanjom i ta\u010dka sa najve\u0107om X koordinatom za svaki upit. Ako za pronala\u017eenje minimuma i maksimuma koristimo segmentno stablo dobijamo vremensku slo\u017eenost \\(O(QlogN)\\).</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-kada-je-n-q-leq-105-i-postoje-dve-prave-tako-da-se-svaka-tacka-iz-niza-a-nalazi-na-bar-jednoj-od-njih","title":"Re\u0161enje kada je \\(N, Q \\leq 10^5\\) i postoje dve prave tako da se svaka ta\u010dka iz niza \\(A\\) nalazi na bar jednoj od njih","text":"<p>Uzmimo 3 razli\u010dite ta\u010dke. Bar jedan od 3 para ovih ta\u010daka se sigurno nalazi na istoj pravoj. Isprobajmo sva tri para i proverimo da li su sve ta\u010dke koje nisu kolinearne sa trenutnim parom me\u0111usobno kolinearne. Na ovaj na\u010din \u0107emo na\u0107i dve prave koje sadr\u017ee sve ta\u010dke iz niza. Za svaki upit bitne su nam samo ekstremen ta\u010dke na ovim pravama i njih mo\u017eemo brzo da na\u0111emo za svaki upit uz pomo\u0107 segmentnog stabla. Na ovaj na\u010din dobijamo konveksni omota\u010d sa najvi\u0161e 4 ta\u010dke i jednostavno mo\u017eemo da proverimo da li se ta\u010dka \\(P\\) nalazi u njemu. Vremenska slo\u017eenost ovog algoritma je \\(O(QlogN)\\).</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-kada-je-n-q-leq-6-times-104-i-sve-koordinate-su-celi-brojevi-iz-intervala-500-500","title":"Re\u0161enje kada je \\(N, Q \\leq 6 \\times 10^4\\) i sve koordinate su celi brojevi iz intervala \\([-500, 500]\\)","text":"<p>Za skup ta\u010daka sa celobrojnim koordinatama u kvadratu dimenzija \\(M \\times M\\) najve\u0107i broj ta\u010daka na konveksnom omota\u010du je oko \\(M^{2/3}\\). Re\u0161enje za ovaj podzadatak je da \u010duvamo konveksne omota\u010de u svakom \u010dvoru segmentnog stabla i radimo njihova spajanja. Vremenska slo\u017eenost je \\(O(QlogNM^{2/3})\\). Ovo re\u0161enje tako\u0111e prolazi i sve prethodne podzadatke.</p>"},{"location":"takprog/2020_2021/sio/03_tacke/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Za sako \\(i\\) na\u0111imo najmanju granicu \\(G_i\\) tako da se ta\u010dka \\(P\\) nalazi u konveksnom omota\u010du podniza od \\(i\\) do \\(G_i\\). Ako ne postoji takav podniz uze\u0107emo \\(G_i=N+1\\). Primetimo da je niz \\(G_i\\) neopadaju\u0107i, pa ga mo\u017eemo na\u0107i primenom two pointers tehnike. Potrebna nam je jo\u0161 struktura podataka koja podr\u017eava operacije ubacivanja i izbacivanja ta\u010daka i odgovara na pitanje da li je ta\u010dka \\(P\\) unutar konveksnog omota\u010da. Posmatrajmo slu\u010daj kada se ta\u010dka \\(P\\) nalazi u konveksnom omota\u010du nekog skupa ta\u010daka. Za svaku pravu koja prolazi kroz \\(P\\), postoje dve ta\u010dke koje su sa razli\u010ditih strana te prave, ili postoji ta\u010dka koja je na toj pravoj. Postmatrajmo sada sl\u010daj kada ta\u010dka \\(P\\) nije u konveksnom omota\u010du nekog skupa ta\u010daka. U ovom slu\u010daju postoji prava koja prolazi kroz \\(P\\) takva da su sve ta\u010dke iz skupa sa jedne njene strane. Posmatrajmo ta\u010dke iz ovog skupa sortirane kru\u017eno po uglu oko \\(P\\). Ako postoji prava takva da su sve ta\u010dke sa jedne njene strane postoji ugao ve\u0107i od 180 stepeni izme\u0111u dve susedne ta\u010dke, a u suprotnom ne postoji. Sada mo\u017eemo da odgovaramo na pitanja da li se ta\u010dka \\(P\\) nalazi u konveksnom omota\u010du skupa ta\u010daka i da podr\u017eimo ubaivanje i izbacivanje ta\u010daka tako \u0161to dr\u017eimo ta\u010dke u \\(\\text{std::set}\\)-u sortirane po uglu. Ta\u010dke mo\u017eemo da poredimo po uglu ako gledamo u kojem kvadrantu se nalaze i ako gledamo znak vektorskog proizvoda za ta\u010dke u istom kvadrantu. Kada ubacujemo ta\u010dku dve ta\u010dke prestaju da budu susedne i dobijamo nova dva para susednih ta\u010daka pa treba da a\u017euriramo informaciju o tome da li postoji ugao ve\u0107i od 180 stepeni. Sli\u010dno tako kod izbacivanja ta\u010dke izbacujemo dva para iz razmatranja i ubacujemo jedan. Jedan izuzetak na koji treba paziti je slu\u010daj kada se neka ta\u010dka poklapa sa \\(P\\) i mo\u017eemo da \u010duvamo informaciju o broju takvih ta\u010daka i da ih ne ubacujemo u \\(\\text{std::set}\\). Kada uz pomo\u0107 ove strukture uradimo two pointers i na\u0111emo granice \\(G_i\\), na upite lako mo\u017eemo odgovoriti upore\u0111ivanjem \\(G_{L_i}\\) i \\(R_i\\). Vremenska slo\u017eenost ovog re\u0161enja je \\(O(NlogN)\\)</p> 03_tacke.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n\nstruct pt{\n    ll x,y;\n    pt(){}\n    pt(ll a,ll b):x(a),y(b){}\n};\n\npt operator - (pt a,pt b){return pt(a.x-b.x,a.y-b.y);}\nll cross(pt a,pt b){return a.x*b.y-a.y*b.x;}\nint part(pt a){return (a.y&gt;0||(a.y==0&amp;&amp;a.x&gt;0))?0:1;}\nbool operator &lt; (pt a,pt b){\n    return mp(part(a),(ll)0)&lt;mp(part(b),cross(a,b));\n}\nbool operator == (pt a,pt b){return mp(a.x,a.y)==mp(b.x,b.y);}\n\nmap&lt;pt,int&gt; pts;\nint cntZero=0,badAngles=0;\n\nbool bad(pt a,pt b){\n    ll c=cross(a,b);\n    if(c&lt;0)return true;\n    //if(c==0&amp;&amp;part(a)==part(b)){\n    //  if(b&lt;a)return true;\n    //}\n    return false;\n}\n\nvoid Add(pt a,pt b){\n    //printf(\"Add (%lld %lld) (%lld %lld)\\n\",a.x,a.y,b.x,b.y);\n    if(bad(a,b))badAngles++;\n}\n\nvoid Del(pt a,pt b){\n    //printf(\"Del (%lld %lld) (%lld %lld)\\n\",a.x,a.y,b.x,b.y);\n    if(bad(a,b))badAngles--;\n}\n\nvoid Add(pair&lt;pt,int&gt; a,pair&lt;pt,int&gt; b){\n    Add(a.first,b.first);\n}\n\nvoid Del(pair&lt;pt,int&gt; a,pair&lt;pt,int&gt; b){\n    Del(a.first,b.first);\n}\n\nmap&lt;pt,int&gt;::iterator getPrev(map&lt;pt,int&gt;::iterator it){\n    if(it==pts.begin())return prev(pts.end());\n    else return prev(it);\n}\n\nmap&lt;pt,int&gt;::iterator getNext(map&lt;pt,int&gt;::iterator it){\n    if(next(it)==pts.end())return pts.begin();\n    else return next(it);\n}\n\nvoid AddPoint(pt a){\n    //printf(\"AddPt (%lld %lld)\\n\",a.x,a.y);\n    if(a==pt(0,0)){\n        cntZero++;\n        return;\n    }\n    pts[a]++;\n    auto it=pts.find(a);\n    if(pts[a]==1){\n        if(pts.size()&gt;2)Del(*getPrev(it),*getNext(it));\n        if(pts.size()&gt;1)Add(*getPrev(it),*it);\n        if(pts.size()&gt;1)Add(*it,*getNext(it));\n    }\n}\n\nvoid DelPoint(pt a){\n    //printf(\"DelPt (%lld %lld)\\n\",a.x,a.y);\n    if(a==pt(0,0)){\n        cntZero--;\n        return;\n    }\n    pts[a]--;\n    auto it=pts.find(a);\n    if(pts[a]==0){\n        if(pts.size()&gt;1)Del(*getPrev(it),*it);\n        if(pts.size()&gt;1)Del(*it,*getNext(it));\n        if(pts.size()&gt;2)Add(*getPrev(it),*getNext(it));\n        pts.erase(it);\n    }\n}\n\nbool IsOk(){\n    return cntZero==0&amp;&amp;(pts.size()&lt;=1||badAngles&gt;0);\n}\n\nvoid Resi(int N, int Px, int Py, int *X, int *Y, int Q, int *L, int *R, bool *O){\n    assert(1&lt;=N &amp;&amp; N&lt;=300000);\n    assert(1&lt;=Q &amp;&amp; Q&lt;=300000);\n    assert(-1000000000&lt;=Px &amp;&amp; Px&lt;=1000000000);\n    assert(-1000000000&lt;=Py &amp;&amp; Py&lt;=1000000000);\n    for(int i=1;i&lt;=N;i++){\n        assert(-1000000000&lt;=X[i] &amp;&amp; X[i]&lt;=1000000000);\n        assert(-1000000000&lt;=Y[i] &amp;&amp; Y[i]&lt;=1000000000);\n    }\n    for(int i=1;i&lt;=Q;i++){\n        assert(1&lt;=L[i] &amp;&amp; L[i]&lt;=R[i] &amp;&amp; R[i]&lt;=N);\n    }\n    pt P(Px,Py);\n    vector&lt;int&gt; ptr(N+1,0);\n    for(int i=1;i&lt;=N;i++){\n        int j=ptr[i-1];\n        while(j&lt;=N&amp;&amp;IsOk()){\n            j++;\n            if(j&lt;=N)AddPoint(pt(X[j],Y[j])-P);\n        }\n        ptr[i]=j;\n        //printf(\"%i %i badAngles:%i cntZero:%i : \",i,j,badAngles,cntZero);\n        //for(auto p:pts)printf(\"(%lld %lld) \",p.x,p.y);printf(\"\\n\");\n        DelPoint(pt(X[i],Y[i])-P);\n    }\n    for(int i=1;i&lt;=Q;i++){\n        //printf(\"%i: %i %i\\n\",i,ptr[L[i]],R[i]);\n        if(ptr[L[i]]&lt;=R[i])O[i]=true;\n        else O[i]=false;\n    }\n}\n</code></pre>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/","title":"4 - Izvla\u010denje slamki","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Pavle i Aleksa se igraju sa slamkama. One su pore\u0111ane u niz i njihove pozicije su numerisane brojevima od \\(1\\) do \\(N\\) sleva nadesno. Sve slamke su razli\u010ditih celobrojnih du\u017eina od \\(1\\) do \\(N\\). </p> <p>Oti\u0161li su kod proroka Mikija da im ka\u017ee kako \u0107e se njihova igra odvijati. On im je rekao da \u0107e biti \\(M\\) de\u0161avanja za redom, i svako od njih \u0107e biti u jednom od dva tipa:</p> <p>\\(1\\) \\(l_i\\) \\(r_i\\) - Aleksa ima priliku da prome\u0161a slamke (promeni im redosled) na pozicijama od \\(l_i\\) do \\(r_i\\) kako god \u017eeli;</p> <p>\\(2\\) \\(x_i\\) - Pavle izvla\u010di slamku na poziciji \\(x_i\\) i odmah je vrati na isto mesto.</p> <p>Svi znaju da, pri izvla\u010denju slamke, nikako ne \u017eelimo da izvu\u010demo najkra\u0107u slamku. Po\u0161to Pavle nema slobodu koju slamku \u0107e izvu\u0107i (prorok Miki je uvek u pravu), a Aleksa ima slobodu u me\u0161anju slamki, on \u017eeli da koristi svoje prilike za me\u0161anje da namesti Pavlu da \u0161to vi\u0161e puta izvu\u010de najkra\u0107u slamku. Odredite koliko je najvi\u0161e puta mogu\u0107e da on to uradi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Slamke(N, A[\\ldots], M, T[\\ldots], X[\\ldots], Y[\\ldots])\\)</li> </ul> <p>gde je \\(N\\)  broj koji predstavlja broj slamki,  niz \\(A\\), du\u017eine \\(N\\) predstavlja du\u017eine slamki sa leva na desno.  Broj \\(M\\) predstavlja broj de\u0161avanja, dok nizovi \\(T\\), \\(X\\) i \\(Y\\) opisuju de\u0161avanja hronolo\u0161kim redosledom. Ukoliko va\u017ei \\(T[i] = 1\\), zna\u010di da je \\(i\\)-to de\u0161avanje me\u0161anje slamki, pa \\(X[i]\\) i \\(Y[i]\\) predstavljaju levu i desnu granicu intervala koji se me\u0161a. Ukoliko va\u017ei \\(T[i] = 2\\), zna\u010di da je \\(i\\)-to de\u0161avanje izvla\u010denje slamke, pa \\(X[i]\\) predstavlja indeks izvu\u010dene slamke. U tom slu\u010daju va\u017ei\u0107e \\(Y[i] = 0\\).  Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#primer","title":"Primer","text":"<p>Neka su \\(N=6\\) i \\(M = 4\\), i neka su nizovi \\(A=\\{3, 1, 4, 6, 5, 2\\}\\), \\(T=\\{1, 2, 1, 2\\}\\), \\(X=\\{ 2, 5, 4, 5\\}\\) i \\(Y=\\{4, 0, 6, 0\\}\\): Nakon prvog me\u0161anja nije mogu\u0107e namestiti najkra\u0107u slamku na poziciju \\(5\\), ali posle drugog jeste, pa je rezultat \\(1\\). </p> <p>Neka su \\(N=4\\) i \\(M = 4\\), i neka su nizovi \\(A=\\{4, 3, 2, 1\\}\\), \\(T=\\{1, 2, 2, 2\\}\\), \\(X=\\{ 1, 1, 1, 3\\}\\) i \\(Y=\\{4, 0, 0, 0\\}\\): Posle prvog me\u0161anja mogu\u0107e je staviti slamku bilo gde, ali ne istovremeno i na poziciju \\(1\\) i poziciju \\(3\\). Od te dve opcije bolja je opcija \\(1\\), jer nju izvla\u010di dvaput, pa je rezultat \\(2\\).</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 3\\cdot10^5\\)</li> <li>\\(1 \\leq A_i \\leq N\\)</li> <li>Svi elementi niza \\(A_i\\) razli\u010diti. </li> <li>\\(T_i \\in \\{1, 2\\}\\)</li> <li>Ukoliko \\(T_i = 1\\), va\u017ei \\(1 \\leq X_i \\leq Y_i \\leq N\\).</li> <li>Ukoliko \\(T_i = 2\\), va\u017ei \\(1 \\leq X_i \\leq N\\), \\(Y_i = 0\\).</li> </ul>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[14 poena]: Sva de\u0161avanja tipa \\(1\\) se de\u0161avaju pre svakog de\u0161avanja tipa \\(2\\).</li> <li>[9 poena]: \\(M \\leq 20\\) i ukoliko \\(T_i = 1\\), va\u017ei \\(Y_i - X_i = 1\\).</li> <li>[13 poena]: Ukoliko \\(T_i = 1\\), va\u017ei \\(Y_i - X_i = 1\\).</li> <li>[15 poena]: \\(N, M \\leq 5000\\).</li> <li>[13 poena]: \\(M \\leq 10000\\).</li> <li>[36 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>izvlacenje_slamki.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Slamke(int N, int* A, int M, int* T, int* X, int* Y);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\).</li> <li>U drugom redu \\(N\\) brojeva, niz \\(A\\).</li> <li>U tre\u0107em redu broj \\(M\\).</li> <li>U narednih \\(M\\) redova po tri broja u svakom redu, \\(T_i\\) \\(X_i\\) \\(Y_i\\).</li> </ul> <p>Obratite pa\u017enju da se broj \\(Y_i\\) u\u010ditava i kada je u pitanju de\u0161avanje drugog tipa. Tada je potrebno da mu vrednost bude \\(0\\). </p> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa rezultat koji je vratila va\u0161a funkcija.</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadatak-1","title":"Podzadatak 1","text":"<p>Za ovaj podzadatak, potrebno je na\u0107i poziciju sa koje se najvi\u0161e puta izvla\u010di slamka, a da je mogu\u0107e staviti najkra\u0107u slamku na tu poziciju. Potrebno je, dakle, samo na\u0107i interval na kojem mo\u017ee zavr\u0161iti najkra\u0107a slamka. Na po\u010detku je taj interval jednak samo njenoj po\u010detnoj poziciji, dok svakim novim me\u0161anjem taj interval se mo\u017ee pro\u0161iriti, ukoliko se makar i malo preklapa sa intervalom me\u0161anja. Vremenska i memorijska slo\u017eenost: \\(O(N+M)\\).</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadatak-2","title":"Podzadatak 2","text":"<p>Za svako me\u0161anje, mo\u017eemo fiksirati da li se menja mesto dvema slamkama na intervalu me\u0161anja. Svaku kombinaciju simuliramo i uzmemo najbolje re\u0161enje. Memorijska slo\u017eenost: \\(O(N+M)\\), vremenska slo\u017eenost: \\(O(2^M\\cdot M + N)\\).</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadatak-3","title":"Podzadatak 3","text":"<p>Ovaj podzadatak ima re\u0161enje veoma sli\u010dno podzadatku \\(4\\), ali ga je lak\u0161e zamisliti, pa je slu\u017eio kao pomo\u0107 takmi\u010darima da do\u0111u do boljeg re\u0161enja. Pogledati re\u0161enje \u010detvrtog podzadatka.</p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadatak-4","title":"Podzadatak 4","text":"<p>Ozna\u010dimo sa \\(dp_{i, j}\\) maksimalno re\u0161enje ako se posle \\(j\\) doga\u0111aja najkra\u0107a slamka nalazi na poziciji \\(i\\). Na po\u010detku va\u017ei \\(dp_{i, 0} = -\\infty\\) (dovoljno mali negativan broj), za svako \\(i\\) na kojem se ne nalazi najkra\u0107a slamka, dok va\u017ei \\(dp_{i, 0} = 0\\), za \\(i\\) koje je po\u010detna pozicija najkra\u0107e slamke. Sada je potrebno da na\u0111emo rekurzivnu vezu. Postoja\u0107e dva slu\u010daja, za dva razli\u010dita tipa doga\u0111aja:</p> <p>\\(1\\) \\(l\\) \\(r\\): \\(dp_{i, j} = max\\{dp_{l, j-1}, dp_{l+1, j-1}, \\ldots, dp_{r, j-1}\\}\\), ukoliko \\(i \\in [l, r]\\). U suprotnom \\(dp_{i, j} = dp_{i, j-1}\\). Dakle, bilo koja pozicija na intervalu mo\u017ee do\u0107i sa bilo koje druge pozicije na intervalu, a optimalno je da uzmemo sa maksimalne.</p> <p>\\(2\\) \\(x\\): \\(dp_{x, j} = dp_{x, j-1} + 1\\), a \\(dp_{i, j} = dp_{i, j-1}\\) ukoliko \\(i \\neq x\\).  Jedino se pove\u0107ava slu\u010daj kad se ba\u0161 tu nalazi najkra\u0107a slamka, ostale se ne menjaju.</p> <p>Memorijska slo\u017eenost: \\(O(NM)\\) (mo\u017ee i \\(O(N)\\)), vremenska slo\u017eenost: \\(O(NM)\\). </p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#podzadatak-5","title":"Podzadatak 5","text":"<p>\u010cuvajmo \\(dp_i\\) za svaki doga\u0111aj \\(i\\) koji je drugog tipa. Tu \u010duvamo najbolje re\u0161enje ako je Pavle u tom trenutku izvukao najkra\u0107u slamku. Kako bismo izra\u010dunali ovu vrednost potrebno je da vidimo odakle smo sve mogli da do\u0111emo. Kre\u0107emo se unazad kroz doga\u0111aje i odr\u017eavamo interval odakle smo mogli da do\u0111emo na poziciju slamke koju je Pavle izvukao u doga\u0111aju \\(i\\), sli\u010dno re\u0161enju prvog podzadatka. Svaki put kada nai\u0111emo na doga\u0111aj \\(j\\) oblika \\(2\\), ako je u intervalu od kojeg smo mogli da do\u0111emo, uradimo operaciju \\(dp_i = max(dp_i, dp_j+1)\\). Krajnje re\u0161enje nam je maksimum celog niza \\(dp\\). Memorijska slo\u017eenost: \\(O(M)\\), vremenska slo\u017eenost: \\(O(M^2+N)\\). </p>"},{"location":"takprog/2020_2021/sio/04_izvlacenje_slamki/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Veoma sli\u010dno re\u0161enju podzadatka \\(4\\), idemo kroz de\u0161avanja jedno po jedno i odr\u017eavamo niz \\(dp_i\\), za do sada pre\u0111ene doga\u0111aje, koje je najbolje re\u0161enje, ako se trenutno najkra\u0107a slamka nalazi na poziciji \\(i\\). Ovaj niz mo\u017eemo odr\u017eavati po rekurentnim vezama iz \\(4\\) podzadatka, koriste\u0107i segmentno stablo sa lenjom propagacijom, koje ima operacije: na\u0111i maksimum na intervalu i postavi ceo interval na neku vrednost. Doga\u0111aj jedan se pokriva operacijom postavi interval na maksimum na intervalu, dok se doga\u0111aj dva pokriva operacijom postavi interval \\([x, x]\\) na vrednost od \\(dp_x+1\\). Memorijska slo\u017eenost: \\(O(N)\\), vremenska slo\u017eenost: \\(O(MlogN+N)\\). </p> 04_izvlacenje_slamki.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 300010\nusing namespace std;\n///\n#define INF 1000000000\n#define mid (l+r)/2\nint dp[MAXN], seg[4*MAXN], lazy[4*MAXN];\nvoid init(int node, int l, int r) {\n    if(l == r) {\n        seg[node] = dp[l];\n        lazy[node] = INF;\n        return;\n    }\n    init(2*node, l, mid); init(2*node+1, mid+1, r);\n    seg[node] = max(seg[2*node], seg[2*node+1]);\n    lazy[node] = INF;\n}\nvoid propagate(int node, int l, int r) {\n    if(lazy[node] != INF) {\n        seg[node] = lazy[node];\n        if(l != r) {\n            lazy[2*node] = lazy[node];\n            lazy[2*node+1] = lazy[node];\n        }\n        lazy[node] = INF;\n    }\n}\nint query(int node, int l, int r, int L, int R) {\n    propagate(node, l, r);\n    if(L &lt;= l &amp;&amp; r &lt;= R) return seg[node];\n    if(r &lt; L || r &lt; l || R &lt; l || R &lt; L) return -INF;\n    return max(query(2*node, l, mid, L, R), query(2*node+1, mid+1, r, L, R));\n}\nvoid update(int node, int l, int r, int L, int R, int val) {\n    propagate(node, l, r);\n    if(L &lt;= l &amp;&amp; r &lt;= R) {\n        lazy[node] = val;\n        propagate(node, l, r);\n        return;\n    }\n    if(r &lt; L || r &lt; l || R &lt; l || R &lt; L) return;\n    update(2*node, l, mid, L, R, val); update(2*node+1, mid+1, r, L, R, val);\n    seg[node] = max(seg[2*node], seg[2*node+1]);\n}\nint Slamke(int N, int* A, int M, int* T, int* X, int* Y) {\n    int idxx = -1;\n    for(int i = 1; i &lt;= N; i++) {\n        if(A[i] == 1) dp[i] = 0;\n        else dp[i] = -INF;\n    }\n    init(1, 1, N);\n    for(int i = 1; i &lt;= M; i++) {\n        if(T[i] == 1) {\n            int maxx = query(1, 1, N, X[i], Y[i]);\n            update(1, 1, N, X[i], Y[i], maxx);\n        } else {\n            int maxx = query(1, 1, N, X[i], X[i]);\n            update(1, 1, N, X[i], X[i], maxx+1);\n        }\n    }\n    return query(1, 1, N, 1, N);\n}\n/*\nint A[MAXN], T[MAXN], X[MAXN], Y[MAXN];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int N; cin &gt;&gt; N;\n    for(int i = 1; i &lt;= N; i++) cin &gt;&gt; A[i];\n    int M; cin &gt;&gt; M;\n    for(int i = 1; i &lt;= M; i++) cin &gt;&gt; T[i] &gt;&gt; X[i] &gt;&gt; Y[i];\n    cout &lt;&lt; Slamke(N, A, M, T, X, Y) &lt;&lt; endl;\n    return 0;\n}\n*/\n</code></pre>"},{"location":"takprog/2020_2021/sio/05_xorko/","title":"5 - Xorko","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Poznati junak iz poznatog modernog superherojskog stripa \"Bitovske operacije protiv Muse Kesed\u017eije\", Ksorko, je u najnovijem poglavlju upao u nezgodnu klopku i sada mu je \u017eivot u velikoj opasnosti! Me\u0111utim, kako to obi\u010dno biva u stripovima edukativnog karaktera, on se mo\u017ee izvu\u0107i i to samo uz va\u0161u pomo\u0107!</p> <p>Ksorko pred sobom ima niz nenegativnih celih brojeva \\(A_1,A_2\\cdots,A_N\\) du\u017eine \\(N\\). Kako je Musa zapovedio, Ksorko mo\u017ee da menja elemente ovog niza po slede\u0107em pravilu: u jednom potezu bira prirodan broj \\(1&lt;i&lt;N\\) i menja vrednosti brojeva \\(A_{i-1}\\) i \\(A_{i+1}\\) u \\((A_{i-1}\\text{ xor }A_i)\\) i \\((A_{i+1}\\text{ xor }A_i)\\) redom, gde \\(\\text{xor}\\) predstavlja operaciju bitovske ekskluzije. Kako njemu treba vrlo jak niz da bi pobegao, on \u017eeli da primeni datu operaciju neki broj puta tako da dobijeni niz bude leksikografski najve\u0107i mogu\u0107i.</p> <p>Vi, kao verni obo\u017eavaoci ovog stripa, nestrpljivo \u010dekate slede\u0107e poglavlje, koje ne\u0107e iza\u0107i dok neko ne re\u0161i Ksorkov problem. Stoga, na vama je da spasete Ksorka i omogu\u0107ite nastavak ovoj epskoj pri\u010di.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2020_2021/sio/05_xorko/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(LexMax(N, A[\\ldots], B[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj koji predstavlja broj elemenata Ksorkovog niza, a taj niz je upravo \\(A\\). U niz \\(B\\) du\u017eine \\(N\\) treba da upi\u0161ete vrednosti brojeva koji \u0107e se nalaziti u Ksorkovom nizu na kraju. Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#primer","title":"Primer","text":"<p>Neka je \\(N=3\\), i neka je niz \\(A=\\{1,3,2\\}\\): tada jedina operacija koju mo\u017eemo da izvr\u0161imo je da izaberemo \\(i=2\\) i zamenimo  \\(1\\) i \\(2\\) sa \\((1 \\text{ xor } 3)=2\\) i \\((2 \\text{ xor } 3)=1\\). Time dobijamo leksikografski ja\u010di niz niz \\(\\{2,3,1\\}\\). Ako primenimo operaciju opet, vra\u0107amo se u po\u010detno stanje pa trea vratiti \\(B=\\{2,3,1\\}\\).</p> <p>Neka je \\(N=5\\), i neka je niz \\(A=\\{31,31,31,31,31\\}\\). Primenom bilo kakvih operacija na ovaj niz nije mogu\u0107e dobiti ve\u0107i niz, pa treba vratiti \\(B=\\{31,31,31,31,31\\}\\).</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 150.000\\)</li> <li>\\(0 \\leq A_i \\leq 10^{18}\\)</li> </ul>"},{"location":"takprog/2020_2021/sio/05_xorko/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[6 poena]: \\(N\\leq10\\), \\(A_i\\leq 1\\)</li> <li>[7 poena]: \\(N\\leq10\\), \\(A_i\\leq 63\\)</li> <li>[12 poena]: \\(A_i\\leq1\\)</li> <li>[21 poena]: \\(N\\leq3000\\)</li> <li>[22 poena]: \\(A_i\\leq15\\)</li> <li>[32 poena]:  Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2020_2021/sio/05_xorko/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>xorko.cpp</code>  koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void LexMax(int N, int* A, int* B);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\).</li> <li>U narednom redu \\(N\\) nenegativnih celih broja \\(A_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa \\(N\\) brojeva koje predstavljaju re\u0161enje koje vrati funkcija.</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#napomena","title":"Napomena","text":"<p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa  <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola  <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in {1, \\ldots, k }\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\ y\\).</p> <p>Ka\u017eemo da je niz \\(P\\) leksikografski manji od niza \\(Q\\) iste du\u017eine ako va\u017ei da je \\(P_i &lt; Q_i\\) za najmanje \\(i\\) za koje je \\(P_i \\neq Q_i\\).</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#nleq10a_ileq1","title":"\\(N\\leq10,A_i\\leq1\\)","text":"<p>Primetimo da ima najvi\u0161e \\(2^{10}\\) mogu\u0107ih kombinacija (svaki broj mo\u017ee biti \\(1\\) ili \\(0\\)). Sada naprosto ru\u010dno bektrekom pretra\u017eimo sva mogu\u0107a stanja do kojih mo\u017eemo sti\u0107i obra\u0107aju\u0107i pa\u017enju da nijedno stanje ne pose\u0107ujemo vi\u0161e puta. Ukupna slo\u017eenost \\(O(2^N\\cdot N)\\).</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#nleq10a_ileq63","title":"\\(N\\leq10,A_i\\leq63\\)","text":"<p>Ovaj podzadatak je sli\u010dan prethodnom, ali sa op\u0161tim brojevima. Naime, isto re\u0161enje bektrekom (mada sa malo komplikovanijom proverom stanja - npr. nekom he\u0161 funkcijom), \u0107e u ovom podzadatku raditi u slo\u017eenosti \\(O(N!\\cdot N)\\), jer zapravo postoji postoji najvi\u0161e \\(N!\\) mogu\u0107ih stanja niza. Dokaz ovoga predstavljamo u narednim podzadacima.</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#nleq3000","title":"\\(N\\leq3000\\)","text":"<p>Primetimo slede\u0107e: Neka su \\(P[i]\\) prefiksni bitovski ksorovi niza \\(A\\) (zna\u010di \\(P[i]=A[1]\\text{ xor }A[2]\\text{ xor }\\cdots\\text{ xor }A[i]\\)). Sada ako izvr\u0161imo operaciju iz teksta zadatka na element \\(i\\), primetimo da to zameni vrednosti \\(P[i-1]\\) i \\(P[i]\\). Zaista, ako krenemo da ra\u010dunamo nove vrednosti</p> \\[ P'[i-1]=A[1]\\text{ xor }A[2]\\text{ xor }\\cdots\\text{ xor }A[i-1]\\text{ xor }A[i]=P[i] \\] \\[ P'[i]=A[1]\\text{ xor }A[2]\\text{ xor }\\cdots\\text{ xor }A[i-1]\\text{ xor }A[i]\\text{ xor }A[i]=P[i-1] \\] <p>dok sve ostale vrednosti niza \\(P[i]\\) ostaju nepromenjene jer se dejstvo na elemente \\(A[i-1]\\) i \\(A[i+1]\\) skrati (ili uop\u0161te ne uti\u010de). Primetimo sada da mo\u017eemo na proizvoljan na\u010din da ispermtujemo prvih \\(N-1\\) prefiksnih ksorova ovog niza, i kako za dati niz prefiksnih ksorova mo\u017eemo na jedinstven na\u010din rekonstruisati niz (\\(A[i]=P[i]\\text{ xor }P[i-1]\\)), takvi nizovi koji se dobiju tim permutovanjem prefiksnih ksorova su upravo i jedini nizovi koje je mogu\u0107e dobiti (odakle i sledi da je najve\u0107i broj razli\u010ditih nizova koje mogu\u0107e dobiti \\((N-1)!\\)).  Sada kad smo ovo uo\u010dili smo skoro pa gotovi sa ovim podzadatkom. Naime, treba pohlepno birati permutaciju prefiksnih ksorova tako da se dobije leksikografski najve\u0107i niz. U svakom trenutku pro\u0111emo kroz ostale prefiksne ksorove koji su nam ostali i naprosto izaberemo onaj koji nam daje najve\u0107i ksor sa prethodno izabranim. Obratiti posebnu pa\u017enju na poslednji prefiksni ksor, koji se ne mo\u017ee menjati. Slo\u017eenost \\(O(N^2)\\).</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#a_ileq1","title":"\\(A_i\\leq1\\)","text":"<p>Sa opservacijama iz prethodnog podzadatka, ovde se mo\u017ee smisliti relativno lako re\u0161enje oblika: pohlepno uzimamo alterniraju\u0107e prefiksne ksorove koji su \\(1\\) i \\(0\\) alterniraju\u0107e dok nam nekih ne ponestane.</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#a_ileq15","title":"\\(A_i\\leq15\\)","text":"<p>Ovaj podzadatak (a i poslednji), se oslanja na to da se ubrza pohlepno tra\u017eenje narednog \u010dlana u \\(N\\leq3000\\) re\u0161enju. Ovde po\u0161to nam je samo bitna vrednost prefiksnog ksora, koja je do \\(15\\), pa onda je dovoljno da samo imamo \\(count\\) niz koji broji koliko imamo koje vrednosti me\u0111u prefiksnim sumama i onda pro\u0111emo kroz sve mogu\u0107e vrednosti slede\u0107eg \u010dlana i izaberemo onu optimalnu. Slo\u017eenost \\(O(N\\cdot\\max A_i)\\)</p>"},{"location":"takprog/2020_2021/sio/05_xorko/#puno-resenje","title":"Puno re\u0161enje","text":"<p>Ubacimo sve prefiksne ksorove u binarni trie. Naime, zapi\u0161imo svaki taj broj kao njegov binarni zapis tako da ima ta\u010dno \\(60\\) cifara (sa potencijalnim vode\u0107im nulama). Sada sve te vrednosti ubacimo u na\u0161 trie. Sada za tako pripremljenu strukturu, mogu\u0107e je vrlo brzo na\u0107i element koji sa datim brojem \\(x\\) daje najve\u0107i ksor, tako \u0161to se spu\u0161tamo niz trie i pohlepno biramo da odemo u dete sa suprotnom cifrom, ukoliko postoji. Tako\u0111e mogu\u0107e je brzo izbaciti broj iz na\u0161e strukture.  Sada naprosto izgradimo tu strukturu i idemo redom, i uvek biramo iz nje onaj element koji sa prethodnom vredno\u0161\u0107u daje najve\u0107i mogu\u0107i ksor, a zatim je izbacujemo iz iste.  Slo\u017eenost \\(O(N\\cdot\\log \\max A_i)\\). </p> 05_xorko.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 150007\nusing namespace std;\nint lc[MAXN*62],rc[MAXN*62],cnt[MAXN*62],br;\nlong long p[MAXN];\nvoid ubaci(long long a,int x,int node)\n{\n    cnt[node]++;\n    if(x==-1) return;\n    if(a&amp;(1LL&lt;&lt;x))\n    {\n        if(lc[node]==-1) lc[node]=++br;\n        ubaci(a,x-1,lc[node]);\n    }\n    else\n    {\n        if(rc[node]==-1) rc[node]=++br;\n        ubaci(a,x-1,rc[node]);\n    }\n}\nlong long findmax(long long a,int x,int node)\n{\n    cnt[node]--;\n    if(x==-1) return 0;\n    long long sol=0;\n    if((!(a&amp;(1LL&lt;&lt;x)) &amp;&amp; lc[node]!=-1) || rc[node]==-1)\n    {\n        sol=findmax(a,x-1,lc[node]);\n        if(!cnt[lc[node]]) lc[node]=-1;\n        sol+=(1LL&lt;&lt;x);\n    }\n    else\n    {\n        sol=findmax(a,x-1,rc[node]);\n        if(!cnt[rc[node]]) rc[node]=-1;\n    }\n    return sol;\n}\nvoid LexMax(int N, long long* A,long long *B)\n{\n    fill(lc,lc+MAXN*62,-1);\n    fill(rc,rc+MAXN*62,-1);\n    for(int i=1;i&lt;=N;i++) p[i]=p[i-1]^A[i];\n    for(int i=1;i&lt;N;i++) ubaci(p[i],59,0);\n    long long last=0;\n    for(int i=1;i&lt;N;i++)\n    {\n        long long t=findmax(last,59,0);\n        B[i]=last^t;\n        last=t;\n    }\n    B[N]=last^p[N];\n}\n</code></pre>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/","title":"6 - Dva stabla","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>Data su vam dva stabla sa po \\(N\\) \u010dvorova. Potrebno je odgovoriti na \\(Q\\) upita. Svaki upit je opisan sa po 4 broja \\(A\\), \\(B\\), \\(C\\) i \\(D\\). Odgovor na upit je broj indeksa \\(i\\) tako da se \u010dvor sa indeksom \\(i\\) nalazi na putu od \\(A\\) do \\(B\\) u prvom stablu i \u010dvor sa indeksom \\(i\\) se nalazi na putu od \\(C\\) do \\(D\\) u drugom stablu. Drugim re\u010dima, ako je \\(S1\\) skup indeksa svih \u010dvorova na putu od \\(A\\) do \\(B\\) u prvom stablu i \\(S2\\) skup indeksa svih \u010dvorova na putu od \\(C\\) do \\(D\\) u drugom stablu, odgovor na upit je \\(|S1 \\cap S2|\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez Tadija \u0160ebez Aleksa Milisavljevi\u0107 <p>Za \\(P=0\\) svi upiti su unapred poznati pa ih mo\u017eemo re\u0161avati u proizvoljnom redosledu. Kada je \\(P=1\\) moramo da odgovorimo na \\(i\\)-ti upit da bismo saznali \\(i+1\\)-vi upit, pa zadatak moramo da re\u0161avamo online, odnosno da na upite odgovaramo redom kojim su zadati.</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{Resi}(N, Q, P, U1[\\dots], V1[\\dots], U2[\\dots], V2[\\dots], A1[\\dots], B1[\\dots], C1[\\dots], D1[\\dots], R[\\dots])\\)</li> </ul> <p>gde je: * \\(N\\) broj \u010dvorova u stablima * \\(Q\\) broj upita * \\(P\\) parametar koji se koristi pri izra\u010dunavanju vrednosti nizova \\(A\\), \\(B\\), \\(C\\) i \\(D\\). * \\(U1\\) i \\(V1\\) nizovi du\u017eine \\(N-1\\) koji opisuju grane prvog stabla. \\(i\\)-ta grana spaja \u010dvorove \\(U1_i\\) i \\(V1_i\\). * \\(U2\\) i \\(V2\\) nizovi du\u017eine \\(N-1\\) koji opisuju grane drugog stabla. \\(i\\)-ta grana spaja \u010dvorove \\(U2_i\\) i \\(V2_i\\). * \\(A1\\), \\(B1\\), \\(C1\\) i \\(D1\\) nizovi du\u017eine \\(Q\\) pomo\u0107u kojih se izra\u010dunavaju nizovi \\(A\\), \\(B\\), \\(C\\) i \\(D\\) na slede\u0107i na\u010din: Neka je \\(ans_i\\) odgovor na \\(i\\)-ti upit i \\(ans_0=0\\). Onda je: - \\(A_i = (A1_i + ans_{i-1}*P - 1) \\% N + 1\\) - \\(B_i = (B1_i + ans_{i-1}*P - 1) \\% N + 1\\) - \\(C_i = (C1_i + ans_{i-1}*P - 1) \\% N + 1\\) - \\(D_i = (D1_i + ans_{i-1}*P - 1) \\% N + 1\\) * \\(R\\) niz u koji treba upisati odgovore na upite.</p> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq Q \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq A[i], B[i], C[i], D[i] \\leq N\\)</li> </ul>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u 9 podzadataka:</p> <ul> <li>[3 poena]: \\(P=0\\), \\(N, Q \\leq 1000\\).</li> <li>[7 poena]: \\(P=0\\), \\(N, Q \\leq 3 \\times 10^4\\), oba stabla su lanci.</li> <li>[8 poena]: \\(P=0\\), \\(N, Q \\leq 3 \\times 10^4\\), drugo stablo je lanac.</li> <li>[11 poena]: \\(P=0\\), \\(N, Q \\leq 3 \\times 10^4\\).</li> <li>[14 poena]: \\(P=0\\), oba stabla su lanci.</li> <li>[15 poena]: \\(P=0\\), drugo stablo je lanac.</li> <li>[30 poena]: \\(P=0\\).</li> <li>[6 poena]: \\(P=1\\), oba stabla su lanci.</li> <li>[6 poena]: \\(P=1\\).</li> </ul>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>dva_stabla.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee da sadr\u017ei i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int Q, int P, int *U1, int *V1, int *U2, int *V2, int *A1, int *B1, int *C1, int *D1, int *R);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova, ali ne smeju da pristupaju van njihovih granica.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza sede\u0107e podatke:</p> <ul> <li>U prvom redu tri broja \\(N\\), \\(Q\\) i \\(P\\).</li> <li>U narednih \\(N-1\\) redova nalazi se po dva broja. U \\(i\\)-tom redu \\(U1_i\\) i \\(V1_i\\).</li> <li>U narednih \\(N-1\\) redova nalazi se po dva broja. U \\(i\\)-tom redu \\(U2_i\\) i \\(V2_i\\).</li> <li>U narednih \\(Q\\) redova nalazi se po 4 broja. U \\(i\\)-tom redu \\(A1_i\\), \\(B1_i\\), \\(C1_i\\) i \\(D1_i\\).</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa odgovore na upite koje je funkcija popunila u nizu \\(R\\), po jedan u svakom redu.</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#primer","title":"Primer","text":""},{"location":"takprog/2020_2021/sio/06_dva_stabla/#ulaz","title":"Ulaz","text":"<pre><code>5 1 0\n1 4\n2 3\n1 5\n1 2\n1 3\n2 3\n1 5\n4 3\n5 3 2 4\n</code></pre>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#objasnjenje","title":"Obja\u0161njenje","text":"<ul> <li>Na putu od \u010dvora \\(5\\) do \u010dvora \\(3\\) u prvom stablu nalaze se \u010dvorovi sa indeksima \\(1\\), \\(2\\), \\(3\\) i \\(5\\).</li> <li>Na putu od \u010dvora \\(2\\) do \u010dvora \\(4\\) u drugom stablu nalaze se \u010dvorovi sa indeksima \\(2\\), \\(3\\) i \\(4\\).</li> <li>Indeksi \\(2\\) i \\(3\\) se pojavljuju na oba puta, pa je re\u0161enje 2.</li> </ul>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-kada-je-n-q-leq-1000","title":"Re\u0161enje kada je \\(N, Q \\leq 1000\\)","text":"<p>Iskoristimo DFS algoritam da na\u0111emo sve \u010dvorove na jednom i na drugom putu i zatim prebrojmo koliko \u010dvorova se nalazi na oba puta. Vremenska slo\u017eenost je \\(O(QN)\\).</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-kada-su-oba-stabla-lanci","title":"Re\u0161enje kada su oba stabla lanci","text":"<p>Uz pomo\u0107 DFS algoritma mo\u017eemo da pore\u0111amo \u010dvorove oba stabla u dva niza. Neka su to nizovi \\(S\\) i \\(T\\). U ovom slu\u010daju se upiti svode na pitanja za podnizove. Posmatrajmo upit za podniz \\(L1 \\dots R1\\) niza \\(S\\) i podniz \\(L2 \\dots R2\\) niza \\(T\\). Ako bismo u nizu \\(T\\) ozna\u010dili sa 1 poziciju \\(i\\) ako se \\(T_i\\) nalazi na podnizu \\(L1 \\dots R1\\) niza \\(S\\), i sa 0 u suprotnom, re\u0161enje za upit bi bilo zbir oznaka na podnizu \\(L2 \\dots R2\\) niza \\(T\\). </p> <p>Za podzadatak kada je \\(N, Q \\leq 3 \\times 10^4\\), mo\u017eemo da odr\u017eavamo oznake u Fenvikovom stablu i upite re\u0161avamo offline pomo\u0107u Mo-ovog algoritma. Upite sortiramo po paru \\((\\lfloor frac{L1}{\\sqrt{N}} \\rfloor, R1)\\) i re\u0161avamo ih u tom redosledu. Kada re\u0161imo upit sa podnizom \\(L1_{i-1} \\dots R1_{i-1}\\) levu granicu pomeramo do \\(L1_i\\), a desnu do \\(R1_i\\), menjaju\u0107i \\(|L1_i-L1_{i-1}|+|R1_i-R1_{i-1}|\\) oznaka u nizu \\(T\\). Na ovaj na\u010din ima\u0107emo \\(O(N \\sqrt{N})\\) promena i za svaku promenu nam treba \\(O(logN)\\) vremena za izmenu u Fenvikovom stablu, pa je vremenska slo\u017eenost ovog re\u0161enja \\(O(N \\sqrt{N} logN)\\).</p> <p>Kada je \\(N, Q \\leq 2 \\times 10^5\\) i \\(P=0\\), re\u0161enje je sli\u010dno kao prethodno, ali potrebna nam je jedna klju\u010dna opservacija: Re\u0161enje za upit \\(L1, R1, L2, R2\\) jednako je re\u0161enje za \\(1, R1, L2, R2\\) minus re\u0161enje za \\(1, L1-1, L2, R2\\). Na ovaj na\u010din mo\u017eemo da rastavimo upite na po dva upita za koje je podniz niza \\(S\\) zapravo prefiks istog. Ako upite sortiramo po desnoj granici podniza niza \\(S\\), ukupan broj izmena u Fenvikovom stablu \u0107e biti najvi\u0161e \\(N\\). Vremenska slo\u017eenost ovog re\u0161enja je \\(O(NlogN)\\).</p> <p>Kada je \\(P=1\\), mo\u017eemo da primenimo isto re\u0161enje, ali umesto Fenvikovog stabla treba da iskoristimo prezistentno segmentno stablo kako bismo mogli da sa\u010duvamo po verziju segmentnog stabla za svaki od \\(N\\) prefiksa niza \\(S\\), i kasnije ih koristili da odgovaramo na upite u zadatom redosledu.</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-kada-je-jedno-stablo-lanac","title":"Re\u0161enje kada je jedno stablo lanac","text":"<p>U ovom slu\u010daju lanac mo\u017eemo da pretvorimo u niz \\(S\\) i na njemu radimo Mo-ov algoritam ili da rastavimo upite kao u pro\u0161lom re\u0161enju. Deo re\u0161enja koji se menja je to da nam vi\u0161e nisu potrebni upiti za zbir na podnizu ve\u0107 za zbir na putu u stablu. Put od \\(A\\) do \\(B\\) u stablu mo\u017eemo da rastavimo na put od korena do \\(A\\), plus put od korena do \\(B\\), minus put od korena do \\(\\text{LCA}(A,B)\\), minus put od korena do \\(\\text{parent}(\\text{LCA}(A,B))\\). Treba jo\u0161 da na\u0111emo na\u010din da dobijemo zbir oznaka svih \u010dvorova na putu od korena do nekog \u010dvora. Uradimo Ojlerov obilazak stabla i smestimo \u010dvorove u niz tim redom kako smo ih posetili u DFS-u. Na ovaj na\u010din \u0107e svako podstablo da \u010dini jedan podniz. Tokom DFS-a mo\u017eemo da zapamtimo i granice podnizova za svako podstablo. Nad nizom koji smo ovako dobili mo\u017eemo da napravimo Fenvikovo stablo koje podr\u017eava upite pove\u0107avanja i smanjivanja vrednosti svih \u010dlanova nekog podniza, i upite koji vra\u0107aju vrednost nekog \u010dvora. Ako koristimo Mo-ov algoritam sa ovom strukturom dobijamo slo\u017eenost \\(O(N \\sqrt{N} logN)\\), \u0161to prolazi podzadatak kada je \\(N, Q \\leq 3 \\times 10^4\\), a ako rastavimo podnizove niza \\(S\\) kao u prethodnom podzadatku, dobijamo re\u0161enje u vremenskoj slo\u017eenosti \\(O(NlogN)\\) \u0161to prolazi i podzadatak kada je \\(N, Q \\leq 2 \\times 10^5\\).</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-kada-je-n-q-leq-3-times-104","title":"Re\u0161enje kada je \\(N, Q \\leq 3 \\times 10^4\\)","text":"<p>Re\u0161enje za ovaj podzadatak je da na jedno stablo primenimo Mo-ov algoritam, a na drugo stablo istu strukturu podataka kao u prethodnom re\u0161enju. Mo-ov algoritam na stablu zapravo primenjujemo na Ojlerovom obilasku. Napravimo od stabla niz du\u017eine \\(2N\\) tako \u0161to stavimo \u010dvor u niz kada ulazimo i kada izlazimo iz \u010dvora. Put od \\(A\\) do \\(B\\), gde je prvo pojavljivanje \u010dvora \\(A\\) pre prvog pojavljivanja \u010dvora \\(B\\), mapiramo na podniz od drugog pojavljivanja \u010dvora \\(A\\) do prvog pojavljivanja \u010dvora \\(B\\), osim ako je \\(A\\) predak \u010dvora \\(B\\), kada ovaj put mapiramo na podniz od prvog pojavljivanja \\(A\\) do prvog pojavljivanja \\(B\\). U prvom slu\u010daju se svi \u010dvorovi na putu osim \\(\\text{LCA}(A, B)\\) pjavljuju ta\u010dno jednom, a ostali \u010dvorovi 0 ili 2 puta. U drugom slu\u010daju svi \u010dvorovi na putu od \\(A\\) do \\(B\\) se pajavljuju ta\u010dno jednom, a ostali \u010dvorovi 0 ili 2 puta. Kada sortiramo upite, u strukturi za drugo stablo odr\u017eavamo sve \u010dvorove koji se pojavljuju ta\u010dno jednom i pre re\u0161avanja upita ubacimo i \u010dvor \\(\\text{LCA}(A, B)\\) ako ve\u0107 nije uba\u010den. Vremenska slo\u017eenost ovog algoritma je \\(O(N \\sqrt{N} logN)\\).</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-kada-je-p0","title":"Re\u0161enje kada je \\(P=0\\)","text":"<p>Kao \u0161to smo rastavili put u drugom stablu, tako mo\u017eemo da rastavimo i put u prvom stablu. I u ovom re\u0161enju na isti na\u010din radimo sa drugim stablom, a za prvo stablo upite rastavljamo na po 4 upita za puteve od korena do nekog \u010dvora. Upite \u0107emo re\u0161iti offline, DFS algoritmom. Kada u\u0111emo u neki \u010dvor dodamo ga u strukturi za drugo stablo, zatim re\u0161imo sve upite za puteve od korena do trenutnog \u010dvora i na kraju kada iza\u0111emo iz \u010dvora izbacujemo trenutni \u010dvor iz strukture za drugo stablo. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(NlogN)\\).</p>"},{"location":"takprog/2020_2021/sio/06_dva_stabla/#resenje-za-100-poena","title":"Re\u0161enje za 100 poena","text":"<p>Online re\u0161enje je sli\u010dno kao i offline re\u0161enje, samo \u0161to koristimo perzistentno segmentno stablo umesto Fenvikovog stabla kao strukturu za drugo stablo. Na taj na\u010din mo\u017eemo da zapamtimo verzije strukture kakva je bila nakon ulaska u svaki \u010dvor, i uz pomo\u0107 toga mo\u017eemo redom da odgovaramo na upite. Vremenska i memorijska slo\u017eenost ovog re\u0161enja je \\(O(NlogN)\\).</p> 06_dva_stabla.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define pb push_back\n\nconst int N=200050;\nconst int M=2*20*N;\n\nint root[N],ls[M],rs[M],sum[M],tsz;\nvoid Add(int p,int&amp;c,int ss,int se,int qi,int x){\n    c=++tsz;ls[c]=ls[p];rs[c]=rs[p];sum[c]=sum[p]+x;\n    if(ss==se)return;\n    int mid=ss+se&gt;&gt;1;\n    if(qi&lt;=mid)Add(ls[p],ls[c],ss,mid,qi,x);\n    else Add(rs[p],rs[c],mid+1,se,qi,x);\n}\nint Get(int c,int ss,int se,int qs,int qe){\n    if(qs&gt;qe||qs&gt;se||ss&gt;qe)return 0;\n    if(qs&lt;=ss&amp;&amp;qe&gt;=se)return sum[c];\n    int mid=ss+se&gt;&gt;1;\n    return Get(ls[c],ss,mid,qs,qe)+Get(rs[c],mid+1,se,qs,qe);\n}\n\nvector&lt;int&gt; E[2][N];\nint lid[N],rid[N],tid;\nvoid Euler(int u,int p,int t){\n    lid[u]=++tid;\n    for(int v:E[t][u])if(v!=p)Euler(v,u,t);\n    rid[u]=++tid;\n}\n\nvoid Build(int u,int p,int t){\n    Add(root[p],root[u],1,tid,lid[u],1);\n    Add(root[u],root[u],1,tid,rid[u],-1);\n    for(int v:E[t][u])if(v!=p)Build(v,u,t);\n}\n\n\nconst int L=20;\nint par[2][N][L],dep[2][N];\nvoid DFS(int u,int p,int t){\n    par[t][u][0]=p;\n    dep[t][u]=dep[t][p]+1;\n    for(int i=1;i&lt;L;i++){\n        par[t][u][i]=par[t][par[t][u][i-1]][i-1];\n    }\n    for(int v:E[t][u])if(v!=p)DFS(v,u,t);\n}\nint LCA(int u,int v,int t){\n    if(dep[t][u]&lt;dep[t][v])swap(u,v);\n    for(int i=L-1;~i;i--)if(dep[t][par[t][u][i]]&gt;=dep[t][v])u=par[t][u][i];\n    for(int i=L-1;~i;i--)if(par[t][u][i]!=par[t][v][i])u=par[t][u][i],v=par[t][v][i];\n    return u==v?v:par[t][v][0];\n}\n\nint Get(int x,int y){\n    if(x==0||y==0)return 0;\n    return Get(root[x],1,tid,1,lid[y]);\n}\n\nint Get(int node,int C,int D,int lca){\n    return Get(node,C)+Get(node,D)-Get(node,lca)-Get(node,par[1][lca][0]);\n}\n\nvoid Resi(int N, int Q, int P, int *U1, int *V1, int *U2, int *V2, int *A1, int *B1, int *C1, int *D1, int *R){\n    for(int i=1;i&lt;N;i++){\n        E[0][U1[i]].pb(V1[i]);\n        E[0][V1[i]].pb(U1[i]);\n\n        E[1][U2[i]].pb(V2[i]);\n        E[1][V2[i]].pb(U2[i]);\n    }\n    Euler(1,0,1);\n    Build(1,0,0);\n    DFS(1,0,0);\n    DFS(1,0,1);\n    int last_ans=0;\n    for(int i=1;i&lt;=Q;i++){\n        int A=(A1[i]+last_ans*P-1)%N+1;\n        int B=(B1[i]+last_ans*P-1)%N+1;\n        int C=(C1[i]+last_ans*P-1)%N+1;\n        int D=(D1[i]+last_ans*P-1)%N+1;\n        int lca1=LCA(A,B,0);\n        int lca2=LCA(C,D,1);\n        R[i]=Get(A,C,D,lca2)+Get(B,C,D,lca2)-Get(lca1,C,D,lca2)-Get(par[0][lca1][0],C,D,lca2);\n        last_ans=R[i];\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/","title":"B1 - Jedna\u010dine","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Za dati prirodan broj \\(n\\), ozna\u010dimo sa \\(S(n)\\) sumu njegovih cifara. Dakle, \\(S(12) = 1 + 2 = 3\\), \\(S(1005) = 1 + 0 + 0 + 5 = 6\\). Du\u0161ko voli da ispituje svojstva prirodnih brojeva, pa je smislio sebi zadatak. Za date brojeve \\(X, Y, A, B\\) (\\(X \\leq Y\\)) njega zanima da li postoji neki broj \\(n\\) takav da \\(X \\leq n \\leq Y\\) za koji va\u017ei da je \\(n = A \\cdot S(n) + B\\). </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Vladimir Milenkovi\u0107 Dragan Uro\u0161evi\u0107 Aleksandar Zlateski"},{"location":"takprog/2021_2022/drz/01_jednacine/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalaze se celi brojevi \\(X, Y, A, B\\).</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko postoji neki broj \\(n\\) za koji va\u017ei i \\(X \\leq n \\leq Y\\) i \\(n = A \\cdot S(n) + B\\), u prvom i jedinom redu standardnog izlaza ispisati taj broj. Ukoliko postoji vi\u0161e od jednog re\u0161enja, ispisati bilo koje od njih. Ukoliko ne postoji nijedno re\u0161enje, ispisati \\(-1\\).</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#ogranicenja","title":"Ograni\u010denja","text":"<p>\\(1 \\leq X \\leq Y \\leq 10^{18}\\) \\(0 \\leq A, B \\leq 10^{18}\\)</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#podzadaci","title":"Podzadaci","text":"<ol> <li>(10 poena) \\(A = 0\\) </li> <li>(20 poena) \\(Y \\leq 10^6\\) </li> <li>(35 poena) \\(A, B \\leq 10^{15}\\) </li> <li>(35 poena) Bez dodatnih ograni\u010denja </li> </ol>"},{"location":"takprog/2021_2022/drz/01_jednacine/#primeri","title":"Primeri","text":""},{"location":"takprog/2021_2022/drz/01_jednacine/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/01_jednacine/#ulaz","title":"Ulaz","text":"<pre><code>9 142 1 0\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Broj \\(9\\) zadovoljava i uslov da je izme\u0111u \\(9\\) i \\(142\\), i va\u017ei da je \\(9 = 1 \\cdot S(9) + 0 = 9\\), tako da je \\(9\\) validno re\u0161enje. U ovom primeru, ne postoji nijedno vi\u0161e validno re\u0161enje.</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/drz/01_jednacine/#ulaz_1","title":"Ulaz","text":"<pre><code>18 23 4 3\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#izlaz_1","title":"Izlaz","text":"<pre><code>23\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#objasnjenje-primera_1","title":"Obja\u0161njenje primera","text":"<p>\\(23\\) je validno re\u0161enje jer je u zadatom intervalu i jer je \\(23 = 4 \\cdot S(23) + 3\\). U ovom primeru, broj \\(23\\) je jedino validno re\u0161enje.</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2021_2022/drz/01_jednacine/#ulaz_2","title":"Ulaz","text":"<pre><code>1 9 1 1\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#izlaz_2","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2021_2022/drz/01_jednacine/#objasnjenje-primera_2","title":"Obja\u0161njenje primera","text":"<p>Nijedan broj iz intervala ne zadovoljava dati uslov.</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#resenje-podzadatka-1","title":"Re\u0161enje podzadatka 1","text":"<p>Primetimo da je u ovom slu\u010daju jedina mogu\u0107a vrednost za \\(n\\) broj $$ n = A\\cdot S(n) + B = 0 \\cdot S(n) + B = B. $$ Zbog toga je dovoljno samo proveriti da li je broj \\(n=B\\) izme\u0111u \\(X\\) i \\(Y\\) i ako jeste ispisati taj broj, u suprotnom ispisati vrednost \\(-1\\). Slo\u017eenost ovog re\u0161enja je \\(O(1)\\).</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#resenje-podzadatka-2","title":"Re\u0161enje podzadatka 2","text":"<p>Kako je \\(n\\leq Y \\leq 10^6\\), dovoljno je za svako \\(n\\) iz intervala \\([X,Y]\\) odrediti zbir cifara (uzastopnim deljenjem tog broja sa \\(10\\) i sabiranjem ostataka), a nakon toga proveriti da li zadovoljava jedna\u010dinu . Naravno, nakon pronalaska prve takve vrednosti za broj \\(n\\) ispisuje se ta vrednost i prekida izvr\u0161avanje programa. Ako nijedan broj iz intervala \\([X,Y]\\) ne zadovoljava jedna\u010dinu, ispisuje se vrednost \\(-1\\). Slo\u017eenost ovog re\u0161enja je \\(O(Y\\log Y)\\).</p>"},{"location":"takprog/2021_2022/drz/01_jednacine/#resenje-podzadataka-3-i-4","title":"Re\u0161enje podzadataka 3 i 4","text":"<p>Primetimo da ako je \\(1\\leq X \\leq n \\leq Y \\leq 10^{18}\\), onda je \\(1 \\leq S(n) \\leq 18 \\cdot 9 = 162\\). Samim tim je skup mogu\u0107ih vrednost za izraz \\(A\\cdot S(n) +B\\) zapravo skup $$ U = {A\\cdot T + B|T = 1, 2, \\dots, 162} $$ i to je skup mogu\u0107ih vrednosti za broj \\(n\\).</p> <p>Prema tome, dovoljno je za elemente \\(n\\in U\\), proveriti da li zadovoljavaju jedna\u010dinu  $$ S(n) = S(A\\cdot T + B) = T $$ i ako neki od njih zadovoljava ispisati njegovu vrednost, u suprotnom ispisati broj \\(-1\\). Broj elemenata skupa \\(U\\) je \\(O(\\log Y)\\), a provera da li neki element \\(n\\) skupa \\(U\\) zadovoljava gornju jednakost ima slo\u017eenost \\(O(\\log n)=O(\\log Y)\\), pa je slo\u017eenost celog algoritma \\(O(\\log^2 Y)\\). </p> <p>Pri re\u0161avanju podzadatka 4 treba voditi ra\u010duna da pri ra\u010dunanju vrednosti \\(A\\cdot T + B\\) mo\u017ee do\u0107i do prekora\u010denja.  </p> 01_jednacine.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll LIM = 1'000'000'000'000'000'000;\ninline int digit_sum (ll x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\nint main() {\n    ll x, y, a, b;\n    scanf(\"%lld %lld %lld %lld\", &amp;x, &amp;y, &amp;a, &amp;b);\n    for (int sum_digits = 0; sum_digits &lt;= 200; sum_digits++) {\n        ll guess = sum_digits * a + b;\n        if (guess &gt; LIM) break;\n        // cout &lt;&lt; sum_digits &lt;&lt; \" \" &lt;&lt; guess &lt;&lt; \" \" &lt;&lt; digit_sum(guess) &lt;&lt; endl;\n        if (x &lt;= guess &amp;&amp; guess &lt;= y &amp;&amp; digit_sum(guess) == sum_digits) {\n            printf(\"%lld\\n\", guess);\n            return 0;\n        }\n    }\n    printf(\"-1\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/02_turnir/","title":"B2 - Turnir","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 267MB <p>\u017detonska igra se igra u \\(N\\) rundi: \\(M\\) takmi\u010dara rasporede svoje \u017eetone u \\(N\\) gomila i u svakoj rundi se poredi broj \u017eetona svakog takmi\u010dara. Svaka runda se igra u vidu turnira (svako sa svakim), pri \u010demu pobe\u0111uje igra\u010d sa ve\u0107im brojem \u017eetona i u \\(i\\)-toj rundi pobednik pri jednom pre\u0111enju dobija \\(s_i\\) poena (ako nema pobednika, niko ne dobija poene).</p> <p>Mi se poslednji priklju\u010dujemo igri i nekako smo uspeli da saznamo kako su svi ostali takmi\u010dari rasporedili svoje \u017eetone. Na raspolaganju imamo \\(K\\) \u017eetona. Odrediti neki raspored na\u0161ih \\(K\\) \u017eetona koji maksimizuje broj poena koje mo\u017eemo da ostvarimo.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Aleksa Milisavljevi\u0107 Andrej Iva\u0161kovi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2021_2022/drz/02_turnir/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se pozitivni celi brojevi \\(N\\), \\(M\\) i \\(K\\), gde je \\(N\\) broj rundi, \\(M\\) takmi\u010dara, a \\(K\\)  broj \u017eetona koje mi posedujemo. </p> <p>U narednom redu, nalazi se \\(N\\) nenegativnih celih brojeva, od kojih je \\(i\\)-ti broj \\(s_i\\), broj poena koje dobije pobednik pri jednom pore\u0111enju u jednoj rundi.</p> <p>Narednih \\(N\\) redova nalazi se po \\(M\\) nenegativnih celih brojeva, \\(j\\)-ti broj u \\(i\\)-tom redu je \\(a_{i,j}\\), broj \u017eetona koje je \\(j\\)-ti igra\u010d raspodelio u \\(i\\)-toj rundi.</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati najve\u0107i mogu\u0107i broj poena koje je mogu\u0107e ostvariti pri optimalnom raspore\u0111ivanju \\(K\\) \u017eetona u \\(N\\) rundi.</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 200\\)</li> <li>\\(1 \\leq K \\leq 10^4\\)</li> <li>\\(0 \\leq s_i \\leq 10^9\\), za svako \\(1 \\leq i \\leq N\\)</li> <li>\\(0 \\leq a_{i,j} \\leq 10^4\\), za svako \\(1 \\leq i \\leq N, 1\\leq j \\leq M\\)</li> </ul>"},{"location":"takprog/2021_2022/drz/02_turnir/#podzadaci","title":"Podzadaci","text":"<ol> <li>(4 poena) \\(N = 1\\)</li> <li>(7 poena) \\(N, K \\leq 6\\)</li> <li>(21 poena) \\(M = 1\\)</li> <li>(26 poena) \\(N, M, K \\leq 100\\)</li> <li>(42 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/drz/02_turnir/#primeri","title":"Primeri","text":""},{"location":"takprog/2021_2022/drz/02_turnir/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/02_turnir/#ulaz","title":"Ulaz","text":"<pre><code>2 3 10\n1 3\n3 0 7\n8 5 1\n</code></pre>"},{"location":"takprog/2021_2022/drz/02_turnir/#izlaz","title":"Izlaz","text":"<pre><code>10\n</code></pre>"},{"location":"takprog/2021_2022/drz/02_turnir/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ukoliko na\u0161ih \\(10\\) rasporedimo tako \u0161to \\(1\\) iskoristimo u prvoj rundi, a preostalih \\(9\\) u drugoj rundi, pobedi\u0107emo u jednom pore\u0111enju u prvoj rundi i u sva tri pore\u0111enja u drugoj rundi. Na taj na\u010din dobi\u0107emo ukupno \\(1 \\cdot 1 + 3 \\cdot 3 = 10\\) poena.</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/drz/02_turnir/#ulaz_1","title":"Ulaz","text":"<pre><code>3 2 10\n3 4 5\n5 6\n9 3\n1 9\n</code></pre>"},{"location":"takprog/2021_2022/drz/02_turnir/#izlaz_1","title":"Izlaz","text":"<pre><code>11\n</code></pre>"},{"location":"takprog/2021_2022/drz/02_turnir/#resenje-prvog-podzadatka","title":"Re\u0161enje prvog podzadatka","text":"<p>Ukoliko se igra sastoji od samo jedne runde, to zna\u010di da svih svojih \\(K\\) \u017eetona koristimo u toj rundi. Ukupan broj poena koji mo\u017eemo da ostvarimo jednak je broju ostalih igra\u010da koji imaju manje od \\(K\\) \u017eetona. Ovo re\u0161enje radi u vremenskoj slo\u017eenosti \\(O(M)\\).</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#resenje-drugog-podzadatka","title":"Re\u0161enje drugog podzadatka","text":"<p>Dovoljno je isprobati sve mogu\u0107e na\u010dine da se \\(K\\) predstavi kao zbir \\(N\\) nenegativnih celih sabiraka, generisane bektrekingom, i da se za svaku od tih podela odredi broj poena koji mo\u017eemo da ostvarimo. Broj na\u010dina da se \\(K\\) razbije na \\(N\\) sabiraka jednak je \\(N+K-1 \\choose N-1\\), a odre\u0111ivanje broja poena za datu podelu se radi u slo\u017eenosti \\(O(MN)\\). Bektreking re\u0161enje ne mora da bude posebno efikasno da bi se u ovom podzadatku dobili svi poeni.</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#resenje-treceg-podzadatka","title":"Re\u0161enje tre\u0107eg podzadatka","text":"<p>Za \\(M=1\\) postoji samo jedan igra\u010d protiv kog igramo, te je pitanje kako rasporediti \u017eetone da ostvarimo najve\u0107i broj pobeda u rundama. Ukoliko je u \\(i\\)-toj rundi ovaj igra\u010d postavio \\(a_{i,1}\\) \u017eetona, onda pobedu u ovoj rundi ostvarujemo postavljanjem \\(a_{i,1}+1\\) \u017eetona. Za ostvarivanje pobede u najve\u0107em broju rundi, dovoljno je pobediti u onim rundama u kojima je na\u0161 protivnik stavio najmanje \u017eetona. Ovo vodi ka jednostavnom gramzivom algoritmu: najpre se sortiraju runde po broju \u017eetona saigra\u010da (u rastu\u0107em poretku), nakon \u010dega se \u201cbud\u017eet\u201d od \\(K\\) \u017eetona tro\u0161i redom u ovim rundama sve dok nam ne ostane nijedan \u017eeton. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N \\log N)\\).</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#resenje-cetvrtog-podzadatka","title":"Re\u0161enje \u010detvrtog podzadatka","text":"<p>Ovaj podzadatak se re\u0161ava primenom dinami\u010dkog programiranja. Defini\u0161imo trodimenzioni niz \\(S_{n,k}\\), uz \\(0 \\leq n \\leq N\\), \\(0 \\leq k \\leq K\\):</p> <ul> <li>\\(S_{n,k}\\): najve\u0107i broj poena koji se mo\u017ee ostvariti ukoliko je iskori\u0161\u0107eno \\(k\\) \u017eetona u prvih \\(n\\) rundi</li> </ul> <p>Trivijalno poznate vrednosti u ovom nizu su:</p> <ul> <li>\\(S_{0,k}=0\\) za svako \\(k\\)</li> </ul> <p>Neka je \\([B]\\) indikator nekog logi\u010dkog izraza: \\(1\\) ukoliko \\(B\\) va\u017ei i \\(0\\) ukoliko ne va\u017ei. U slu\u010dajevima \\(n&gt;0\\) koristimo rekurentnu vezu:</p> <ul> <li>\\(S_{n,k} = \\max_{1 \\leq z \\leq k} (S_{n-1,k-z} + \\sum_{j=1}^{m} [a_{n,j} &lt; z])\\) (*)</li> </ul> <p>Ova rekurentna veza mo\u017ee da se objasni na slede\u0107i na\u010din: najbolji na\u010din da se \\(k\\) \u017eetona rasporedi u \\(n\\) rundi mo\u017ee da se odredi ukoliko se razmotre svi mogu\u0107i brojevi \u017eetona \\(z\\) u \\(n\\)-toj rundi, odredi koliko igra\u010da ima manje od \\(z\\) \u017eetona u \\(n\\)-toj rundi i tako odredi broj poena, na to doda optimalna raspodela \\(k-z\\) \u017eetona u prethodnim rundama, i odredi najbolje takvo \\(z\\). Tada je kona\u010dan odgovor na pitanje iz zadatka vrednost \\(S_{N,K}\\), koja mo\u017ee da se odredi u vremenskoj slo\u017eenosti \\(O(NMK^2)\\).</p>"},{"location":"takprog/2021_2022/drz/02_turnir/#resenje-petog-podzadatka","title":"Re\u0161enje petog podzadatka","text":"<p>Re\u0161enje koje donosi sve poene je optimizacija re\u0161enja \u010detvrtog podzadatka.</p> <p>Primetimo da su jedini zna\u010dajni brojevi \u017eetona u \\(n\\)-toj rundi \\(0, a_{n,1}+1, a_{n,2}+1, \\ldots, a_{n,M}+1\\), odnosno brojevi \u017eetona pri kojima se ostvaruju razli\u010diti brojevi poena. U okviru jedne runde je nebitno koji igra\u010d je stavio koliko \u017eetona, bitni su samo brojevi. Stoga ne gubimo nikakve informacije sortiranjem brojeva \u017eetona razli\u010ditih igra\u010da u okviru jedne runde.</p> <p>Primetimo i da je \\(S_{n,k}\\) za fiksirano \\(k\\) rastu\u0107e u \\(n\\), odnosno \\(S_{n,k} \\leq S_{n',k}\\) za \\(n &lt; n\u2019\\).</p> <p>Uz ova dva koraka, primetimo da nije neophodno ispitati sve mogu\u0107e \\(z\\) u formuli (*). Samim tim ra\u010dunanje \\(S_{n,k}\\), koje se u prethodnom podzadatku radilo u vremenskoj slo\u017eenosti \\(O(MK)\\), mo\u017ee da se uradi u \\(O(M)\\). Ukupna vremenska slo\u017eenost je \\(O(NMK)\\).</p> <p>Za one koji \u017eele da znaju vi\u0161e: ovaj zadatak je inspirisan igrom Blotto.</p> 02_turnir.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 202\n#define maxk 10005\nusing namespace std;\nint n,m,k;\nint s[maxn];\nlong long dp[maxn][maxk];\nint a[maxn][maxn];\nint main() {\n    scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;k);\n    for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;s[i]);\n    for(int i=1;i&lt;=n;i++) {\n        for(int j=1;j&lt;=m;j++) {\n            scanf(\"%d\",&amp;a[i][j]);\n        }\n        sort(a[i]+1,a[i]+(m+1));\n    }\n    for(int i=1;i&lt;=n;i++) {\n        for(int j=0;j&lt;=k;j++) dp[i][j]=dp[i-1][j];\n        for(int l=0;l&lt;=m;l++) {\n            int c;\n            if(l==0) c=0;\n            else c=a[i][l]+1;\n            for(int j=c;j&lt;=k;j++) {\n                dp[i][j]=max(dp[i][j],dp[i-1][j-c]+1ll*l*s[i]);\n            }\n        }\n    }\n    long long ans=dp[n][0];\n    for(int j=1;j&lt;=k;j++) ans=max(ans,dp[n][j]);\n    printf(\"%lld\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/03_burad/","title":"B3 - Burad","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Nakon \u0161to se penzionisao u Vr\u010dinsoftu i postao velemajstor programiranja na Vr\u010dinskoj Sili, Marko je odlu\u010dio da na\u0111e novi hobi. Po\u0161to svi znaju da je Vr\u010din ki\u0161no mesto, odlu\u010dio je da skuplja ki\u0161u u svojih \\(N\\) buri\u0107a. </p> <p>On ih je pore\u0111ao u red s leva na desno i numerisao ih brojevima od \\(1\\) do \\(N\\), tako da je bure sa brojem \\(1\\) najlevlje. Bure \\(i\\) ima kapacitet od \\(a_i\\) litara. </p> <p>Marko zna da \u0107e narednih \\(M\\) dana da pada ki\u0161a, ali na jako specifi\u010dan na\u010din -- \\(i\\)-tog dana ki\u0161a \u0107e padati tako da voda upada isklju\u010divo u buri\u0107e numerisane brojevima od \\(l_i\\) do \\(r_i\\) (uklju\u010duju\u0107i i njih). Ako ki\u0161a dospeva u neko bure, u danu u njega upadne ta\u010dno jedan litar ki\u0161e. Ako se Marku ne svidi vremenska prognoza za taj dan, on ima mogu\u0107nost da prekrije sve buri\u0107e, kako ki\u0161a tog dana ne bi upala u njih.</p> <p>Marko voli da sakupi \u0161to vi\u0161e vode, ali jo\u0161 vi\u0161e mrzi kad mu se prelije neko bure. Po\u0161to je oka\u010dio tastaturu o klin, zamolio je vas da izra\u010dunate -- koliko najmanje dana je potrebno da prekrije sve buri\u0107e, tako da se nijedno bure ne prelije (ne padne u njega vi\u0161e litara vode nego \u0161to mu je kapacitet)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2021_2022/drz/03_burad/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se pozitivni celi brojevi \\(N\\) i \\(M\\), gde je \\(N\\) broj buri\u0107a koje Marko poseduje, a \\(M\\) broj ki\u0161nih dana. </p> <p>U narednom redu, nalazi se \\(N\\) nenegativnih celih brojeva, od kojih je \\(i\\)-ti broj ba\u0161 \\(a_i\\), kapacitet \\(i\\)-tog bureta.</p> <p>Narednih \\(M\\) redova sadr\u017ee po dva pozitivna cela broja \\(l_i\\) i \\(r_i\\) koji opisuju ki\u0161ne dane.</p>"},{"location":"takprog/2021_2022/drz/03_burad/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jedan broj - najmanji broj dana u kojim Marko mora prekriti buri\u0107e.</p>"},{"location":"takprog/2021_2022/drz/03_burad/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 2\\cdot10^5\\)</li> <li>\\(0 \\leq a_i \\leq 10^9\\), za svako \\(1 \\leq i \\leq N\\)</li> <li>\\(1 \\leq l_i \\leq r_i \\leq N\\), za svako \\(1 \\leq i \\leq M\\)</li> </ul>"},{"location":"takprog/2021_2022/drz/03_burad/#podzadaci","title":"Podzadaci","text":"<ol> <li>(6 poena) \\(l_i = r_i\\), za svako \\(1 \\leq i \\leq M\\)</li> <li>(7 poena) Ni u jedno bure ne\u0107e padati ki\u0161a vi\u0161e od jedanput po vremenskoj prognozi</li> <li>(13 poena) \\(a_i \\in \\{0, 10^9\\}\\), za svako \\(1 \\leq i \\leq N\\).</li> <li>(15 poena) \\(N, M \\leq 2000\\)</li> <li>(59 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/drz/03_burad/#primeri","title":"Primeri","text":""},{"location":"takprog/2021_2022/drz/03_burad/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/03_burad/#ulaz","title":"Ulaz","text":"<pre><code>5 4\n3 1 0 0 3\n1 3\n1 2\n1 5\n4 5\n</code></pre>"},{"location":"takprog/2021_2022/drz/03_burad/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2021_2022/drz/03_burad/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Potrebno je prekriti buri\u0107e svaki dan sem drugog, jer \u0107e ina\u010de ki\u0161a upasti u buri\u0107e kapaciteta \\(0\\).</p>"},{"location":"takprog/2021_2022/drz/03_burad/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/drz/03_burad/#ulaz_1","title":"Ulaz","text":"<pre><code>6 9\n4 1 2 3 1 2\n2 4\n1 3\n4 4\n1 4\n5 6\n3 4\n6 6\n3 3\n1 6\n</code></pre>"},{"location":"takprog/2021_2022/drz/03_burad/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/drz/03_burad/#resenje-kada-l_i-r_i","title":"Re\u0161enje kada \\(l_i = r_i\\)","text":"<p>Po\u0161to \u0107e ki\u0161a svakog dana padati nad ta\u010dno jednim buretom, mo\u017eemo svako bure gledati zasebno. Izbroja\u0107emo koliko litara je prognozirano da upadne u \\(i\\)-to bure, nazovimo taj broj \\(cnt_i\\). Ukoliko \\(cnt_i &gt; a_i\\), zna\u010di da dolazi do prelivanja i moramo prekriti buri\u0107e \\(cnt_i - a_i\\) dana. Uradimo to za svako \\(i\\) i sumirajmo kako bismo dobili krajnje re\u0161enje. Vremenska slo\u017eenost je \\(O(N+M)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/drz/03_burad/#resenje-kada-u-svako-bure-pada-najvise-jedan-litar-kise","title":"Re\u0161enje kada u svako bure pada najvi\u0161e jedan litar ki\u0161e","text":"<p>Jedina mesta na kojima mo\u017ee do\u0107i do prelivanja jesu burad sa kapacitetom \\(0\\), a po\u0161to su svi intervali disjunktni, to zna\u010di da je ukupna du\u017eina svih intervala do \\(N\\), pa je dovoljno efikasno da za svaki dan pro\u0111emo kroz sve buri\u0107e u koje bi upala ki\u0161a i proverimo da li neki od njih ima kapacitet \\(0\\). Vremenska slo\u017eenost \\(O(N+M)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/drz/03_burad/#resenje-kada-a_i-in-0-109","title":"Re\u0161enje kada \\(a_i \\in \\{0, 10^9\\}\\)","text":"<p>Jedina mesta na kojima mo\u017ee do\u0107i do prelivanja jesu burad sa kapacitetom \\(0\\), u koje ne sme upasti ni litar ki\u0161e. Zato, Marko mora prekriti sve buri\u0107e na dane kada bi u makar jedno bure kapaciteta \\(0\\) upala ki\u0161a, \u0161to je ekvivalentno sa proverom da li u intervalu nizu postoji \\(0\\). Ovo mo\u017eemo proveriti npr. binarnom pretragom nad indeksima gde se pojavljuje \\(0\\) ili prefiksnim sumama kojim brojimo nule na prefiksu. Vremenska slo\u017eenost \\(O(N+M)\\) ili \\(O(N+MlogN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/drz/03_burad/#resenje-kada-n-m-leq-2000","title":"Re\u0161enje kada \\(N, M \\leq 2000\\)","text":"<p>Prvo je potrebno da odredimo koliko litara ki\u0161e je prognozirano za svako bure. To mo\u017eemo jednostavno uraditi tako \u0161to za svaki dan prolazimo kroz sve buri\u0107e i uve\u0107amo broj litara za jedan. Nazovimo taj broj litara za \\(i\\)-to bure \\(cnt_i\\). Sada je potrebno da posmatramo isklju\u010divo buri\u0107e za koje va\u017ei \\(cnt_i &gt; a_i\\), odnosno one koji bi se prelili kada ni\u0161ta ne bismo u\u010dinili. </p> <p>Sada, idemo sleva nadesno i svaki put kada nai\u0111emo na takvo bure, znamo da moramo da pokrijemo buri\u0107e na makar \\(cnt_i - a_i\\) novih dana. \u010cuvajmo u nekom nizu sve dane za koje nismo odredili da li \u0107emo prekriti buri\u0107e taj dan (zva\u0107emo ih neobrisani intervali). Kad god moramo da obri\u0161emo novi interval, obrisa\u0107emo onaj interval koji sadr\u017ei \\(i\\), a prose\u017ee se \u0161to je mogu\u0107e dalje u desno. Ovo je optimalno, jer su tako najve\u0107e \u0161anse da \u0107emo tim brisanjem smanjiti \\(cnt_j\\) drugih kriti\u010dnih buri\u0107a. Kada odaberemo takav interval, bri\u0161emo ga iz niza, i smanjujemo odgovaraju\u0107e elemente \\(cnt\\) niza. Nastavljamo desno dok ne obradimo ceo niz. </p> <p>Vremenska slo\u017eenost je \\(O(NM)\\), a memorijska \\(O(N+M)\\).</p>"},{"location":"takprog/2021_2022/drz/03_burad/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ideja iza ovog re\u0161enja ista je kao za prethodno, samo je potrebno da sve uradimo efikasnije. Prvi deo, pronala\u017eenje niza \\(cnt_i\\), uradi\u0107emo konstrukcijom novog niza, \\(b\\). Na po\u010detku, on \u0107e biti ispunjen nulama. Za svaki dan \\(i\\), mi \u0107emo pove\u0107ati \\(b_{l_i}\\) za jedan, a smanjiti \\(b_{r_i+1}\\) isto za jedan. Niz \\(cnt\\) dobijamo kao niz prefiksnih suma nad nizom \\(b\\).</p> <p>Drugi deo \u0107emo raditi sli\u010dno kao u prethodnom re\u0161enju, samo \u0161to \u0107emo umesto niza neobrisanih intervala, \u010duva\u0107emo skup (std::multiset), sortiran po desnom kraju intervala. \u010cuva\u0107emo samo one intervale koji sadr\u017ee trenutni element, dakle doda\u0107emo interval \\(j\\) tek kad va\u017ei \\(l_j = i\\), a izbaciti tek kad je obrisan ili kada \\(r_j = i\\). Svaki put kada treba da obri\u0161emo interval, obrisa\u0107emo najve\u0107i u skupu. Sli\u010dno se mo\u017ee uraditi i sa prioritetnim redom (std::priority_queue), sa malo dodatne analize.</p> <p>Vremenska slo\u017eenost je \\(O(N+MlogN)\\), a memorijska \\(O(N+M)\\).</p> 03_burad.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint solve(int N, int M, vector&lt;int&gt; a, vector&lt;pair&lt;int, int&gt; &gt; days) {\n  sort(days.begin(), days.end());\n  int pref[N+2], ends[N+2];\n  fill(pref, pref+N+2, 0);\n  fill(ends, ends+N+2, 0);\n  for(auto x : days) {\n    pref[x.first]++;\n    pref[x.second+1]--;\n  }\n  for(int i = 1; i &lt;= N; i++) {\n    pref[i] += pref[i-1];\n  }\n  priority_queue&lt;int&gt; pq;\n  int idx = 0, res = 0, active = 0;\n  for(int i = 1; i &lt;= N; i++) {\n    while(idx &lt; M &amp;&amp; days[idx].first == i) {\n      pq.push(days[idx].second);\n      idx++;\n    }\n    while(pref[i] &gt; a[i-1] &amp;&amp; pref[i]-a[i-1] &gt; active) {\n      int r = pq.top(); pq.pop();\n      ends[r]++;\n      active++;\n      res++;\n    }\n    active -= ends[i];\n  }\n  return res;\n}\n\nint main() {\n    int N, M; cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; a;\n    vector&lt;pair&lt;int, int&gt; &gt; days;\n    for(int i = 1; i &lt;= N; i++) {\n        int x; cin &gt;&gt; x;\n        a.push_back(x);\n    }\n    for(int i = 0; i &lt; M; i++) {\n        int x, y; cin &gt;&gt; x &gt;&gt; y;\n        days.push_back({x, y});\n    }\n    cout &lt;&lt; solve(N, M, a, days);\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/04_koncert/","title":"A1 - Koncert","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Va\u017eno obave\u0161tenje: odr\u017eava se koncert najpoznatijih izvo\u0111a\u010da rok muzike na kome u\u010destvuju Riblja \u010corba, Bajaga, Rokeri s Moravu, Dejan Cuki\u0107 i Rijana! Organi reda su dobili informaciju da su neki u\u010desnici Dr\u017eavnog takmi\u010denja iz informatike (ujedno i ljubitelji turbo-folka) odlu\u010dili da se infiltriraju me\u0111u publikom i prave nerede pevaju\u0107i pesme Dragane Mirkovi\u0107, \u0160emse Suljakovi\u0107a i Tejlor Svift.</p> <p>Prostor na kome je publika mo\u017eemo zamisliti kao matricu sa \\(n\\) redova (numerisanih od \\(1\\) do \\(n\\) odozgo nadole) i \\(m\\) kolona gde je red broj \\(1\\) prvi red, neposredno ispred izvo\u0111a\u010da, a red broj \\(n\\) je poslednji red. Svako polje matrice je ili slobodno (ozna\u010deno znakom '\\(0\\)') ili zauzeto od strane neke osobe (ozna\u010deno znakom '\\(1\\)'). Kada takmi\u010dar do\u0111e na koncert on izabere neko slobodno polje u poslednjem redu i stane tamo (ako takvih polja nema, ide ku\u0107i). Nakon toga, u jednom potezu mo\u017ee uraditi jednu od slede\u0107e 2 stvari:</p> <ul> <li>Pomeri se za jedno polje iznad (u red ispred) ukoliko je to polje slobodno; ili</li> <li>Pomeri se za jedno polje ulevo ili udesno (u istom redu). Prilikom pomeranja ulevo/udesno takmi\u010dar mo\u017ee gurati jednu ili vi\u0161e osoba u odgovaraju\u0107em smeru (ili se samo pomeriti na odgovaraju\u0107e polje ako je slobodno); preciznije, ako je snaga takmi\u010dara \\(k\\), tada, ukoliko se neposredno levo od takmi\u010dara nalazi uzastopna grupa od \\(a\\) (\\(a \\geq 0\\)) osoba nakon koje postoji bar jedno slobodno polje, mogu\u0107e je pomeriti se ulevo za jedno polje, pri \u010demu se cela grupa od \\(a\\) osoba tako\u0111e pomera za po jedno polje ulevo, ako i samo ako je \\(a \\leq k\\). Isto va\u017ei i za pomeranje udesno. Nije dozvoljeno gurati ljude van matrice.</li> </ul> <p>Takmi\u010dar \u017eeli da nekim nizom poteza do\u0111e do nekog polja u prvom redu ali tako da nijedno polje ne poseti vi\u0161e od jednom. \u010cim prvi put do\u0111e do nekog polja u prvom redu, on vi\u0161e ne pravi poteze ve\u0107 kre\u0107e da brejk-densuje i peva \"Cvetak zanovetak\"; njegov cilj je ostvaren.</p> <p>Odrediti na koliko na\u010dina takmi\u010dar mo\u017ee ostvariti svoj cilj i ispisati taj broj po modulu \\(10^9+7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Igor Pavlovi\u0107 <p>Kako nije dozvoljeno ponavljanje polja na putu, u svakom redu se ide samo u jednom smeru (ulevo ili udesno) ili direktno na gore. Promena strkture reda guranjem ne uti\u010de na dalji deo puta jer nije dozvoljeno vra\u0107anje unazad.</p> <p>U Podzadatku 1 je dovoljno koristiti klasi\u010dno dinami\u010dko programiranje za ra\u010dunanje broja odgovaraju\u0107ih puteva u \\(O(nm)\\) ili primeniti malo kombinatorike: za svaki od \\(n\\) redova mo\u017eemo na \\(m\\) na\u010dina izabrati polje u koje dolazimo iz prethodnog reda (za poslednji red, to je polje iz koga po\u010dinjemo) a nakon toga je put jedinstveno odre\u0111en. Dakle, odgovor je \\(m^n\\) mod \\((10^9 + 7)\\). Za Podzadatak 2 je dovoljno isprobati sve mogu\u0107e puteve, najednostavnije koriste\u0107i rekurziju/bektrek u slo\u017eenosti \\(O(m\\cdot m^n)\\).</p> <p>Zadatak je najprirodnije re\u0161avati dinami\u010dkim programiranjem. Defini\u0161imo \\(d[i][j] =\\) broj (validnih) puteva koji se zavr\u0161avaju u polju \\((i,j)\\) date matrice \\(a\\) pri \u010demu je poslednji potez \"nagore\". Kona\u010dno re\u0161enje je \\(\\sum_{1 \\leq j \\leq m, \\  a[1][j]=0} d[1][j]\\) a po\u010detne vrednosti su \\(d[n][j] = a[n][j]\\) za \\(j=1,2,\\ldots,m\\). Rekurentna veza je data sa \\(d[i][j] =\\sum_x d[i+1][x]\\), gde se sumiranje vr\u0161i po svim indeksima \\(x\\) takvih da je (guranjem) u \\((i+1)\\)-om redu mogu\u0107e do\u0107i od pozicije \\(x\\) (koja treba biti prazno polje) do pozicije \\(j\\) (koja ne mora nu\u017eno biti prazno polje). Najjednostavniji na\u010din je ispitati svaku poziciju \\(x\\) iz \\((i+1)\\)-og reda; ako je \\(x_L\\) pozicija \\((k+1)\\)-ve osobe levo  u odnosu na poziciju \\(x\\) a \\(x_R\\) pozicija \\((k+1)\\)-ve osobe desno  u odnosu na poziciju \\(x\\), tada, sa pozicije \\(x\\) mo\u017eemo guranjem do\u0107i do bilo koje koje (i samo te) pozicije iz segmenta \\([x_L+(k+1), x_R-k]\\). Vrednosti \\(x_L\\) i \\(x_R\\) za svako \\(x\\) mo\u017eemo odrediti u svega dva prolaza kroz \\((i+1)\\)-vi red (sleva udesno i sdesna ulevo) npr. ubacivaju\u0107i pozicije jedinica na koje nai\u0111emo u neki pomo\u0107ni vektor. Ovo daje re\u0161enje slo\u017eenosti \\(O(nm^2)\\) \u0161to je dovoljno za Podzadatak 4.</p> <p>U Podzadatku 3 nema guranja pa se rekurentna veza mo\u017ee uprostiti uvo\u0111enjem pomo\u0107nih matrica, npr. \\(L[i][j]=\\) broj puteva koji se zavr\u0161avaju u polju \\((i,j)\\) pri \u010demu je poslednji potez \"ulevo\" i analogno za \\(R[i][j]\\) i \"udesno\". Sada se sve ove matrice mogu paraleno izra\u010dunati, \\(d[i][j] = d[i+1][j]+L[i+1][j]+R[i+1][j]\\), \\(L[i][j] = L[i][j+1]+d[i][j+1]\\), \\(R[i][j] = R[i][j-1]+d[i][j-1]\\) (u odgovaraju\u0107em redosledu i proveru zauzetosti polja). To je \\(O(1)\\) po polju tj. \\(O(nm)\\) ukupno.</p> <p>Za kona\u010dno re\u0161enje, treba ubrzati \\(O(nm^2)\\) algoritam. Iz tog re\u0161enja, znamo da \u0107e za svako polje \\((i+1,x)\\), vrednost \\(d[i+1][x]\\) u\u010destvovati u formuli za ra\u010dunanje vrednosti \\(d[i][j]\\) za svako \\(j\\in[x_L+(k+1),x_R-k]\\) (uz proveru \\(d[i][j]=0\\) i granice za segment). Zato mo\u017eemo, nakon obrade \\((i+1)\\)-og reda, za svako \\(x\\) pove\u0107ati sve \\(d[i][j]\\) iz reda iznad koji su u odgovaraju\u0107em segmentu za \\(d[i+1][x]\\). Naravno, direktna implementacija ovoga ne bi smanjila slo\u017eenost ali mo\u017eemo koristiti poznati trik; dovoljno je dodati elementu na po\u010detku segmenta \\(+d[i+1][x]\\) i dodati elementu nakon kraja segmenta \\(-d[i+1][x]\\) (za svako \\(x\\)) i na kraju \u0107e tra\u017eene vrednosti u novom redu biti prefiksne sume trenutnih vrednosti. Ovo daje algoritam slo\u017eenosti \\(O(nm)\\).</p> <p>Alternativno (i ne\u0161to jednostavnije re\u0161enje) je definisati \\(d[i][j]=\\)broj puteva koji po\u010dinju iz polja \\((i,j)\\). Tada vrednosti mo\u017eemo ra\u010dunati odozgo nadole i, na osnovu prethodne diskusije, va\u017ei \\(d[i][j] = \\sum_{j_L + k + 1 \\leq x \\leq j_R - k} d[i-1][x]\\), gde se vrednosti \\(j_L\\) i \\(j_R\\) odnose na trenutni, \\(i\\)-ti red. Koriste\u0107i prefiksne sume, prethodnu sumu mo\u017eemo izra\u010dunati u \\(O(1)\\) (preciznije, jedan red matrice \\(d\\) ra\u010dunamo u \\(O(m)\\)) pa dobijamo algoritam slo\u017eenosti \\(O(nm)\\).</p> 04_koncert.cpp<pre><code>#include&lt;cstdlib&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAX_N = 2000;\n\nint n, m, k;\nchar a[MAX_N + 10][MAX_N + 10];\nint dp[MAX_N + 10][2];\nvector&lt;int&gt; v;\n\nint main()\n{\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);\n    for (int i = 1; i &lt;= n; i++)\n    {\n        scanf(\"%s\", a[i] + 1);\n    }\n\n    int curr = 0;\n    for (int j = 1; j &lt;= m; j++)\n        if (a[n][j] == '0')\n            dp[j][curr] = 1;\n        else\n            dp[j][curr] = 0;\n\n    for (int i = n; i &gt; 1; i--)\n    {\n        curr = 1 - curr;\n        for (int j = 0; j &lt;= m; j++)\n            dp[j][curr] = 0;\n\n        // left\n        v.clear();\n        for (int j = 1; j &lt;= m; j++)\n        {\n            if (a[i][j] == '1')\n                v.push_back(j);\n            else\n            {\n                int left = 0;\n                if ((int)v.size() &gt; k)\n                    left = v[v.size() - (k + 1)] + (k + 1);\n                else\n                    left = v.size() + 1;\n                dp[left][curr] = (dp[left][curr] + dp[j][1 - curr]) % MOD;\n                dp[j][curr] = (dp[j][curr] - dp[j][1 - curr]) % MOD;\n            }\n        }\n\n        // right\n        v.clear();\n        for (int j = m; j &gt;= 1; j--)\n        {\n            if (a[i][j] == '1')\n                v.push_back(j);\n            else\n            {\n                int right = 0;\n                if ((int)v.size() &gt; k)\n                    right = v[v.size() - (k + 1)] - (k + 1);\n                else\n                    right = m - v.size();\n                dp[j][curr] = (dp[j][curr] + dp[j][1 - curr]) % MOD;\n                dp[right + 1][curr] = (dp[right + 1][curr] - dp[j][1 - curr]) % MOD;\n            }\n        }\n\n        for (int j = 1; j &lt;= m; j++)\n            dp[j][curr] = (dp[j][curr] + dp[j - 1][curr]) % MOD;\n        for (int j = 1; j &lt;= m; j++)\n            if (a[i - 1][j] == '1') dp[j][curr] = 0;\n    }\n\n    int sol = 0;\n    for (int j = 1; j &lt;= m; j++)\n        sol = (sol + dp[j][curr]) % MOD;\n    if (sol &lt; 0)\n        sol = sol + MOD;\n    printf(\"%d\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/04_koncert/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se celi brojevi \\(n\\), \\(m\\) i \\(k\\), redom, gde su \\(n\\) i \\(m\\) dimenzije matrice a \\(k\\) snaga takmi\u010dara. U narednih \\(n\\) redova, nalazi se po \\(m\\) karaktera, bez razmaka, od kojih je svaki '\\(0\\)' ili '\\(1\\)' - opis prostora na kome je publika.</p>"},{"location":"takprog/2021_2022/drz/04_koncert/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati broj na\u010dina na koje takmi\u010dar mo\u017ee ostvariti svoj cilj po modulu \\(10^9+7\\).</p>"},{"location":"takprog/2021_2022/drz/04_koncert/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq n, m \\leq 2000\\)</li> <li>\\(0 \\leq k \\leq m\\)</li> <li>Svi karakteri matrice iz ulaza \u0107e biti '\\(0\\)' ili '\\(1\\)'.</li> </ul>"},{"location":"takprog/2021_2022/drz/04_koncert/#podzadaci","title":"Podzadaci","text":"<ol> <li>(7 poena) Nema ljudi u publici, tj. svi karakteri ulazne matrice \u0107e biti '\\(0\\)'.</li> <li>(11 poena) \\(n,m \\leq 7\\).</li> <li>(15 poena) \\(k = 0\\).</li> <li>(22 poena) \\(n, m \\leq 400\\)</li> <li>(45 poena) Bez dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/drz/04_koncert/#primeri","title":"Primeri","text":""},{"location":"takprog/2021_2022/drz/04_koncert/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/04_koncert/#ulaz","title":"Ulaz","text":"<pre><code>3 9 3\n010001100\n101011010\n011101110\n</code></pre>"},{"location":"takprog/2021_2022/drz/04_koncert/#izlaz","title":"Izlaz","text":"<pre><code>7\n</code></pre>"},{"location":"takprog/2021_2022/drz/04_koncert/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Imamo 3 reda i u svakom redu po 9 polja; snaga takmi\u010dara je 3. Ozna\u010dimo sa 'U' potez nagore, sa 'L'  potez ulevo i sa 'R'  potez udesno. Ako se krene iz polja (3,1), svi na\u010dini su: RURU i RURRU; ako se krene iz polja (3,5), svi na\u010dini su: LUU, LULU, LURU; ako se krene iz polja (3, 9), svi na\u010dini su: UU i ULU. Ovo je ukupno \\(7\\) mod \\((10^9 + 7) = 7\\) na\u010dina. Primetimo npr da kretanja RUU i RURRRU iz polja (3,1) nisu validna - prvo jer u tre\u0107em potezu nije mogu\u0107e i\u0107i nagore kada je polje iznad zauzeto a drugo jer u petom potezu takmi\u010dar ne mo\u017ee gurati 4 osobe jer mu je snaga 3.</p>"},{"location":"takprog/2021_2022/drz/04_koncert/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/drz/04_koncert/#ulaz_1","title":"Ulaz","text":"<pre><code>4 5 1\n11000\n00110\n01001\n10001\n</code></pre>"},{"location":"takprog/2021_2022/drz/04_koncert/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2021_2022/drz/05_smeker/","title":"A2 - \u0160meker","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Na igrali\u0161tu se sva\u0161ta de\u0161ava. Kako bi klan iz susednog igrali\u0161ta mogao svakog trenutka da lansira napad, mora da postoji jasna podela uloga me\u0111u decom. Zbog toga, svako igrali\u0161te mora da ima svog predsednika, potpredsednika, \u0161mekera, golmana i blagajnika.</p> <p>Dok se ostale uloge biraju tradicionalnim demokratskim putem, uloga de\u017eurnog \u0161mekera, koja je, svakako, po mnogo \u010demu posebna, ima i poseban na\u010din izbora. Naime, igrali\u0161te mo\u017eemo zamisliti kao koordinatnu ravan. Kako na igrali\u0161tu postoje striktna pravila pona\u0161anja, svako dete \u0107e do\u0107i direktno na svoju predodre\u0111enu poziciju \\((x,y)\\), i ostatak dana se odatle ne\u0107e pomerati (nemojte da brinete, svakom detetu je obezbe\u0111ena li\u010dna ljulja\u0161ka i par klikera da mu ne bi bilo dosadno). \u0160meker je neko ko je uvek u centru pa\u017enje, pa taj jedino mo\u017ee biti dete sa pozicijom na koordinatama \\((x_s,y_s)\\) tako da va\u017ei slede\u0107e:</p> <ul> <li>Broj dece na igrali\u0161tu sa koordinatama \\((x,y)\\), gde je \\(x&gt;x_s\\) i \\(y&gt;y_s\\) je jednak broju dece na igrali\u0161tu sa koordinatama \\((x,y)\\), gde je \\(x&lt;x_s\\) i \\(y&lt;y_s\\);</li> <li>Broj dece na igrali\u0161tu sa koordinatama \\((x,y)\\), gde je \\(x&gt;x_s\\) i \\(y&lt;y_s\\) je jednak broju dece na igrali\u0161tu sa koordinatama \\((x,y)\\), gde je \\(x&lt;x_s\\) i \\(y&gt;y_s\\).</li> </ul> <p>Na po\u010detku je igrali\u0161te prazno i na njega redom dolaze deca. U \\(i\\)-tom minutu \u0107e \\(i\\)-to dete sti\u0107i na svoju poziciju \\((x_i,y_i)\\). Predsednik igrali\u0161ta vas je zamolio da pravedno reguli\u0161ete dodelu uloge \u0161mekera, tako \u0161to posle svakog novog dolaska deteta predlo\u017eite kandidata koji ispunjava uslove, ili da ka\u017eete ukoliko takav ne postoji. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2021_2022/drz/05_smeker/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalazi pozitivan ceo broj \\(N\\), ukupan broj dece. U \\(i\\)-tom od narednih \\(N\\) redova se nalaze po \\(2\\) cela broja \\(x_i\\) i \\(y_i\\), koja predstavljaju poziciju \\(i\\)-tog deteta, koje \u0107e do\u0107i na igrali\u0161te u \\(i\\)-tom minutu.</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz potrebno je ispisati \\(N\\) linija. U \\(i\\)-toj liniji je potrebno ispisati indeks nekog deteta koje mo\u017ee biti \u0161meker (ukoliko ih ima vi\u0161e, ispisati bilo koje), a ukoliko takvo ne postoji, potrebno je ispisati \\(-1\\).</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N \\leq 200.000\\)</li> <li>\\(1 \\leq x_i,y_i \\leq 1.000.000.000\\)</li> <li>Sve vrednosti \\(x_i\\) su me\u0111usobno razli\u010dite</li> <li>Sve vrednosti \\(y_i\\) su me\u0111usobno razli\u010dite</li> </ul>"},{"location":"takprog/2021_2022/drz/05_smeker/#podzadaci","title":"Podzadaci","text":"<ol> <li>(12 poena) \\(N\\leq500\\) </li> <li>(22 poena) \\(x_i=y_i\\) </li> <li>(23 poena) \\(N\\leq4.000\\) </li> <li>(43 poena) Bez dodatnih ograni\u010denja</li> </ol>"},{"location":"takprog/2021_2022/drz/05_smeker/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/05_smeker/#ulaz","title":"Ulaz","text":"<pre><code>3\n1 1\n2 2\n3 3\n</code></pre>"},{"location":"takprog/2021_2022/drz/05_smeker/#izlaz","title":"Izlaz","text":"<pre><code>1\n-1\n2\n</code></pre>"},{"location":"takprog/2021_2022/drz/05_smeker/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Posle prve minute \u0107e se na igrali\u0161tu nalaziti samo jedno dete, tako da \u0107e biti po \\(0\\) dece u svakom od \u010detiri posmatrana skupa, pa \u0107e on mo\u0107i da bude \u0161meker. Posle drugog minuta \u0107e na igrali\u0161tu biti \\(2\\) deteta, i nijedan ne\u0107e mo\u0107i da bude \u0161meker.  Posle tre\u0107eg minuta, dete broj \\(2\\) mo\u017ee da bude \u0161meker jer ima po \\(1\\) dete \u010dije su obe koordinate ve\u0107e/manje, dok je ovih \"me\u0161ovitih\" po \\(0\\).</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/drz/05_smeker/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n1 1\n2 5\n3 3\n4 2\n5 4\n</code></pre>"},{"location":"takprog/2021_2022/drz/05_smeker/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n-1\n-1\n-1\n3\n</code></pre>"},{"location":"takprog/2021_2022/drz/05_smeker/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Posle 5 minuta, za dete broj \\(3\\) su sva \\(4\\) skupa veli\u010dine \\(1\\), pa on mo\u017ee da bude \u0161meker.</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#resenje-kada-n-m-leq-500","title":"Re\u0161enje kada \\(N, M \\leq 500\\)","text":"<p>U ovom slu\u010daju, kao re\u0161enje mo\u017eemo da za svako dete samo izbrojimo koliko postoji dece u svakom od \\(4\\) kvadranta. Za ovo naprosto iteriramo kroz svu decu posle svakog dodavanja, i sa par provera uslova na\u0111emo \u0161mekera. Slo\u017eenost \\(O(N^3)\\)</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#resenje-kada-tacke-imaju-iste-x-i-y-koordinate","title":"Re\u0161enje kada ta\u010dke imaju iste \\(x\\) i \\(y\\) koordinate","text":"<p>U ovom slu\u010daju, mo\u017eemo da vidimo da je drugi uslov trivijalno ispunjen, pa samo treba da na\u0111emo dete za koje va\u017ei da ima jednako dece gore desno i dole levo. Ovo je ekvivalentno sa time da ako posmatramo da su deca na pravoj, tra\u017eimo onog \u010dija je pozicija medijana niza. Stoga nam je potrebna neka struktura koja nam omogu\u0107ava odr\u017eavanje medijane niza u kojem dodajemo nove elemente. Ovo mo\u017ee da se uradi nekim jakim strukturama kao <code>ordered statistic set</code>, ali najelementarnije re\u0161enje bi bilo da odr\u017eavamo dve <code>heap</code> strukture, jedan gde se \u010duva najve\u0107ih i drugi gde se \u010duva najmanjih pola elemenata. Kada dodajemo jedan element u niz, ubacimo ga u neki od njih, i onda najvi\u0161e jednim prebacivanjem mo\u017eemo da odr\u017eimo tra\u017eenu strukturu.</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#resenje-kada-nleq-4000","title":"Re\u0161enje kada \\(N\\leq 4000\\)","text":"<p>Primetimo da je uslov da je neko dete \u0161meker ekvivalentan sa time da je njegova \\(x\\)-koordinata medijana po svim \\(x\\)-koordinatama, i njegova \\(y\\)-koordinata medijana po svim \\(y\\)-koordinatama. Zaista, ako je gore levo \\(a_1\\), gore desno \\(a_2\\), dole desno \\(a_3\\) i dole levo \\(a_4\\) dece, uslov za medijane je \\(a_1+a_2=a_3+a_4\\) i \\(a_1+a_4=a_2+a_3\\), pa sabiranjem imamo \\(2a_1+a_2+a_4=a_2+2a_3+a_4\\iff a_1=a_3\\), iz \u010dega zaklju\u010dujemo i \\(a_2=a_4\\), pa dete koje je po obe koordinate medijana je zaista \u0161meker. Obratno, ako je \\(a_1=a_3\\) i \\(a_2=a_4\\), uslovi \\(a_1+a_2=a_3+a_4\\) i \\(a_1+a_4=a_2+a_3\\) su trivijalno ispunjeni, pa smo dokazali tra\u017eenu ekvivalenciju. </p> <p>Sada imamo vrlo lako re\u0161enje u \\(O(N^2logN)\\) tako \u0161to posle svakog dodavanja po obe koordinate na\u0111emo medijanu u \\(O(NlogN)\\), i u zavisnosti od toga jel pripada istom detetu smo na\u0161li \u0161mekera ili na\u0161li da \u0161meker ne postoji.</p>"},{"location":"takprog/2021_2022/drz/05_smeker/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ovde je neophodno samo kombinovati ideje iz prethodna dva podzadatka. Kao u drugom podzadatku odr\u017eavamo medijanu, ali zasebno za \\(x\\)- i za \\(y\\)-koordinatu u na\u0161oj omiljenoj strukturi. Onda posle svakog novog deteta, vidimo da li su deca koji odgovaraju tim medijanama jednaki. Ukupna slo\u017eenost \\(O(NlogN)\\).</p> 05_smeker.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst string folder=\"testcases\\\\\";\npriority_queue&lt;pair&lt;int,int&gt;&gt; pql[2];\npriority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; pqu[2];\nvoid addtoheaps(int i,int k,int val)\n{\n    pair&lt;int,int&gt; t={val,k};\n    if(k==1) {pql[i].push(t); return;}\n    if(k&amp;1)\n    {\n        if(t&lt;pqu[i].top()) pql[i].push(t);\n        else\n        {\n            pair&lt;int,int&gt; r=pqu[i].top();\n            pqu[i].pop(); pqu[i].push(t);\n            pql[i].push(r);\n        }\n        return;\n    }\n    if(t&gt;pql[i].top()) pqu[i].push(t);\n    else\n    {\n        pair&lt;int,int&gt; r=pql[i].top();\n        pql[i].pop(); pql[i].push(t);\n        pqu[i].push(r);\n    }\n}\nint getmedian(int i)\n{\n    if(pql[i].size()!=pqu[i].size()) return pql[i].top().second;\n    return -1;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;=n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&amp;x,&amp;y);\n        addtoheaps(0,i,x);\n        addtoheaps(1,i,y);\n        int a=getmedian(0);\n        int b=getmedian(1);\n        printf(\"%d\\n\",((a==b)?a:-1));\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/drz/06_konstrukta/","title":"A3 - Konstrukta","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1600ms 256MB <p>Verovatno ste svi \u010duli za Evroviziju, jedno od najpoznatijih svetskih muzi\u010dkih takmi\u010denja. Ove godine, na Evroviziji \u0107e u\u010destvovati ta\u010dno \\(N\\) dr\u017eava. Pro\u0161logodi\u0161nji pobednik takmi\u010denja, Svanzibarija, je odustao iz nepoznatih razloga. Kako se finalno takmi\u010denje pribli\u017eava, potrbeno je odlu\u010diti se koja od \\(N\\) dr\u017eava u\u010desnica \u0107e orgainzovati finale. Izme\u0111u ovih \\(N\\) dr\u017eava postoji ta\u010dno \\(N-1\\) direktnih autobuskih linija, koje povezuju pojedine parove dr\u017eava. Linije koja povezuje dve dr\u017eave ne prolaze kroz neku od ostalih dr\u017eave. Garantuje se da su linije tako konstruisane da je mogu\u0107e otputovati od bilo koje dr\u017eave do bilo koje druge odre\u0111enim podskupom linija. Ne zaboravite, ove \\(26101997\\). godine avioni su prestali da lete i jedino prevozno sredstvo su autobusi.</p> <p>Organizatori \u017eele najbolje mogu\u0107e uslove za sve takmi\u010dare, oni su odlu\u010dili da organizuju takmi\u010denje u dr\u017eavi u kojoj svi takmi\u010dari mogu sti\u0107i \u0161to je br\u017ee mogu\u0107e. Ovo podrazumeva da maksimalan broj linija koje moraju predstavnici jedne dr\u017eave da promene da bi do\u0161li do mesta finala bude \u0161to je manji mogu\u0107.</p> <p>Naravno, to nije sve! Da bi dodatno olak\u0161ali put, organizatori su re\u0161ili da konstrui\u0161u ta\u010dno jo\u0161 jednu direktnu autobusku liniju izme\u0111u dve razli\u010dite dr\u017eave izme\u0111u koje ona do sada nije postojala. Na taj na\u010din, broj linija koji \u0107e predstavnici pojedinih dr\u017eava promeniti da bi do\u0161li do finala mo\u017ee da se smanji.</p> <p>Pomozite organizatorima da odlu\u010de izme\u0111u koje dve dr\u017eave \u0107e konstruisati direktnu autobusku liniju i gde \u0107e se odr\u017eati finale Evrovizije.</p> <p>Napomena: Va\u0161a odluka se smatra ispravnom ako ne postoji neki drugi na\u010din za konstruisanje dodatne autobuske linije i biranje mesta odr\u017eavanja finala koji dovodi do toga da broj linija koji pre\u0111u predstavnici najudaljenije dr\u017eave bude manji.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Aleksa Milisavljevi\u0107 Aleksa Plav\u0161i\u0107 <p>Zadatak mo\u017eemo modelovati kao neusmereno stablo, gde \u010dvorovi predstavljaju dr\u017eave, dok grane predstavljaju autobuske linije.</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#opis-ulaza","title":"Opis Ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei prirodan broj \\(N\\), broj dr\u017eava koje u\u010destvuju na Evroviziji. Svaki od narednih \\(N - 1\\) redova sadr\u017ei po dva prirodna broja \\(u\\), \\(v\\), indekse dr\u017eava koje su povezane direktnom autobuskom linijom.</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#opis-izlaza","title":"Opis Izlaza","text":"<p>U prvom redu standardnog izlaza ispisati redne brojeve dr\u017eava izme\u0111u kojih \u0107e se konstruisati dodatna autobuska linija. U drugom redu izlaza ispisati dr\u017eavu u kojoj \u0107e biti organizovana Evrovizija.</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3\\leq N \\leq 2 \\cdot 10^5\\)</li> <li>\\(1\\leq u \\neq v \\leq N\\)</li> </ul>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#podzadaci","title":"Podzadaci","text":"<ol> <li>(16 poena) Svaki grad je povezan sa najvi\u0161e dva druga grada direktnom linijom.</li> <li>(13 poena) \\(N \\leq 100\\)</li> <li>(12 poena) \\(N \\leq 400\\)</li> <li>(26 poena) \\(N \\leq 2000\\)</li> <li>(33 poena) Bez dodatnih ograni\u010denja</li> </ol>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/drz/06_konstrukta/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 2\n1 3\n1 4\n1 5\n</code></pre>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#izlaz","title":"Izlaz","text":"<pre><code>2 3\n1\n</code></pre>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Dodatna autobusku liniju mo\u017eemo sagraditi izme\u0111u dr\u017eava sa indeksima \\(2\\) i \\(3\\) i za mesto odr\u017eavanja Evrovizije biramo dr\u017eavu sa indeksom \\(1\\). Predstavnici dr\u017eave sa indeksima \\(2\\), \\(3\\), \\(4\\) i \\(5\\) moraju promeniti jednu autobusku liniju, dok predstavnici organizatora ne moraju koristi autobus. U ovom primeru postoje i druge mogu\u0107nosti za konstruisanje dodatne autobuske linije koje dovode do optimalnog re\u0161enja.</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#prvi-podzadatak","title":"Prvi podzadatak:","text":"<p>Uvek mo\u017eemo posti\u0107i da najudaljeniji \u010dvor bude na udaljenosti \\(D = \\frac{N}{4} + 1\\). Ako \u010dvorove na putu indeksiramo sa \\(x_1, x_2, \\dots, x_N\\) postavi\u0107emo granu izme\u0111u \u010dvorova \\(x_{D + 1}\\) i x_{N - D + 1} i Evroviziju \u0107emo odr\u017eati u prvom od njih. Lako se mo\u017ee pokazati da ne mo\u017eemo posti\u0107i bolje re\u0161enje za graf koji je put. Potrebno je biti pa\u017eljiv za puteve du\u017eine \\(4\\) i \\(5\\).</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#drugi-podzadatak","title":"Drugi podzadatak:","text":"<p>Fiksira\u0107emo \u010dvorove izme\u0111u kojih \u0107emo dodati granu (\\(O(N^2)\\) mogu\u0107nosti) i fiksira\u0107emo \u010dvor u kome \u0107e biti odr\u017eana Evrovizija (\\(O(N)\\) mogu\u0107nosti). Potrebno je na\u0107i najkra\u0107i put od \u010dvora u kome \u0107e biti odr\u017eana Evrovizija do ostalih \u010dvorova, \u0161to mo\u017eemo uraditi algoritmom pretrage u \u0161irinu (BFS). Mo\u017eemo iskoristiti i odre\u0111ene modifikacije pretrage u dubinu (DFS), po\u0161to graf sadr\u017ei ta\u010dno jedan ciklus. Vremenska slo\u017eenost ovog algoritma iznosi \\(O(N^4)\\), dok memorijska iznosi \\(O(N)\\) ili \\(O(N^2)\\) zavisno od reprezentacije grafa.</p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#treci-podzatak","title":"Tre\u0107i podzatak:","text":"<p>Obzervacija 1: Evroviziju uvek treba odr\u017eati u jednom od krajeva grane koje dodajemo. Ovo ne povla\u010di da u nekim drugim \u010dvorovima ne mo\u017eemo odr\u017eati Evroviziju, ve\u0107 da je jedan od krajeva grane uvek me\u0111u optimalnim izborima. Primetimo da specijalan slu\u010daj predstavljaju grafovi koji imaju dijametar (najdu\u017ei put) du\u017eine 2, u tom slu\u010daju dodavanje nove grane ne pobolj\u0161ava re\u0161enje.</p> <p>Ovo nam pru\u017ea podlogu za algoritam vremenske slo\u017eenosti \\(O(N^3)\\), po\u0161to za fiksnu granu treba da proverimo samo dve mogu\u0107nosti za mesto odr\u017eavanja Evrovizije. U slu\u010daju da je dijametar du\u017eine \\(2\\), mo\u017eemo ispisati bilo koju granu. </p>"},{"location":"takprog/2021_2022/drz/06_konstrukta/#kompletno-resenje","title":"Kompletno re\u0161enje:","text":"<p>Obzervacija 2: Grana koju dodajemo uvek \u0107e povezivati dva \u010dvora na dijametru stabla (ako imamo vi\u0161e dijametara, mo\u017eemo izabrati proizvoljan).</p> <p>Neka niz \u010dvorova \\(x_1, x_2, \\dots, x_d\\) predstavlja dijametar stabla. Primetimo da je maksimalna udaljenost nekog od \u010dvorova binarno pretra\u017eiva i da ne mo\u017ee iznositi vi\u0161e od \\(\\frac{d}{2}\\) (ako se Evrovizija odr\u017eava u \u010dvoru \\(x_{\\frac{d + 1}{2}}\\)). Pretpostavimo da trenutno proveravamo u binarnoj pretrazi da li mo\u017ee maksimalna udaljenost biti manja ili jednaka od \\(c\\). U tom slu\u010daju optimalno je postaviti granu izme\u0111u \u010dvorova \\(x_{c + 1}\\) i $x_{d - c + 1} i odr\u017eati Evroviziju u prvom od njih ili izme\u0111u \u010dvorova \\(x_c\\) i \\(x_{d - c}\\) i odr\u017eati Evroviziju u drugom od njih. Kada znamo izme\u0111u koja dva \u010dvora \u0107emo postaviti granu i da jedan od njih mora biti mesto odr\u017eavanja Evrovizije, ostalo je samo proveriti da li neki od njih zadovoljava uslov da nakon postavljanja grane svi ostali \u010dvorovi budu udaljeni ne vi\u0161e od \\(c\\). To mo\u017eemo ponovo uraditi nekim od algoritama za pronalazak najkra\u0107eg puta u grafu. Ukupna vremenska slo\u017eenost \\(O(N log N)\\) i memorijska \\(O(N)\\).</p> <p>Bonus: Re\u0161ite zadatak u vremenskoj slo\u017eenosti \\(O(N)\\).</p> 06_konstrukta.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define pii pair&lt;int, int&gt;\n\nconst int maxN = 2e5 + 10;\n\nint N, furthestNode, maxDist, dist[maxN];\nvector&lt;int&gt; v[maxN], diametarPath;\nmap&lt;pii, int&gt; edges;\n\n\nvoid bfs(int startNode) {\n    dist[startNode] = 0;\n    queue&lt;int&gt; q;\n    q.push(startNode);\n\n    while(!q.empty()) {\n        int currentNode = q.front();\n        q.pop();\n\n        for (int node: v[currentNode]) {\n            if (dist[node] == -1) {\n                dist[node] = dist[currentNode] + 1;\n                q.push(node);\n            }\n        }\n    }\n}\n\nint findBiggestDistanceFromNode(int startNode, int newLineEndpointA, int newLineEndpointB) {\n    v[newLineEndpointA].push_back(newLineEndpointB);\n    v[newLineEndpointB].push_back(newLineEndpointA);\n\n    for (int i = 1; i &lt;= N ;i++) {\n        dist[i] = -1;\n    }\n\n    bfs(startNode);\n\n    int biggestDistance = 0;\n    for (int i = 1; i &lt;= N; i++) {\n        biggestDistance = max(biggestDistance, dist[i]);\n    }\n\n    v[newLineEndpointA].pop_back();\n    v[newLineEndpointB].pop_back();\n\n    return biggestDistance;\n}\n\nvoid findDiameterEnd(int node, int dist, int parent) {\n    if (dist &gt; maxDist) {\n        maxDist = dist;\n        furthestNode = node;\n    }\n\n    for (int i: v[node]) {\n        if (i != parent) {\n            findDiameterEnd(i, dist + 1, node);\n        }\n    }\n}\n\nvoid getDiameterPath(int currentNode, int targetNode, int par, vector&lt;int&gt; &amp;currentPath) {\n    currentPath.push_back(currentNode);\n\n    if (currentNode == targetNode) {\n        diametarPath = currentPath;\n    }\n\n    for (int i: v[currentNode]) {\n        if (i != par) {\n            getDiameterPath(i, targetNode, currentNode, currentPath);\n        }\n    }\n\n    currentPath.pop_back();\n}\n\npii findPairOfNonConnectedNodes() {\n    for (int node = 1; node &lt;= N; node++) {\n        int nextNode = node == N ? 1 : node + 1;\n        if (edges.find({node, nextNode}) == edges.end()) {\n            return {node, nextNode};\n        }\n    }\n\n    return {-1, 1};\n}\n\nint main() {\n\n    scanf(\"%d\", &amp;N);\n\n    for (int i = 1; i &lt; N; i++) {\n        int x, y;\n        scanf(\"%d%d\", &amp;x, &amp;y);\n        edges[{x, y}] = true;\n        edges[{y, x}] = true;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    maxDist = -1;\n    findDiameterEnd(1, 0, 0);\n    int firstDiameterEndpoint = furthestNode;\n\n    maxDist = -1;\n    findDiameterEnd(firstDiameterEndpoint, 0, 0);\n    int secondDiameterEndpoint = furthestNode;\n\n    vector&lt;int&gt; path;    \n    getDiameterPath(firstDiameterEndpoint, secondDiameterEndpoint, 0, path);\n\n    int diamLen = diametarPath.size();\n    int lo = 0;\n    int ro = diamLen/2;\n\n    while (lo &lt; ro - 1) {\n        int mid = lo + ro &gt;&gt; 1;\n        maxDist = findBiggestDistanceFromNode(diametarPath[mid], diametarPath[mid], diametarPath[diamLen - mid]);\n        maxDist = min(maxDist, findBiggestDistanceFromNode(diametarPath[diamLen - mid - 1], diametarPath[mid - 1], diametarPath[diamLen - mid - 1]));\n\n        if (maxDist &lt;= mid) {\n            ro = mid;\n        } else {\n            lo = mid;\n        }\n    }\n\n    int eurosongFinalNode, newLineEndpointA, newLineEndpointB;\n\n    if (findBiggestDistanceFromNode(diametarPath[ro], diametarPath[ro], diametarPath[diamLen - ro]) &lt;\n                                    findBiggestDistanceFromNode(diametarPath[diamLen - ro - 1], diametarPath[ro - 1], diametarPath[diamLen - ro - 1])) {\n        eurosongFinalNode = diametarPath[ro];\n        newLineEndpointA = diametarPath[ro];\n        newLineEndpointB = diametarPath[diamLen - ro];\n    } else {\n        eurosongFinalNode = diametarPath[diamLen - ro - 1];\n        newLineEndpointA = diametarPath[diamLen - ro  - 1];\n        newLineEndpointB = diametarPath[ro - 1];\n    }\n\n    if (newLineEndpointA == newLineEndpointB || edges.find({newLineEndpointA, newLineEndpointB}) != edges.end()) { // new path is irrelevant\n        pii nonConnectedNodes = findPairOfNonConnectedNodes();\n        newLineEndpointA = nonConnectedNodes.first;\n        newLineEndpointB = nonConnectedNodes.second; \n    } \n\n    printf(\"%d %d\\n\", newLineEndpointA, newLineEndpointB);\n    printf(\"%d\\n\", eurosongFinalNode);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/","title":"1 - Ra\u010dunar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Na jednom ra\u010dunaru se izvr\u0161ava \\(N\\) zadataka paralelno. Za svaki zadatak je poznat po\u010detni i krajnji tranutak njegovog izvr\u0161avanja. Nakon \u0161to zadatak zavr\u0161i sa izvr\u0161avanjem on prvo mora da sa\u010deka da se zavr\u0161e svi zadaci koji su po\u010deli pre njega pre nego \u0161to upi\u0161e svoj rezultat u memoriju. Upisivanje u memoriju se vr\u0161i trenutno.</p> <p>Va\u0161 zadatak je da za svaki od \\(N\\) zadataka odredite u kom trenutku \u0107e njegov rezultat biti upisan u memoriju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Igor Pavlovi\u0107 Igor Pavlovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 <p>Najpre je neophodno uo\u010diti da svaki zadatak iz postavke ima svoj redni broj (indeks) u redosledu zadataka, po\u010detak i kraj izvr\u0161avanja, te trenutak upisa rezultata u memoriju koji je potrebno odrediti. Stoga je korisno iskoristiti neku od struktura koja grupi\u0161e ove \u010detiri karateristike svakog zadatka. Tako\u0111e, prema postavci, zadaci nisu sortirani ni prema po\u010detnom, a ni prema krajnjem trenutku svog izvr\u0161avanja.</p>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei jedan ceo broj \\(N\\). Narednih \\(N\\) redova standardnog ulaza sadr\u017ee dva cela broja \\(A_i\\) i \\(B_i\\), po\u010detni i krajnji trenutak zadatka.</p>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(i\\)-tom redu standardnog izalaza ispisati trenutak u kom \u0107e \\(i\\)-ti zadatak upisati svoj rezultat.</p>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq A_i, B_i \\leq 10^9\\)</li> <li>Po\u010detni i krajnji trenuci svih zadataka su me\u0111usobno razli\u010diti</li> <li>Nijedan zadatak ne\u0107e po\u010deti u trenutku kada se neki zadatak zavr\u0161io</li> </ul>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#podzadaci","title":"Podzadaci","text":"<ul> <li>(22 poena): \\(1 \\leq N \\leq 200\\)</li> <li>(27 poena): \\(1 \\leq N \\leq 2000\\)</li> <li>(29 poena): \\(1 \\leq A_i, B_i \\leq 5\\cdot  10^5\\)</li> <li>(22 poena): Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 6\n1 4\n3 5\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#izlaz","title":"Izlaz","text":"<pre><code>6\n4\n6\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Prvi i drugi zadatak ne moraju da \u010dekaju da ostali zadaci zavr\u0161e sa izvr\u0161avanjem. Tre\u0107i zadatak \u0107e sa\u010dekati da prvi zadatak zavr\u0161i sa izvr\u0161avanjem zato \u0161to je on zapo\u010det pre njega.</p>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n5 6\n3 4\n1 2\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n4\n2\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#kvadratno-resenje","title":"Kvadratno re\u0161enje","text":"<p>Dovoljno je u dve ugne\u017e\u0111ene petlje redosledom pro\u0107i po svim zadacima i za svaki zadatak ispitati da li postoji neki drugi zadatak koji je po\u010deo pre njega, a koji se zavr\u0161ava nakon njega. Drugim re\u010dima, u petljama za svaka dva zadatka \\(i\\) i \\(j\\) proveravati da li je \\(A_j &lt; A_i\\) i \\(B_j &gt; B_i\\) i simultano a\u017eurirati tra\u017eeno vreme upisa u memoriju na maksimalno \\(B_j\\) od zadataka koji zadovoljavaju prethodni uslov. Najzad, po redosledu pro\u0107i i ispisati vremena. Kako se u svakoj od dve petlje prolazi kroz sve zadatke, ovo re\u0161enje ima kvadratnu vremensku slo\u017eenost, odnosno \\(\\mathcal{O}(N^2)\\), gde \\(N\\) predstavlja broj zadataka.</p>"},{"location":"takprog/2021_2022/egoi_izb/01_racunar/#glavno-resenje-u-loglinearnoj-slozenosti","title":"Glavno re\u0161enje u loglinearnoj slo\u017eenosti","text":"<p>Da bi se problem re\u0161io na efikasan na\u010din, mogu se zadaci umesto po indeksu sortirati po vremenu po\u010detka izvr\u0161avanja. Po\u0161to u tako sortiranim zadacima nakon \\(i\\)-tog zadatka nema zadataka koji su po\u010deli posle njega, to je dovoljno u samo jednom prolasku kroz zadatke, vode\u0107i ra\u010duna o dotada\u0161njem maksimumu, a\u017eurirati vreme upisa u memoriju kao trenutnu vrednost maksimuma. Najzad, potrebno je pre ispisa zadatke ponovo sortirati po redosledu u\u010ditavanja, odnosno po indeksima, kako bi se u jednom prolasku ispisala tra\u017eena vremena. Kako je operaciju sortiranja efikasnim algoritmima mogu\u0107e izvr\u0161iti u loglinearnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(N\\log N)\\), a kako je ovo vremenski najzahtevnija operacija u predlo\u017eenom re\u0161enju, to je i ukupna slo\u017eenost ovog re\u0161enja loglinearna po broju zadataka.</p> 01_racunar.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxN 200005\n\nusing namespace std;\n\nstruct Task{\n\nTask(int a,int b, int i){\n    start = a;\n    end = b;\n    id = i;\n};\n\nint start, end, id, ans;\n};\n\nbool cmp_start(Task a,Task b){\n    return a.start &lt; b.start;\n}\n\nbool cmp_id(Task a,Task b){\n    return a.id &lt; b.id;\n}\n\nvector &lt;Task&gt; tasks;\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n    assert(n&lt;=2e5);\n\n    for(int i=0;i&lt;n;i++){\n        int a, b;\n        cin&gt;&gt;a&gt;&gt;b;\n        assert(a&lt;=1e9);\n        assert(b&lt;=1e9);\n        tasks.push_back({a,b,i});\n    }\n\n    sort(tasks.begin(),tasks.end(),cmp_start);\n\n    int m=-1;\n    for(int i=0;i&lt;n;i++){\n        m=max(m,tasks[i].end);\n        tasks[i].ans = m;\n    }\n\n    sort(tasks.begin(),tasks.end(),cmp_id);\n\n    for(int i=0;i&lt;n;i++){\n        cout&lt;&lt;tasks[i].ans&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/","title":"2 - XXL matrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Poznato je da komisija sve svoje odluke donosi nakon razmatranja jedne velike magi\u010dne matrice sa crnim i belim poljima. Na\u017ealost, tokom jesenjeg \u010di\u0161\u0107enja, komisija je ovu matricu negde sklonila i zagubila!</p> <p>Jedine informacije koje su preostale o matrici su broj belih polja kojima po\u010dinje svaka vrsta i broj belih polja kojima po\u010dinje svaka kolona (tj. indeks prvog crnog polja u svakoj vrsti i u svakoj koloni, ili du\u017eina vrste/kolone ako u njima nema crnih polja). Komisija je ove podatke odvajkada koristila da bi odredila broj takmi\u010dara koje \u0107e pozvati na naredni krug takmi\u010denja.</p> <p>Komisiju sada zanima koliko je matrica minimalno ili maksimalno mogla da sadr\u017ei crnih polja. Pored ostalih podataka, komisija Vam je dala i broj \\(t\\), kojim Vam govori da li je va\u017ean minimalan broj crnih polja ili maksimalan broj crnih polja. Ukoliko je \\(t=0\\), komisiju zanima minimalan broj crnih polja, a ukoliko je \\(t=1\\), komisiju interesuje maksimalan broj crnih polja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Savi\u0107 Aleksa Milisavljevi\u0107 Dragan Uro\u0161evi\u0107 Vladimir Milovanovi\u0107 <p>Neka je \\(N\\) broj vrsta i neka je \\(M\\) broj kolona. Pretpostavimo da su vrste numerisane brojevima od \\(0\\) do \\(N-1\\), a kolone brojevima od \\(0\\) do \\(M-1\\). </p> <p>Primetimo da ne mora za svaki izbor ulaznih podataka postojati re\u0161enje. Naime ako je \\(0\\leqslant a_i &lt; M\\), onda to zna\u010di da se na polju sa koordinatama \\((i,a_i)\\) nalazi crno polje. Zbog toga broj belih polja kojima po\u010dinje kolona \\(a_i\\) nije ve\u0107i od \\(a_i\\), pa je \\(b_{a_i} \\leqslant i\\). Odnosno, ako je \\(0\\leqslant a_i &lt; M\\) i \\(b_{a_i} &gt; i\\) za neko \\(i\\), onda ne postoji matrica koja zadovoljava uslove opisane nizovima \\(a\\) i \\(b\\). Sli\u010dno, ako je \\(0\\leqslant b_j &lt; N\\), onda je polje sa koordinatama \\((b_j, j)\\) crno, pa vrsta \\(b_j\\) po\u010dinje sa ne vi\u0161e od \\(j\\) belih polja i zbog toga je \\(a_{b_j} \\leqslant j\\). Dakle ako za neko \\(j\\) (\\(0\\leqslant j &lt; M\\)) va\u017ei da je \\(0\\leqslant b_j &lt; N\\) i \\(a_{b_j}&gt;j\\), onda ne postoji matrica koja zadovoljva uslove opisane nizovima \\(a\\) i \\(b\\).</p> <p>Pretpostavimo da postoji matrica opisana nizovima \\(a\\) i \\(b\\). Tada za svako \\(i\\) za koje je \\(0\\leqslant a_i &lt; M\\) va\u017ei da je polje sa koordinatama \\((i,a_i)\\) crno. Sli\u010dno, ako za neko \\(j\\) va\u017ei da je \\(0\\leqslant b_j &lt; N\\), onda je polje sa koordinatama \\((b_j,j)\\) crno.  I to je minimalni skup crnih polja. Prema tome, broj crnih polja \u0107emo odrediti tako \u0161to izbrojimo koliko ima razli\u010ditih polja u uniji skupova $$ A={(i,a_i)|0\\leqslant i &lt; N, 0\\leqslant a_i &lt; M} \\quad \\text{i} \\quad B={(b_j,j)|0\\leqslant j &lt; M, 0\\leqslant b_j &lt; N}. $$</p> <p>Pretpostavimo da postoji matrica koja zadovoljava uslove opisane nizovima \\(a\\) i \\(b\\). Tada mogu biti crna sva polja \\((i,j)\\) (\\(0\\leqslant i &lt; N\\), \\(0\\leqslant j &lt; M\\)) koja zadovoljavaju i slede\u0107a dva uslova: $$ a_i \\leqslant j &lt; M \\quad \\text{i}\\quad b_j \\leqslant i &lt; N. $$</p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, data su tri cela broja \\(N\\), broj vrsta matrice, \\(M\\), broj kolona matrice i \\(t\\). U drugom redu, dato je \\(N\\) celih brojeva, \\(i\\)-ti od njih predstavlja broj belih polja sa kojima po\u010dinje \\(i\\)-ta vrsta. U tre\u0107em redu, nalazi se \\(M\\) celih brojeva, \\(i\\)-ti od njih predstavlja broj belih polja sa kojima po\u010dinje \\(i\\)-ta kolona.</p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#opis-izlaza","title":"Opis izlaza","text":"<p>Potrebno je ispisati jedan ceo broj, minimalan broj crnih polja u matrici, ukoliko je \\(t=0\\), odnosno maksimalan broj crnih polja u matrici, ukoliko je \\(t=1\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1  \\leq N \\leq  10^5\\).</li> <li>\\(1  \\leq M \\leq  10^5\\).</li> <li>\\(0 \\leq t \\leq 1\\).</li> <li>Garantuje se da postoji barem jedna matrica koja ispunjava sva ograni\u010denja zadata ulaznim podacima.</li> </ul>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#podzadaci","title":"Podzadaci","text":"<ol> <li>(6 poena) \\(N, M \\leq  4\\), \\(t=0\\).</li> <li>(9 poena) \\(N, M \\leq  4\\), \\(t=1\\).</li> <li>(12 poena) \\(N, M \\leq  1000\\), \\(t=0\\).</li> <li>(18 poena) \\(N, M \\leq  1000\\), \\(t=1\\).</li> <li>(22 poena) \\(t=0\\).</li> <li>(33 poena) \\(t=1\\).</li> </ol>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#ulaz","title":"Ulaz","text":"<pre><code>5 5 0\n\n2 0 2 5 1\n\n1 4 0 2 2\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#ulaz_1","title":"Ulaz","text":"<pre><code>5 5 1\n\n2 0 2 5 1\n\n1 4 0 2 2\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#izlaz_1","title":"Izlaz","text":"<pre><code>10\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ukoliko sa <code>x</code> ozna\u010dimo crna polja u matrici, a sa <code>o</code> bela, matrica koja ima minimalnih \\(6\\) crnih polja i ispunjava ograni\u010denja zadata ulaznim podacima je:</p> <p><code>o o x o o</code></p> <p><code>x o o o o</code></p> <p><code>o o x x x</code></p> <p><code>o o o o o</code></p> <p><code>o x o o o</code></p> <p>Matrica koja ima maksimalnih \\(10\\) crnih polja i ispunjava ograni\u010denja zadata ulaznim podacima je:</p> <p><code>o o x o o</code></p> <p><code>x o x o o</code></p> <p><code>o o x x x</code></p> <p><code>o o o o o</code></p> <p><code>o x x x x</code></p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#resenje-kad-je-nm-leq-4","title":"Re\u0161enje kad je \\(N,M \\leq 4\\)","text":"<p>U ovom slu\u010daju se mogu ispitati sve matrice dimenzija \\(N\\times M\\) \u010dija su polja bela ili crna (tj, za svaku od njih se mo\u017ee proveriti da li zadovoljava uslove opisane nizovima \\(a\\) i \\(b\\)). Naime matrica ima \\(2^{N M} \\leqslant 2^{16} = 65536\\). Nakon toga se lako odredi broj crnih polja u matrici koja ima najmanji i/ili najve\u0107i broj crnih polja.</p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#resenje-kad-je-nm-leq-1000","title":"Re\u0161enje kad je \\(N,M \\leq 1.000\\)","text":"<p>U ovom slu\u010daju se za svako polje matrice odre\u0111uje da li je crno, za varijantu kada treba da odredimo najmanji broj crnih polja i/ili za varijantu kada treba da odredimo najve\u0107i broj crnih polja. Za odre\u0111ivanje boje koristimo gore navedene uslove. Slo\u017eenost ovog re\u0161enja je \\(\\Theta(NM)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/02_xxl_matrica/#resenje-kad-je-n-m-leq-100000","title":"Re\u0161enje kad je \\(N, M \\leq 100.000\\)","text":"<p>Opi\u0161imo kako odre\u0111ujemo maksimalni broj crnih polja (opet \u0107emo pretpostaviti da postoji matrica koja zadovoljava uslove problema). Maksimalan broj crnih polja odre\u0111ujemo tako \u0161to odre\u0111ujemo maksimalan broj crnih polja u vrstama polaze\u0107i od nulte vrste i obra\u0111uju\u0107i ih redom. Ako trenutno obra\u0111ujemo vrstu sa rednim brojem \\(i\\), onda mogu biti crna sva polja \\((i,j)\\) koja zadovoljavaju uslove \\(j\\geqslant a_i\\) i \\(b_j \\leqslant i\\). Jedan od na\u010dina da to uradimo je da defini\u0161emo pomo\u0107ni niz \\(c\\) du\u017eine \\(M\\) \u010diji elementi na po\u010detku imaju vrednost \\(0\\), a ako se trenutno obra\u0111uje vrsta broj \\(i\\), onda \u0107e vrednosti elemenata niza \\(c\\) biti $$ c_j = \\begin{cases} 1,\\quad &amp;\\text{ako je }b_j\\leqslant i\\ 0,\\quad &amp;\\text{ako je }b_j &gt; i. \\end{cases} $$ Tada \u0107e najve\u0107i broj crnih polja u vrsti broj \\(i\\) biti $$ c_{a_i} + c_{a_i+1} + c_{a_i+2} + \\dotsb + c_{M-1}. $$ Ove zbirove \u0107emo najefikasnije odrediti koriste\u0107i Fenvikovo stablo (Fenwick tree) ili segmentno stablo. Primetimo da se niz \\(c\\) (potencijalno) menja pri obradi svake vrste, pa u skladu sa tim treba a\u017eurirati i odgovaraju\u0107e stablo. Slo\u017eenost ovog re\u0161enja je \\(\\Theta(N\\log M)\\).</p> <p>Minimalni broj crnih polja mo\u017eemo odrediti tako \u0161to formiramo skup sastavljen od parova \\((i,a_i)\\) (\\(0\\leqslant i &lt; N\\), \\(a_i &lt; M\\)) i \\((b_j,j)\\) (\\(0\\leqslant j &lt; M\\), \\(b_j &lt; N\\)), a zatim izbrojimo koliko u tom skupu ima elemenata. </p> 02_xxl_matrica.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 100005\nusing namespace std;\nint n,m,t;\nint a[maxn];\nint b[maxn];\nset&lt;pair&lt;int,int&gt; &gt; s;\nvector&lt;int&gt; ad[maxn];\nint bt[maxn];\nvoid upd(int i) {\n    while(i&lt;=m) {\n        bt[i]++;\n        i+=(i&amp;(-i));\n    }\n}\nint que(int i) {\n    int ret=0;\n    while(i&gt;0) {\n        ret+=bt[i];\n        i-=(i&amp;(-i));\n    }\n    return ret;\n}\nint main() {\n    scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;t);\n    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]);\n    for(int i=0;i&lt;m;i++) scanf(\"%d\",&amp;b[i]);\n    for(int i=0;i&lt;n;i++) {\n        if(a[i]!=m) s.insert({i,a[i]});\n    }\n    for(int i=0;i&lt;m;i++) {\n        if(b[i]!=n) s.insert({b[i],i});\n    }\n    long long mn=s.size();\n    for(int i=0;i&lt;m;i++) {\n        ad[b[i]].push_back(i);\n    }\n    long long mx=0;\n    for(int i=0;i&lt;n;i++) {\n        for(auto j:ad[i]) {\n            upd(m-j);\n        }\n        mx+=que(m-a[i]);\n    }\n    if(t==0) printf(\"%lld\\n\",mn);\n    if(t==1) printf(\"%lld\\n\",mx);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/","title":"3 - Nadvla\u010denje konopca","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Na dr\u017eavnom takmi\u010denju iz nadvla\u010denja konopca u\u010destvuje \\(N\\) takmi\u010dara. Takmi\u010denje ima \\(N\\) rundi. U svakoj u\u010destvuju ta\u010dno dva takmi\u010dara (neki takmi\u010dari mogu u\u010destvovati i u vi\u0161e rundi, a neki ni u jednoj). U \\(i\\)-toj rundi u\u010destvuju takmi\u010dari \\(a_i\\) i \\(b_i\\).  </p> <p>Dr\u017eavna komisija za nadvla\u010denje konopca je upravo Vas odabrala da budete sudija na \\(T\\) ovakvih takmi\u010denja! Na svakom od njih potrebno je odrediti pobednika svake runde, ali tako da, u cilju popularizacije takmi\u010denja, svaki takmi\u010dar pobedi barem jednom.</p> <p>Vas na svakom takmi\u010denju posebno interesuje na koliko na\u010dina je mogu\u0107e odabrati pobednika u svakoj rundi, tako da ovaj uslov bude ispunjen? Po\u0161to ovaj broj mo\u017ee da bude veoma veliki, ispisati ga po modulu <code>998244353</code>. Dva na\u010dina odre\u0111ivanja pobednika su razli\u010dita, ukoliko postoji barem jedna runda u kojoj nije isti takmi\u010dar progla\u0161en pobednikom.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je jedan ceo broj \\(T\\), broj takmi\u010denja na kojima ste pozvani da sudite. Potom slede opisi tih \\(T\\) takmi\u010denja. U prvom redu opisa svakog takmi\u010denja, dat je jedan ceo broj \\(N\\), broj takmi\u010dara i rundi. U narednih \\(N\\) redova, data su po dva cela broja. U \\(i\\)-tom od tih redova, dati su brojevi \\(a_i\\) i \\(b_i\\), koji predstavljaju u\u010desnike \\(i\\)-te runde.</p>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#opis-izlaza","title":"Opis izlaza","text":"<p>U svakom od \\(T\\) redova, potrebno je ispisati po jedan ceo broj - broj na\u010dina da se odaberu pobednici svake runde odgovaraju\u0107eg takmi\u010denja, tako da svaki takmi\u010dar pobedi u barem jednoj rundi.</p>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li> <p>\\(1  \\leq T \\leq  2 \\cdot 10^5\\)</p> </li> <li> <p>\\(3  \\leq N \\leq  2 \\cdot 10^5\\).</p> </li> <li> <p>\\(1  \\leq a_i \\neq b_i \\leq N\\).</p> </li> <li> <p>U nikoje dve runde istog takmi\u010denja ne u\u010destvuje isti par takmi\u010dara.</p> </li> <li> <p>Suma svih \\(N\\) ne prelazi \\(2 \\cdot 10^5\\) po jednom ulaznom fajlu.</p> </li> </ul>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#podzadaci","title":"Podzadaci","text":"<ol> <li>(10 poena) \\(N \\leq  17\\) i \\(T \\leq 10\\).</li> <li>(26 poena) \\(N \\leq  2000\\) i \\(T \\leq 10\\).</li> <li>(17 poena) Svaki takmi\u010dar u\u010destvuje u ta\u010dno dve runde.</li> <li>(47 poena) Nema dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#ulaz","title":"Ulaz","text":"<pre><code>2\n5\n1 2\n2 3\n1 3\n4 1\n5 4\n5\n1 2\n2 3\n3 4\n4 1\n1 3\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#izlaz","title":"Izlaz","text":"<pre><code>2\n0\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ukoliko su pobednici rundi prvog takmi\u010denja redom \\([1,2,3,4,5]\\), ili \\([2,3,1,4,5]\\), tada je svaki takmi\u010dar pobedio u barem jednoj rundi. Proverom se mo\u017ee utvrditi da su ovo jedina dva na\u010dina na koja se mogu odrediti pobednici rundi, tako da uslovi budu ispunjeni. U drugom takmi\u010denju, takmi\u010dar sa indeksom \\(5\\) ne u\u010destvuje ni u jednoj rundi, pa ne postoji na\u010din da se odrede pobednici, tako da svaki takmi\u010dar pobedi u barem jednoj rundi.</p>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#resenje-kada-n-leq-20","title":"Re\u0161enje kada \\(N \\leq 20\\)","text":"<p>Za svaki me\u010d ima ukupno \\(2\\) na\u010dina da se izabere pobednik tako da ima ukupno \\(2^N\\)  ukupno na\u010dina da se izaberu pobednici. Naprosto pro\u0111emo kroz sve te kombinacije (npr iteriranjem brojeva od \\(0\\) do \\(2^N-1\\) i gledaju\u0107i njihov binarni zapis) i vidimo da li u svakoj od njih se desi da ima jednu pobedi. Slo\u017eenost \\(O(2^N)\\)</p>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#resenje-kada-svaki-takmicar-ucestvuje-u-2-meca","title":"Re\u0161enje kada svaki takmi\u010dar u\u010destvuje u 2 me\u010da","text":"<p>Posmatrajmo graf \u010diji su \u010dvorovi takmi\u010dari i postoji grana izme\u0111u dva takmi\u010dara ako igraju me\u010d me\u0111usobno. Sada nam je zadatak ekvivalentan sa time da se orijenti\u0161u grane tako da svaki \u010dvor ima izlazni stepen ta\u010dno \\(1\\) (ovakvi grafovi se ina\u010de zovu funkcionalni grafovi).</p> <p>U ovom podzadatku svaki \u010dvor je stepena ta\u010dno \\(2\\). Za takav graf znamo da je svaka povezana komponenta ciklus (doka\u017eite!). U ciklusu o\u010dito imamo samo \\(2\\) na\u010dina da orijenti\u0161emo grane (neformalno re\u010deno u smeru kazaljke na satu i suprotno). Tako da je u ovom slu\u010daju odgovor \\(2^{\\text{broj komponenti}}\\). Slo\u017eenost \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/03_nadvlacenje_konopca/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Zapravo je glavno re\u0161enje mala modifikacija prethonog. Naime, o\u010dito nam je potreban uslov da u svakoj komponenti ima isto \u010dvorova i grana (da bi mogao savko da pobedi barem jednom). Ispostavlja se da ako je ovaj uslov ispunjen, odgovor je opet \\(2^{\\text{broj komponenti}}\\) (a u suprotnom je \\(0\\)). Dokaz ovoga mo\u017eemo da vidimo na slede\u0107i na\u010din: ako postoji \u010dvor stepena \\(1\\) znamo da on mora da pobedi taj me\u010d tako da nam je to jedinstveno odre\u0111eno i mo\u017eemo da skinemo taj \u010dvor i granu i opet dobijemo graf sa isto \u010dvorova i grana, i to za \\(1\\) manje. Nastavljamo ovaj proces, i kad nema nijedan \u010dvor stepena \\(1\\), tada svi imaju stepen \\(2\\), \u0161to po prethodnom podzadatku znamo da imamo ta\u010dno \\(2\\) na\u010dina da orijenti\u0161emo.</p> 03_nadvlacenje_konopca.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 300000\nusing namespace std;\nint t;\nint n;\nvector&lt;int&gt; a[maxn];\nbool vis[maxn];\nconst int mod=998244353;\nint dfs(int u) {\n    int ret=2;\n    vis[u]=true;\n    for(auto v:a[u]) {\n        ret--;\n        if(!vis[v]) ret+=dfs(v);\n    }\n    return ret;\n}\nint main() {\n    scanf(\"%d\",&amp;t);\n    while(t--) {\n        scanf(\"%d\",&amp;n);\n        for(int i=0;i&lt;n;i++) {\n            int u,v;\n            scanf(\"%d %d\",&amp;u,&amp;v);\n            a[u].push_back(v);\n            a[v].push_back(u);\n        }\n        int ans=1;\n        for(int i=1;i&lt;=n;i++) {\n            if(!vis[i]) {\n                if(dfs(i)==0) {\n                    ans=ans*2;\n                    if(ans&gt;=mod) ans-=mod;\n                }\n                else ans=0;\n            }\n        }\n        printf(\"%d\\n\",ans);\n        for(int i=1;i&lt;=n;i++) {\n            a[i].clear();\n            vis[i]=false;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/","title":"4 - \u0160estougao","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Data je celobrojna matrica \\(m\\), dimenzija \\(N \\times N\\). \u0160estougao je skup povezanih polja u matricija \u010dija ivi\u010dna linija obrazuje prost \u0161estougao (sa stranicama paralelnim stranama matrice). Lep \u0161estougao je \u0161estougao u kome va\u017ei da za svaku stranicu postoji druga stranica sa istom du\u017einom i \u010diji je ukupan obim jednak \\(A\\). </p> <p>Dato je \\(Q\\) upita - svaki upit je podmatrica originalne matrice i za svaki upit odrediti najve\u0107u mogu\u0107u vrednost zbira elemenata u nekom lepom \u0161estouglu koji je kompletno sadr\u017ean u toj podmatrici.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107 <p>Prva stvar koju treba da primetimo je da uslov da je figura \u0161estogao i da ima stranice paralelne ivicama matrice zapravo zna\u010di da je u pitanju figura koja se dobija tako \u0161to iz pravougaonika izbacimo manji pravougaonik koji je takav da im se ta\u010dno jedan \u0107o\u0161ak poklapa.</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardong ulaza, data su dva cela broja \\(N\\), dimenzija matrice i \\(A\\), obim lepih \u0161estouglova. U narednih \\(N\\) redova, dato je po \\(N\\) celih brojeva. \\(j\\)-ti broj u \\(i\\)-tom od tih redova je \\(j\\)-ta vrednost u \\(i\\)-tom redu matrice, (tj. vrednost \\(m_{i,j}\\)). U narednom redu, dat je ceo broj \\(Q\\), broj upita. U narednih \\(Q\\) redova, data su po \u010detiri cela broja, \\(u\\), \\(d\\), \\(l\\) i \\(r\\). Ovi brojevi predstavljaju upit nad podmatricom kojoj su dva naspramna \u0107o\u0161ka \\(m_{u,l}\\) i \\(m_{d,r}\\) (tj. podmatricom koja sadr\u017ei sve elemente koji su izme\u0111u \\(u\\)-tog i \\(d\\)-tog reda i izme\u0111u \\(l\\)-te i \\(r\\)-te kolone).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#opis-izlaza","title":"Opis izlaza","text":"<p>U svakom od \\(Q\\) redova, potrebno je ispisati po jedan ceo broj. U \\(i\\)-tom redu, potrebno je ispisati najve\u0107i mogu\u0107i zbir elemenata u nekom lepom \u0161estouglu koji je kompletno sadr\u017ean u podmatrici opisanoj u \\(i\\)-tom upitu.</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1  \\leq N \\leq  500\\).</li> <li>\\(1  \\leq A \\leq  10^4\\).</li> <li>\\(1  \\leq Q \\leq 10^5\\).</li> <li>\\(-10^9 \\leq m_{i,j} \\leq 10^9\\).</li> <li>Garantuje se da u svakoj podmatrici postoji barem jedan lep \u0161estougao.</li> </ul>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#podzadaci","title":"Podzadaci","text":"<ol> <li>(7 poena) \\(N \\leq 5\\).</li> <li>(8 poena) \\(A = 8, Q \\leq 10\\).</li> <li>(11 poena) \\(N \\leq 50, Q \\leq 10\\).</li> <li>(13 poena) \\(A = 8\\).</li> <li>(19 poena) \\(N \\leq 50\\).</li> <li>(42 poena) Nema dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#ulaz","title":"Ulaz","text":"<pre><code>3 8\n2 3 2\n5 6 -3\n2 3 4\n2\n1 2 1 2\n1 3 2 3\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#izlaz","title":"Izlaz","text":"<pre><code>14\n13\n</code></pre>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Podmatrica nad kojom je postavljen prvi upit je obojena zelenom bojom na slici ispod. Lep \u0161estougao sa najve\u0107om sumom koji je kompleto sadr\u017ean u njoj je oivi\u010den crvenom bojom na slici ispod:</p> <p></p> <p></p> <p></p> <p>Podmatrica nad kojom je postavljen drugi upit je obojena zelenom bojom na slici ispod. Lep \u0161estougao sa najve\u0107om sumom koji je kompleto sadr\u017ean u njoj je oivi\u010den crvenom bojom na slici ispod:</p> <p></p> <p></p> <p></p> <p>Primetimo da se u oba \u0161estougla stranice du\u017eine \\(2\\) javljaju dva puta, a stranice du\u017eine \\(1\\) \u010detiri puta, tj \u0161estouglovi imaju obim \\(8\\) i za svaku stranicu postoji druga stranica sa istom du\u017einom.</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#resenje-kada-n-leq-5","title":"Re\u0161enje kada \\(N \\leq 5\\)","text":"<p>U ovom podzadatku mo\u017eemo da fiksiramo svaki \u0161estougao, proverimo da li je on lep i prera\u010dunamo odgovor za svaku podmatricu. Razli\u010ditih \u0161estouglova ima \\(O(N^6)\\), dok razli\u010ditih podmatrica ima \\(O(N^4)\\). Zbog toga, ovo re\u0161enje radi u vremenskoj slo\u017eenosti \\(O(N^{10})\\).</p> <p>Vremenska slo\u017eenost je \\(O(N^{10})\\), a memorijska \\(O(N^4)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#resenje-kada-a-8-q-leq-10","title":"Re\u0161enje kada \\(A = 8, Q \\leq 10\\)","text":"<p>Primetimo da su \u0161estouglovi sa obimom \\(8\\) upravo kvadrati dimenzija \\(2  \\times  2\\) iz kojih je izba\u010den jedan \u0107o\u0161ak. Takvih \u0161estouglova ima \\(O(N^2)\\) u matrici. U svakom upitu mo\u017eemo da iteriramo kroz celu podmatricu i izra\u010dunamo zbir brojeva u svakom lepom \u0161estouglu.</p> <p>Vremenska slo\u017eenost je \\(O(Q \\cdot N^2)\\), a memorijska je \\(O(N^2)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#resenje-kada-n-leq-50-q-leq-10","title":"Re\u0161enje kada \\(N \\leq 50, Q \\leq 10\\)","text":"<p>Za re\u0161avanje ovog podzadatka moramo detaljnije da razmotrimo kada ta\u010dno izbacivanjem manjeg pravougaonika iz ve\u0107eg nastaje lep \u0161estougao.</p> <p>Pretpostavimo da smo imali pravougaonik dimenzija \\(w \\times h\\) i da smo iz jednog njegovog \u0107o\u0161ka izbacili pravougaonik dimenzija \\(p \\times q\\). Posmatrajmo dva slu\u010daja:</p> <ul> <li>Prvi slu\u010daj: \\(w \\neq h\\), tj. orginalni pravougaonik nije kvadrat. Bez umanjenja op\u0161tosti, pretpostavimo da \\(w &gt; h\\). \u0160estougao koji nastaje brisanjem pravougaonika ima stranice du\u017eina \\(w\\), \\(h\\), \\(w-p\\), \\(q\\), \\(p\\), \\(h-q\\). Kako \\(w \\neq h\\) i kako u \u0161estouglu, da bi bio lep, svaka du\u017eina mora da se javlja barem dva puta , to mora da va\u017ei \\(w = w-p\\) ili \\(w = q\\) ili \\(w = p\\) ili \\(w = h-q\\). Me\u0111utim, kako va\u017ei \\(p, w-p &lt; w\\) i \\(q, h-q &lt; h &lt; w\\) , to ovaj slu\u010daj nije mogu\u0107, tj. \u0161estougao mora biti kvadarat.</li> <li>Drugi slu\u010daj: \\(w = h\\). Uvedimo \\(a = w = h\\). \u0160estougao koji nastaje brisanjem pravougaonika ima stranice du\u017eina \\(a\\), \\(a\\), \\(a-p\\), \\(q\\), \\(p\\), \\(a-q\\). Kako svaka du\u017eina mora da se javlja barem dva puta, to razlikujemo slede\u0107a dva slu\u010daja: \\(p = q\\) i \\(p = a - q\\). Dodatno, primetimo da je obim ovog \u0161estougla upravo \\(a + a + a - p + q + p + a - q = 4a\\), tj. \\(a = \\frac{A}{4}\\).</li> </ul> <p>Dakle, da bi \u0161estougao bio lep, on mora da nastane tako \u0161to se iz kvadrata stranice \\(a = \\frac{A}{4}\\) izbaci pravougaonik dimenzija \\(p \\times q\\), za koje va\u017ei \\(p = q\\) ili \\(p + q = a\\). Primetimo da u po\u010detnoj matrici kvadrata stranice \\(a\\) ima \\((N-a+1)^2\\), a za svaki od njih postoji \\(4(a-1)\\) pravougaonika koje mo\u017eemo da izbacimo da bi dobili lep \u0161estougao. Dakle, ukupno postoji \\(O(N^3)\\) lepih \u0161estouglova u matrici.</p> <p>Koriste\u0107i ovu informaciju, lako mo\u017eemo da re\u0161imo podzadatak. U svakom upitu, pro\u0111emo kroz sve lepe \u0161estouglove. Ovo je najlak\u0161e uraditi tako \u0161to prvo fiksiramo gornji levi \u0107o\u0161ak kvadrata iz kojeg bri\u0161emo pravougaonik, zatim stranice pravougaonika i kona\u010dno jedan od \u010detiri \u0107o\u0161ka kvadrata koji se poklapa sa pravougaonikom.</p> <p>Vremenska slo\u017eenost je \\(O(Q N^3)\\), a memorijska je \\(O(N^2)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#resenje-kada-n-leq-50","title":"Re\u0161enje kada \\(N \\leq 50\\)","text":"<p>Ovaj zadatak zahteva da malo popravimo re\u0161enje iz prethodnog. Klju\u010dno je primetiti da za svaki gornji levi \u0107o\u0161ak kvadrata iz kojeg izbacujemo pravougaonik mo\u017eemo da izra\u010dunamo lep \u0161estougao koji nastaje sa najve\u0107im zbirom. Ovo zapamtimo za svako polje. Potom u svakom upitu pro\u0111emo kroz sva polja koja su kandidati za gornji levi \u0107o\u0161ak pravougaonika i na taj na\u010din prona\u0111emo lep \u0161estougao sa najve\u0107im zbirom koji se potpuno nalazi u podmatrici iz upita.</p> <p>Vremenska slo\u017eenost je \\(O(Q N^2)\\), a memorijska je \\(O(N^2)\\).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#resenje-kada-a-8","title":"Re\u0161enje kada \\(A = 8\\)","text":"<p>Za re\u0161enja ovog podzadatka je neophodna tehnika sparse tabela.</p> <p>Prvo u pomo\u0107noj matrici \\(b[i][j]\\) zapamtimo lep \u0161estougao sa najve\u0107im zbirom koji je nastao tako \u0161to smo kvadratu kome je gornje levo polje upravo \\((i,j)\\) sklonili jedan \u0107o\u0161ak.</p> <p>U pomo\u0107noj matrici \\(sparse[i][j][k]\\), prera\u010dunamo maksimume svih lepih \u0161estouglova koji nastaju od kvadrata dimenzija \\(2 \\times 2\\) kojima je gornji levi \u0107o\u0161ak na nekom od polja iz skupa \\(\\{(i,j),(i,j+1),...,(i,j+2^k-1)\\}\\). Za ovu matricu je lako na\u0107u rekurzivnu formulu:</p> \\[ sparse[i][j][0] = b[i][j], \\] \\[ sparse[i][j][k] = max(sparse[i][j][k-1],sparse[i][j+2^(k-1)][k-1]) \\] <p>Na osnovu ove matrice, mo\u017eemo da odgovaramo na upite u vremenskoj slo\u017eenosti \\(O(N)\\). Neka je \\(k\\) najve\u0107i broj takav da je \\(2^k \\leq r-l\\). Da bi odgovorili na upit, pro\u0111emo kroz svaki red \\(i\\) u intervalu \\([u,d-1]\\) i za svaki od njih izra\u010dunamo vrednost \\(max(b[i][l][k],b[i][r-2^k][k])\\) (na ovaj na\u010din smo uzeli maksimum svih lepih \u0161estouglova kojima je gornji levi \u0107o\u0161ak u redu \\(i\\)). Maksimum od svih tih vrednosti je odgovr na upit.</p> <p>Vremenska slo\u017eenost je \\(O(N^2 \\log N + Q N)\\), a memorijska \\(O(N^2 \\log N)\\) (ako pamtimo uvek samo rezultate prethodnog kola).</p>"},{"location":"takprog/2021_2022/egoi_izb/04_sestougao/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za glavno re\u0161enje, neophodno je generalizovati ideju iz prethodnog podzadatka, kori\u0161\u0107enjem opservacije o tome kakav pravougaonik moramo da izbacimo da bi dobili lep \u0161estougao. U matrici \\(b[i][j]\\) zapamtimo maksimum svih lepih \u0161estouglova koji su nastali tako \u0161to smo izbacili neki pravougaonik iz kvadrata kojem je gornje levo polje \\((i,j)\\). Potom ra\u010dunamo i koristimo tabelu na sli\u010dan na\u010din kao u prethodnom podzadatku.</p> <p>Vremenska slo\u017eenost je \\(O(N^3 + Q N)\\), a memorijska \\(O(N^2 \\log N)\\).</p> <p>Zadatak je bilo mogu\u0107e re\u0161iti i u boljoj vremenskoj slo\u017eenosti \\(O(N^3 + N^2 \\log^2 N + Q)\\), kori\u0161\u0107enjem dvodimenzionalnih tabela, ali to nije bilo potrebno za maksimalne poene.</p> 04_sestougao.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 501\n#define maxl 9\nusing namespace std;\nint n;\nint a;\nint s;\nint m[maxn][maxn];\nlong long pref[maxn][maxn];\nlong long b[maxn][maxn];\nlong long sprs[maxn][maxn][maxl][maxl];\nint gdeg[maxn];\ninline long long sum(int u,int d,int l,int r) {\n    return pref[d][r]-pref[d][l-1]-pref[u-1][r]+pref[u-1][l-1];\n}\ninline long long maxsum(int u,int d,int l,int r) {\n    long long ans=-1e18;\n    while(u&lt;=d) {\n        int c=l;\n        while(c&lt;=r) {\n            ans=max(ans,sprs[u][c][gdeg[d-u+1]][gdeg[r-c+1]]);\n            c=c+(1&lt;&lt;gdeg[r-c+1]);\n        }\n        u=u+(1&lt;&lt;gdeg[d-u+1]);\n    }\n    return ans;\n}\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;a);\n    s=a/4;\n    int j=0;\n    for(int i=1;i&lt;=n;i++) {\n        if(1&lt;&lt;(j+1)&lt;=i) j++;\n        gdeg[i]=j;\n    }\n    for(int i=1;i&lt;=n;i++) {\n        for(int j=1;j&lt;=n;j++) {\n            scanf(\"%d\",&amp;m[i][j]);\n            pref[i][j]=pref[i-1][j]+pref[i][j-1]-pref[i-1][j-1]+m[i][j];\n        }\n    }\n    for(int i=1;i+s-1&lt;=n;i++) {\n        for(int j=1;j+s-1&lt;=n;j++) {\n            b[i][j]=-1e18;\n            long long tot=sum(i,i+s-1,j,j+s-1);\n            for(int k=1;k&lt;s;k++) {\n                long long k1=sum(i,i+k-1,j,j+k-1);\n                long long k2=sum(i,i+k-1,j+s-k,j+s-1);\n                long long k3=sum(i+s-k,i+s-1,j,j+k-1);\n                long long k4=sum(i+s-k,i+s-1,j+s-k,j+s-1);\n                long long k5=sum(i,i+k-1,j,j+(s-k)-1);\n                long long k6=sum(i,i+k-1,j+k,j+s-1);\n                long long k7=sum(i+s-k,i+s-1,j,j+s-k-1);\n                long long k8=sum(i+s-k,i+s-1,j+k,j+s-1);\n                b[i][j]=max(b[i][j],tot-k1);\n                b[i][j]=max(b[i][j],tot-k2);\n                b[i][j]=max(b[i][j],tot-k3);\n                b[i][j]=max(b[i][j],tot-k4);\n                b[i][j]=max(b[i][j],tot-k5);\n                b[i][j]=max(b[i][j],tot-k6);\n                b[i][j]=max(b[i][j],tot-k7);\n                b[i][j]=max(b[i][j],tot-k8);\n            }\n            sprs[i][j][0][0]=b[i][j];\n        }\n    }\n    for(int k=0;k&lt;9;k++) {\n        for(int l=0;l&lt;9;l++) {\n            if(k==0 &amp;&amp; l==0)  continue;\n            if(k==0) {\n                for(int i=1;i+s-1&lt;=n;i++) {\n                    for(int j=1;j+(1&lt;&lt;l)-1+s-1&lt;=n;j++) {\n                        sprs[i][j][k][l]=max(sprs[i][j][k][l-1],sprs[i][j+(1&lt;&lt;(l-1))][k][l-1]);\n                    }\n                }\n            }\n            else {\n                for(int i=1;i+(1&lt;&lt;k)-1+s-1&lt;=n;i++) {\n                    for(int j=1;j+(1&lt;&lt;l)-1+s-1&lt;=n;j++) {\n                        sprs[i][j][k][l]=max(sprs[i][j][k-1][l],sprs[i+(1&lt;&lt;(k-1))][j][k-1][l]);\n                    }\n                }\n            }\n        }\n    }\n    int q;\n    scanf(\"%d\",&amp;q);\n    while(q--) {\n        int u,d,l,r;\n        scanf(\"%d %d %d %d\",&amp;u,&amp;d,&amp;l,&amp;r);\n        printf(\"%lld\\n\",maxsum(u,d-s+1,l,r-s+1));\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/","title":"1 - Poslovan \u010dovek","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1300ms 256MB <p>Ovo je pri\u010da o Huanu, momku koji je imao stila. On je \u017eiveo negde dole, severno-ju\u017eno od Brazila. Huan je mnogo voleo da radi, tako da je imao dva posla. Svakog dana on je mogao da bira na koji od poslova \u0107e oti\u0107i. Ako bi izabrao prvi posao, na kraju dana zaradio bi \\(A\\) funti (isti iznos bez obzira na to koji je dan). Ako \\(i\\)-tog dana Huan izabere drugi posao, on \u0107e tog dana zaraditi \\(B_i\\) funti. Kada zaradi vi\u0161e od \\(C\\) funti na drugom poslu, njegova plata \u0107e biti duplo ve\u0107a nego planirano na drugom poslu. To zna\u010di ako Huan izabere da radi drugi posao dana \\(j &gt; k\\), gde je \\(k\\) prvi dan kada je Huan ukupno zaradio vi\u0161e od \\(C\\) funti na drugom poslu, onda \u0107e Huanova plata \\(j\\)-tog dana biti \\(2 \\cdot B_j\\), umesto \\(B_j\\) funti. Pomozite Huanu i izra\u010dunajte koliko najvi\u0161e novca mo\u017ee da zaradi u narednih \\(N\\) dana.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Plav\u0161i\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei tri cela broja \\(N\\), \\(A\\), \\(C\\), broj dana koji \u0107e Huan raditi, Huanova dnevna zarada na prvom poslu i granica nakon koje \u0107e se njegova plata na drugom poslu duplirati.</p> <p>Drugi red standardnog ulaza sadr\u017ei niz \\(B\\) du\u017eine \\(N\\), gde \\(B_i\\) predstavlja Huanovu potencijalnu platu ako izabere da \\(i\\)-tog dana radi drugi posao. </p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#opis-izlaza","title":"Opis izlaza","text":"<p>U jednom redu standardnog izlaza ispisati maksimalnu zaradu u funtama koju mo\u017ee Huan imati nakon \\(N\\) dana.</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq A \\leq 10^9\\)</li> <li>\\(0 \\leq C \\leq 10^9\\)</li> <li>\\(1 \\leq B_i \\leq 10^9\\)</li> </ul>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#podzadaci","title":"Podzadaci","text":"<ul> <li>(11 poena): \\(1 \\leq N \\leq 20\\)</li> <li>(12 poena): \\(C = 0\\)</li> <li>(10 poena): Va\u017ei \\(B_i = B_j\\) za svako \\(1\\leq i, j \\leq N\\).</li> <li>(18 poena): Va\u017ei \\(B_i \\leq B_{i + 1}\\), za svako \\(1 \\leq i &lt; N\\)</li> <li>(25 poena): Sve vrednosti sa ulaza nisu ve\u0107e od \\(2000\\).</li> <li>(24 poena): Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#ulaz","title":"Ulaz","text":"<pre><code>4 5 3\n1 4 2 7\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#izlaz","title":"Izlaz","text":"<pre><code>28\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Huan \u0107e birati poslove po slede\u0107em rasporedu:</p> <ol> <li>dan - prvi posao, zarada 5 funti</li> <li>dan - drugi posao, zarada 4 funte, od ovog trenutka kre\u0107e da se duplira zarada na drugom poslu</li> <li>dan - prvi posao, zarada 5 funti</li> <li>dan - drugi posao, zarada 14 funti</li> </ol> <p>Huan \u0107e ukupno zaraditi 5 + 4 + 5 + 14 = 28 funti.</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#ulaz_1","title":"Ulaz","text":"<pre><code>3 1000000000 3\n1 1 1\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#izlaz_1","title":"Izlaz","text":"<pre><code>3000000000\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#resenje-kada-n-leq-20","title":"Re\u0161enje kada \\(N \\leq 20\\)","text":"<p>Po\u0161to za svaki dan postoji dve mogu\u0107nosti, oti\u0107i na prvi ili drugi posao, ukupno postoji \\(2^N\\) mogu\u0107nosti. Mo\u017eemo probati svaku mogu\u0107nost, simulirati zaradu novca i odabrati optimalni odabir poslova.</p> <p>Vremenska slo\u017eenost je \\(O(N\\cdot 2^N)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#resenje-kada-c-0","title":"Re\u0161enje kada \\(C = 0\\)","text":"<p>Po\u0161to je od po\u010detka ispunio kvotu za dupliranu platu na drugom poslu, potrebno je \\(i\\)-tog dana oti\u0107i na prvi posao ukoliko je \\(A \\leq 2\\cdot B_i\\),  u suprotnom oti\u0107i na drugi posao. </p> <p>Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#resenje-kada-b_i-b_j","title":"Re\u0161enje kada \\(B_i = B_j\\)","text":"<p>Po\u0161to je plata na drugom poslu ista svakog dana, nazovimo je \\(B\\). Fiksirajmo \\(k\\) kao prvi dan kada je ispunjena kvota (prvi dan kad bi plata na drugom poslu bila \\(2\\cdot B\\)), isprobajmo sve brojeve od \\(1\\) do \\(N\\), tim redom. </p> <p>Kako bi dan \\(k\\) bio prvi kad je plata duplirana, potrebno je da Huan u prvih \\(k-1\\) dana ta\u010dno \\(\\lceil \\frac{C}{B} \\rceil\\) dana ode na drugi posao (ukoliko \\(\\lceil \\frac{C}{B} \\rceil &gt; k-1\\), ta vrednost za \\(k\\) nije mogu\u0107a). Samim tim rezultat za fiksno \\(k\\) je </p> \\[ \\lceil \\frac{C}{B} \\rceil \\cdot B + (k-1-\\lceil \\frac{C}{B} \\rceil) \\cdot A + (N-k+1) \\cdot \\max(A, 2\\cdot B), \\] <p>\u0161to se mo\u017ee lako izra\u010dunati.</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#resenje-kada-b_i-leq-b_i1","title":"Re\u0161enje kada \\(B_i \\leq B_{i+1}\\)","text":"<p>Sli\u010dno prethodnom re\u0161enju, fiksirajmo \\(k\\). U prvih \\(k-1\\) dana, na drugi posao \u0107e sigurno oti\u0107i kada va\u017ei \\(B_i \\geq A\\). Ukoliko sa tim danima nije ispunio kvotu, potrebno je da na drugi posao ode jo\u0161 nekoliko dana dok ne ispuni kvotu, uvek idu\u0107i danima kada je najve\u0107e \\(B_i\\). Po\u0161to mu se ve\u0107 ne isplati, \u017eeli da \u0161to manje dana potro\u0161i na to. </p> <p>Po\u0161to je niz \\(B\\) neopadaju\u0107i, mo\u017eemo primetiti da \u0107e za neko \\(0 \\leq t_1 \\leq k-1\\) prvih \\(t_1\\) dana oti\u0107i na prvi posao, a danima \\([t_1+1, k-1]\\) oti\u0107i na drugi posao. </p> <p>Sem toga, postoji neko \\(k \\leq t_2 \\leq N\\), takvo da se danima \\([t_2, N]\\) vi\u0161e isplati oti\u0107i na drugi posao (ako \\(k\\)-tog dana ispunimo kvotu). Dakle, rezultat za fiksno \\(k\\) je:</p> \\[ t_1 \\cdot A +\\sum_{i = t_1+1}^{k-1} B_i  + (t_2-k)\\cdot A + 2\\cdot \\sum_{i = t_2}^{N} B_i  \\] <p>Brojeve \\(t_1\\) i \\(t_2\\) mo\u017eemo na\u0107i binarnom pretragom, dok rezultat mo\u017eemo efikasno izra\u010dunati prefiksnom sumom nad nizom \\(B\\). Ponovo moramo paziti da je mogu\u0107e da nam fiksirana vrednost mo\u017ee biti \\(k\\).</p> <p>Vremenska slo\u017eenost je \\(O(NlogN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#resenje-kada-n-a-c-b_i-leq-2000","title":"Re\u0161enje kada \\(N, A, C, B_i \\leq 2000\\)","text":"<p>Ovo re\u0161enje je veoma sli\u010dno prethodnom - po\u0161to je \\(N\\) malo, za svako \\(k\\) mo\u017eemo iznova sortirati niz \\(B\\) na intervalima \\([1, k-1]\\) i \\([k, N]\\) i primeniti prethodno re\u0161enje. </p> <p>Vremenska slo\u017eenost je \\(O(N^2logN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/01_poslovan_covek/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ponovo fiksiramo \\(k\\) i idemo sleva nadesno, odvojeno re\u0161avamo intervale \\([1, k-1]\\) i \\([k, N]\\). Za desni interval, jednostavno \u0107emo izra\u010dunati sufiksne sume \\(suf_i = suf_{i+1} + \\max(A, 2\\cdot B_j)\\) koje \u0107emo kasnije koristiti u krajnjem re\u0161enju.</p> <p>\u0160to se ti\u010de levog intervala, spomenuli smo da postoje oni dani kada se Huanu uvek isplati da ode na drugi posao (\\(B_i \\geq A\\)) i oni kad ide na drugi posao samo kako bi ispunio kvotu. Za prvi tip, dovoljno je odr\u017eavati njihovu sumu \\(Bsum\\) kako menjamo \\(k\\). Za drugi tip je komplikovanije, jer mo\u017ee da se desi da za jedno \\(k\\) ode na drugi posao, a za slede\u0107e \\(k\\) istog dana ode na prvi posao. </p> <p>Zato \u0107emo odr\u017eavati min hip (priority_queue) sa najve\u0107im vrednostima \\(B\\) koji nisu prvog tipa (dakle, za koje va\u017ei \\(B_i &lt; A\\)). \u010cuva\u0107emo u njemu sve vrednosti koje su nam potrebne da, zajedno sa danima prvog tipa, ispuni kvotu. Nazovimo sumu elemenata u hipu \\(Hsum\\). Odr\u017eavamo hip tako da u njemu imamo \u0161to manje elemenata, a va\u017ei \\(Bsum + Hsum \\geq C\\). Kada se \\(k\\) premesti sa \\(i-1\\) na \\(i\\), ukoliko je \\(B_i \\leq A\\) onda uve\u0107avamo \\(Bsum\\) i potencijalno bri\u0161emo neke najmanje elemente iz hipa, ukoliko nam vi\u0161e nisu potrebni, smanjuju\u0107i \\(Hsum\\). Ukoliko va\u017ei \\(B_i &lt; A\\), onda \u0107emo prvo dodati \\(B_i\\) u hip i pove\u0107ati \\(Hsum\\), a onda potencijalno obrisati najmanje elemente koji su vi\u0161ak (to mo\u017ee biti i element koji smo upravo dodali) i smanjujemo \\(Hsum\\). </p> <p>Rezultat za fiksno \\(k\\) je onda \\(Hsum + Bsum + suf_i\\).</p> <p>Vremenska slo\u017eenost je \\(O(NlogN)\\), a memorijska \\(O(N)\\).</p> 01_poslovan_covek.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxN = 2e5 + 10;\nint N, A, C;\nint B[maxN];\nlong long sufBest[maxN];\n\nint main() {\n\n    cin &gt;&gt; N &gt;&gt; A &gt;&gt; C;\n\n  for (int i = 1 ; i &lt;= N; i++) {\n    cin &gt;&gt; B[i];\n  }\n\n  for (int i = N; i &gt; 0; i--) {\n    sufBest[i] = sufBest[i  + 1] + max(A, 2 * B[i]);\n  }\n\n  multiset&lt;int&gt; taken;\n  long long setSum = 0;\n  long long answer = 0;\n  long long totalSum = 0;\n  for (int i = 1; i &lt;= N; i++) {\n    totalSum+=max(A, B[i]);\n    taken.insert(B[i]);\n    setSum+=B[i];\n    while(setSum - *taken.begin() &gt; C &amp;&amp; *taken.begin() &lt; A) {\n        setSum-= *taken.begin();\n        taken.erase(taken.begin());\n    }\n\n    if (setSum &gt; C) {\n      int setSize = taken.size();\n      answer = max(answer, setSum + 1ll * (i - setSize) * A  + sufBest[i + 1]);\n    }\n  }\n\n  answer = max(answer, totalSum);\n\n  cout &lt;&lt; answer &lt;&lt; endl;\n}\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/","title":"2 - Arhitekta","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 128MB <p>Kralj Bajtovije \u017eeli da pove\u017ee svojih \\(N\\) gradova putevima. On trenutno razmatra \\(M\\) puteva, od kojih \\(i\\)-ti povezuje gradove \\(u_i\\) i \\(v_i\\). Za svaki od tih \\(M\\) puteva poznata je i vrednost \\(w_i\\) - cena izgradnje \\(i\\)-tog puta. Kralj \u017eeli da pove\u017ee svoje gradove tako da je od bilo kog grada mogu\u0107e sti\u0107i do bilo kog drugog grada koriste\u0107i izgra\u0111ene puteve. Tu Vi stupate na scenu.</p> <p>Vi ste \u010duveni arhitekta Milivoje Felipe San\u010do Gomez Rozario don Karlos, poznatiji pod imenom Milivoje Felipe Gomez Rozario don Karlos. Kada ste saslu\u0161ali kralja, objasnili ste mu da je cena izgradnje nekog skupa puteva upravo bitovska disjunkcija cene izgradnje svih puteva iz tog skupa.</p> <p>Pomozite kralju i izaberite neke puteve tako da je mogu\u0107e od bilo kog grada sti\u0107i do bilo kog drugog grada i da je pritom cena najmanja mogu\u0107a.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Mladen Puzi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#opis-ulaza","title":"Opis ulaza","text":"<p>U jedinom redu standardnog izlaza ispisati jedan ceo broj - minimalna cena izgradnje nekog skupa puteva tako da je od svakog grada mogu\u0107e sti\u0107i do svakog drugog grada koriste\u0107i neke od ovih puteva. Garantuje se da je uvek mogu\u0107e ispuniti ovaj uslov.</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati jedan ceo broj - minimalna cena izgradnje nekog skupa puteva tako da je od svakog grada mogu\u0107e sti\u0107i do svakog drugog grada koriste\u0107i neke od ovih puteva. Garantuje se da je uvek mogu\u0107e ispuniti ovaj uslov.</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(1 \\leq M \\leq 2 \\cdot 10^5\\).</li> <li>\\(1 \\leq u_i &lt; v_i \\leq N\\) za svako \\(1 \\leq i \\leq M\\).</li> <li>Za svake \\(1 \\leq i \\neq j \\leq M\\) va\u017ei \\(u_i \\neq u_j\\) ili \\(v_i \\neq v_j\\).</li> <li>\\(0 \\leq w_i \\leq 10^9\\).</li> <li>Garantuje se da je uvek mogu\u0107e sti\u0107i od bilo kog grada do bilo kog drugog grada izgradnjom nekih od \\(M\\) puteva.</li> </ul>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#podzadaci","title":"Podzadaci","text":"<ol> <li>(6 poena) \\(M = N - 1\\).</li> <li>(14 poena) \\(N = M\\) i va\u017ee ograni\u010denja \\(u_i = i\\) i \\(v_i = i + 1\\) za svako \\(1 \\leq i \\leq M -  1\\) i \\(u_M = 1\\) i \\(v_M = N\\).</li> <li>(13 poena) \\(0 \\leq w_i \\leq 1\\).</li> <li>(26 poena) \\(1 \\leq M \\leq 10^3\\) i \\(0 \\leq w_i \\leq 10^3\\) za svako \\(1 \\leq i \\leq M\\).</li> <li>(41 poen) Nema dodatnih ograni\u010denja.</li> </ol>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#primeri","title":"Primeri","text":""},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#ulaz","title":"Ulaz","text":"<pre><code>4 4\n1 2 4\n1 3 6\n2 4 1\n1 4 2\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Izgradi\u0107emo puteve izme\u0111u gradova \\(1\\) i \\(2\\), gradova \\(1\\) i \\(3\\) i gradova \\(1\\) i \\(4\\). Cena izgradnje prvog puta je \\(4\\), drugog je \\(6\\), dok je cena izgradnje tre\u0107eg od navedenih puteva \\(2\\). Bitovska disjunkcija ovih brojeva je upravo \\(6\\). Mo\u017ee se proveriti da nije mogu\u0107e izabrati puteve tako da svi gradovi budu povezani putevima, a da cena ukupne izgradnje puteva bude manja. </p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#napomena","title":"Napomena","text":"<p>Operator bitovske disjunkcije u Pascal-u je ozna\u010den sa <code>or</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>|</code>. Ova operacija \\(x\\ \\text{or} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{or} \\  y\\).</p> <p>Bitovska disjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{or} \\ x_{2}  \\ \\text{or} \\  ...  \\ \\text{or} \\  x_{n} = (...(((x_{1}  \\ \\text{or} \\  x_{2})  \\ \\text{or} \\  x_{3}) \\ \\text{or} \\ x_{4})...)  \\ \\text{or} \\  x_{n}\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#resenje-kada-m-n-1","title":"Re\u0161enje kada \\(M = N-1\\)","text":"<p>U ovom podzadatku moramo odabrati sve putevi da bismo konstruisali odgovaraju\u0107i plan. Na\u0111imo bitovsku disjunkciju cena svih grana. Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#resenje-kada-skup-puteva-pravi-ciklus","title":"Re\u0161enje kada skup puteva pravi ciklus","text":"<p>U ovom podzadatku, moramo odabrati sve puteve sem jednog, gde mo\u017eemo bilo koji izostaviti. Mo\u017eemo prebaciti ovaj graf u niz du\u017eine \\(N\\), gde \u010duvamo cene puteva redom. Da bismo efikasno na\u0161li bitovsku disjunkciju svih puteva sem jednog, \u010duva\u0107emo prefiksnu i sufiksnu bitovsku disjunkciju tog niza. Re\u0161enje je onda bitovska disjunkcija odgovaraju\u0107eg prefiksa i sufiksa. Od svih mogu\u0107ih opcija, biramo onu koja daje najjeftiniji plan. Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#resenje-kada-0-leq-w_i-leq-1","title":"Re\u0161enje kada \\(0 \\leq w_i \\leq 1\\)","text":"<p>Bitovska disjunkcija brojeva iz skupa \\(\\{0, 1\\}\\) mo\u017ee biti 0 samo ako su svi brojevi \\(0\\). U suprotnom ona je \\(1\\). Zato, proverimo da li kada uzmemo sve puteve cene \\(0\\) dobijemo dr\u017eavu u kojoj je svaki grad povezan sa svakim drugim. Ukoliko da, re\u0161enje je \\(0\\), u suprotnom, re\u0161enje je \\(1\\). Ovo mo\u017eemo proveriti na primer DFS algoritmom. Vremenska i memorijska slo\u017eenost je \\(O(N+M)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#resenje-kada-1-leq-m-w_i-leq-103","title":"Re\u0161enje kada \\(1 \\leq M, w_i \\leq 10^3\\)","text":"<p>Po\u0161to su cene puteva do \\(1000\\), onda je najve\u0107i mogu\u0107i rezultat \\(1023\\). Proveri\u0107emo sve mogu\u0107e ukupne cene jednu po jednu od najmanje ka najve\u0107oj. Recimo da proveravamo rezultat \\(x\\). Pro\u0111imo redom kroz sve grane i dodajmo samo one koje mo\u017eemo, tako da \\(x\\) ostane mogu\u0107 rezultat. U ovom slu\u010daju, to zna\u010di da ni na jednoj poziciji u binarnom zapisu nema cifru \\(1\\), a da je u broju \\(x\\) ta cifra \\(0\\). Kada dodamo sve te grane, kao u prethodnom podzadatku proverimo da li je mogu\u0107e sti\u0107i od svakog grada do svakog drugog koriste\u0107i te grane. Ako da, i to je najmanje takvo \\(x\\), to je re\u0161enje. Vremenska slo\u017eenost je \\(O(M\\cdot \\max(w_i))\\), a memorijska \\(O(N+M)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/02_arhitekta/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Umesto da fiksiramo mogu\u0107i rezultat kao u prethodnom zadatku, gradi\u0107emo rezultat bit po bit, krenuv\u0161i od najvrednijeg bita. Po\u0161to va\u017ei da je \\(2^{0} + 2^{1} + \\ldots + 2^{i} \\leq 2^{i+1}\\), u interesu nam je da najvredniji bit bude \u0161to manji. Poku\u0161ajmo prvo da izbegnemo najvredniji bit. Dodajmo sve grane u \u010dijim te\u017einama je ta cifra \\(0\\). Ukoliko mo\u017eemo da napravimo plan samo sa tim granama, stavljamo \\(0\\) na tu cifru rezultata, a izbacujemo iz skupa grana sve grane \u010dijoj ceni je ta cifra \\(1\\), jer su nepotrebne. Ukoliko ne mo\u017eemo, onda stavljamo \\(1\\) na tu cifru, ali odr\u017eavamo isti skup grana (neophodne su nam obe vrste). U oba slu\u010daja, prelazimo na slede\u0107i bit na isti na\u010din. Na kraju, ima\u0107emo konstruisani rezultat. Vremenska slo\u017eenost je \\(O(M\\log(w_i))\\), a memorijska \\(O(N+M)\\). </p> 02_arhitekta.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 300000\nusing namespace std;\nstruct edge\n{\n    int u, v, w;\n};\n\nint n, m;\nedge edges[maxn];\nvector&lt;int&gt; graph[maxn];\nbool vis[maxn];\n\n\nvoid clear()\n{\n\n    for(int u = 1; u &lt;= n; u++) {\n\n        graph[u].clear();\n        vis[u] = false;\n\n    }\n\n}\n\nvoid construct_graph(int max_w)\n{\n\n    for(int i = 1; i &lt;= m; i++) {\n\n        if( (max_w &amp; edges[i].w) == edges[i].w) {\n\n            graph[edges[i].u].push_back(edges[i].v);\n            graph[edges[i].v].push_back(edges[i].u);\n\n        }\n\n    }\n\n}\n\nint dfs_tree_size(int u)\n{\n\n    vis[u] = true;\n    int ret = 1;\n\n    for(int v : graph[u]) {\n\n        if(!vis[v]) {\n\n            ret += dfs_tree_size(v);\n\n        }\n\n    }\n\n    return ret;\n\n}\n\nint main()\n{\n\n    scanf(\"%d %d\", &amp;n, &amp;m);\n\n    for(int i = 1; i &lt;= m; i++) {\n\n        int u, v, w;\n        scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w);\n        edges[i] = {u, v, w};\n\n    }\n\n    int ans = 0;\n    int bit = (1 &lt;&lt; 30);\n\n    while(bit &gt; 0) {\n\n        clear();\n        construct_graph(ans | (bit - 1) );\n\n        if(dfs_tree_size(1) != n) {\n\n            ans |= bit;\n\n        }\n\n        bit &gt;&gt;= 1;\n\n    }\n\n    printf(\"%d\", ans);\n    return 0;\n\n}\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/","title":"3 - Zagrade","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Arsenije sa svoje terase ima prelep pogled na more. Me\u0111utim, trenutno postoje planovi za izgradnju koji nastoje da mu zagrade taj pogled. On je odlu\u010dio da se \u017eali kome ve\u0107 treba i dobio je odgovor da jedini na\u010din da razmotre njegovu \u017ealbu je da re\u0161i tajni zadatak koji \u0107e mu poslati u bliskoj budu\u0107nosti.</p> <p>Kroz par dana je Arsenije u po\u0161ti dobio niz od \\(N\\) zagrada, sa porukom \"zna\u0161 \u0161ta ti je \u010diniti\". Zaista, Arsenije je znao \u0161ta mora da uradi. On jednom potezu mo\u017ee da premesti zagradu sa po\u010detka niza na kraj niza, i potrebno je da na\u0111e najmanji broj poteza tako da dobijeni niz zagrada bude validan. Podsetnik, za niz zagrada ka\u017eemo da je validan ako je mogu\u0107e umetnuti neki broj znakova \\(0\\) i \\(+\\) tako da se dobije validan matemati\u010dki izraz. </p> <p>Me\u0111utim, u narednih \\(Q\\) dana mu sti\u017ee po jedna zapovest: \"promeni zagradu na poziciji \\(i\\) (ako je otvorena, promeni u zatvorenu i obrnuto)\". Arsenije vr\u0161i ove promene nezavisno od operacija koje je vr\u0161io prethodnih dana, to jest on menja svoj originalni niz zagrada. Va\u0161 zadatak u ovih \\(Q+1\\) dana je da pomognete Arseniju da re\u0161i ovaj problem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze dva broja \\(N\\) i \\(Q\\) iz teksta zadatka. U narednoj liniji se nalazi niska zagrada du\u017eine \\(N\\). U narednih \\(Q\\) linija se nalazi po jedan broj koji ozna\u010dava indeks zagrade koje Arsenije treba da promeni.</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#opis-izlaza","title":"Opis izlaza","text":"<p>Potrbeno je ispisati \\(Q+1\\) brojeva, svaki u zasebnoj liniji; u prvoj liniji treba ispisati re\u0161enje Arsenijevog problema pre svih promena, a u \\(i\\)-toj liniji od narednih linija treba ispisati re\u0161enje Arsenijevog problema posle \\(i\\)-te promene. Ako re\u0161enje ne postoji, ispisati \\(-1\\). Niz zagrada je indeksiran od 1.</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,Q \\leq 300.000\\)</li> <li>\\(N\\) je parno </li> <li>Svaka promena je odre\u0111ena brojem izme\u0111u \\(1\\) i \\(N\\).</li> </ul>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#podzadaci","title":"Podzadaci","text":"<ul> <li>(17 poena): \\(N,Q\\leq500\\)</li> <li>(23 poena): \\(N,Q\\leq5000\\)</li> <li>(21 poena): Sve promene menjaju zatvorene zagrade  u otvorene</li> <li>(39 poena): Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#ulaz","title":"Ulaz","text":"<pre><code>2 2\n()\n1\n2\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#izlaz","title":"Izlaz","text":"<pre><code>0\n-1\n1\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Po\u010detni niz je validan jer je \\((0)\\) validan matemati\u010dki izraz, pa je prvi broj ispisa \\(0\\). Posle prve  promene niz postaje \\())\\), \u0161to nikad ne mo\u017ee postati validno. Posle druge promene, dobijamo niz \\()(\\), a posle jednog poteza, niz postaje \\(()\\), \u0161to je ve\u0107 prokomentarisano da je validno.</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#ulaz_1","title":"Ulaz","text":"<pre><code>4 4\n))((\n1\n2\n3\n4\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n-1\n-1\n-1\n0\n</code></pre>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#resenje-kada-n-q-leq-500","title":"Re\u0161enje kada \\(N, Q \\leq 500\\)","text":"<p>Nakon svake promene, prebacujmo jednu po jednu zagradu sa po\u010detka na kraj, dok ne nai\u0111emo na prvi put kada imamo validan niz zagrada. Re\u0161enje je broj preba\u010denih zagrada. Proveravamo da li je niz zagrada validan tako \u0161to idemo sleva nadesno i odr\u017eavamo broj neuparenih otvorenih zagrada. Ukoliko nai\u0111emo na otvorenu zagradu, pove\u0107avamo taj broj. Ukoliko nai\u0111emo na zatvorenu zagradu, a broj neuparenih otvorenih zagrada je ve\u0107i od \\(0\\), onda uparujemo jednu otvorenu zagradu sa tom zatvorenom zagradom, pa smanjujemo taj broj. Ukoliko nemamo neuparenih otvorenih zagrada, a nai\u0111emo na zatvorenu zagradu, niz zagrada nije validan. On tako\u0111e nije validan ako zavr\u0161imo proces sa neuparenim otvorenim zagradama. Vremenska slo\u017eenost je \\(O(QN^2)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#resenje-kada-n-q-leq-5000","title":"Re\u0161enje kada \\(N, Q \\leq 5000\\)","text":"<p>U ovom podzadatku \u0107emo primeniti svaku promenu i poku\u0161ati da na\u0111emo re\u0161enje u \\(O(N)\\). Posmatrajmo slede\u0107i niz:</p> \\[ p_0 = 0 \\] \\[ p_i =  \\begin{cases} p_{i \u2212 1} + 1, i\\text{-ta zagrada je otvorena} \\\\ p_{i \u2212 1} \u2212 1, i\\text{-ta zagrada je zatvorena} \\end{cases} \\] <p>Primetimo da je uslov da niz zagrada bude validan da va\u017ei \\(p_i \\leq 0\\) za svako \\(1\\leq i \\leq N\\) i \\(p_N = 0\\) (ovo je ekvivalentno tome da nijedan prefiks nema vi\u0161e zatvorenih nego otvorenih zagrada i da ukupno imamo jednako otvorenih i zatvorenih zagrada).</p> <p>Posmatrajmo sad \u0161ta se desi kada prvih \\(i\\) zagrada prebacimo na kraj. Mo\u017eemo primetiti da \u0107e se prvih \\(i\\) elemenata niza \\(p_i\\) prebaciti na kraj i onda \u0107e se ceo niz pove\u0107ati za \\(\u2212p_i\\). Po\u0161to \u017eelimo da svi elementi budu ve\u0107i ili jednaki \\(0\\), onda moramo da ga pove\u0107amo za \u0161to vi\u0161e, \u0161to zna\u010di da \u0107emo uzeti \u0161to manje \\(p_i\\). Dakle, re\u0161enje je \\(i\\) za koje je \\(p_i\\) najmanje. Ukoliko ima izjedna\u010denja, onda uzimamo najmanje takvo \\(i\\). Nakon svake promene samo ponovo izra\u010dunamo niz \\(p_i\\). Vremenska slo\u017eenost je \\(O(QN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#resenje-kada-sve-promene-menjaju-zatvorene-zagrade-u-otvorene","title":"Re\u0161enje kada sve promene menjaju zatvorene zagrade u otvorene","text":"<p>Primetimo da, kako bi niz zagrada bio validan, moramo imati jednak broj otvorenih i zatvorenih zagrada. Recimo da na po\u010detku imamo \\(l\\) otvorenih, a \\(r\\) zatvorenih zagrada. Ukoliko \\(r &lt; l\\) onda o\u010digledno nikad ne mo\u017eemo dobiti validan niz zagrada. U suprotnom, mo\u0107i \u0107emo da imamo validan niz zagrada samo nakon \u0161to \\(\\frac{r\u2212l}{2}\\) zatvorenih zagrada pretvorimo u otvorene. Ukoliko \\(\\frac{r\u2212l}{2} &gt; Q\\), onda opet nikad ne\u0107emo imati re\u0161enje. U suprotnom, dovoljno je da primenimo re\u0161enje iz prethodnog podzadatka nakon \\(\\frac{r\u2212l}{2}\\) promena (svi ostali rezultati su \\(\u22121\\)). Vremenska slo\u017eenost je \\(O(N+Q)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/ejoi_izb/03_zagrade/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ovaj podzadatak se radi sli\u010dno kao drugi podzadatak, samo zbog efikasne promene niza \\(p_i\\) potrebno je da odr\u017eavamo segmentno stablo sa lenjom propagacijom nad njim. Promena koja je potrebna je dodavanje \\(+1\\) ili \\(\u22121\\) na neki sufiks, i nala\u017eenje minimuma celog niza. Da bismo uzeli najlevlji minimum celog niza, segmentno stablo gradimo nad nizom parova \\(\\{p_i, i\\}\\), pa \u0107emo upitom minimuma dobiti onaj par sa najmanjim \\(p_i\\), a najmanjim indeksom u slu\u010daju izjedna\u010denja. Vremenska slo\u017eenost je \\(O(Q\\log N)\\), a memorijska \\(O(N)\\).</p> 03_zagrade.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 300007\nusing namespace std;\nstring s;\npair&lt;int,int&gt; seg[4*MAXN];\nint bag[4*MAXN],cnt=0;\nvoid relax(int ind)\n{\n    bag[2*ind]+=bag[ind];\n    bag[2*ind+1]+=bag[ind];\n    seg[ind]=min(make_pair(seg[2*ind].first+bag[2*ind],seg[2*ind].second),make_pair(seg[2*ind+1].first+bag[2*ind+1],seg[2*ind+1].second));\n    bag[ind]=0;\n}\nvoid upd(int val,int l,int r,int lt,int rt,int ind)\n{\n    if(l&gt;rt || r&lt;lt) return;\n    if(l&gt;=lt &amp;&amp; r&lt;=rt) {bag[ind]+=val; return;}\n    relax(ind);\n    int s=(l+r)/2;\n    upd(val,l,s,lt,rt,2*ind);\n    upd(val,s+1,r,lt,rt,2*ind+1);\n    seg[ind]=min(make_pair(seg[2*ind].first+bag[2*ind],seg[2*ind].second),make_pair(seg[2*ind+1].first+bag[2*ind+1],seg[2*ind+1].second));\n}\nvoid make(int l,int r,int ind)\n{\n    if(l==r) {seg[ind].second=l; return;}\n    int s=(l+r)/2;\n    make(l,s,2*ind);\n    make(s+1,r,2*ind+1);\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    string s;\n    cin&gt;&gt;n&gt;&gt;q;\n    cin&gt;&gt;s;\n    make(0,n,1);\n    for(int i=0;i&lt;n;i++) {upd(((s[i]=='(')?1:-1),0,n,i+1,n,1); cnt+=((s[i]=='(')?1:-1);}\n    if(cnt!=0) printf(\"-1\\n\");\n    else printf(\"%d\\n\",seg[1].second);\n    while(q--)\n    {\n        int t;\n        cin&gt;&gt;t; t--;\n        upd(((s[t]=='(')?-2:2),0,n,t+1,n,1); cnt+=((s[t]=='(')?-2:2);\n        s[t]^=1;\n        if(cnt!=0) printf(\"-1\\n\");\n        else printf(\"%d\\n\",seg[1].second);\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/","title":"1 - Nesusedni","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 200ms 256MB <p>Programer Pera ima omiljeno slovo \\(c_1\\) (jedno od malih slova engleskog alfabeta) i poseduje \\(a_1\\) komada ovog slova. Programerka Petra tako\u0111e ima svoje omiljeno slovo \\(c_2\\) (jedno od malih slova enegleskog alfabeta, razli\u010dito od Petrovog) i \\(a_2\\) komada svog slova. </p> <p>Pera i Petra su re\u0161ili da naprave string u kome \u0107e se na\u0107i svih \\(a_1+a_2\\) njihovih slova ali takav da u njemu ne postoje dva ista susedna slova. Odredite bilo koji string koji zadovoljava ove uslove ili konstatujte da takav string ne postoji.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Vladimir Milovanovi\u0107 <p>Kako imamo ta\u010dno 2 razli\u010dita slova, jedini na\u010din da string ne sadr\u017ei dva ista susedna slova je da se slova pojavljuju naizmeni\u010dno u stringu tj. \\(c_1c_2c_1c_2\\ldots\\) ili \\(c_2c_1c_2c_1\\ldots\\). Ovo je mogu\u0107e ako i samo ako je \\(|a_1 - a_2| \\leq 1\\). Zaista, ako je \\(|a_1 - a_2| &gt; 1\\), \"istro\u0161i\u0107emo\" jedno slovo u naizmeni\u010dnom pojavljivanju pre kraja stringa. Sa druge strane, ako je \\(a_1 = a_2\\), imamo 2 mogu\u0107a re\u0161enja (bilo koje slovo mo\u017ee biti prvo), a ako je \\(|a_1 - a_2|=1\\), re\u0161enje je jedinstveno jer moramo po\u010deti (i zavr\u0161iti) slovom koje se pojavljuje vi\u0161e puta.</p> <p>Slo\u017eenost algoritma je \\(O(a_1 + a_2)\\), zbog ispisa.</p> 01_nesusedni.cpp<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0); // uvek dodati ovu liniju ako se radi sa cin/cout umesto sa scanf/printf (iako nije neophodna za ovaj zadatak)\n\n    char c1, c2;\n    int a1, a2;\n\n    cin &gt;&gt; c1 &gt;&gt; c2;\n    cin &gt;&gt; a1 &gt;&gt; a2;\n\n    if (abs(a1 - a2) &gt; 1)\n    {\n        cout &lt;&lt; \"nemoguce\" &lt;&lt; \"\\n\";\n        return 0;\n    }\n\n    if (a1 &lt; a2)\n    {\n        char tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n\n    for (int i = 0; i &lt; a1 + a2; i++)\n    {\n        if (i % 2 == 0)\n            cout &lt;&lt; c1;\n        else\n            cout &lt;&lt; c2;\n    }\n\n    cout &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalaze Perino i Petrino slovo \\(c_1\\) i \\(c_2\\), redom, bez razmaka. U narednom redu se nalaze dva prirodna broja \\(a_1\\) i \\(a_2\\), razdvojena razmakom, koja predstavljaju broj komada slova koje poseduju Pera i Petra, redom.</p>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu ispisati string koji zadovoljava sve uslove iz zadatka. Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje. Ukoliko re\u0161enje ne postoji, ispisati 'nemoguce' (bez navodnika).</p>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv1/01_nesusedni/#ulaz","title":"Ulaz","text":"<pre><code>ab\n2 2\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#izlaz","title":"Izlaz","text":"<pre><code>baba\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv1/01_nesusedni/#ulaz_1","title":"Ulaz","text":"<pre><code>nm\n4 10\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#izlaz_1","title":"Izlaz","text":"<pre><code>nemoguce\n</code></pre>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom primeru su iskori\u0161\u0107ena 2 slova 'a' i 2 slova 'b' i ne postoje dva ista susedna slova - dakle, string je validan. String 'abab' je tako\u0111e validno re\u0161enje za ovaj primer. U drugom primeru, ma kako rasporedili 4 slova 'n' i 10 slova 'm', uvek \u0107e postojati dva susedna ista slova pa tra\u017eeni string ne postoji.</p>"},{"location":"takprog/2021_2022/kv1/01_nesusedni/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(c_1\\) i \\(c_2\\)  su me\u0111usobno razli\u010dita mala slova engleskog alfabeta</li> <li>\\(1 \\leq a_1, a_2 \\leq 50.000\\)</li> </ul> <p>Test primeri su podeljeni u 3 disjunkne grupe:</p> <ul> <li>U test primerima vrednim \\(20\\) poena va\u017ei \\(c_1 =\\) '\\(a\\)',  \\(c_2 =\\) '\\(b\\)' i \\(1 \\leq a_1, a_2 \\leq 3\\).</li> <li>U test primerima vrednim \\(40\\) poena va\u017ei \\(1 \\leq a_1, a_2 \\leq 1.000\\)</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/","title":"2 - Transfuzija krvi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Lokalna bolnica vas je zamolila da pomognete oko planiranja transfuzija krvi. Trenutno imaju \\(N\\) pacijenata koji \u010dekaju transfuziju, i za svakog od njih je poznata krvna grupa i broj jedinica krvi koje su mu potrebne. Interesuje ih da li je, sa zalihama koje su na raspolaganju, mogu\u0107e svakom od ovih pacijenata dati transfuziju sa odgovaraju\u0107om koli\u010dinom krvi grupe koja je kompatibilna sa njegovom.</p> <p>Za potrebe ovog zadatka, postoje \u010detiri krvne grupe: O, A, B i AB (u stvarnosti, klasifikacija je komplikovanija).</p> <p>Prilikom transfuzije va\u017ee slede\u0107a pravila:</p> <ul> <li>Pacijent \u010dija je krvna grupa O mo\u017ee primiti samo krv grupe O.</li> <li>Pacijent \u010dija je krvna grupa A ili B mo\u017ee primiti krv \u010dija je grupa   ista kao njegova, ili krv grupe O.</li> <li>Pacijent \u010dija je krvna grupa AB mo\u017ee primiti bilo kakvu krv.</li> <li>Pacijent mo\u017ee da primi vi\u0161e razli\u010ditih krvnih grupa. Na primer,   pacijent B grupe kom su potrebne dve jedinice mo\u017ee primiti jednu O   grupe i jednu B grupe.</li> <li>Jedinice se ne mogu razdvajati: broj jedinica krvi bilo koje grupe   koje pacijent primi mora biti ceo broj.</li> </ul> <p>Od vas se tra\u017ei da za svakog pacijenta date spisak jedinica koje \u0107e primiti, tako da su data pravila ispunjena, svaki pacijent dobije onoliko jedinica koliko mu je potrebno, i da je broj iskori\u0161\u0107enih jedinica manji ili jednak od onog u zalihama. Ukoliko ovo nije mogu\u0107e, va\u0161 program treba da samo ispi\u0161e <code>nemoguce</code>.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Andrej Iva\u0161kovi\u0107 <p>Za po\u010detak, pacijenti O grupe su jednostavni: mogu da prime samo krv O grupe, tako da kod njih nemamo nikakvih odluka. U prvom prolazu kroz pacijente, mo\u017eemo njima dodeliti odgovaraju\u0107e koli\u010dine O krvi, i zatim u slede\u0107em prolazu razmatrati samo pacijente A, B i AB grupe.</p> <p>U slede\u0107em prolazu mo\u017eemo dodeliti krv pacijentima A grupe. Kod njih imamo izbor izme\u0111u A i O, ali je odluka jednostavna: sada kada nema vi\u0161e pacijenata O grupe, krv A grupe je strogo \"manje korisna\" od O, jer svi koji mogu da je prime mogu da prime i krv O grupe. Dakle, ako mo\u017eemo, bolje je da dodeljujemo krv A grupe i \u010duvamo O, koju \u0107emo koristiti samo ako vi\u0161e uop\u0161te nema krvi A grupe.</p> <p>Dalje, dodeljivanje krvi pacijentima B grupe mo\u017eemo uraditi na isti na\u010din kao za A. Na kraju, ostaju samo pacijenti AB-grupe, tako da vi\u0161e nije bitno koju krvnu grupu koristimo i mo\u017eemo im dodeliti proizvoljnu koje je preostalo u zalihama.</p> <p>Ako je u bilo kom trenutku u zalihama nedovoljno krvi za nekog pacijenta, prekidamo program i ispisujemo \"<code>nemoguce</code>\". U suprotnom, potrebno je da za svakog pacijenta sa\u010duvamo dodeljene jedinice krvi (npr. u nizu) i ispi\u0161emo ih na kraju.</p> 02_transfuzija.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n\nenum GROUP { O, A, B, AB } ;\n\nGROUP parse_group(const char *s) {\n    if(s[0] == 'O') return O;\n    else if(s[0] == 'A') return s[1] == 'B' ? AB : A;\n    else return B;\n}\n\nstruct patient {\n    int use[4], todo;\n    GROUP group;\n} ;\n\nconst int N = 10005;\npatient patients[N];\nint have[4];\n\nvoid transfer(int i, int type, int amount) {\n    if(amount &gt; have[type]) {\n        printf(\"nemoguce\\n\");\n        exit(0);\n    }\n\n    patients[i].todo -= amount;\n    patients[i].use[type] += amount;\n    have[type] -= amount;\n}\n\nvoid transfer_upto(int i, int type, int amount) {\n    transfer(i, type, amount &gt; have[type] ? have[type] : amount);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; 4; i++)\n        scanf(\"%d\", &amp;have[i]);\n\n    for(int i = 0; i &lt; n; i++) {\n        char group[10];\n        scanf(\" %s %d\", &amp;group, &amp;patients[i].todo);\n        patients[i].group = parse_group(group);\n    }\n\n    for(int i = 0; i &lt; n; i++)\n        if(patients[i].group == O)\n            transfer(i, O, patients[i].todo);\n\n    for(int i = 0; i &lt; n; i++)\n        if(patients[i].group == A || patients[i].group == B) {\n            transfer_upto(i, patients[i].group, patients[i].todo);\n            transfer(i, O, patients[i].todo);\n        }\n\n    for(int i = 0; i &lt; n; i++)\n        if(patients[i].group == AB) {\n            transfer_upto(i, O, patients[i].todo);\n            transfer_upto(i, A, patients[i].todo);\n            transfer_upto(i, B, patients[i].todo);\n            transfer(i, AB, patients[i].todo);\n        }\n\n    printf(\"moguce\\n\");\n    for(int i = 0; i &lt; n; i++)\n        printf(\"%d %d %d %d\\n\", patients[i].use[O], patients[i].use[A], patients[i].use[B], patients[i].use[AB]);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu se nalazi jedan ceo broj \\(N\\): broj pacijenata u bolnici.</p> <p>U drugom redu se nalazi \u010detiri broja \\(O, A, B, AB\\): broj jedinica krvi u zalihama bolnice za svaku od \u010detiri krvne grupe. Redom, ovi brojevi predstavljaju zalihe O, A, B i AB grupe.</p> <p>U narednih \\(N\\) redova se nalaze opisi pojedina\u010dnih pacijenata, koji se sastoje od stringa sa njegovom krvnom grupom (jedan od <code>O</code>, <code>A</code>, <code>B</code>, <code>AB</code>) i broja jedinica (ceo broj) koji mu je potreban razdvojenih razmakom.</p>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko je mogu\u0107e rasporediti zalihe krvi tako da svaki pacijent dobije odgovaraju\u0107i broj jedinica po\u0161tuju\u0107i data pravila, u prvi red izlaza ispisati <code>moguce</code>. Zatim, u narednih \\(N\\) redova ispisati jedinice dodeljene pacijentima, u istom redosledu kojim su pacijenti dati na ulazu. U svakom redu ovo ispisati kao \u010detiri cela broja: broj jedinica svake od grupa dodeljen tom pacijentu, istim redosledom kojim su date u zalihama (O, A, B, AB).</p> <p>Ukoliko nije mogu\u0107e rasporediti zalihe, u prvi i jedini red izlaza ispisati <code>nemoguce</code>.</p> <p>Ako postoji vi\u0161e rasporeda koji zadovoljavaju pravila, ispisati bilo koji.</p>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq N \\leq 10^4\\)</li> <li>Ukupan broj jedinica krvi u zalihama je najvi\u0161e \\(10^6\\).</li> <li>Ukupan broj jedinica krvi potrebnih pacijentima je najvi\u0161e \\(10^6\\).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena: pacijenti imaju samo krvne grupe   O ili A. U zalihama postoje samo jedinice krvi ovih grupa.</li> <li>U test primerima vrednim 30 poena: pacijenti imaju samo krvne grupe   O, A ili B. U zalihama postoje samo jedinice krvi ovih grupa.</li> <li>U test primerima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv1/02_transfuzija/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 0 2 2\nA 1\nB 1\nAB 3\n</code></pre>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#izlaz","title":"Izlaz","text":"<pre><code>moguce\n1 0 0 0\n0 0 1 0\n1 0 0 2\n</code></pre>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Bolnica u zalihama ima po dve jedinice krvi O, B i AB grupe. Jedno mogu\u0107e re\u0161enje je da pacijent grupe A kom je potrebna jedna jedinicia dobije O, pacijent grupe B dobije B, a pacijent grupe AB kom su potrebne tri jedinice dobije jednu O i dve AB.</p>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv1/02_transfuzija/#ulaz_1","title":"Ulaz","text":"<pre><code>3\n1 0 4 0\nA 1\nAB 2\nO 1\n</code></pre>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#izlaz_1","title":"Izlaz","text":"<pre><code>nemoguce\n</code></pre>"},{"location":"takprog/2021_2022/kv1/02_transfuzija/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Bolnica u zalihama ima jednu jedinicu O krvi i \u010detiri B. Po\u0161to imamo pacijenta A grupe i O grupe, koji mogu od ove dve da prime samo O krv, nema je dovoljno i nije mogu\u0107e zadovoljiti sve potrebe.</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/","title":"3 - Prepisiva\u010di","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Na pro\u0161logodi\u0161njem ciklusu takmi\u010denja iz informatike prime\u0107en je broj prepisiva\u010da ve\u0107i nego ikad. Stoga je Komisija ove godine jako zabrinuta zbog ovog problema. Paranoja je zavladala i \u010dlanovi Komisije prona\u0161li su na\u010din da prona\u0111u prepisiva\u010de.</p> <p>Naime, pretpostavi\u0107emo da \u0107e na predstoje\u0107m takmi\u010denju u\u010destvovati \\(N\\) takmi\u010dara, i da \u0107e takmi\u010dar \\(i\\) sedeti na mestu sa koordinatama \\((x_i, y_i)\\). Komisija smatra da je \u010detvorka u\u010denika sumnjiva ukoliko mesta na kojima sede formiraju trapez \u010dija je jedna osnovica dvostruko du\u017ea od druge. </p> <p>Da bi procenili koliko kontrolora treba postaviti na takmi\u010denje, Komisiju zanima broj sumnjivih \u010detvorki me\u0111u takmi\u010darima. Pomozite Komisiji i izra\u010dunajte ovaj broj umesto njih, a oni \u0107e vas zauzvrat nagraditi poenima (ukoliko niste prepisivali, naravno).</p> <p>Napomena: Trapez je \u010detvorougao \\(ABCD\\) u kome va\u017ei \\(AB||CD\\). Osnovice ovog trapeza su du\u017ei \\(AB\\) i \\(CD\\). \u010cetvorke sa istim skupom u\u010denika a razli\u010ditim redosledom smatramo istim \u010detvorkama i ne brojimo ih zasebno.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Milojevi\u0107 Mom\u010dilo To\u0161i\u0107 Vladimir Milenkovi\u0107 <p>Primetimo prvo da je udaljenost ta\u010daka sa koordinatama \\((x_A, y_A)\\) i \\((x_B, y_B)\\) jednaka \\(\\sqrt{(x_A-x_B)^2 + (y_B-y_A)^2}\\), a provera da li su paralelne prave odre\u0111ena ovim dvema, i ta\u010dkama \\((x_C, y_C)\\) \\((x_D, y_D)\\) je provera jednakosti koeficijenta pravca ovih prava \\(\\frac{y_A-y_B}{x_A-x_B}=\\frac{y_C-y_D}{x_C-x_D}\\), \u0161to kako bismo izbegli deljenje nulom mo\u017eemo zapisati ovako: \\((y_A-y_B)(x_C-x_D) = (x_A-x_B)(y_C-y_D)\\).</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#opis-ulaza","title":"Opis ulaza","text":"<p>Na prvoj liniji standardnog ulaza nalazi se broj takmi\u010dara \\(N\\), dok se u narednih \\(N\\) linija redom daju koordinate takmi\u010dara \\(x_i\\) i \\(y_i\\).</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#opis-izlaza","title":"Opis izlaza","text":"<p>Na prvoj i jedinoj liniji standardnog izlaza treba ispisati broj sumnjivih \u010detvorki me\u0111u takmi\u010darima.</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 1\n1 -1\n2 2\n2 -2\n</code></pre>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n0 0\n1 2\n1 1\n0 3\n-2 1\n</code></pre>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N\\leq 1500\\)</li> <li>\\(-10^8\\leq x_i\\leq 10^8\\)</li> <li> <p>\\(-10^8\\leq y_i\\leq 10^8\\)</p> </li> <li> <p>Garantuje se da nikoja dva takmi\u010dara ne\u0107e sedeti na istom mestu, to jest za \\(i\\neq j\\) va\u017ei \\((x_i, y_i)\\neq (x_j, y_j)\\), kao ni da nijedna tri takmi\u010dara ne\u0107e sedeti na mestima \u010dije koordinate predstavljaju kolinearne ta\u010dke.</p> </li> </ul> <p>Test primeri podeljeni su u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena, \\(N\\leq 4, -10\\leq x_i\\leq 10, -10\\leq y_i\\leq 10\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(N\\leq 100\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(N\\leq 400\\).</li> <li>U test primerima vrednim \\(50\\) poena, \\(N\\leq 1500\\).</li> </ul>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#slucaj-n-leq-4","title":"Slu\u010daj \\(N \\leq 4\\)","text":"<p>Ukoliko je \\(N\\) manje od 4, jasno je da nema re\u0161enja. Ukoliko je \\(N\\) ta\u010dno 4, mo\u017eemo poku\u0161ati da obele\u017eimo unete ta\u010dke sa \\(A,B,C,D\\) u svakom redosledu i da proverimo da li va\u017ei relacija data u zadatku (da su prave \\(AB\\) i \\(CD\\) paralelne i da je udaljenost izme\u0111u \\(A\\) i \\(B\\) dva puta manja od udaljenosti izme\u0111u \\(C\\) i \\(D\\) ili obratno).</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#slucaj-n-leq-100","title":"Slu\u010daj \\(N \\leq  100\\)","text":"<p>Mo\u017eemo fiksirati bilo koje 4 ta\u010dke i proveriti da li va\u017ei relacija (prvu fiksiranu ozna\u010dimo sa \\(A\\), drugu sa \\(B\\) itd).</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#slucaj-n-leq-400","title":"Slu\u010daj \\(N \\leq  400\\)","text":"<p>Mo\u017eemo primetiti da ako fiksiramo \\(A\\), \\(B\\), i \\(C\\), ta\u010dka \\(D\\) se nalazi na jedinstvenoj pravoj kroz C, i to na jedinstvenoj udaljenosti (dva puta manjoj od \\(\\overline{CD}\\)), te treba posmatrati samo 2 mogu\u0107nosti za ta\u010dku \\(D\\): ta\u010dka na toj pravoj na udaljenosti \\(\\overline{AB}/2\\) \"levo\" i \"desno\" od C. Ako dodamo te ta\u010dke u po\u010detni niz i sortiramo, svako dodatno pojavljivanje neke ta\u010dke \\(m\\) puta zna\u010di da ta ta\u010dka mo\u017ee biti na kra\u0107oj osnovici za \\(m\\) trojki, te je re\u0161enje zbir svih \\(m\\) vrednosti za sve ta\u010dke, podeljeno sa 2 (jer smo ura\u010dunali obe ta\u010dke kra\u0107e osnovice).</p>"},{"location":"takprog/2021_2022/kv1/03_prepisivaci/#svi-poeni","title":"Svi poeni","text":"<p>Ako posmatramo primer sumnjivog \u010detvorougla, mo\u017ee nam pasti na pamet da produ\u017eimo du\u017e AC i BD, i dupliramo ih (inspiracija iz \\(AB=2\\overline{CD})\\), i tada \u0107emo zbog Talesove teoreme dobiti da je uslovu zadatka ekvivalentan uslov da se te dve du\u017ei seku u istoj ta\u010dki (poku\u0161ajte da doka\u017eete, zdravo je i zabavno). Ova ta\u010dka je slika ta\u010dke A u odnosu na C i ta\u010dke B u odnosu na D. Kako je \\(N&lt;1500\\), prirodno je razmi\u0161ljati u smeru re\u0161enja s kvadratnom slo\u017eeno\u0161\u0107u, te i posmatranja svaka dva para ta\u010daka. Ukoliko za svake dve ta\u010dke \\(X,Y\\) pamtimo sve ta\u010dke koje se dobijaju kao slika X u odnosu na Y, vidimo da ta\u010dka koja se pojavljuje \\(k\\) puta odre\u0111uje \\(\\binom{k}{2}\\)=\\(\\frac{k*(k+1)}{2}\\) sumnjivih \u010detvorouglova, te za svaku upam\u0107enu ta\u010dku treba sabrati ovu vrednost. Ovo je mogu\u0107e implementirati sortiranjem slika ta\u010daka predstavljenih kao par brojeva (koordinata) i brojanjem pojavljivanja svake.</p> 03_prepisivaci.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAX_N 3005\n\nusing namespace std;\n\nstruct tacka{\n    int x, y;\n};\n\nbool comp(tacka p1, tacka p2){\n    return p1.x&lt;p2.x or (p1.x==p2.x and p1.y&lt;p2.y);\n}\n\nint N, x[MAX_N], y[MAX_N];//Podaci sa ulaza\n\nvector&lt;tacka&gt; p;//Vektor u kome ce biti smestene preslikane tacke\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin&gt;&gt;N;\n    for(int i=0; i&lt;N; ++i){\n        cin&gt;&gt;x[i]&gt;&gt;y[i];\n    }\n    //Racunanje slika tacaka pri preslikavanju preko druge tacke\n    for(int i=0; i&lt;N; ++i){\n        for(int j=0; j&lt;N; ++j){\n            if(i==j)\n                continue;\n            tacka P;\n            P.x=2*x[i]-x[j];\n            P.y=2*y[i]-y[j];\n            p.push_back(P);\n        }\n    }\n\n    sort(p.begin(), p.end(), comp);\n\n    long long total=0;//Ukupan broj sumnjivih cetvorki\n    long long d=0;//Trenutna duzina niza istih elemenata u vektoru p\n\n    int l=p.size();\n\n    for(int i=0; i&lt;l; ++i){\n        d+=1;\n        if(i==l-1 or p[i].x!=p[i+1].x or p[i].y!=p[i+1].y){\n            total+=d*(d-1)/2;\n            d=0;\n        }\n    }\n\n    cout&lt;&lt;total;\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv1/04_cenzura/","title":"4 - Cen*ura","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Sloboda govora je divna stvar, ali neke ideje su prosto previ\u0161e lo\u0161e da bi se \u0161irile! Zato je oformljena Kontrolna Organizacija \u0160tetnih Ideja (KO\u0160I), koja treba da pomogne ljudima da se \"ne zanesu\" previ\u0161e u tekstovima koje pi\u0161u. Me\u0111utim, oni nisu  ba\u0161 najsigurniji kako to da rade jo\u0161 uvek, pa su odlu\u010dili da ako ne\u0161to urade, urade jednu stvar kako treba!</p> <p>KO\u0160I je odredio najgoru re\u010d koju mogu da smisle: zabranjenu re\u010d \\(S\\) du\u017eine \\(M\\). Da niko ne mora nikad da bude izlo\u017een ovako stra\u0161noj re\u010di, odlu\u010dili su da je obri\u0161u svuda gde mogu. Pred sobom imaju tekst \\(T\\) du\u017eine \\(N\\) i cilj im je da neka slova zamene sa <code>*</code> (ASCII vrednost \\(42\\)) tako da se re\u010d \\(S\\) ne pojavljuje kao podsekvenca teksta  \\(T\\). Podse\u0107amo da je re\u010d \\(S\\) podsekvenca teksta \\(T\\) ako je mogu\u0107e obrisati neka slova iz \\(T\\) tako ostane upravo \\(S\\).</p> <p>Me\u0111utim, nije poenta ure\u0111ivanja promeniti su\u0161tinu teksta, stoga moraju da promene \u0161to manje slova u tekstu \\(T\\). Ovo im ne ide za rukom, pa su pitali vas za pomo\u0107.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2021_2022/kv1/04_cenzura/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalazi tekst \\(T\\) koji se sastoji od malih slova latinskog alfabeta. U drugom redu se nalazi zabranjena re\u010d \\(S\\) koji se sastoji od malih slova latinskog alfabeta.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom redu standardnog izlaza napisati jedan prirodan broj koji predstavlja najmanji broj slova koje treba da zamenimo sa  <code>*</code> da bi ostvarili cilj. U drugom redu standardnog izlaza ispisati ure\u0111enu verziju teksta \\(T\\) u kojoj se re\u010d \\(S\\) ne pojavljuje kao podsekvenca.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/kv1/04_cenzura/#ulaz","title":"Ulaz","text":"<pre><code>ttaakkprroogg\ntakprog\n</code></pre>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#izlaz","title":"Izlaz","text":"<pre><code>1\nttaakk*rroogg\n</code></pre>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Kada slovo <code>p</code> cenzuri\u0161emo, ono se vi\u0161e ni ne pojavljuje u tekstu, pa \\(S\\) nikako ne mo\u017ee biti podsekvenca.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 200.000\\)</li> <li>\\(1 \\leq M \\leq 10\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: zabranjena re\u010d je <code>a</code></li> <li>U test primerima vrednim \\(10\\) poena: sva slova zabranjene re\u010di su <code>a</code></li> <li>U test primerima vrednim \\(15\\) poena: zabranjena re\u010d je <code>ab</code></li> <li>U test primerima vrednim \\(15\\) poena: \\(N \\leq 5.000\\), a zabranjena re\u010d je <code>abc</code></li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#bodovanje","title":"Bodovanje","text":"<p>Mogu\u0107e je dobiti i parcijalne poene po test primeru: ako na\u0111ete pravilan najmanji broj cenzurisanih slova, ali ne i pravilnu cenzuru teksta, dobijate 80% bodova na tom primeru.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#zabranjena-rec-je-a","title":"Zabranjena re\u010d je 'a'","text":"<p>U ovom podzadatku je o\u010dito dovoljno samo cenzurisati sva pojavljivanja slova 'a', \u0161to mo\u017eemo da uradimo tako \u0161to linearno pro\u0111emo kroz \\(T\\) i na\u0111emo svuda gde se pojavljuje to slovo, zamenimo sa *, i izbrojimo koliko se puta pojavio.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#sva-slova-zabranjene-reci-su-a","title":"Sva slova zabranjene re\u010di su 'a'","text":"<p>Isto je re\u0161enje kao u prethodnom podzadatku, samo presko\u010dimo prvih \\(M-1\\) pojavljivanja slova 'a'.</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#da-li-je-jedna-rec-podsekvenca-druge","title":"Da li je jedna re\u010d podsekvenca druge?","text":"<p>Da bismo umeli da pristupimo ovom problemu potrebno je analizirati algoritam kako proveravamo da li je jedna re\u010d podsekvenca druge.  Ovo se vr\u0161i pohlepnim algoritmom. Naime, neka proveravamo da li je re\u010d \\(S\\) podsekvenca re\u010di \\(T\\). Onda prolazimo linearno kroz re\u010d \\(T\\) dok pamtimo najdu\u017ei prefiks \\(S\\) koji nam se pojavljuje do sad kao podsekvenca.  Sada, kada slede\u0107i put nai\u0111emo na slede\u0107e slovo koje bi nam trebalo da bismo pove\u0107ali du\u017einu tog najve\u0107eg prefiksa (to jest slede\u0107e slovo u \\(S\\)), znamo da nam je optimalno da  ga iskoristimo u konstrukiciji \\(S\\) kao podsekvence. To zna\u010di da u tom slu\u010daju mo\u017eemo da pove\u0107amo du\u017einu tog najdu\u017eeg prefiksa, dok on u suprotnom ostaje isti. Na kraju vidimo da li je najdu\u017ei prefiks \\(S\\) koji je podsekvenca \\(T\\) upravo ceo \\(S\\) u tom slu\u010daju je odgovor \"DA\", a u suprotnom \"NE\".</p>"},{"location":"takprog/2021_2022/kv1/04_cenzura/#puno-resenje","title":"Puno re\u0161enje","text":"<p>Sada kada smo prou\u010dili taj algoritam, mo\u017eemo da re\u0161imo ceo zadatak. Re\u0161enje \u0107emo vr\u0161iti dinami\u010dkim programiranjem, najsli\u010dnije DP re\u0161enju za najdu\u017eu zajedni\u010dku podsekvencu dve niske. Naime neka je \\(DP[n][k]\\) vrednost \"koliko najmanje karaktera treba cenzurisati u prvih \\(n\\) slova \\(T\\) da bi najdu\u017ei prefiks \\(S\\) koji je podsekvenca tih prvih \\(n\\) karaktera du\u017eine ta\u010dno \\(k\\)\". Sada ove vrednosti u dinami\u010dkom programiranju se lako ra\u010dunaju: ako ne \u017eelimo da pove\u0107amo vrednost \\(k\\), onda kad nai\u0111emo na slovo koje bi nam ga pove\u0107alo, moramo da cenzuri\u0161emo, a u suprotnom samo pove\u0107amo vrednost \\(k\\). Kako stanja ima \\(MN\\) i svako ima konstantno prelaza, dobijamo ukupno vremensku i memorijsku slo\u017eenost \\(O(MN)\\). </p> 04_cenzura.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint dp[200007][15];\npair&lt;int,int&gt; prv[200007][15];\nint main()\n{\n    string a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    int n=a.size(),m=b.size();\n    for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)\n    {\n        dp[i+1][j]=dp[i][j]+((a[i]==b[j])?1:0); prv[i+1][j]={i,j};\n        if(a[i]==b[j] &amp;&amp; j &amp;&amp; dp[i+1][j]&gt;dp[i][j-1]) {dp[i+1][j]=dp[i][j-1]; prv[i+1][j]={i,j-1};}\n        if(j &amp;&amp; dp[i+1][j-1]&lt;dp[i+1][j]) {dp[i+1][j]=dp[i+1][j-1]; prv[i+1][j]={i+1,j-1};}\n    }\n    int sol=n,nd=0;\n    for(int i=0;i&lt;m;i++) if(dp[n][i]&lt;sol) {sol=dp[n][i]; nd=i;}\n    pair&lt;int,int&gt; p=make_pair(n,nd);\n    while(true)\n    {\n        if(p.first==0) break;\n        pair&lt;int,int&gt; pr=prv[p.first][p.second];\n        if(pr.second==p.second &amp;&amp; a[pr.first]==b[p.second]) a[pr.first]='*';\n        p=pr;\n    }\n    cout&lt;&lt;sol&lt;&lt;endl&lt;&lt;a;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/","title":"5 - No\u0107na vo\u017enja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 4000ms 256MB <p>U zemlji Bajtoviji nalazi se \\(N\\) naselja, ozna\u010denih razli\u010ditim celim brojevima od \\(1\\) do \\(N\\). Postoji \\(N-1\\) puteva izme\u0111u nekih naselja, tako da je mogu\u0107e sti\u0107i od bilo kog naselja do bilo kog drugog koriste\u0107i te puteve (tj. Bajtovija je oblika stabla). Rastojanje dva naselja je du\u017eina najkra\u0107eg puta izme\u0111u ta dva naselja.</p> <p>U bazi podataka Javnog Komunalnog Preduze\u0107a Putevi Bajtovije sva naselja nalaze se pore\u0111ano nekim redosledom \\(p_i\\) (ozna\u010dava da je \\(i\\)-to naselje u redu naselje \\(p_i\\)).</p> <p>U jednom trenutku krenule su da se de\u0161avaju \u010dudne stvari u dva oblika:</p> <ul> <li>\\(1\\) \\(a\\) \\(b\\), administratori baza podataka zamenili su u redosledu \\(p_a\\) i \\(p_b\\).</li> <li>\\(2\\) \\(l\\) \\(r\\) \\(x\\), hakeri su upali u sistem i ucenjuju administratore. Tra\u017ee im odgovor na pitanje: koliko je daleko naselje \\(x\\) od najdaljeg od naselja \\(p_l, p_{l+1}, \\ldots, p_r\\). </li> </ul> <p>Administratori baza podataka Javnog Komunalnog Preduze\u0107a Putevi Bajtovije vas mole za pomo\u0107 da odgovorite na pitanja hakera. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 i Pavle Martinovi\u0107 Tadija \u0160ebez Tadija \u0160ebez"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\) - broj naselja. U drugom redu nalazi se \\(N\\) celih brojeva, redosled naselja na spisku. Narednih \\(N-1\\) redova sadr\u017ee dva broja \\(u\\) i \\(v\\), ozna\u010davaju\u0107i da postoji put izme\u0111u naselja numerisanih \\(u\\) i \\(v\\). </p> <p>Naredni red sadr\u017ei prirodni broj \\(Q\\), broj doga\u0111aja. Svaka od narednih \\(Q\\) linija sadr\u017ei ili \\(1\\) \\(a\\) \\(b\\) - ozna\u010davaju\u0107i doga\u0111aj prvog tipa - ili \\(2\\) \\(l\\) \\(r\\) \\(x\\) - ozna\u010davaju\u0107i doga\u0111aj drugog tipa. </p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki doga\u0111aj drugog tipa potrebno je ispisati u zasebnom redu standardnog izlaza odgovor na pitanje ucenjiva\u010da.</p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#ulaz","title":"Ulaz","text":"<pre><code>5\n5 4 1 2 3\n1 2\n2 3\n1 4\n2 5\n5\n2 3 4 5\n1 3 5\n2 3 4 5\n1 2 4\n2 3 4 5\n</code></pre>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#izlaz","title":"Izlaz","text":"<pre><code>2\n2\n3\n</code></pre>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Prvi doga\u0111aj: najdalje naselje od naselja \\(5\\) na datom intervalu je naselje \\(1\\), na rastojanju \\(2\\).</p> <p>Drugi doga\u0111aj: zamena pozicije naselja \\(1\\) i \\(3\\).</p> <p>Tre\u0107i doga\u0111aj: najdalje naselje od naselja \\(5\\) na datom intervalu je naselje \\(3\\), na rastojanju \\(2\\).</p> <p>\u010cetvrti doga\u0111aj:  zamena pozicije naselja \\(4\\) i \\(2\\). </p> <p>Peti doga\u0111aj: najdalje naselje od naselja \\(5\\) na datom intervalu je naselje \\(4\\), na rastojanju \\(3\\).</p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 80.000\\)</li> <li>\\(1 \\leq p_i \\leq N\\) i \\(p_i \\neq p_j\\) za \\(i \\neq j\\)</li> <li>\\(1 \\leq a, b, x, u, v \\leq N\\) i \\(a \\neq b\\)</li> <li>\\(1 \\leq l \\leq r \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N, Q \\leq 4000\\).</li> <li>U test primerima vrednim \\(15\\) poena: Svako naselje je susedno sa najvi\u0161e dva druga naselja.</li> <li>U test primerima vrednim \\(25\\) poena: U svakom doga\u0111aju va\u017ei\u0107e \\(x = 1\\) i \\(p_a, p_b \\neq 1\\) </li> <li>U test primerima vrednim \\(25\\) poena: Nema doga\u0111aja oblika \\(1\\).</li> <li>U test primerima vrednim \\(25\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#podzadatak-kada-je-n-q-leq-4000","title":"Podzadatak kada je \\(N, Q \\leq 4000\\)","text":"<p>Mo\u017eemo da odr\u017eavamo trenutni redosled naselja u nizu. Operacija zamene se svodi na jednostavno zamenjivanje dva \u010dlana niza, dok je odgovaranje na drugi tip doga\u0111aja malo komplikovanije. Mo\u017eemo da pustimo DFS ili BFS algoritam iz naselja \\(x\\) kako bismo na\u0161li udaljenosti od istog do svakog drugog naselja. Nakon \u0161to smo na\u0161li i sa\u010duvali udaljenosti mo\u017eemo da pro\u0111emo kroz deo niza od \\(l\\) do \\(r\\) i na\u0111emo najve\u0107u udaljenost. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(QN)\\).</p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#podzadatak-kada-je-svako-naselje-susedno-sa-najvise-dva-druga-naselja","title":"Podzadatak kada je svako naselje susedno sa najvi\u0161e dva druga naselja","text":"<p>U ovom slu\u010daju naselja zapravo formiraju lanac i mo\u017eemo da ih pore\u0111amo u niz po\u010dev\u0161i od jednog kraja. Za svako naselje zapamtimo njegovu poziciju u ovom nizu. Kada tra\u017eimo najve\u0107u udaljenost od naselja \\(x\\) do skupa naselja od \\(l\\) do \\(r\\) bitna su nam samo dva naselja iz tog skupa, naselje sa najmanjom i naselje sa najve\u0107om pozicijom (udaljeno\u0161\u0107u od kraja lanca). Ovo mo\u017eemo efikasno da implementiramo kori\u0161\u0107enjem neke strukture podataka koja podr\u017eava upite za minimum/maksimum na podnizu i promenu \u010dlana niza. Na primer mo\u017eemo da koristimo segmentno stablo i dobijemo vremensku slo\u017eenost \\(O(N + QlogN)\\).</p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#podzadatak-kada-je-u-svakom-dogaaju-x-1-i-p_a-p_b-neq-1","title":"Podzadatak kada je u svakom doga\u0111aju \\(x = 1\\) i \\(p_a, p_b \\neq 1\\)","text":"<p>Kako se u svakom pitanju tra\u017ei najve\u0107a udaljenost od naselja 1, na po\u010detku pustimo DFS ili BFS algoritam iz ovog naselja i na\u0111imo uzaljenosti do svakog drugog naselja. \u010cuvajmo niz gde je \\(i\\)-ti \u010dlan udaljenost od naselja 1 do naselja \\(p_i\\). Pitanja se svode na tra\u017eenje maksimuma na podnizu ovog niza. Mo\u017eemo i ovde da iskoristimo segmentno stablo za efikasne operacije tra\u017eenja maksimuma i promene u nizu nakon doga\u0111aja prvog tipa. Vremensa slo\u017eenost je \\(O(N + QlogN)\\).</p>"},{"location":"takprog/2021_2022/kv1/05_nocna_voznja/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Sli\u010dno kao kod re\u0161enja za lanac za svako pitanje mo\u017eemo da na\u0111emo dva naselja od kojih \u0107e uvek jedno biti najdalje bez obzira na odabir naselja \\(x\\). Za ovo re\u0161enje treba nam malo teorije vezane za stabla. Pre\u010dnik stabla je najve\u0107a udaljenost izme\u0111u dva \u010dvora, a krajevi pre\u010dnika su \u010dvorovi koji su na toj najve\u0107oj udaljenosti. Korisna osobina pre\u010dnika stabla je to da je najdalji \u010dvor od proizvoljnog \u010dvora uvek jedan od krajeva pre\u010dnika. Naselja koja \u0107emo tra\u017eiti su krajevi pre\u010dnika podstabla koje obuhvata naselja \\(p_l, p_{l+1}, \\dots, p_r\\). I u ovom re\u0161enju mo\u017eemo koristiti segmentno stablo. Za svaki segment \u010duvajmo krajeve pre\u010dnika, a pre\u010dnik za dva spojena segmenta tra\u017eimo tako \u0161to na\u0111emo najve\u0107u udaljenost izme\u0111u 2 od 4 \u010dvora koji su krajevi pre\u010dnika levog i desnog segmenta. Ostaje jo\u0161 da na\u0111emo na\u010din kako efikasno da na\u0111emo udaljenost izme\u0111u dva \u010dvora. Mo\u017eemo da postavimo \u010dvor 1 kao koren i izra\u010dunamo dubinu svakog \u010dvora \\(depth(x)\\). Distanca izme\u0111u dva \u010dvora \\(x\\) i \\(y\\) je \\(depth(x) + depth(y) - 2 depth(LCA(x, y))\\), gde je \\(LCA(x, y)\\) najmanji zajedni\u010dki predak \u010dvorova \\(x\\) i \\(y\\), odnosno \u010dvor na kom se put od \\(x\\) do korena i put od \\(y\\) do korena sre\u0107u. Najmanji zajedni\u010dki predak mo\u017ee se na\u0107i u \\(O(logN)\\) sa binary lifting tehnikom ili u \\(O(1)\\) sa sparse tabelom nad Ojlerovim putem. Preprocesiranje za obe opcije je vremenske i memorijeske slo\u017eenosti \\(O(NlogN)\\), a celo re\u0161enje vermenske slo\u017eenosti \\(O(NlogN + Q log^2 N)\\) ili \\(O(NlogN + QlogN)\\) u zavisnosti od odabrane tehnike.</p> 05_nocna_voznja.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 80007\n#define MAXL 17\nusing namespace std;\nint d[MAXN],p[MAXL][MAXN],t,in[MAXN],out[MAXN],n,per[MAXN];\nvector&lt;int&gt; g[MAXN];\nvoid dfs(int s,int f,int dub)\n{\n    d[s]=dub;\n    p[0][s]=f;\n    in[s]=t++;\n    for(int i=0;i&lt;g[s].size();i++) if(g[s][i]!=f) dfs(g[s][i],s,dub+1);\n    out[s]=t++;\n}\nvoid lcainit()\n{\n    dfs(1,1,0);\n    for(int j=1;j&lt;MAXL;j++) for(int i=1;i&lt;=n;i++) p[j][i]=p[j-1][p[j-1][i]];\n}\nbool insub(int u,int v) {return in[u]&lt;=in[v] &amp;&amp; out[u]&gt;=out[v];}\nint lca(int u,int v)\n{\n    if(insub(u,v)) return u;\n    if(insub(v,u)) return v;\n    for(int i=MAXL-1;i&gt;=0;i--) if(!insub(p[i][u],v)) u=p[i][u];\n    return p[0][u];\n}\nint dist(int u,int v) {return d[u]+d[v]-2*d[lca(u,v)];}\npair&lt;int,int&gt; mojmax(pair&lt;int,int&gt; a, pair&lt;int,int&gt; b)\n{\n    if(dist(a.first,a.second)&lt;dist(b.first,b.second)) return b;\n    return a;\n}\npair&lt;int,int&gt; sga(int a,int b,int c,int d)\n{\n    if(a==-1) return {c,d};\n    if(c==-1) return {a,b};\n    pair&lt;int,int&gt; res={a,b};\n    res=mojmax(res,{a,c});\n    res=mojmax(res,{a,d});\n    res=mojmax(res,{b,c});\n    res=mojmax(res,{b,d});\n    res=mojmax(res,{c,d});\n    return res;\n}\npair&lt;int,int&gt; seg[4*MAXN];\nvoid upd(int l,int r,int v,int w,int ind)\n{\n    if(l==r) {seg[ind]={v,v}; return;}\n    int s=(l+r)/2;\n    if(w&lt;=s) upd(l,s,v,w,2*ind);\n    else upd(s+1,r,v,w,2*ind+1);\n    pair&lt;int,int&gt; lv=seg[2*ind],ds=seg[2*ind+1];\n    seg[ind]=sga(lv.first,lv.second,ds.first,ds.second);\n}\npair&lt;int,int&gt; mp(int l,int r,int lt,int rt,int ind)\n{\n    if(l&gt;=lt &amp;&amp; r&lt;=rt) return seg[ind];\n    if(r&lt;lt || l&gt;rt) return {-1,-1};\n    int s=(l+r)/2;\n    pair&lt;int,int&gt; lv=mp(l,s,lt,rt,2*ind),ds=mp(s+1,r,lt,rt,2*ind+1);\n    return sga(lv.first,lv.second,ds.first,ds.second);\n}\nint main()\n{\n    int q;\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;per[i]);\n    for(int i=1;i&lt;n;i++)\n    {\n        int t1,t2;\n        scanf(\"%d%d\",&amp;t1,&amp;t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    lcainit();\n    for(int i=1;i&lt;=n;i++) upd(1,n,per[i],i,1);\n    scanf(\"%d\",&amp;q);\n    while(q--)\n    {\n        int type;\n        scanf(\"%d\",&amp;type);\n        if(type==1)\n        {\n            int x,y;\n            scanf(\"%d%d\",&amp;x,&amp;y);\n            swap(per[x],per[y]);\n            upd(1,n,per[x],x,1);\n            upd(1,n,per[y],y,1);\n        }\n        else\n        {\n            int l,r,x;\n            scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;x);\n            pair&lt;int,int&gt; p=mp(1,n,l,r,1);\n            printf(\"%d\\n\",max(dist(x,p.first),dist(x,p.second)));\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/","title":"1 - Ma\u0111ioni\u010dar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Saznali ste da su vam drugari kupili knjigu ma\u0111ioni\u010darskih trikova kao novogodi\u0161nji poklon. Me\u0111utim, zbog ovog saznanja, krenuli ste da nestrpljivo i\u0161\u010dekujete po\u010detak va\u0161e budu\u0107e karijere  ma\u0111ioni\u010dara. Toliko ste nestrpljivi, da ste odlu\u010dili da ne mo\u017eete sa\u010dekati Novu godinu, pa ste izmislili svoj ma\u0111ioni\u010darski trik!</p> <p>Na raspolaganju imate \u0161pil od \\(N\\) karata, gde na svakoj karti pi\u0161e po jedan broj od \\(1\\) do \\(N\\). Na svakoj karti napisan je razli\u010dit broj. Kao prvi korak trika uze\u0107ete taj \u0161pil i prome\u0161ati ga na takav na\u010din da ta\u010dno znate kojim redosledom idu karte u \u0161pilu. Zatim \u0107ete pozvati iz publike jednog gledaoca, koji \u0107e vam pomo\u0107i u izvo\u0111enju va\u0161eg trika. Prvo \u0107ete mu dati mogu\u0107nost da prese\u010de \u0161pil: uzme nekoliko karata sa vrha i stavi ih na dno u istom poretku. Primetiti da on ne mora da prese\u010de \u0161pil ukoliko to ne \u017eeli. Dalje, taj gledalac \u0107e uzeti neku kartu iz \u0161pila, ali ne onu sa vrhu \u0161pila, i zatim \u0107ete lupiti petama tri puta, uraditi kolut unapred, pokloniti se i najaviti publici da ste otkrili koju je kartu uzeo gledalac! Kada, posle toga, pogodite njegovu kartu svi \u0107e biti odu\u0161evljeni va\u0161om magijom.</p> <p>Ono \u0161to publika ne zna je da kada je gledalac izvla\u010dio kartu iz \u0161pila, vi ste virnuli i videli kartu \\(K\\) koja se nalazila direktno iznad nje u \u0161pilu i na osnovu nje pogodili izvu\u010denu kartu. Kako niste jo\u0161 sigurni u va\u0161e izvr\u0161avanje ovog trika, \u017eelite da proverite da radi na ra\u010dunaru.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva pozitivna cela broja \\(N\\) i \\(K\\): broj karata u \u0161pilu i broj na karti iznad izvu\u010dene karte.</p> <p>U drugom redu standardnog ulaza, nalaze se \\(N\\) pozitivnih celih brojeva, \\(i\\)-ti od njih je \\(p_i\\) i on predstavlja broj napisan na \\(i\\)-toj karti sa vrha \u0161pila.</p>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza treba ispisati jedan pozitivan ceo broj, koji predstavlja broj na karti koju je izvukao gledalac.</p>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv2/01_madjionicar/#ulaz","title":"Ulaz","text":"<pre><code>2 2\n2 1\n</code></pre>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Videli ste kartu sa brojem \\(2\\), \u0161to zna\u010di da on mora da je izvukao kartu sa brojem \\(1\\), \u0161to i uspe\u0161no pogodite.</p>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv2/01_madjionicar/#ulaz_1","title":"Ulaz","text":"<pre><code>5 3\n5 4 1 2 3\n</code></pre>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Kako god gledalac prese\u010de \u0161pil, karta sa brojem \\(3\\) \u0107e se nalaziti iznad karte sa brojem \\(5\\). Na primer: ako uzme \\(3\\) karte sa vrha (karte \\(5,4,1\\)) i stavi ih na dno u istom poretku, onda \u0107e \u0161pil sa vrha na dole biti \\(2,3,5,4,1\\), stoga je karta koja je ispod karte sa brojem \\(3\\) upravo karta sa brojem \\(5\\). Primetite da ovde nije mogu\u0107e da gledalac nije presekao \u0161pil, jer u tom slu\u010daju niste mogli da vidite broj \\(3\\) iznad izvu\u010dene karte.</p>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 20.000\\)</li> <li>\\(1\\leq K \\leq N\\)</li> <li>\\(1 \\leq p_i \\leq N\\), za svako \\(1 \\leq i \\leq N\\)</li> <li>\\(p_i\\neq p_j\\) za sve \\(1\\leq i &lt; j\\leq N\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(15\\) poena: \\(N=2\\).</li> <li>U test primerima vrednim \\(20\\) poena: va\u017ei \\(p_i=i\\) za svako \\(1\\leq i\\leq N\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(N=5\\).</li> <li>U test primerima vrednim \\(45\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv2/01_madjionicar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Po\u0161to je u zadatku poznata karta (odnosno njena vrednost \\(K\\)) koja se nalazi direktno iznad tra\u017eene karte, ako se \u0161pil karata posmatra kao niz pozitivnih celobrojnih vrednosti, to \u0107e drugim re\u010dima zna\u010diti, da je postavkom zadatka data vrednost u nizu pod indeksom za jedan manjim u odnosu na indeks zahtevane vrednosti. Stoga je u prvom koraku potrebno prona\u0107i indeks \\(i\\) u nizu pod kojim je zapisana data vrednost \\(K\\), a zatim u narednim koraku ispisati vrednost pod indeksom \\(i+1\\). Kako bi se osvojili svi poeni, neophodno je obratiti pa\u017enju na jedan specijalan slu\u010daj, koji je obja\u0161njen u drugom javnom primeru u postavci zadatka, a to je kada je \\(i=N\\). U ovom slu\u010daju indeks tra\u017eene karte nije \\(i+1\\), odnosno \\(N+1\\), iz razloga \u0161to on ne postoji, ve\u0107 je to prva karta u \u0161pilu, odnosno vrednost pod indeksom \\(i=1\\), uz pretpostavku da indekse ra\u010dunamo po\u010dev\u0161i od jedinice, a ne od nule. Elegantan na\u010din da se pokrije ovaj izuzetak jeste uzeti \\(i+1\\) i prona\u0107i ostatak pri deljenju sa \\(N\\), to jest indeks tra\u017eene vrednosti \u0107e biti \\((i+1) \\mod N\\) i sve \u0161to treba uraditi u zadatku nakon u\u010ditavanja odgovaraju\u0107ih podataka je ispis vrednosti pod pomenutim indeksom.</p> <p>Kako se u najgorem slu\u010daju vrednost niza \\(K\\) mo\u017ee nalaziti pod indeksom \\(N\\), neophodno je u gore opisanom prvom koraku pro\u0107i kroz \u010ditav niz da bi se to utvrdilo, pa je asimptotska vremenska slo\u017eenost algoritma \\(\\mathcal{O}(N)\\), odnosno linearna po du\u017eini niza.</p> 01_madjionicar.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 20007\nusing namespace std;\nint p[MAXN];\nint main()\n{\n    int n,k;\n    cin&gt;&gt;n&gt;&gt;k;\n    for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i];\n    for(int i=0;i&lt;n;i++) if(p[i]==k) printf(\"%d\",p[(i+1)%n]);\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/","title":"2 - Ekskurzija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 256MB <p>Nakon uspe\u0161no zavr\u0161enog prvog kruga kvalifikacija, profesor Guki je odlu\u010dio da odvede svoje u\u010denike na ekskurziju. Iako je spremio ogromnu koli\u010dinu krem bananica i izabrao premijum destinaciju, Denino brdo, njegovi u\u010denici nisu ba\u0161 najsre\u0107niji! Oni smatraju da bi mnogo korisnije bilo da ulo\u017ee dodatno vreme u ve\u017ebanje zadataka sa Petlje i poprave svoj skor na bar 490 poena u drugom krugu kvalifikacija. Me\u0111utim, kako znaju da profesoru mnogo zna\u010di poseta Deninom brdu (\u010dak je spremio i te krem bananice), odlu\u010dili su da mu pru\u017ee priliku i postave jedan sitan uslov za svoj polazak.</p> <p>U\u010denici \u0107e po\u0107i na ekskurziju ako je mogu\u0107e raspodeliti ih u ta\u010dno \\(K\\) nepraznih grupa, tako da svaki u\u010denik pripada ta\u010dno jednoj grupi i svi u\u010denici u okviru jedne grupe dobiju razli\u010dit ceo pozitivan broj krem bananica.</p> <p>Pomozite Gukiju da sazna da li ima potrebe da pakuje krem baninice, ili nema dovoljnu koli\u010dinu za sve u\u010denike (u tom slu\u010daju \u0107e morati sam da ih pojede).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Dragan Uro\u0161evi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei pozitivan ceo broj \\(T\\), broj razli\u010ditih testova.</p> <p>Svaka od narednih \\(T\\) linija sadr\u017ei po tri cela pozitivna broja, \\(N\\), \\(M\\), \\(K\\) - broj u\u010denika, broj krem baninica koje je profesor spremio i zahtevani broj grupa.</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#opis-izlaza","title":"Opis izlaza","text":"<p>U svakoj od \\(T\\) linija standardnog izlaza ispisati \"Tak\" (bez navodnika) ako \u0107e za zadate parametre ekskurzija biti odr\u017eana, u suprotnom ispisati \"Nie\" (bez navodnika).</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#ulaz","title":"Ulaz","text":"<pre><code>2\n5 100 2\n2 2 1\n</code></pre>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#izlaz","title":"Izlaz","text":"<pre><code>Tak\nNie\n</code></pre>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvom testu mogu\u0107e je podeliti studente u dve grupe, na primer jednu veli\u010dine \\(4\\) i drugu veli\u010dine \\(1\\). U prvoj grupi u\u010denici bi dobili redom \\(10, 15, 20\\) i \\(35\\) krem bananica. U\u010denik iz druge grupe bi u tom slu\u010daju dobio preostalih \\(20\\) krem bananica.</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\)</li> <li>\\(1 \\leq N \\leq 10^9\\)</li> <li>\\(1 \\leq M \\leq 10^{17}\\)</li> <li>\\(1 \\leq K \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 10 poena: \\(N = 3\\).</li> <li>U testovima vrednim 10 poena: \\(K = 1\\).</li> <li>U testovima vrednim 20 poena: \\(N, M \\leq 10\\).</li> <li>U testovima vrednim 30 poena: \\(N \\leq 2000\\).</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#resenje-kad-n-3","title":"Re\u0161enje kad \\(N = 3\\)","text":"<p>U ovom slu\u010daju, broj grupa ne mo\u017ee biti ve\u0107i od \\(3\\). Prema tome, potrebno je samo odrediti minimalni broj bananica za sve tri vrednosti za broj grupa. Ako je \\(K=1\\), onda u toj grupi ima 3 u\u010denika, minimalni broj bananica je \\(1+2+3=6\\). Ako je  \\(K=2\\), onda u jednoj grupi moraju biti dva u\u010denika (i minimalan broj bananica je \\(1+2=3\\)), a u drugoj grupi 1 u\u010denik (i minimalan broj bananica je \\(1\\)), pa je ukupan minimalan broj bananica \\(4\\). Ako je \\(K=3\\), onda je u svakoj grupi \\(1\\) u\u010denik, pa je ukupan minimalan broj bananica \\(3\\).</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#resenje-kad-k-1","title":"Re\u0161enje kad \\(K = 1\\)","text":"<p>U ovom slu\u010daju, svi u\u010denici su u istoj grupi i minimalan broj bananica je $$ 1+2+3+\\dotsb + N = \\frac{N\\cdot(N+1)}{2}. $$ Potrebno je voditi ra\u010duna da poslednji proizvod mo\u017ee biti vrlo veliki broj.</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#resenje-kad-n-m-leq-10","title":"Re\u0161enje kad \\(N, M \\leq 10\\)","text":"<p>U ovom slu\u010daju, do re\u0161enja se mo\u017ee do\u0107i primenom pretrage sa vra\u0107anjem (bektrek).</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#resenje-kad-n-leq-2000","title":"Re\u0161enje kad \\(N \\leq 2000\\)","text":"<p>U ovom slu\u010daju se primenjuje glavno re\u0161enje u kojem ne primetimo sve formule, ve\u0107 primenjujemo neke manje efikasne metode (npr. prolazak kroz sve grupe).</p>"},{"location":"takprog/2021_2022/kv2/02_ekskurzija/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Potrebno je primetiti da grupe treba da budu pribli\u017eno jednake veli\u010dine. Naime, ako je \\(c_1\\) broj u\u010denika u jednoj grupi, \\(c_2\\) broj u\u010denika u drugoj grupi i pri tome va\u017ei \\(c_2 \\geq c_1 + 2\\), onda je minimalni broj bananica za te dve grupe $$ B_1 = \\frac{c_1\\cdot(c_1+1)}{2} + \\frac{c_2\\cdot (c_2+1)}{2} = \\frac{c_1^2+c_2^2+c_1+c_2}{2}. $$ Ako jednog u\u010denika prebacimo iz druge grupe u prvu grupu, onda je minimalni broj bananica u te dve grupe  $$ B_2 = \\frac{(c_1+1)\\cdot(c_1+2)}{2} + \\frac{(c_2-1)\\cdot c_2}{2} = \\frac{c_1^2+c_2^2+3c_1-c_2+2}{2}. $$ Razlika dva poslednja broja je $$ B_1 - B_2 = \\frac{2c_2 - 2c_1 - 2}{2} = c_2 - c_1 -1 &gt; 0, $$ tj. minimalan broj bananica se smanjio.</p> <p>Prema tome, sve grupe treba da imaju pribli\u017eno jednako elemenata. Ako je broj u\u010denika deljiv brojem grupa, onda bi svaka grupa imala \\(N/K\\) u\u010denika. Ako broj u\u010denika nije deljiv brojem grupa onda \u0107e jedan deo grupa imati \\(N_1 = \\lfloor N/K \\rfloor\\),  a drugi deo grupa \\(N_2 = N_1 + 1\\). Broj grupa \\(K_2\\) koje imaju \\(N_2\\) u\u010denika je $$ K_2 = N - K \\cdot \\lfloor N/K\\rfloor = N \\text{ mod } K, $$ gde je \\(N \\text{ mod } K\\) ostatak pri deljenju broja \\(N\\) brojem \\(K\\). Kona\u010dno, minimalan ukupan broj bananica je $$ (K-K_2) \\cdot \\frac{N_1\\cdot (N_1+1)}{2} + K_2 \\cdot \\frac{N_2\\cdot (N_2+1)}{2}. $$</p> <p>Slo\u017eenost algoritma je \\(O(1)\\).</p> 02_ekskurzija.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n\nconst int maxN = 1000000000;\nconst long long maxM = 100000000000000000;\nint t;\nlong long n, m, k;\n\nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    assert(n &gt; 0 &amp;&amp; n &lt;= maxN);\n    assert(m &gt; 0 &amp;&amp; m &lt;= maxM);\n    assert(k &gt; 0 &amp;&amp; k &lt;= n);\n\n    long long velicinaGrupe = n / k;\n    long long potrebneBannice = velicinaGrupe * (velicinaGrupe + 1) / 2 * k + (velicinaGrupe + 1) * (n % k);\n\n    if (potrebneBannice &lt;= m) {\n        cout &lt;&lt; \"Tak\" &lt;&lt; endl;\n    } else {\n        cout&lt;&lt; \"Nie\" &lt;&lt; endl;\n    }\n}\n\nint main() {\n\n    cin &gt;&gt; t;\n\n    assert(t &gt;0 &amp;&amp; t&lt;=10);\n\n    while(t--) {\n        solve();\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/","title":"3 - Palindrom \u0161afl","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Ve\u0107ina ljubitelja ko\u0161arke je \u010dula za novi potez na ko\u0161arka\u0161kim terenima, takozvani Sombor \u0161afl. Zato je Komisija odlu\u010dila da uvede novi potez u svet programiranja, Palindrom \u0161afl. Palindrom \u0161afl je potez u kom izaberete nepraznu podnisku uzastopnih slova u niski \\(T\\) i ispreme\u0161tate slova u toj podniski tako da cela niska postane palindrom. Raspored slova van te podniske ostaje nepromenjen.</p> <p>U ovom zadatku data je niska \\(T\\) i potrebno je da odgovorite na pitanje koja je minimalna du\u017eina podniske koju mo\u017eete izabrati tako da uspe\u0161no izvr\u0161ite Palindrom \u0161afl.</p> <p>Podse\u0107amo vas da za nisku \\(T\\) ka\u017eemo da je palindrom ako se \u010dita isto s leve i desne strane.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Lazar Milenkovi\u0107 Aleksa Milisavljevi\u0107 <p>Sa \\(N\\) \u0107emo ozna\u010diti du\u017einu date niske, sa \\(\\Sigma\\) broj karaktera u alfabetu, u na\u0161em slu\u010daju \\(26\\).</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#opis-ulaza","title":"Opis ulaza","text":"<p>U jedinom redu standardnog ulaza nalazi se niska \\(T\\), koja se sastoji isklju\u010divo od malih slova engleskog alfabeta.</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati ceo broj koji predstavlja minimalnu du\u017einu podniske na kojoj mo\u017ee da se izvr\u0161i Palindrom \u0161afl. Garantuje se da je niska takva da uvek postoji bar jedna odgovaraju\u0107a podniska za Palindrom \u0161afl.</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#ulaz","title":"Ulaz","text":"<pre><code>abbaaca\n</code></pre>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Najkra\u0107a podniska uzastopnih slova koju mo\u017eemo izabrati za \u0161afl je od 3. do 6. karaktera. Tada nisku mo\u017eemo promeniti u \\(abacaba\\).</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#ulaz_1","title":"Ulaz","text":"<pre><code>abcba\n</code></pre>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Niska \\(T\\) sa ulaza je palindrom, najkra\u0107a neprazna podniska za \u0161afl je du\u017eine \\(1\\).</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Du\u017eina niske \\(T\\) je makar \\(1\\), a najvi\u0161e \\(2\\cdot 10^5\\).</li> <li>Sva slova u niski \\(T\\) su mala slova engleskog alfabeta.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 15 poena: Niska \\(T\\) sadr\u017ei ta\u010dno dva slova \\(b\\) i ostala slova su \\(a\\).</li> <li>U testovima vrednim 20 poena: Du\u017eina niske \\(T\\) nije ve\u0107a od \\(50\\).</li> <li>U testovima vrednim 25 poena: Du\u017eina niske \\(T\\) nije ve\u0107a od \\(3000\\).</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#resenje-kada-su-dva-slova-b-a-ostala-a","title":"Re\u0161enje kada su dva slova 'b', a ostala \u2018a\u2019","text":"<p>Optimalno re\u0161enje u ovom slu\u010daju je ili pomeriti oba slova na dva centralna polja ili pomeriti jedno slovo na poziciju simetri\u010dnu poziciji drugog slova.</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#resenje-kada-n-leq-50","title":"Re\u0161enje kada \\(N \\leq 50\\)","text":"<p>Zadatak mo\u017eemo re\u0161iti tako \u0161to pretpostavimo levu i desnu granicu optimalne podniske, \\(i\\) i \\(j\\), respektivno (broj mogu\u0107nosti je \\(\\Theta(N^2)\\)). Za svaku mogu\u0107nost \\((i,j)\\), u linearnom vremenu proverimo da li je mogu\u0107e izvr\u0161iti \u0161afl tako da je rezultuju\u0107a niska palindrom. Posmatramo interval \\([i,j]\\) i simetri\u010dni interval \\([n-j+1, n-i+1]\\). Ukoliko izvan ova dva intervala, ulazna niska nije palindromska, tada je nemogu\u0107e promeniti bilo \u0161ta u \\([i,j]\\) tako da re\u0161enje postane palindrom. Drugim re\u010dima, pretpostavka \\([i,j]\\) nije validna. U suprotnom, kada interval \\([i,j]\\) ne sadr\u017ei sredinu niske, dovoljno je proveriti da za svako slovo va\u017ei da je njegova u\u010destanost u \\([i,j]\\) ista kao i njegova u\u010destanost u \\([N-j+1, N-i+1]\\). Kada \\([i,j]\\) sadr\u017ei sredinu niske, provera je sli\u010dna, samo u obzir treba uzeti i preklapanja intervala \\([i,j]\\) i \\([N-j+1, N-i+1]\\).</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#resenje-kada-n-leq-3000","title":"Re\u0161enje kada \\(N \\leq 3000\\)","text":"<p>Prethodna ideja se mo\u017ee ubrzati ako primetimo da kada fiksiramo dva kraja proveru mo\u017eemo izvr\u0161iti u vremenskoj slo\u017eenosti \\(O(\\Sigma)\\).</p>"},{"location":"takprog/2021_2022/kv2/03_palindrom_safl/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Posmatrajmo najpre najve\u0107i broj \\(l\\), takav da je prefiks niske du\u017eine \\(l\\) jednak sufiksu du\u017eine \\(l\\) u obrnutom redosledu. Optimalno re\u0161enje nikada ne\u0107e sadr\u017eati prvih \\(l\\) i poslednjih \\(l\\) slova niske. Najpre \u0107emo proveriti da li je mogu\u0107e izvr\u0161iti \u0161afl na samo levoj polovini niske. To proveravamo tako \u0161to tra\u017eimo najmanji indeks \\(i_1 \\le |T|/2\\) takav da za svako slovo va\u017ei da je njegova u\u010destanost u intervalu \\([l+1,i_1]\\) ista kao i njegova u\u010destanost u intervalu \\([N-i_1+1, N-l]\\) i da je ulazna niska palindrom u intervalu \\([i_1, N-i_1]\\). Ukoliko takav indeks postoji kandidat za re\u0161enje je interval \\([l,i_1]\\).</p> <p>U nastavku \u0107emo pretpostaviti da optimalno re\u0161enje sadr\u017ei sredi\u0161nji deo niske i po\u010dinje od indeksa \\(l+1\\). (Po\u0161to su po definiciji vrednosti \\(l\\) slova u nisci na pozicijama \\(l+1\\) i \\(N-l\\) razli\u010dita, optimalna podniska mora uvek sadr\u017eati bar jednu od ove dve pozicije. U implementaciji je potrebno proveriti oba slu\u010daja pojedina\u010dno.) Tra\u017eimo najmanji indeks \\(i_2 &gt; N/2\\) takav da za svako slovo va\u017ei da je njegova u\u010destanost u intervalu \\([i_2+1, N-l]\\) manja ili jednaka njegovoj u\u010destanosti u intervalu \\([l+1, i_2]\\). Ukoliko takav indeks postoji, kandidat za re\u0161enje je interval \\([l+1, i_2]\\). Ovo mo\u017eemo garantovati, jer nam se garantuje da \u0107e postojati takav interval. Iz toga mo\u017eemo zaklju\u010diti da \u0107e i ,,centralni deo\u2019\u2019 mo\u0107i da se ispreme\u0161ta da bude palindrom.</p> <p>U\u010desestanost slova u intervalima mo\u017eemo odrediti kori\u0161\u0107enjem prefiksnih suma i opisano re\u0161enje je mogu\u0107e implementirati u vremenskoj slo\u017eenosti od \\(O(N \\cdot \\Sigma)\\). Malo pa\u017eljivija implementacija daje vremensku slo\u017eenost od \\(O(N)\\). Postoje i alternativna re\u0161enja zadatka koja koriste binarnu pretragu ili pretra\u017eiva\u010dka stabla i rade u slo\u017eenosti \\(O(N \\log N)\\), \u0161to je tako\u0111e dovoljno za sve poene na ovom zadatku.</p> 03_palindrom_safl.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n\nconst int maxN = 2e5;\nconst int maxS = 26;\nstring s;\nint n;\nint p[maxN + 10][maxS + 1];\n\nbool compare(int l, int r) {\n    int l1 = n - r + 1;\n    int r1 = n - l + 1;\n\n    for (int i = 0; i &lt; 26; i++) {\n        if (p[r][i] - p[l - 1][i] != p[r1][i] - p[l1 - 1][i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool palindrom_shuffle(int l, int r) {\n    int odd = 0;\n\n    for (int i = 0; i &lt; 26; i++) {\n        if (2 * p[r][i] - p[l - 1][i] - p[n - l + 1][i] &lt; 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint solve() {\n    n = s.size();\n\n    for (int i = 0; i &lt; 26; i++) {\n        p[0][i] = 0;\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 0; j &lt; 26; j++) {\n            p[i][j] = p[i - 1][j];\n        }\n        p[i][s[i - 1] - 'a']++;\n    }\n\n    int d = 1;\n    while (s[d - 1] == s[n - d] &amp;&amp; d &lt;= n / 2) d++;\n\n    if (d &gt; n / 2) {\n        return 1;\n    }\n\n    int d1 = n / 2;\n\n    while(s[d1 - 1] == s[n - d1]) {\n        d1--;\n    }\n\n\n    if (compare(d, d1)) {\n        return d1 - d + 1;\n    }\n\n    for (int i = n/2 + 1; i &lt;= n - d; i++) {\n        if (palindrom_shuffle(d, i)) {\n            return i - d + 1;\n        }\n    }\n\n    return n - 2 * d + 2;    \n}\n\nint main() {\n    cin&gt;&gt;s;\n\n    int ans = solve();\n    reverse(s.begin(), s.end());\n    ans = min(ans, solve());\n\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/","title":"4 - Gu\u0161ter","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 128MB <p>GU\u0160TER, novi strani investitor, do\u0161ao je u Srbiju i njegova prva biznis avantura je otvaranje herpetolo\u0161ke radnje u centru Beograda. Plan poslovanja je napravljen, ali je do\u0161lo do problema pri izboru naziva radnje.</p> <p></p> <p>Menad\u017eeri i PR stru\u010dnjaci GU\u0160TER-a su ustanovili da je va\u017eno da logotip iznad ulaznih vrata sadr\u017ei izabrano ime i bude u obliku zmije: najpre se prvi red logotipa \u010dita sleva na desno, pa se drugi red \u010dita zdesna na levo, pri \u010demu je po\u010detak drugog reda na istoj poziciji kao i kraj prvog reda; tre\u0107i red se \u010dita sleva na desno, a po\u010detak tre\u0107eg reda je na istoj poziciji kao i kraj drugog reda itd. Logotip mo\u017ee da bude napisan u bilo kom broju redova (\u010dak i jednom), dokle god svaki red sadr\u017ei bar dva slova. Na primer, re\u010d \u201c<code>hastalavista</code>\u201d mo\u017ee da se napi\u0161e u obliku zmije na slede\u0107i na\u010din: <pre><code>hast\n ala\n vista\n</code></pre> Nisu svi oblici zmije podjednako dobri. Stru\u010dnjaci su ustanovili da je najpogodniji logotip za datu re\u010d onaj koji ima najve\u0107i zmija-skor. Zmija-skor se defini\u0161e kao broj (neure\u0111enih) parova slova, jedno tik iznad drugog, koja se poklapaju. Na primer, navedena zmija ima zmija-skor 1: prvo i tre\u0107e slovo \u201c<code>a</code>\u201d su jedno iznad drugog. Me\u0111utim, mogu\u0107e je posti\u0107i zmija-skor 2 slede\u0107om zmijom: <pre><code>   has\nivalat\nsta\n</code></pre> Ljudi iz GU\u0160TER-a imaju predlog za ime radnje, ali ne znaju kako treba da izgleda optimalan logotip. Odlu\u010dili da se obrate vama, mladim programerima, ne bi li re\u0161ili problem i privukli \u0161to je mogu\u0107e vi\u0161e mu\u0161terija. Pomozite GU\u0160TER-u da zaradi \u0161to je mogu\u0107e vi\u0161e.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Plav\u0161i\u0107 Aleksa Plav\u0161i\u0107 Lazar Milenkovi\u0107 Aleksa Milisavljevi\u0107 <p>Ovaj zadatak se re\u0161ava dinami\u010dkim programiranjem, \u0161to se vidi po tome \u0161to je re\u010d o optimizaciji i po tome \u0161to na\u0107i optimalno re\u0161enje za dati ulaz zavisi od optimalnih re\u0161enja za podniske tog ulaza.</p> <p>Osnova re\u0161enja za tri podzadatka je ista: dobiti \\(50\\) ili \\(100\\) poena na ovom zadatku zahteva da se primete mogu\u0107e optimizacije. Neka je \\(n\\) du\u017eina date niske \\(s\\) (indeksirane od nule).</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza nalazi se niska koja predstavlja predlog imena herpetolo\u0161ke radnje. Znaci u ovoj niski su mala slova engleske abecede.</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza ispisati jedan nenegativan ceo broj: najve\u0107i zmija-skor koji mo\u017ee da se ostvari nekim zmijolikim rasporedom predlo\u017eenog imena.</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv2/04_guster/#ulaz","title":"Ulaz","text":"<pre><code>hastalavista\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Primer iz teksta zadatka.</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv2/04_guster/#ulaz_1","title":"Ulaz","text":"<pre><code>anavolimilovana\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Nije mogu\u0107e postaviti bilo koji par istih slova jedno tik iznad drugog.</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2021_2022/kv2/04_guster/#ulaz_2","title":"Ulaz","text":"<pre><code>abccbbcaac\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#izlaz_2","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2021_2022/kv2/04_guster/#objasnjenje_2","title":"Obja\u0161njenje","text":"<p>Optimalan raspored je: <pre><code>abc\n bc\n bca\n  ca\n</code></pre> Dva puta se slovo <code>b</code> nalazi iznad slova <code>b</code>, tri puta se slovo <code>c</code> nalazi iznad slova <code>c</code>, a samo jednom se <code>a</code> nalazi iznad slova <code>a</code>, \u0161to daje ukupan zmija-skor 6.</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>Znaci niske su mala slova engleske abecede.</li> <li>Niska sadr\u017ei ne vi\u0161e od \\(3000\\) znakova i ne manje od dva znaka.</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(30\\) poena: Niska nema vi\u0161e od \\(100\\) znakova.</li> <li>U test primerima vrednim \\(20\\) poena: Niska ima vi\u0161e od \\(100\\), a ne vi\u0161e od \\(500\\) znakova.</li> <li>U test primerima vrednim \\(50\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv2/04_guster/#resenje-za-n-leq-100","title":"Re\u0161enje za \\(n \\leq 100\\)","text":"<p>Defini\u0161imo dvodimenzioni niz \\(\\mathit{dp}\\) formata \\((n+1)\\times(n+1)\\):</p> <ul> <li>\\(\\mathit{dp}[i][j]\\) za \\(i,j&gt;0\\): optimalan zmija-skor koji sufiks niske \\(s\\) du\u017eine \\(i\\) mo\u017ee da ostvari, ukoliko se u prvog redu logotipa nalazi \\(j\\) znakova; ako ne postoji nijedan takav dozvoljen logotip, \\(-\\infty\\);</li> <li>\\(\\mathit{dp}[i][0]\\) i \\(\\mathit{dp}[0][j]\\) mogu da se ignori\u0161u i nemaju nikakvo posebno zna\u010denje.</li> </ul> <p>Ukoliko znamo sve vrednosti \\(\\mathit{dp}[i][j]\\), tada je re\u0161enje jednako \\(\\max_{2 \\leq j \\leq n} \\{\\mathit{dp}[n][j]\\}\\): optimalno re\u0161enje sadr\u017ei bilo koji (dozvoljen) broj simbola u prvom redu.</p> <p>Najpre primetimo neke osnovne \u010dinjenice o \\(\\mathit{dp}[i][j]\\) koje slu\u017ee kao temelj odre\u0111ivanja kona\u010dnog re\u0161enja:</p> <ul> <li>\\(\\mathit{dp}[i][i] = 0\\), re\u010d je o re\u0161enju u kom ceo logotip za sufiks du\u017eine \\(i\\) staje u jedan red;</li> <li>\\(\\mathit{dp}[i][j] = -\\infty\\) za \\(i&lt;j\\);</li> <li>\\(\\mathit{dp}[i][1] = -\\infty\\) (nije mogu\u0107e da u bilo kom redu bude samo jedan znak).</li> </ul> <p>Za dalje ra\u010dunanje se oslanjamo na naredno zapa\u017eanje:</p> <p>Ako sufiks niske \\(s\\) du\u017eine \\(i\\) sadr\u017ei \\(j\\) znakova (\\(1&lt;j&lt;i\\)), optimalan zmija-skor koji mo\u017ee da se ostvari je najve\u0107i od svih zbirova \\(\\mathit{dp}[i-j][k]\\) i broja poklapanja znakova ukoliko se u prvom redu nalazi \\(j\\), a u drugom \\(i\\) znakova.</p> <p>Broj poklapanja mo\u017ee da se izra\u010duna proverom da li se poklapaju znaci \\(s\\) na pozicijama \\(n-i+j+p-1\\) i \\(n-i+j-p\\), pri \u010demu se \\(p\\) menja. Ako defini\u0161emo \\(P(t,p)\\) kao indikator da li se ovi znaci na pozicijama \\(n-t+p-1\\) i \\(n-t-p\\) poklapaju (dakle \\(0\\) ili \\(1\\); \\(0\\) je odgovor i u slu\u010daju da je jedan od ovih znakova van opsega niske), prethodna \u010dinjenica mo\u017ee da se zapi\u0161e u vidu naredne rekurentne veze:</p> \\[ \\mathit{dp}[i][j] = \\max_{2&lt;k\\leq i-j} \\{\\mathit{dp}[i-j][k] + \\sum_{p=1}^{\\min(j,k)} P(i-j,p)\\} \\] <p>Sve vrednosti \\(\\mathit{dp}[i][j]\\) mogu da se odrede prate\u0107i ovu formulu. U pseudokodu, ovako izgleda glavni deo algoritma: <pre><code>for i in 1 .. n:\n    for j in 2 .. i:\n        dp[i][j] = -\u221e\n        for k in 2 .. j:\n            broj_poklapanja = 0\n            for p in 1 .. min(j, k):\n                broj_poklapanja += P(i - j, p)\n            dp[i][j] = max(dp[i][j], dp[i - j][k] + broj_poklapanja)\n</code></pre></p> <p>Kona\u010dna vremenska slo\u017eenost je \\(O(n^4)\\), a memorijska \\(O(n^2)\\).</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#resenje-za-n-leq-500","title":"Re\u0161enje za \\(n \\leq 500\\)","text":"<p>U ovom slu\u010daju potrebno je primetiti da pri odre\u0111ivanju \\(\\mathit{dp}[i][j]\\) i \\(\\mathit{dp}[i][j+1]\\) treba da vodimo ra\u010duna o naredne dve sume: * \\(\\sum_{p=1}^{\\min(j,k)} P(i-j,p)\\); * \\(\\sum_{p=1}^{\\min(j,k+1)} P(i-j,p)\\) a njihova razlika je ili \\(0\\) ili poslednji sabirak u zbiru: \\(P(i-j,k+1)\\).</p> <p>Prethodno re\u0161enje stoga mo\u017ee da se uprosti time \u0161to se promenljiva <code>broj_poklapanja</code> a\u017eurira svaki put kada se a\u017eurira \\(k\\). Implementacija se menja na slede\u0107i na\u010din: <pre><code>for i in 1 .. n:\n    for j in 2 .. i:\n        dp[i][j] = -\u221e\n        broj_poklapanja = P(i - j, 1)\n        for k in 2 .. j:\n            if k &lt;= j:\n                broj_poklapanja += P(i - j, k)\n            dp[i][j] = max(dp[i][j], dp[i - j][k] + broj_poklapanja)\n</code></pre></p> <p>Rezultuju\u0107a slo\u017eenost je \\(O(n^3)\\), a memorijska \\(O(n^2)\\).</p>"},{"location":"takprog/2021_2022/kv2/04_guster/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Re\u0161enje za svih \\(100\\) poena radi u vremenskoj slo\u017eenosti \\(O(n^2)\\) i zasniva se na izbegavanju ponavljanja nepotrebnog rada.</p> <p>Primetimo da u re\u0161enju prethodnog podzadatka imamo iteracije po \\(j\\) i po \\(k\\), koje odre\u0111uju du\u017eine dva uzastopna reda. Kako se a\u017eurira \\(j\\), menja se poslednji znak u prvom redu i prvi znak u drugom redu, kao i podaci o svim poklapanjima. Stoga u optimizovanom re\u0161enju \u017eelimo da iskoristimo iste podatke o poklapanjima \u0161to je mogu\u0107e du\u017ee tako \u0161to \u0107e spoljna iteracija biti po polo\u017eaju poslednjeg znaka prvog reda. Sufiksu du\u017eine \\(z+d\\), u kom prvi red ima du\u017einu \\(d\\), prvi red se zavr\u0161ava znakom sa indeksom \\(n-z-1\\) i drugi red po\u010dinje znakom sa indeksom \\(n-z\\) \u2013 spoljna iteracija je po \\(z\\), unutra\u0161nja po \\(d\\).</p> <p>Za dobijanje kona\u010dnog re\u0161enja neophodno je posmatrati \u0161ta se de\u0161ava u slu\u010daju dva susedna reda u logotipu ukoliko drugi red po\u010dinje znakom sa indeksom \\(n-z\\). Pretpostavimo da prvi red ima du\u017einu \\(d\\).</p> <ul> <li>Ako je prvi red kra\u0107i od drugog, broj znakova koji se poklapaju je jednak \\(\\sum_{p=1}^{d} P(i-j,p)\\). Dakle, jedino je pitanje odrediti neko \\(k \\geq d\\) tako da je \\(\\mathit{dp}[z][k]\\) maksimizovano.</li> <li>Ako je prvi red du\u017ei od ili jednake du\u017eine kao i drugi, tada nas me\u0111u svim \\(\\mathit{dp}[z][k]+\\sum_{p=1}^{k} P(i-j,p)\\) za koje je \\(k\\leq d\\) zanima ono najve\u0107e.</li> </ul> <p>U prvom slu\u010daju je dovoljno uvesti matricu \\(m\\) definisanu na slede\u0107i na\u010din:</p> <ul> <li>\\(m[i][j] = \\max_{j\\leq k\\leq i}\\{\\mathit{dp}[i][k]\\}\\) za \\(j \\leq i\\)</li> </ul> <p>koja mo\u017ee da se izra\u010duna pomo\u0107u rekurentne veze:</p> <ul> <li>\\(m[i][i] = \\mathit{dp}[i][i] = 0\\);</li> <li>\\(m[i][j] = \\max\\{\\mathit{dp}[i][j],m[i][j+1]\\}\\), za \\(0\\leq j&lt;i\\).</li> </ul> <p>U drugom slu\u010daju radimo sli\u010dnu stvar kao u drugom podzadatku: pratimo aktuelno najve\u0107e \\(\\mathit{dp}[z][k] + \\sum_{p=1}^{k} P(i-j,p)\\) za sve \\(k\\leq d\\). To vodi narednom pseudokodu (izuzev inicijalizacije): <pre><code>for d in 2 .. n:\n    broj_poklapanja[1] = P(i - j, 1)\n    sufiks_max[d][d] = dp[d][d]\n    poklapanje_plus_ostatak[0] = 0;\n    for k in 1 .. d:\n        sufiks_max[d][d - k] = max(sufiks_max[d][d - k + 1], dp[d][d - k]);\n        poklapanje_plus_ostatak[k] = 0;\n    for t in 2 .. min(d, n - d):\n        broj_poklapanja[t] = broj_poklapanja[t - 1] + P(d, t);\n        poklapanje_plus_ostatak[t] = broj_poklapanja[t] + dp[d][t];\n        dp[d + t][t] = max(dp[d + t][t], sufiks_max[d][t] + broj_poklapanja[t]);\n    max_zbir = 0;\n    for j in 2 .. (n - d):\n        if j &lt;= d:\n            max_do_sad = max(max_do_sad, poklapanje_plus_ostatak[j]);\n        dp[d + j][j] = max(dp[d + j][j], max_do_sad);\n</code></pre></p> <p>Za kraj, pomenimo da je mogu\u0107e dobiti sve poene \u010dak i kada se implementira re\u0161enje slo\u017eenosti \\(O(n^2 \\log n)\\), pod uslovom da je konstanta sakrivena \\(O\\)-notacijom dovoljno mala. Jedno ovakvo re\u0161enje se zasniva na idejama iz prva dva podzadatka, pri \u010demu se ra\u010dunanje tra\u017eenog minimuma vr\u0161i kori\u0161\u0107enjem segmentnog stabla. Me\u0111utim, re\u0161enje vremenske slo\u017eenosti \\(O(n^2)\\) je kra\u0107e i br\u017ee.</p> 04_guster.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#define MAXN 3000\n\nint poklapanje(std::string&amp; s, int n, int p, int j) {\n  if (p - j &lt; 0 || p + j - 1 &gt;= n) {\n    return 0;\n  }\n  return s[p - j] == s[p + j - 1];\n}\n\nint min(int x, int y) {\n  return x &lt; y? x : y;\n}\n\nint max(int x, int y) {\n  return x &gt; y? x : y;\n}\n\nstd::string s;\nint n;\nint dp[MAXN + 1][MAXN + 1];\nint sufiks_max[MAXN + 1][MAXN + 1];\nint broj_poklapanja[MAXN + 1];\nint poklapanje_plus_ostatak[MAXN + 1];\nint resenje;\n\nint main() {\n  // efikasnost standardnog ulaza i izlaza\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(NULL);\n\n  // ulaz\n  std::cin &gt;&gt; s;\n  n = s.length();\n\n  // inicijalizacija DP\n  for (int i = 0; i &lt;= n; i++) {\n    for (int j = 0; j &lt;= n; j++) {\n      dp[i][j] = (i == j) - 1;\n      sufiks_max[i][j] = 0;\n    }\n    broj_poklapanja[i] = 0;\n    poklapanje_plus_ostatak[i] = 0;\n  }\n\n  // DP rekurentna veza\n  for (int d = 2; d &lt;= n; d++) {\n    broj_poklapanja[1] = poklapanje(s, n, n - d, 1);\n    // racunanje sufiksnih maksimuma za dp[d]\n    sufiks_max[d][d] = dp[d][d];\n    poklapanje_plus_ostatak[0] = 0;\n    for (int k = 1; k &lt;= d; k++) {\n      sufiks_max[d][d - k] = max(sufiks_max[d][d - k + 1], dp[d][d - k]);\n      poklapanje_plus_ostatak[k] = 0;\n    }\n    // t: razlicite duzine sledeceg reda\n    for (int t = 2; t &lt;= min(d, n - d); t++) {\n      broj_poklapanja[t] = broj_poklapanja[t - 1] + poklapanje(s, n, n - d, t);\n      poklapanje_plus_ostatak[t] = broj_poklapanja[t] + dp[d][t];\n      dp[d + t][t] = max(dp[d + t][t], sufiks_max[d][t] + broj_poklapanja[t]);\n    }\n    // slucaj kada je trenutni red duzi od sledeceg\n    int max_do_sad = 0;\n    for (int j = 2; j &lt;= n - d; j++) {\n      if (j &lt;= d) {\n        max_do_sad = max(max_do_sad, poklapanje_plus_ostatak[j]);\n      }\n      dp[d + j][j] = max(dp[d + j][j], max_do_sad);\n    }\n  }\n\n  // resenje: sve dozvoljene duzine prvog reda\n  resenje = dp[n][0];\n  for (int i = 1; i &lt;= n; i++) {\n    resenje = max(resenje, dp[n][i]);\n  }\n\n  // izlaz\n  std::cout &lt;&lt; resenje &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/","title":"5 - \u010carobnjak","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>\u010carobnjak Milivoje poseduje \\(N\\) magi\u010dnih napitaka pore\u0111anih u niz. Za svaki od tih \\(N\\) napitaka data je njegova mo\u0107 \\(a_i\\). Milivoje \u017eeli da iskombinuje ove napitke u jedan i tako prizove mo\u0107nu \u010din. On zna da mu je za to potrebno da prvo odabere ta\u010dno \\(K\\) od postoje\u0107ih \\(N\\) napitaka i ostale ostavi po strani. Dakle, Milivoje izabere \\(K\\) napitaka, ostale odbaci, a izabranim napicima ne menja redosled. Potom Milivoje kombinuje tih \\(K\\) napitaka sve dok mu ne ostane samo jedan.</p> <p>Da bi se spre\u010dilo \u0161to vi\u0161e nesre\u0107a na poslu, \u010darobnjaci su na me\u0111unarodnom kongresu usvojili veoma stroga pravila o tome kako se napici smeju me\u0161ati. Ta pravila su slede\u0107a:</p> <ul> <li>Mogu\u0107e je uzeti poslednji napitak iz niza i nasuti ceo napitak u bo\u010dicu koja sadr\u017ei prvi napitak. U tom slu\u010daju mo\u0107 prvog napitka postaje razlika mo\u0107i prvog i poslednjeg napitka. Dakle, ukoliko je prvi napitak imao mo\u0107 \\(x\\), a poslednji mo\u0107 \\(y\\), pri ovoj operaciji poslednji napitak se uklanja iz niza, a mo\u0107 prvog napitka postaje \\(x-y\\).</li> <li>Mogu\u0107e je uzeti prvi napitak iz niza i nasuti ceo napitak u bo\u010dicu koja sadr\u017ei poslednji napitak. U tom slu\u010daju mo\u0107 poslednjeg napitka postaje razlika mo\u0107i poslednjeg i prvog napitka. Dakle, ukoliko je prvi napitak imao mo\u0107 \\(x\\), a poslednji mo\u0107 \\(y\\), pri ovoj operaciji prvi napitak se uklanja iz niza, a mo\u0107 poslednjeg napitka postaje \\(y-x\\).</li> </ul> <p>Primetiti da primenom ovih operacija mo\u0107 nekog napitka mo\u017ee postati i negativna. U oba slu\u010daja jedan napitak se potro\u0161i, tj. broj napitaka u nizu se smanji za jedan. U svakom trenutku Milivoje mo\u017ee da bira koje \u0107e od pravila koristiti. On \u0107e ovaj proces ponoviti \\(K-1\\) puta, tj. sve dok u nizu ne ostane samo jedan napitak. Kako Milivoje \u017eeli da prizove \u0161to mo\u0107niju \u010din, njega interesuje koja je najve\u0107a mogu\u0107a mo\u0107 napitka koji mo\u017ee ostati nakon primene svih operacija. Milivoje je jedan od najboljih \u010darobnjaka na svetu i ukoliko mu pomognete, on \u0107e baciti \u010din koja \u0107e Vam doneti \\(100\\) poena na ovom zadatku.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva pozitivna cela broja \\(N\\) i \\(K\\) - broj napitaka na po\u010detku i broj napitaka koje Milivoje treba da izabere. </p> <p>U drugom redu standardnog ulaza, nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(a_i\\) i on predstavlja mo\u0107 \\(i\\)-tog napitka.</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza potrebno je ispisati jedan ceo broj, koji predstavlja najve\u0107u mo\u0107 napitka koji mo\u017ee ostati u nizu nakon primene svih operacija.</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv2/05_carobnjak/#ulaz","title":"Ulaz","text":"<pre><code>3 2\n5 3 2\n</code></pre>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Milivoje treba da izabere dva napitka. Ukoliko izabere prvi i poslednji napitak i primeni drugu operaciju, on \u0107e dobiti napitak koji ima mo\u0107 \\(a_1-a_3=5-2=3\\).</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq K \\leq N \\leq 200.000\\)</li> <li>\\(|a_i| \\leq 100.000\\), za svako \\(1 \\leq i \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N \\leq 10\\).</li> <li>U test primerima vrednim \\(15\\) poena: \\(N \\leq 200\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(K = N\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(N \\leq 1.000\\).</li> <li>U test primerima vrednim \\(35\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#resenje-za-n-leq-10","title":"Re\u0161enje za \\(N \\leq 10\\)","text":"<p>U ovom slu\u010daju mo\u017eemo za svaki odabir \\(K\\) od \\(N\\) elemenata isprobati sve mogu\u0107e na\u010dine da izvr\u0161imo operacije. Vremenska slo\u017eenost je \\(O({N \\choose K} \\cdot 2^K)\\).</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#resenje-za-n-leq-200","title":"Re\u0161enje za \\(N \\leq 200\\)","text":"<p>U ovom podzadatku do re\u0161enja mo\u017eemo do\u0107i primenom dinami\u010dkog programiranja. Defini\u0161imo \\(dp[l][r][p][g][h]\\) na slede\u0107i na\u010din:</p> <ul> <li>Za \\(g=0, h=0\\) najve\u0107a vrednost tako da u nizu napitaka ostane napitak sa tom mo\u0107i, pa onda napici iz intervala \\([l,r]\\) i da smo izvan intervala odabrali da zadr\u017eimo \\(p\\) elemenata.</li> <li>Za \\(g=0, h=1\\) najmanja vrednost tako da u nizu napitaka ostane napitak sa tom mo\u0107i, pa onda napici iz intervala \\([l,r]\\) i da smo izvan intervala odabrali da zadr\u017eimo \\(p\\) elemenata.</li> <li>Za \\(g=1, h=0\\) najve\u0107a vrednost tako da u nizu napitaka ostane napitak sa tom mo\u0107i, pre njega napici iz intervala \\([l,r]\\) i da smo izvan intervala odabrali da zadr\u017eimo \\(p\\) elemenata.</li> <li>Za \\(g=1, h=1\\) najmanja vrednost tako da u nizu napitaka ostane napitak sa tom mo\u0107i, pre njega napici iz intervala \\([l,r]\\) i da smo izvan intervala odabrali da zadr\u017eimo \\(p\\) elemenata.</li> </ul> <p>Kako se operacijama isklju\u010divo oduzima vrednost jednog kraja od vrednosti drugog, to se pronala\u017eenje maksimalne ili minimalne vrednosti na jednom kraju upravo svodi na pronala\u017eenje minimalne odnosno maksimalne vrednosti na suprotnom i primenu jedne operacije. Ovo dinami\u010dko programiranje je vremenske slo\u017eenosti \\(O(N^3)\\).</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#resenje-za-k-n","title":"Re\u0161enje za \\(K = N\\)","text":"<p>Za re\u0161avanje ovog podzadatka, neophodno je primetiti da su sve vrednosti mo\u0107i napitka koji ostaje poslednji u nizu ili razlika nepraznog prefiksa i odgovaraju\u0107eg nepraznog sufiksa ili razlika nepraznog sufiksa i odgovaraju\u0107eg nepraznog prefiksa. Za po\u010detak, primetimo da mo\u0107 napitka koji ostaje poslednji u nizu uvek mo\u017eemo preslikati na niz \\(b\\) koji sadr\u017ei \\(N\\) vrednosti koje su isklju\u010divo \\(+\\) ili \\(-\\). Konkretno, ako mo\u0107 nekog napitka iz po\u010detnog niza u\u010destvuje sa znakom \\(+\\) u mo\u0107i napitka koji ostaje poslednji, na tu poziciju u nizu \\(b\\) stavljamo \\(+\\), a u suprotnom \\(-\\). Posmatrajmo sada niz \\(b\\). \u017delimo da ga svedemo na niz koji ima samo jedan element i taj element ima vrednost \\(+\\), primenom operacija definisanih u tekstu. Primetimo da ukoliko prva i poslednja vrednost u nizu \\(b\\) imaju isti znak, tada sigurno nije mogu\u0107e izvr\u0161iti ni jednu operaciju, jer tada \u017eelimo da i prvi i poslednji element u\u010destvuju sa istim znakom, a znamo da primenom bilo koje od dve operacije dovodimo do toga da u kona\u010dnoj sumi u\u010destvuju sa razli\u010ditim znakom. U suprotnom, mo\u017eemo da izvr\u0161imo bilo koju od ove dve operacije. Na nizu \\(b\\) ovo se odr\u017eava brisanjem jednog od dva kraja. Dakle, ukoliko posle primene nekih operacija do\u0111emo do niza koji ima vi\u0161e od jednog elementa i njegovi krajevi su razli\u010ditog znaka, onda nas taj niz nikako ne mo\u017ee dovesti do niza koji sadr\u017ei samo jedan element \\(+\\). Zbog toga nije mogu\u0107e da u nizu \\(b\\) postoji vi\u0161e od jednog para susednih pozicija koje imaju suprotan znak. Dakle, dovoljno je da uzmemo maksimum razlika svih nepraznih prefiksa i odgovaraju\u0107ih nepraznih sufiksa, odnosno nepraznih sufiksa i odgovaraju\u0107ih nepraznih prefiksa. Ovo je mogu\u0107e uraditi u  vremenskoj slo\u017eenosti \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#resenje-kad-n-leq-1000","title":"Re\u0161enje kad \\(N \\leq 1000\\)","text":"<p>Re\u0161avanje ovog podzadatka se nadovezuje na re\u0161avanje prethodnog. Fiksira\u0107emo svaku poziciju koja \u0107e predstavljati razliku izme\u0111u prefiksa i sufiksa (odnosno sufiksa i prefiksa) i potom izbaciti \\(N-K\\) elemenata tako da se ta razlika maksimizuje i da ni prefiks ni sufiks ne ostanu prazni. Ovo je mogu\u0107e posti\u0107i sortiranjem celog niza sa promenjenim znakom elemenata u sufiksu, te izbacivanjem najmanjih \\(N-K\\) elemenata. Neophodno je samo voditi ra\u010duna da izbacivanje tih elemenata ne dovede do praznog prefiksa ili sufiksa. Ovakvo re\u0161enje je vremenske slo\u017eenosti \\(O(N^2 \\log N)\\).</p>"},{"location":"takprog/2021_2022/kv2/05_carobnjak/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za re\u0161enje celog zadatka, neophodno je optimizovati re\u0161enje prethodnog podzadatka tako da ne moramo da za svaku poziciju sortiramo niz i ponovo biramo najmanje elemente. Glavna ideja u toj optimizaciji se zasniva na tome da se promenom pozicije koja razdvaja prefiks i sufiks za jedan menjaju ta\u010dno dve vrednosti iz niza koji sortiramo i iz kojeg biramo najmanjih \\(N-K\\). Mo\u017eemo koristiti strukturu <code>set</code> ili segmentno stablo da bi odr\u017eavali taj niz. Re\u0161enje kompletnog zadatka je vremenske slo\u017eenosti \\(O(N \\log N)\\).</p> 05_carobnjak.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 200005\n#define maxv 100000\nusing namespace std;\nlong long a[maxn];\nint n,k;\nlong long pref[maxn];\nlong long suf[maxn];\nint cnt[4*maxn];\nint pref_cnt[4*maxn];\nlong long sum[4*maxn];\ninline void clear_seg(int id,int l,int r) {\n    sum[id]=0;\n    cnt[id]=0;\n    pref_cnt[id]=0;\n    if(l==r) return;\n    int m=(l+r)/2;\n    clear_seg(id*2+1,l,m);\n    clear_seg(id*2+2,m+1,r);\n}\ninline void update(int id,int l,int r,int pos,int c,int p,int s) {\n    cnt[id]+=c;\n    pref_cnt[id]+=p;\n    sum[id]+=s;\n    if(l==r) return;\n    int m=(l+r)/2;\n    if(pos&lt;=m) update(id*2+1,l,m,pos,c,p,s);\n    else update(id*2+2,m+1,r,pos,c,p,s);\n}\ninline pair&lt;long long,pair&lt;int,int&gt;&gt; pick(int id,int l,int r,int k,int ps,int ss) {\n    if(k==0) return {0,{0,0}};\n    if(k&gt;=cnt[id] &amp;&amp; ps&gt;pref_cnt[id] &amp;&amp; ss&gt;cnt[id]-pref_cnt[id]) return {sum[id],{pref_cnt[id],cnt[id]}};\n    if(l==r) {\n        if(k&gt;=cnt[id]) {\n            if(ps==pref_cnt[id]) return {1ll*(l-maxv)*(cnt[id]-1),{pref_cnt[id]-1,cnt[id]-1}};\n            else return {1ll*(l-maxv)*(cnt[id]-1),{pref_cnt[id],cnt[id]-1}};\n        }\n        else {\n            return  {1ll*(l-maxv)*k,{k,k}};\n        }\n    }\n    int m=(l+r)/2;\n    pair&lt;long long,pair&lt;int,int&gt; &gt; p2=pick(id*2+2,m+1,r,k,ps,ss);\n    pair&lt;long long,pair&lt;int,int&gt; &gt; p1=pick(id*2+1,l,m,k-p2.second.second,ps-p2.second.first,ss-p2.second.second+p2.second.first);\n    return {p1.first+p2.first,{p1.second.first+p2.second.first,p1.second.second+p2.second.second}};\n}\nlong long solve() {\n    for(int i=1;i&lt;=n;i++) {\n        pref[i]=pref[i-1]+a[i];\n    }\n    for(int i=n;i&gt;=1;i--) {\n        suf[i]=suf[i+1]+a[i];\n    }\n    long long ans=-1e18;\n    clear_seg(0,0,maxn);\n    update(0,0,maxn,-a[1]+maxv,1,1,-a[1]);\n    for(int i=2;i&lt;=n;i++) {\n        update(0,0,maxn,a[i]+maxv,1,0,a[i]);\n    }\n    for(int i=1;i&lt;=n-1;i++) {\n        pair&lt;long long,pair&lt;int,int &gt; &gt; p=pick(0,0,maxn,n-k,i,n-i);\n        ans=max(ans,pref[i]-suf[i+1]+p.first);\n        update(0,0,maxn,a[i+1]+maxv,-1,0,-a[i+1]);\n        update(0,0,maxn,-a[i+1]+maxv,1,1,-a[i+1]);\n    }\n    return ans;\n}\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;k);\n    for(int i=1;i&lt;=n;i++) {\n        scanf(\"%lld\",&amp;a[i]);\n    }\n    long long ans=solve();\n    for(int i=1;i&lt;=n;i++) {\n        a[i]=-a[i];\n    }\n    ans=max(ans,solve());\n    printf(\"%lld\",ans);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/","title":"1 - Biodiverzitet","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Kao \u0161to ve\u0107 znate, za\u0161tita \u017eivotne sredine i biodiverziteta jako su va\u017eni. Zato ste unajmljeni da pomognete sa projektom procene biodiverziteta u Srbiji.</p> <p>\u017divotinjske vrste koje \u017eive ili su \u017eivele u Srbiji indeksirane su brojevima \\(0, 1, 2, ...\\). Indeksi su dodeljeni tako da biolo\u0161ki predak vrste sa indeksom \\(i\\) ima indeks \\(\\lfloor i/K\\rfloor\\), gde je \\(K\\) unapred fiksiran prirodan broj. Ovde \\(\\lfloor i/K\\rfloor\\) ozna\u010dava rezultat celobrojnog deljenja broja \\(i\\) sa \\(K\\).</p> <p>Vi treba da analizirate biodiverzitet jednog podru\u010dja. Zato vam je dat skup vrsta koje trenutno obitavaju na tom prostoru. Va\u0161 zadatak je da odredite broj razli\u010ditih biolo\u0161kih predaka vrsta koje trenutno \u017eive na ovom podru\u010dju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Aleksa Milojevi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja \\(N\\) i \\(K\\) - broj vrsta koje trenutno \u017eive na datom podru\u010dju i broj koji odre\u0111uje kako izra\u010dunati indeks biolo\u0161kog pretka.</p> <p>U drugom redu standardnog ulaza nalazi se niz celih brojeva \\(i_1,  i_2, \\ldots, i_N\\) du\u017eine \\(N\\), gde \\(i_k\\) koji predstavljaju indekse vrsta koje trenutno \u017eive na datom podru\u010dju. </p>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati ceo broj koji predstavlja broj razli\u010ditih biolo\u0161kih predaka vrsta koje trenutno \u017eive na datom podru\u010dju. </p>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#ulaz","title":"Ulaz","text":"<pre><code>5 4\n10 20 15 11 30\n</code></pre>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Preci datih vrsti su redom vrste sa indeksom 2, 5, 3, 2, 7. Dakle, imamo \u010detiri razli\u010dita pretka.</p>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^4\\)</li> <li>\\(0 \\leq i_k \\leq 10^9\\), za \\(1 \\leq k \\leq N\\)</li> <li>\\(1 \\leq K \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 20 poena va\u017ei \\(N \\leq 10, i_k\\leq 100\\).</li> <li>U testovima vrednim 10 poena va\u017ei \\(K=1, i_k\\leq 100\\).</li> <li>U testovima vrednim 20 poena va\u017ei \\(i_k\\leq 10^6\\)</li> <li>U testovima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv3/01_biodiverzitet/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Kako je cilj odrediti broj razli\u010ditih biolo\u0161kih predaka vrsta koje trenutno \u017eive, a budu\u0107i da su u zadatku dati indeksi vrsta koje trenutno \u017eive, najpre je potrebno pristupiti izra\u010dunavanju indeksa biolo\u0161kih predaka. To se \u010dini tako \u0161to se indeks vrste \\(i\\) celobrojno podeli sa \\(K\\) i to za sve indekse \\(i_1, i_2, \\ldots, i_N\\) u zadatom nizu. Time se dobija novi niz koji zapravo predstavlja niz biolo\u0161kih predaka. Treba primetiti da se u op\u0161tem slu\u010daju vrednosti unutar niza bilo\u0161kih predaka mogu ponavljati. Najzad da bi se odredio broj razli\u010ditih predaka potrebno je prebrojati jedinstvene \u010dlanove niza koji sadr\u017ei i duplikate. Postoji vi\u0161e na\u010dina na koji je mogu\u0107e izra\u010dunati broj jedinstvenih \u010dlanova niza, a jedan od njih je da se \u010dlanovi niza biolo\u0161kih predaka sortiraju i onda u jednom prolazu kroz niz izbroje razli\u010dite vrednosti.</p> <p>U re\u0161enju, pored operacija prolaza kroz niz u kojima se izvr\u0161ava celobrojno deljenje ili prebrajanje jedinstvenih \u010dlanova, a koje su linearne slo\u017eenosti \\(\\mathcal{O}(N)\\), tako\u0111e imamo i operaciju sortiranja koja je dominantne slo\u017eenosti. Koriste\u0107i se efikasnim algoritmima niz je mogu\u0107e sortirati u loglinearnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(N\\log N)\\), iako je za maksimalan broj poena to bilo dovoljno u\u010diniti i u kvadratnoj, odnosno \\(\\mathcal{O}(N^2)\\) slo\u017eenosti.</p> 01_biodiverzitet.cpp<pre><code>n, k = map(int, input().split())\nniz = list(map(int, input().split()))\nprint(len(set(map(lambda x: x//k, niz))))\n</code></pre>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/","title":"2 - Mla\u0111ioni\u010dar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>Mladen je pre nekoliko dana gledao ma\u0111ioni\u010darsku predstavu, u kojoj je ma\u0111ioni\u010dar odlu\u010dio da izvede jedan neobi\u010dan trik. </p> <p>Prvo je ubacio \\(N\\) kuglica u d\u017eak, koriste\u0107i samo crvene, zelene i plave kuglice. Zatim je izvla\u010dio kuglice jednu po jednu, dok nije izvukao crvenu. Posle toga ih je sve vratio u d\u017eak, pa je izvla\u010dio kuglice dok nije prona\u0161ao zelenu. Na kraju, opet ih je vratio i izvla\u010dio dok nije prona\u0161ao plavu kuglicu.</p> <p>Ideja trika je bila da poka\u017ee da su kuglice magi\u010dno menjale boju dok su bile sakrivene, i da su doga\u0111aji kakvi su se desili nemogu\u0107i ako je u d\u017eaku stvarno bilo \\(N\\) kuglica sa po\u010detka. Mladen, ipak, nije siguran da je ovo ta\u010dno, i misli da je sve \u0161to je video mogu\u0107e bez trikova.</p> <p>Mladen se ne se\u0107a svega \u0161to je video, ali se se\u0107a koliko je kuglica izvu\u010deno u svakom od tri dela trika, i koliko je kuglica uba\u010deno u d\u017eak na po\u010detku. Interesuje ga da li postoji neki broj crvenih, zelenih i plavih kuglica u d\u017eaku takav da je ovaj ishod mogu\u0107, i ako jeste, da mu date jedan takav primer.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Dimitrije Erdeljan Dragan Uro\u0161evi\u0107 Andrej Iva\u0161kovi\u0107 <p>Ozna\u010dimo sa \\(r\\), \\(g\\) i \\(b\\), redom broj crvenih, zelenih i plavih kuglica. Tada \u0107e u najnepovoljnijem slu\u010daju crvenu kuglici izvu\u0107i nakon \u0161to izvu\u010de sve zelene i plave. Sli\u010dno \u0107e zelenu kuglicu izvu\u0107i najkasnije nakon izvla\u010denja svih crvenih i plavih, a plavu nakon \u0161to izvu\u010de sve crvene i zelene. Prema tome, va\u017ei\u0107e slede\u0107e nejednakosti $$ A \\leq g+b+1,\\quad B \\leq r+b+1, \\quad C \\leq r+g+1. $$ Pored toga je ukupan broj kuglica jednak \\(N\\), pa va\u017ei: $$ r+g+b = N. $$</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se \u010detiri cela broja \\(N, A, B, C\\): broj kuglica u d\u017eaku i redom brojevi kuglica izvu\u010deni u prvoj (do prve crvene kuglice), drugoj (do prve zelene) i tre\u0107oj (do prve plave) fazi trika.</p> <p>Broj izvu\u010denih kuglica uklju\u010duje i poslednju. Na primer, ako su u prvoj fazi izvu\u010dene dve zelene, plava, i na kraju jedna crvena kuglica, \\(A\\) je \\(4\\).</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#opis-izlaza","title":"Opis izlaza","text":"<p>Ukoliko postoje brojevi \\(R, G, B\\) takvi da su doga\u0111aji opisani u zadatku mogu\u0107i ukoliko je u d\u017eaku na po\u010detku bilo \\(R\\) crvenih, \\(G\\) zelenih i \\(B\\) plavih kuglica, u prvoj liniji standardnog izlaza ispisati <code>moguce</code>, i u drugoj liniji ispisati brojeve \\(R\\), \\(G\\) i \\(B\\).</p> <p>U suprotnom, u jedinoj liniji standardnog izlaza ispisati <code>nemoguce</code>.</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#ulaz","title":"Ulaz","text":"<pre><code>10 3 4 2\n</code></pre>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#izlaz","title":"Izlaz","text":"<pre><code>moguce\n5 3 2\n</code></pre>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Ako je u d\u017eaku bilo pet crvenih, tri zelene i dve plave kuglice, jedna mogu\u0107nost je da se trik odvijao na slede\u0107i na\u010din: prvo su izvu\u010dene dve plave pa crvena kuglica, u drugoj fazi crvena, plava, crvena pa zelena, i u tre\u0107oj zelena pa plava kuglica.</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#ulaz_1","title":"Ulaz","text":"<pre><code>5 5 5 5\n</code></pre>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#izlaz_1","title":"Izlaz","text":"<pre><code>nemoguce\n</code></pre>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Ako su u prvoj fazi izvu\u010dene sve kuglice, mo\u017eemo zaklju\u010diti da d\u017eak sadr\u017ei ta\u010dno jednu (poslednju) crvene boje. Sli\u010dno mo\u017eemo zaklju\u010diti da postoji ta\u010dno jedna plava i jedna zelena kuglica. Kako postoji pet kuglica, ovakav niz doga\u0111aja nije mogu\u0107.</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^9\\)</li> <li>\\(1 \\leq A, B, C \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U testovima vrednim 30 poena va\u017ei \\(N \\leq 200\\).</li> <li>U testovima vrednim 30 poena va\u017ei \\(N \\leq 2000\\).</li> <li>U testovima vrednim 40 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#resenje-kad-je-n-leq-200","title":"Re\u0161enje kad je \\(N \\leq 200\\)","text":"<p>U ovom slu\u010daju, mo\u017eemo za sve mogu\u0107e vrednosti brojeva \\(r\\), \\(g\\) i \\(b\\) (a to su prirodni brojevi izme\u0111u \\(1\\) i \\(N\\)), proveriti da li zadovoljavaju tri nejednakosti i poslednju jednakost i prekinuti proveravanje onog trenutka kada su zadovoljene. Ako pomenute nejednakosti i jednakost nisu zadovoljeni ni za jednu kombinaciju vrednosti \\(r\\), \\(g\\) i \\(b\\), ne postoji raspored kuglica koji odgovara vrednostima \\(A\\), \\(B\\) i \\(C\\). O\u010digledno je slo\u017eenost ovog re\u0161enja \\(O(N^3)\\). </p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#resenje-kad-je-n-leq-2000","title":"Re\u0161enje kad je \\(N \\leq 2000\\)","text":"<p>Primetimo da za fiksirane vrednosti broja crvenih (\\(r\\)) i zelenih (\\(g\\)) kuglica mo\u017eemo odrediti broj plavih kuglica po formuli \\(b=N-r-g\\). Zbog toga je dovoljno za sve kombinacije vrednosti brojeva \\(r\\) i \\(g\\) (a to su brojevi izme\u0111u \\(1\\) i \\(N\\)), odrediti vrednost broja \\(b\\), a nakon toga proveriti da li su zadovoljene tri nejednakosti.  Slo\u017eenost ovog re\u0161enja \\(O(N^2)\\).</p>"},{"location":"takprog/2021_2022/kv3/02_mladjionicar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Kako u vre\u0107i treba da bude bar jedna crvena, zelena i plava, brojeve kuglica mo\u017eemo prikazati kao $$ r = 1 + r1,\\quad g = 1+g1, \\quad b = 1+b1,\\quad r1,g1,b1\\geq 0. $$ Tada va\u0161i slede\u0107e:</p> \\[ r1+g1+b1 = (r-1) + (g-1) + (b-1) = (r+g+b)-3 = N-3 = N1. \\] <p>Pored toga, polazne nejednakosti postaju: $$ A\\leq g+b+1 = (1+b1)+(1+b1)+1 = g1+b1+3, $$ odnosno $$ g1+b1 \\geq A-3, $$ ili preciznije $$ g1+b1 \\geq \\max(A-3,0) = A1. $$ Sli\u010dno se dobija $$ r1+b1 \\geq \\max(B-3,0)=B1 $$ i $$ r1+g1 \\geq \\max(C-3,0) = C1. $$ Sabiranjem poslednje tri nejednakosti dobijamo $$ 2r1+2g1+2b1=2N1\\geq A1+B1+C1, $$ i ovo je potreban uslov da bi postojalo re\u0161enje.</p> <p>Pokazuje se da je to i dovoljan uslov. Da bi odredili re\u0161enje, primetimo da iz uslova $$ r1+g1+b1 = N1\\quad\\text{i}\\quad g1+b1\\geq A1, $$ dobijamo $$ r1 = N1-(g1+b1) \\leq N1-A1 = r1_{max}, $$ i sli\u010dno: $$ g1 \\leq N1-B1= g1_{max}\\quad\\text{i}\\quad b1 \\leq N1-C1=b1_{max}. $$ Za brojeve \\(r1\\), \\(g1\\) i \\(b1\\) biramo najve\u0107e koji zadovoljavaju nejednakosti i u zbiru daju broj \\(N1\\). Primetimo da se mogu odabrati brojevi \\(r1\\), \\(g1\\) i \\(b1\\) tako da zadovoljavaju gornje nejednakosti i zbir bude \\(N1\\) zato \u0161to je zbir gornjih ograni\u010denja  $$ r1_{max}+g1_{max}+b1_{max} = (N1-A1)+(N1-B1)+(N1-C1) = 3N1 - (A1+B1+C1) \\geq 3N1 - 2N1 = N1. $$ Kona\u010dno, same vrednosti mo\u017eemo izabrati na slede\u0107i na\u010din: $$ r1 = \\min(N1,N1-A1),\\quad g1 = \\min(N1-r1, N1-B1),\\quad b1=\\min(N1-r1-g1,N-C1). $$</p> <p>Slo\u017eenost ovog re\u0161enja je \\(O(1)\\).</p> 02_mladjionicar.cpp<pre><code>#include &lt;cstdio&gt;\n\nint min(int a, int b) { return a &lt; b ? a : b; }\nint max(int a, int b) { return a &lt; b ? b : a; }\n\nint main() {\n    int n, gb, rb, rg;\n    scanf(\"%d %d %d %d\", &amp;n, &amp;gb, &amp;rb, &amp;rg);\n\n    // bez poslednje\n    gb--; rb--; rg--;\n\n    // smena da bi garantovali da imamo bar jednu od svake boje\n    if(n &lt; 3) {\n        printf(\"nemoguce\\n\");\n        return 0;\n    }\n    n -= 3;\n    rg = max(0, rg - 2);\n    gb = max(0, gb - 2);\n    rb = max(0, rb - 2);\n\n    /*\n      r + g + b == n  (1)\n      r + g &gt;= rg     (2)\n      g + b &gt;= gb     (3)\n      r + b &gt;= rb     (4)\n\n      (2) + (3) + (4):\n      2(r + g + b) &gt;= rg + gb + rb\n      2n &gt;= rg + gb + rb  (5)\n\n      (5) je potreban uslov -- ako ne vazi nema resenja. Ako vazi, na\n      sledeci nacin mozemo naci resenje, tako da je i dovoljan:\n\n      (1) - (2):\n      b &lt;= n - rg  (6)\n      slicno:\n      r &lt;= n - gb  (7)\n      g &lt;= n - rb  (8)\n\n      Ako odaberemo bilo koja tri r, g, b za koje vazi (6--8) i (1),\n      bice ispunjeni i uslovi (2--4) (npr (2) sledi iz (1)-(6)).\n      Mozemo ih odabrati tako sto biramo redom najvece moguce\n      vrednosti za koje zbir iz (1) nije premasen -- zbir ce uvek biti\n      dostignut zbog sledeceg:\n\n      rmax + gmax + bmax == (n-rg) + (n-gb) + (n-rb) == 3n - (rg + gb + rb)\n      (5):\n      rmax + gmax + bmax &gt;= 3n - 2n == n\n     */\n\n    // NB: rg + gb + rb moze biti vece od INT_MAX\n    long long rgb2 = (long long)rg + (long long)gb + (long long)rb;\n\n    if(2*n &lt; rgb2) {\n        printf(\"nemoguce\\n\");\n    } else {\n        int r, g, b;\n        r = min(n - gb, n);\n        g = min(n - rb, n - r);\n        b = min(n - rg, n - r - g);\n\n        printf(\"moguce\\n%d %d %d\\n\", r+1, g+1, b+1);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv3/03_psiho/","title":"3 - Psiho","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Zovete se Patrik Bajtmen. Imate dvadeset i sedam godina. Brinete o sebi balansiranom dijetom, strogim re\u017eimom treninga. Ujutru, ako vam je lice naduveno, stavi\u0107ete ledenu masku dok radite zadatke iz programiranja. Mo\u017eete da ih uradite hiljadu trenutno...</p> <p>Radite u jednoj programerskoj firmi, i \u017eelite da stignete do vrha, samog vrha. Hijerarhija firme je u obliku stabla, odnosno svaka osoba, sem direktora, ima ta\u010dno jednog nadre\u0111enog. U firmi radi \\(N\\) osoba i one su numerisane od \\(1\\) do \\(N\\). Za svaku osobu znate njihovog nadre\u0111enog, sem osobe \\(1\\), koja predstavlja direktora. </p> <p>Opsednuti ste vizit kartama i zato pratite kuda one prolaze kroz kompaniju. Odavno ste primetili da one uvek idu uz hijerarhiju, odnosno na gore (osoba je uvek daje svom nadre\u0111enom). Ta\u010dno \\(M\\) vizit karti \u0107e biti pu\u0161teno u cirkulaciju i za svaku znate u kom minutu \u0107e se to desiti, kao i koja osoba \u0107e to uraditi. </p> <p>Sve osobe koje trenutno poseduju ne\u010diju vizit kartu prosledi\u0107e je narednog minuta svom nadre\u0111enom. Preciznije, ukoliko se neka vizit karta u minutu \\(t\\) nalazi kod osobe \\(a\\), u minutu \\(t+1\\) nalazi\u0107e se kod osobe koja je nadre\u0111ena osobi \\(a\\). Ako se ta vizit karta nalazi kod \u0161efa, on \u0107e je skloniti u svoju kolekciju, na bezbedno. Ukoliko nekoj osobi (uklju\u010duju\u0107i direktoru) u istom trenutku stigne vi\u0161e od jedne vizit karte, ta osoba \u0107e uzeti neke dve vizit karte, uporediti ih i obe baciti u \u0111ubre. To \u0107e ponavljati dokle god mu ne ostane najvi\u0161e jedna vizit karta. Na primer, ako u trenutku \\(t\\) nekoj osobi stigne \\(5\\) vizit karti, ta osoba \u0107e prvo uzeti dve, uporediti ih, pa baciti, i onda ponovo to uraditi sa slede\u0107e dve karte. Preostalu vizit kartu prosledi\u0107e nadre\u0111enom u trenutku \\(t+1\\). U slu\u010daju da joj je stiglo \\(4\\) vizit karte, nakon pore\u0111enja joj ne bi ostala ni jedna, pa ne bi imala \u0161ta da prosledi.</p> <p>Vas, Patrika Bajtmana, zanima koliko vizit karti je ba\u010deno u \u0111ubre. Za\u0161to? Zato \u0161to ste vi srbijanski psiho.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2021_2022/kv3/03_psiho/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva  cela broja \\(N\\) i \\(M\\) - broj osoba u firmi i broj vizit karti koje \u0107e biti u cirkulaciji.</p> <p>U drugom redu standardnog ulaza nalazi se niz celih brojeva \\(p_2,  p_3, \\ldots, p_N\\) du\u017eine \\(N-1\\), gde \\(p_i\\) predstavlja oznaku osobe koja je nadre\u0111ena osobi \\(i\\). </p> <p>Narednih \\(M\\) linija sadr\u017ee po dva cela broja \\(t_i\\) i \\(v_i\\) - minut u kojem se pojavila \\(i\\)-ta vizit karta i oznaka osobe kod koje se pojavila. I ova vizit karta se ra\u010duna u karte koje su stigle kod osobe \\(v_i\\) u trenutku \\(t_i\\).</p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati ceo broj koji predstavlja broj vizit karti koje su ba\u010dene u \u0111ubre. </p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv3/03_psiho/#ulaz","title":"Ulaz","text":"<pre><code>6 6\n1 2 2 2 4 \n3 6\n7 3\n7 5\n8 5\n7 1\n4 4\n</code></pre>"},{"location":"takprog/2021_2022/kv3/03_psiho/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/kv3/03_psiho/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Prva i \u0161esta vizit karta \u0107e se na\u0107i u isto vreme kod osobe \\(4\\) i one \u0107e se odbaciti. Sli\u010dno, druga i tre\u0107a vizit karta \u0107e se na\u0107i kod osobe \\(2\\) i onda \u0107e ih odbaciti. \u010cetvrta i peta vizit karta \u0107e neometano do\u0107i do direktora.</p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv3/03_psiho/#ulaz_1","title":"Ulaz","text":"<pre><code>5 10\n1 1 1 1 \n4 4\n3 3\n3 4\n2 2\n2 3\n2 4\n1 2\n1 3\n1 4\n1 5\n</code></pre>"},{"location":"takprog/2021_2022/kv3/03_psiho/#izlaz_1","title":"Izlaz","text":"<pre><code>8\n</code></pre>"},{"location":"takprog/2021_2022/kv3/03_psiho/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Prva vizit karta neometano sti\u017ee do direktora. Druga i tre\u0107a vizit karta sti\u017eu kod direktora u trenutku \\(4\\) i on ih odbacuje. \u010cetvrta, peta i \u0161esta karta sti\u017eu kod direktora u trenutku \\(3\\) i on uzima dve nasumi\u010dne i odbacuje ih, a tre\u0107u \u010duva za kolekciju. Sedma, osma, deveta i deseta se sve odbacuju, sti\u017eu u trenutku \\(2\\).</p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 10^5\\)</li> <li>\\(1 \\leq p_i \\leq N\\), \\(p_i &lt; i\\), za \\(2 \\leq i \\leq N\\)</li> <li>\\(1 \\leq t_i \\leq 10^9\\), za \\(1 \\leq i \\leq M\\)</li> <li>\\(1 \\leq v_i \\leq N\\), za \\(1 \\leq i \\leq M\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N, M \\leq 1000\\).</li> <li>U testovima vrednim 20 poena: \\(p_i = i-1\\), za \\(2 \\leq i \\leq N\\).</li> <li>U testovima vrednim 20 poena: \\(t_i = 1\\), za \\(1 \\leq i \\leq M\\) .</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv3/03_psiho/#resenje-za-n-m-leq-1000","title":"Re\u0161enje za \\(N, M \\leq 1000\\)","text":"<p>Ovde je mogu\u0107e primeniti razna sporija re\u0161enja, npr. mo\u017eemo odr\u017eavati skup aktivnih vizit karti, odnosno onih koje nisu jo\u0161 odba\u010dene ili sa\u010duvane od strane direktora. Svakog trenutka, sve aktivne vizit karte \u0161aljemo nadre\u0111enom i onda simuliramo pore\u0111enje vizit karti. Vremenska slo\u017eenost: \\(O(N\\cdot M)\\), memorijska slo\u017eenost: \\(O(N+M)\\).</p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#resenje-za-p_i-i-1","title":"Re\u0161enje za \\(p_i = i-1\\)","text":"<p>U ovom slu\u010daju hijerarhija kompanije je linearna, tj. samo put od svakog zaposlenog do direktora. Najbitnija obzervacija u ovom zadatku jeste da mo\u017eemo ignorisati sva susretanja vizit karti pre direktora. Ako su se dve karte susrele pre direktora, zajedno \u0107e i sti\u0107i kod direktora, gde \u0107e se svakako porediti i odbaciti.</p> <p>Ovo nam govori da je dovoljno da za svaki trenutak odredimo koliko vizit karti sti\u017ee kod direktora tad. Karta koja se pojavila u trenutku \\(t_i\\) kod osobe \\(p_i\\) \u0107e kod direktora sti\u0107i u trenutku \\(t_i+p_i-1\\), pa koriste\u0107i npr. strukturu map ili obi\u010dno sortiranje, odrediti sve \u0161to nam je potrebno da izra\u010dunamo koliko karata \u0107e biti odba\u010deno (ukoliko u trenutku \\(t\\) sti\u017ee \\(x\\) karata kod direktora, tada on odbacuje \\(\\lfloor \\frac{x}{2} \\rfloor \\cdot 2\\) vizit karti. Vremenska slo\u017eenost: \\(O(N+MlogM)\\), memorijska slo\u017eenost: \\(O(N+M)\\). </p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#resenje-za-t_i-1","title":"Re\u0161enje za \\(t_i = 1\\)","text":"<p>Re\u0161enje je sli\u010dno glavnom re\u0161enju, samo \u0161to je mogu\u0107e izbe\u0107i mapu/sortiranje, i lak\u0161e je primetiti pogrebu za dubinama zaposlenih.</p>"},{"location":"takprog/2021_2022/kv3/03_psiho/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Poput re\u0161enja kada \\(p_i = i-1\\), ignori\u0161emo pore\u0111enja sem kod direktora. Jedina razlika je \u0161to ovaj put moramo druga\u010dije da izra\u010dunamo u kom trenutku \u0107e se neka karta na\u0107i kod direktora. Potrebno je da izra\u010dunamo dubinu svakog zaposlenog, odnosno koliko je sekundi potrebno da vizit karta od osobe \\(i\\) stigne do direktora (ozna\u010dimo to sa \\(d_i\\)). </p> <p>Za ovo je mogu\u0107e koristiti grafovske algoritme, ali po\u0161to va\u017ei \\(p_i &lt; i\\) to nije neophodno. Dovoljno je da to uradimo koriste\u0107i slede\u0107e formule: \\(d_1 = 0\\)  i \\(d_i = d_{p_i} + 1\\). Kada to izra\u010dunamo, vreme kada \u0107e neka karta do\u0107i do direktora je \\(t_i + d_{v_i}\\). Vremenska slo\u017eenost: \\(O(N+MlogM)\\), memorijska slo\u017eenost: \\(O(N+M)\\).</p> 03_psiho.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define PRINT(x) cerr&lt;&lt;#x&lt;&lt;'='&lt;&lt;x&lt;&lt;endl;\n#define NL(x) \" \\n\"[(x)]\n#define lld long long\n#define pil pair&lt;int,lld&gt;\n#define pli pair&lt;lld,int&gt;\n#define pll pair&lt;lld,lld&gt;\n#define pii pair&lt;int,int&gt;\n#define pb push_back\n#define fi first\n#define se second\n#define mid ((l+r)/2)\n#define endl '\\n'\n#define all(a) begin(a),end(a)\n#define sz(a) int((a).size())\n#define LINF 1000000000000000LL\n#define INF 1000000000\n#define EPS 1e-9\nusing namespace std;\nint solve(int N, int M, vector&lt;int&gt; p, vector&lt;pair&lt;int, int&gt; &gt; cards) {\n    int dub[N+1];\n    dub[1] = 0;\n    for(int i = 2; i &lt;= N; i++) {\n        dub[i] = dub[p[i-2]] + 1;\n    }\n    map&lt;int, int&gt; cnt;\n    for(auto x : cards) {\n        cnt[x.first + dub[x.second]]++;\n    }\n    int rez = 0;\n    for(auto x : cnt) {\n        rez += x.second - x.second%2;\n    }\n    return rez;\n}\nint main() {\n    ios::sync_with_stdio(false); //cin.tie(0);\n    int N, M; cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; p;\n    int cnt = 0;\n    for(int i = 0; i &lt; N-1; i++) {\n        int x; cin &gt;&gt; x;\n        p.push_back(x);\n    }\n    vector&lt;pair&lt;int, int&gt; &gt; cards;\n    for(int i = 0; i &lt; M; i++) {\n        int t, v; cin &gt;&gt; t &gt;&gt; v;\n        cards.push_back({t, v});\n    }\n    cout &lt;&lt; solve(N, M, p, cards) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/","title":"4 - Konjugacija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Jednom, mudri \u010car TakMi opazi segmente neke na \\(x\\)-osi. I bi mu jasno da neki segment \\([l,r]\\) sadr\u017ei neku ta\u010dku sa koordinatom \\(c\\) samo ako i ako je \\(l \\leq c \\leq r\\), jer tako je zapisano u knjigama geometarskim. I znade da je centar nekog segmenta zapravo ta\u010dka u sredi\u0161tu segmenta toga, jer druga\u010dije ne mo\u017ee biti. I, najbitnije od svega, shvati da su dva segmenta konjugovana ako svaki od njih sadr\u017ei centar onog drugog, jer konji su plemenite \u017eivotinje.</p> <p>Za datih \\(N\\) segmenata \\([a_i, b_i]\\) na \\(x\\)-osi, odredite koliko je (neure\u0111enih) parova konjugovanih segmenata me\u0111u njima, jer druga\u010dije poene ne mo\u017eete osvojiti.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Nikola Milosavljevi\u0107 Mom\u010dilo To\u0161i\u0107 <p>Mo\u017eemo za svaki par segmenata proveriti u konstantnoj slo\u017eenosti da li su konjugovani - slo\u017eenost ovog algoritma je \\(O(N^2)\\), \u0161to je dovoljno za Podzadatak 1</p> <p>Ako su koordinate krajeva segmenata brojevi ne ve\u0107i od \\(MaxVal\\), tada postoji \\(O(MaxVal^2)\\) mogu\u0107ih pozicija za segmenate. Mo\u017eemo u nekoj pomo\u0107noj matrici \\(m\\) pamtiti \\(m[i][j] =\\) broj segmenata sa krajevima u \\(i\\) i \\(j\\). Zatim, sli\u010dno kao i u prethodnom slu\u010daju, za svake dve mogu\u0107e pozicije segmenata proverimo da li su oni konjugovani i koliko je to ukupno parova na osnovu matrice \\(m\\). Ukupna slo\u017eenost je \\(O(N + MaxVal^4)\\) \u0161to je dovoljno za Podzadatak 2</p> <p>Jedna od ideja je sortirati segmente neopadaju\u0107e na osnovu koordinate centra \\(c_i = \\frac{a_i+b_i}{2}\\) i za svaki segment \\(i\\) odrediti koliko ima segmenata levo od njega koji su konjugovani sa njim; kona\u010dno re\u0161enje dobijamo kada saberemo ove koli\u010dine za svaki segment. Broj takvih segemenata je jednak broju indeksa \\(j\\) za koje va\u017ei \\(1 \\leq j &lt; i\\) i \\(a_i \\leq c_j\\) i \\(c_i \\leq b_j\\).</p> <p>U Podzadatku 3 su segmenti ve\u0107 sortirani rastu\u0107e po oba kraja posebno (pa samim tim i po centru) pa je skup segmenata levo od \\(i\\)-tog i koji su konjugovani sa \\(i\\)-tim neki uzastopni podniz sortiranog niza segmenata. U svakom koraku se sa po\u010detka ovog podniza mogu izbacivati segmenti koji nisu konjugovani sa trenutnim (ne\u0107e biti konjugovani ni sa \"desnijim\" segmentima zbog uslova podzadatka) pa tehnika dva pokaziva\u010da i/ili binarne pretrage re\u0161ava ovaj podzadatak u slo\u017eenosti \\(O(N)\\) ili \\(O(N \\log N)\\).</p> <p>Pretpostavimo da su sve koordinate centara \\(c_i\\) relativno mali, razli\u010diti celi brojevi (mo\u017eemo se obezbediti da budu celi tako \u0161to na po\u010detku pomno\u017eimo sve krajeve segemenata sa \\(2\\)). Defini\u0161imo niz \\(A\\) gde je za svako \\(i=\\overline{1,N}\\), \\(A[c_i] = r_i\\) a na ostalim pozicijama su nule. Ako je \\(c_1 &lt; c_2 &lt; \\ldots &lt; c_N\\), tada je broj segmenata koji su levo od segmenta \\(i\\) i koji su konjugovani sa njim jednak broju elememenata uzstopnog podniza \\(A[l_i], A[l_i+1],\\ldots, A[c_i - 1]\\) koji su ve\u0107i ili jednaki od \\(c_i\\) (posmatra se samo podniz od \\(l_i\\)-te do \\((c_i-1)\\)-te pozicije jer su indeksi - centri segmenata i oni moraju pripadati \\(i\\)-tom segmentu; vrednosti elementa su desni krajevi tih segmenata pa moraju biti \\(\\geq c_i\\) da bi sadr\u017eali centar \\(i\\)-tog segmenta). </p> <p>Ovim se zadatak svodi na relativno poznat problem: dat je niz \\(A\\) du\u017eine \\(M\\) i \\(N\\) upita oblika \\((l, r, k)\\) - odrediti koliko ima elemenata u podnizu \\(A[l..r]\\) koji su ve\u0107i ili jednaki \\(k\\). Ovaj problem se najlak\u0161e re\u0161ava offline koriste\u0107i strukturu segmentno stablo. Na po\u010detku napunimo pomo\u0107ni niz \\(B\\) nulama i sortiramo sve elememente i upite (zajedno) opadaju\u0107e po vrednosti elementa odnosno vrednosti \\(k\\) u upitima. Zatim idemo redom po sortiranom nizu i kada nai\u0111emo na neki element \\(A[i]\\), na poziciji \\(i\\) u nizu \\(B\\) postavimo jedinicu; kada nai\u0111emo na upit \\((l,r,k)\\), samo odredimo broj (ili zbir) svih elemenata u nizu \\(B\\) na pozicijama od \\(l\\) do \\(r\\) jer su u tom trenutku dodati samo elementi iz \\(A\\) koji su ve\u0107i ili jednaki \\(k\\). Ovo se jednostavno radi segmentnim stablom u ukupnoj slo\u017eenosti \\(O(M + N \\log M)\\).</p> <p>U Podzadatku 4 su vrednosti \\(c_i\\) zaista dovoljno male da se njima mo\u017ee direktno indeksirati niz \\(A\\) (tj. ovde je \\(M \\leq 10^6\\)) a slu\u010dajevi se jednakim \\(c_i\\)-ovima se re\u0161avaju malom modifikacijom algoritma. Kada su vrednosti \\(c_i\\) velike (npr. do \\(10^9\\)) treba koristiti implicitno segmentno stablo ili, jednostavnije, kompresovati koordinate na po\u010detku, \u0161to daje algoritam slo\u017eenosti \\(O(N \\log MaxVal)\\) ili \\(O(N \\log N)\\) koji re\u0161ava sve podzadatke. </p> <p>Alternativni pristup (za re\u0161avanje problema na koji smo sveli originalni problem) je kori\u0161\u0107enje takozvane \\(Sqrt\\)-dekompozicije gde delimo niz na \\(\\sqrt{N}\\) delova veli\u010dine \\(\\sqrt{N}\\) i za svaki od njih pamtimo sortirani niz elemenata iz tog dela. Kada do\u0111e upit \\((l,r,k)\\), za najvi\u0161e dva dela u kojima su krajevi upita odradimo pretragu ru\u010dno a za ostalih \\(O(\\sqrt{N})\\) delova odradimo binarnu pretragu nad odgovaraju\u0107im nizom. Ovo daje algoritam slo\u017eenosti \\(O(N\\sqrt{N}\\log N)\\) koji bi, uz pristojnu implementaciju, tako\u0111e trebalo da osvoji sve poene. Napomenimo da ovaj pristup u istoj slo\u017eenosti re\u0161ava varijantu problema u kome se zahteva da se na upite odgovara u zadatom redosledu (online) i gde su dozvoljeni upiti koji modifikuju pojedina\u010dne elemente (ina\u010de, ova te\u017ea varijanta problema se mo\u017ee re\u0161iti i u slo\u017eenosti \\(O(N \\log^2 N)\\)).</p> 04_konjugacija.cpp<pre><code>#include&lt;cstdlib&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MAX_N = 150000;\nconst int TREE_SIZE = (1 &lt;&lt; 19);\n\nstruct point\n{\n    int type; // 1 - left query, 2 - value, 3 - right query\n    int ind;\n    int position;\n\n    point(int t, int i, int p)\n    {\n        type = t; ind = i; position = p;\n    }\n};\n\nstruct point2\n{\n    int type; // 1 - query, 2 - array element\n    int val;\n    int ind;\n\n    point2(int t, int v, int i)\n    {\n        type = t; val = v; ind = i;\n    }\n};\n\nstruct query\n{\n    int l, r;\n    int val;\n};\n\nbool cmp(const point&amp; A, const point&amp; B)\n{\n    if (A.position != B.position)\n        return (A.position &lt; B.position);\n    return (A.type &lt; B.type); \n}\n\nbool cmp2(const point2&amp; A, const point2&amp; B)\n{\n    if (A.val != B.val)\n        return (A.val &gt; B.val);\n    return (A.type &gt; B.type);\n}\n\nstruct SegmentTree\n{\n    int sum[TREE_SIZE];\n\n    void init()\n    {\n        for (int i = 0; i &lt; TREE_SIZE; i++) sum[i] = 0;\n    }\n\n    // add 1 at position pos\n    void add(int pos)\n    {\n        pos = pos + (TREE_SIZE &gt;&gt; 1) - 1;\n        while (pos &gt; 0)\n        {\n            sum[pos] = sum[pos] + 1;\n            pos = (pos &gt;&gt; 1);\n        }\n    }\n\n    // calculate sum[l..r]\n    long long calc(int node, int node_L, int node_R, int l, int r)\n    {\n        if (node_R &lt; l || node_L &gt; r)\n            return 0;\n        if (l &lt;= node_L &amp;&amp; node_R &lt;= r)\n            return (sum[node]);\n\n        int node_M = (node_L + node_R) &gt;&gt; 1;\n        return calc((node &lt;&lt; 1), node_L, node_M, l, r) + calc((node &lt;&lt; 1) + 1, node_M + 1, node_R, l, r);\n    }\n};\n\nint N;\nlong long sol;\nint l[MAX_N + 10], r[MAX_N + 10];\n\nvector&lt;point&gt; points;\nvector&lt;point2&gt; points2;\nint A[MAX_N + 10];\nquery Q[MAX_N + 10];\nSegmentTree tree;\n\nint main()\n{\n    scanf(\"%d\", &amp;N);\n    sol = 0LL;\n\n    for (int i = 1; i &lt;= N; i++)\n    {   // dupliramo koordinate da bi centar bio ceo broj\n        scanf(\"%d%d\", &amp;l[i], &amp;r[i]);\n        int c = l[i] + r[i];\n        l[i] = 2 * l[i];\n        r[i] = 2 * r[i];\n        points.push_back(point(1, i, l[i]));\n        points.push_back(point(2, i, c));\n        points.push_back(point(3, i, c - 1));\n        Q[i].val = c;\n    }\n\n    // kompresujemo koordinate\n    sort(points.begin(), points.end(), cmp);\n\n    int currInd = 0;\n    for (int i = 0; i &lt; (int)points.size(); i++)\n    {\n        if (points[i].type == 2)\n        {\n            A[++currInd] = r[points[i].ind];\n        }\n        else\n        {\n            if (points[i].type == 1)\n            {\n                Q[points[i].ind].l = currInd + 1;\n            }\n            else\n            {\n                Q[points[i].ind].r = currInd;\n            }\n        }\n    }\n\n    // posebno racunamo kada se centri segmenata poklapaju\n    int lastPos = -1, cnt = 0;\n    for (int i = 0; i &lt; (int)points.size(); i++)\n    {\n        if (points[i].type == 2)\n        {\n            if (points[i].position == lastPos)\n                cnt++;\n            else\n            {\n                cnt = 0;\n                lastPos = points[i].position;\n            }\n            sol = sol + cnt;\n        }\n    }\n\n    // Sada je problem ekvivalentan sa: dat je niz A[1..N] i N upita (l,r,v) sa znacenjem:\n    // koliko ima elemenata u podnizu A[l..r] koji su veci ili jednaki od k?\n    // Resenje je suma odgovora na sve upite. Ovo radimo offline sortiranjem upita\n    // opadajuce po parametru k i dodavanjem odgovarajucih elemenata niza i brojanjem istih\n    // koristeci segmentno stablo.\n\n    for (int i = 1; i &lt;= N; i++)\n    {\n        points2.push_back(point2(1, Q[i].val, i));\n        points2.push_back(point2(2, A[i], i));\n    }\n    sort(points2.begin(), points2.end(), cmp2);\n    tree.init();\n\n    for (int i = 0; i &lt; (int)points2.size(); i++)\n    {\n        if (points2[i].type == 1) // query\n        {\n            int left = Q[points2[i].ind].l;\n            int right = Q[points2[i].ind].r;\n            if (left &lt;= right)\n                sol = sol + tree.calc(1, 1, (TREE_SIZE &gt;&gt; 1), left, right);\n        }\n        if (points2[i].type == 2) // add element\n        {\n            tree.add(points2[i].ind);\n        }\n    }\n\n    printf(\"%lld\\n\", sol);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se prirodan broj \\(N\\) - broj segmenata.</p> <p>U narednih \\(N\\) redova nalaze se po dva cela broja \\(a_i\\) i \\(b_i\\), redom, koji predstavljaju krajeve \\(i\\)-tog segmenta.</p>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza ispisati ceo broj koji predstavlja broj (neure\u0111enih) parova konjugovanih segmenata me\u0111u datim segmentima.</p>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv3/04_konjugacija/#ulaz","title":"Ulaz","text":"<pre><code>5\n7 12\n4 10\n1 21\n20 24\n22 26\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Centar segmenta \\([7,12]\\) je \\(9.5\\) a centar segmenta \\([4,10]\\) je \\(7\\).  Kako segment \\([7,12]\\) sadr\u017ei \\(7\\) a segment \\([4,10]\\) sadr\u017ei \\(9.5\\), ova dva segmenta su konjugovana. Sli\u010dno, segmenti \\([7,12]\\) i \\([1,21]\\) su konjugovani kao i segmenti \\([20,24]\\) i \\([22,26]\\). Kako nema drugih parova konjugovanih segmenata, re\u0161enje je \\(3\\).</p>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv3/04_konjugacija/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n3 8 \n3 8\n3 8\n4 8\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#izlaz_1","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Svaka dva segmenta iz ulaza su konjugovana.</p>"},{"location":"takprog/2021_2022/kv3/04_konjugacija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 150.000\\)</li> <li>\\(0 \\leq a_i \\leq b_i \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 10 poena: \\(N \\leq 1000\\).</li> <li>U testovima vrednim 15 poena: \\(0 \\leq a_i, b_i \\leq 100\\) za \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 20 poena: \\(a_i &lt; a_{i+1}\\) i \\(b_i &lt; b_{i+1}\\) za \\(1 \\leq i &lt;N\\) .</li> <li>U testovima vrednim 25 poena: \\(N \\leq 50.000\\), \\(0 \\leq a_i \\leq b_i \\leq 10^6\\) za \\(1 \\leq i \\leq N\\)</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/","title":"5 - Min max plus","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>Dat je niz od \\(N\\) funkcija \\(F_1(x), F_2(x), \\dots, F_N(x)\\). Ove funkcije su opisane pomo\u0107u dva niza \\(T_1, T_2, \\dots, T_N\\) i \\(K_1, K_2, \\dots, K_N\\) od po \\(N\\) celih brojeva.</p> <ul> <li>\\(F_i(x) = \\left\\{\\begin{array}{lr}min(x, K_i) , &amp; T_i = 1\\\\ max(x, K_i), &amp; T_i = 2\\\\ x + K_i, &amp; T_i = 3 \\end{array}\\right\\}\\)</li> </ul> <p>Potrebno je odgovoriti na \\(Q\\) upita, gde je \\(i\\)-ti upit opisan sa brojevima \\(L_i\\), \\(R_i\\) i \\(X0_i\\). Odgovor na upit je: </p> <ul> <li>\\(F_{L_i}(X0_i) + F_{L_i + 1}(F_{L_i}(X0_i)) + \\dots + F_{R_i}(F_{R_i - 1}(\\dots F_{L_i + 1}(F_{L_i}(X0_i)) \\dots))\\)</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Tadija \u0160ebez Tadija \u0160ebez - Tadija \u0160ebez 05_min_max_plus.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define pb push_back\n#define ll long long\nconst ll inf=2e18;\nconst int N=200050;\nconst int M=2*N;\nint root,tsz,ls[M],rs[M],x[N],tme;\nll mn[M],smn[M],mx[M],smx[M],lzy_bot[M],lzy_top[M],lzy_add[M];\nll lzy_D_bot[M],lzy_D_top[M],lzy_D_add[M];\nvoid pull(int c){\n    if(mn[ls[c]]&lt;mn[rs[c]]){\n        mn[c]=mn[ls[c]];\n        smn[c]=min(smn[ls[c]],mn[rs[c]]);\n    }else if(mn[ls[c]]&gt;mn[rs[c]]){\n        mn[c]=mn[rs[c]];\n        smn[c]=min(mn[ls[c]],smn[rs[c]]);\n    }else{\n        mn[c]=mn[ls[c]];\n        smn[c]=min(smn[ls[c]],smn[rs[c]]);\n    }\n    if(mx[ls[c]]&gt;mx[rs[c]]){\n        mx[c]=mx[ls[c]];\n        smx[c]=max(smx[ls[c]],mx[rs[c]]);\n    }else if(mx[ls[c]]&lt;mx[rs[c]]){\n        mx[c]=mx[rs[c]];\n        smx[c]=max(mx[ls[c]],smx[rs[c]]);\n    }else{\n        mx[c]=mx[ls[c]];\n        smx[c]=max(smx[ls[c]],smx[rs[c]]);\n    }\n}\nvoid Build(int&amp;c,int ss,int se){\n    c=++tsz;\n    lzy_bot[c]=-inf;\n    lzy_top[c]=inf;\n    if(ss==se){\n        mn[c]=mx[c]=x[ss];\n        smn[c]=inf;\n        smx[c]=-inf;\n        return;\n    }\n    int mid=ss+se&gt;&gt;1;\n    Build(ls[c],ss,mid);\n    Build(rs[c],mid+1,se);\n    pull(c);\n}\nvoid upd(int c,ll bot,ll top,ll add,ll D_bot,ll D_top,ll D_add){\n    mn[c]+=add;\n    smn[c]+=add;\n    mx[c]+=add;\n    smx[c]+=add;\n    lzy_bot[c]+=add;\n    lzy_top[c]+=add;\n    lzy_add[c]+=add;\n    lzy_D_add[c]+=D_add;\n    if(mn[c]==mx[c]){\n        if(mn[c]&lt;bot){\n            lzy_add[c]+=bot-mn[c];\n            lzy_D_add[c]+=D_bot;\n            mn[c]=mx[c]=bot;\n        }\n        if(mx[c]&gt;top){\n            lzy_add[c]+=top-mx[c];\n            lzy_D_add[c]+=D_top;\n            mn[c]=mx[c]=top;\n        }\n    }else{\n        if(mn[c]&lt;bot){\n            if(mx[c]==smn[c]){\n                smx[c]=bot;\n            }\n            mn[c]=bot;\n            lzy_bot[c]=bot;\n            lzy_D_bot[c]+=D_bot;\n        }\n        if(mx[c]&gt;top){\n            if(mx[c]==smn[c]){\n                smn[c]=top;\n            }\n            mx[c]=top;\n            lzy_top[c]=top;\n            lzy_D_top[c]+=D_top;\n        }\n    }\n}\nvoid push(int c){\n    if(lzy_bot[c]!=-inf||lzy_top[c]!=inf||lzy_add[c]!=0||lzy_D_add[c]!=0){\n        upd(ls[c],lzy_bot[c],lzy_top[c],lzy_add[c],lzy_D_bot[c],lzy_D_top[c],lzy_D_add[c]);\n        upd(rs[c],lzy_bot[c],lzy_top[c],lzy_add[c],lzy_D_bot[c],lzy_D_top[c],lzy_D_add[c]);\n        lzy_bot[c]=-inf;\n        lzy_top[c]=inf;\n        lzy_add[c]=0;\n        lzy_D_bot[c]=0;\n        lzy_D_top[c]=0;\n        lzy_D_add[c]=0;\n    }\n}\nvoid Min(int c,int ss,int se,int qs,int qe,int k){\n    if(qs&gt;qe||qs&gt;se||ss&gt;qe||k&gt;=mx[c])return;\n    if(qs&lt;=ss&amp;&amp;qe&gt;=se&amp;&amp;k&gt;smx[c]){\n        upd(c,-inf,k,0,0,(ll)(mx[c]-k)*(tme-1),0);\n        return;\n    }\n    int mid=ss+se&gt;&gt;1;\n    push(c);\n    Min(ls[c],ss,mid,qs,qe,k);\n    Min(rs[c],mid+1,se,qs,qe,k);\n    pull(c);\n}\nvoid Max(int c,int ss,int se,int qs,int qe,int k){\n    if(qs&gt;qe||qs&gt;se||ss&gt;qe||mn[c]&gt;=k)return;\n    if(qs&lt;=ss&amp;&amp;qe&gt;=se&amp;&amp;smn[c]&gt;k){\n        upd(c,k,inf,0,(ll)(mn[c]-k)*(tme-1),0,0);\n        return;\n    }\n    int mid=ss+se&gt;&gt;1;\n    push(c);\n    Max(ls[c],ss,mid,qs,qe,k);\n    Max(rs[c],mid+1,se,qs,qe,k);\n    pull(c);\n}\nvoid Add(int c,int ss,int se,int qs,int qe,int k){\n    if(qs&gt;qe||qs&gt;se||ss&gt;qe)return;\n    if(qs&lt;=ss&amp;&amp;qe&gt;=se){\n        upd(c,-inf,inf,k,0,0,(ll)-k*(tme-1));\n        return;\n    }\n    int mid=ss+se&gt;&gt;1;\n    push(c);\n    Add(ls[c],ss,mid,qs,qe,k);\n    Add(rs[c],mid+1,se,qs,qe,k);\n    pull(c);\n}\npair&lt;ll,ll&gt; Get(int c,int ss,int se,int qi){\n    if(ss==se)return {mx[c],lzy_D_add[c]+lzy_D_bot[c]+lzy_D_top[c]};\n    int mid=ss+se&gt;&gt;1;\n    push(c);\n    if(qi&lt;=mid)return Get(ls[c],ss,mid,qi);\n    else return Get(rs[c],mid+1,se,qi);\n}\nint qrd[N],iqrd[N],l[N],r[N],x0[N],t[N],k[N];\nvector&lt;int&gt; Qs[N];\nll ans[N];\nint main(){\n    int n;\n    scanf(\"%i\",&amp;n);\n    for(int i=1;i&lt;=n;i++)scanf(\"%i\",&amp;t[i]);\n    for(int i=1;i&lt;=n;i++)scanf(\"%i\",&amp;k[i]);\n    int q;\n    scanf(\"%i\",&amp;q);\n    for(int i=1;i&lt;=q;i++){\n        scanf(\"%i %i %i\",&amp;l[i],&amp;r[i],&amp;x0[i]);\n        qrd[i]=i;\n        Qs[r[i]].pb(i);\n    }\n    sort(qrd+1,qrd+1+q,[&amp;](int i,int j){return l[i]&lt;l[j];});\n    for(int i=1;i&lt;=q;i++)x[i]=x0[qrd[i]],iqrd[qrd[i]]=i;\n    Build(root,1,q);\n    int ptr=0;\n    for(int i=1;i&lt;=n;i++){\n        while(ptr&lt;q&amp;&amp;l[qrd[ptr+1]]&lt;=i)ptr++;\n        tme++;\n        if(t[i]==1)Min(root,1,q,1,ptr,k[i]);\n        else if(t[i]==2)Max(root,1,q,1,ptr,k[i]);\n        else Add(root,1,q,1,ptr,k[i]);\n        for(int qi:Qs[i]){\n            ll val,D;\n            tie(val,D)=Get(root,1,q,iqrd[qi]);\n            ans[qi]=D+tme*val-(ll)(l[qi]-1)*x0[qi];\n        }\n    }\n    for(int i=1;i&lt;=q;i++)printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi se broj \\(N\\). U drugom redu standardnog ulaza nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(T_i\\). U tre\u0107em redu standardnog ulaza nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(K_i\\). U \u010detvrtom redu standardnog ulaza nalazi se broj \\(Q\\). U narednih \\(Q\\) redova nalazi se po 3 cela broja, u \\(i\\)-tom brojevi \\(L_i\\), \\(R_i\\) i \\(X0_i\\).</p>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati odgovore na upite, u zasebnim redovima.</p>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#ulaz","title":"Ulaz","text":"<pre><code>5\n3 3 2 1 3\n3 8 -7 -6 -6\n2\n1 1 4\n1 4 -5\n</code></pre>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#izlaz","title":"Izlaz","text":"<pre><code>7\n4\n</code></pre>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#objasnjenje","title":"Obja\u0161njenje","text":"<ul> <li>\\(F_1(x) = x + 3\\)</li> <li>\\(F_2(x) = x + 8\\)</li> <li>\\(F_3(x) = max(x, -7)\\)</li> <li>\\(F_4(x) = min(x, -6)\\)</li> <li>\\(F_5(x) = x - 6\\)</li> <li>Za prvi upit: \\(F_1(4) = 7\\)</li> <li>Za drugi upit: </li> <li>\\(F_1(-5) + F_2(F_1(-5)) + F_3(F_2(F_1(-5))) + F_4(F_3(F_2(F_1(-5)))) =\\) </li> <li>\\(-2 + F_2(-2) + F_3(F_2(-2)) + F_4(F_3(F_2(-2))) =\\) </li> <li>\\(-2 + 6 + F_3(6) + F_4(F_3(6)) =\\) </li> <li>\\(-2 + 6 + 6 + F_4(6) = -2 + 6 + 6 -6 = 4\\)</li> </ul>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#ulaz_1","title":"Ulaz","text":"<pre><code>10\n1 1 2 2 1 2 3 2 1 3\n0 10 -7 -15 -13 -7 -4 4 12 -15\n6\n9 9 11\n1 9 -7\n7 7 -20\n1 8 6\n9 10 -2\n9 10 -13\n</code></pre>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#izlaz_1","title":"Izlaz","text":"<pre><code>11\n-51\n-24\n-27\n-19\n-41\n</code></pre>"},{"location":"takprog/2021_2022/kv3/05_min_max_plus/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 2 \\times 10^{5}\\)</li> <li>\\(0 \\leq |K_i| \\leq 10^{9}\\) za \\(T_i \\in \\{ 1, 2 \\}\\)</li> <li>\\(0 \\leq |K_i| \\leq 10^{6}\\) za \\(T_i = 3\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\leq N\\)</li> <li>\\(0 \\leq |X0_i| \\leq 10^{9}\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 8 poena: \\(N, Q \\leq 10^{3}\\).</li> <li>U testovima vrednim 20 poena: \\(T_i = 3\\) za sve \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 20 poena: \\(T_i = 1\\) za sve \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 24 poena: \\(N, Q \\leq 4 \\times 10^{4}\\).</li> <li>U testovima vrednim 28 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/okr/01_odbijanje/","title":"B1 - Odbijanje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 512MB <p>Komisija je za ovo takmi\u010denje ponovo spremila \u010dudan ure\u0111aj i naizgled beskorisna pitanja o njemu: idealnu gumenu lopticu i stazu po kojoj se ona kotrlja. Stazu \u0107emo posmatrati kao pravu liniju, gde loptica po\u010dinje na poziciji \\(0\\), kre\u0107u\u0107i se brzinom 1 u desno, ka pozitivnim pozicijama (dakle, nakon jedne sekunde \u0107e biti na poziciji 1, nakon dve na poziciji 2, ...).</p> <p>Da bi staza bila zanimljivija, na njoj se nalazi \\(N\\) zidova na pozicijama \\(X_i\\) i stabilnostima \\(S_i\\). Kada loptica udari u zid, odbija se i po\u010dinje da se kre\u0107e u suprotnom smeru. Kako je loptica idealna, nastavi\u0107e da se kre\u0107e istom brzinom \\(1\\). Nakon sudara, stabilnost zida se smanjuje za \\(1\\), i ako se smanjila na \\(0\\), taj zid nestaje.</p> <p>Komisiju interesuje program koji \u0107e, za date pozicije i stabilnosti zidova, odrediti koliko \u0107e vremena pro\u0107i od po\u010detka kretanja loptice do poslednjeg sudara sa zidom.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Dimitrije Erdeljan Andrej Iva\u0161kovi\u0107 Andrej Iva\u0161kovi\u0107"},{"location":"takprog/2021_2022/okr/01_odbijanje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu dat je jedan prirodni broj, broj zidova \\(N\\). U narednih \\(N\\) redova su data po dva cela broja \\(X_i, S_i\\), redom pozicija i stabilnost \\(i\\)-tog zida.</p>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu izlaza je potrebno ispisati broj sekundi od po\u010detka kretanja loptice do poslednjeg sudara sa zidom. Kako ovaj broj mo\u017ee biti veoma velik, ispi\u0161ite njegov ostatak pri deljenju sa \\(10^9 + 7\\).</p>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/okr/01_odbijanje/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 7\n-1 1\n-3 1\n</code></pre>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#izlaz","title":"Izlaz","text":"<pre><code>18\n</code></pre>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Kuglica po\u010dinje na poziciji \\(0\\), i za dve sekunde udara u zid na poziciji \\(2\\), \u010dija stabilnost se smanjuje na \\(7-1 = 6\\). Odbija se i kre\u0107e u desno, i nakon tri sekunde se sudara sa zidom na poziciji \\(-1\\), koji nakon sudara nestaje. Dalje se kuglica kre\u0107e tri sekunde desno, pa pet sekundi levo, i kada se odbije od zida na \\(-3\\) taj zid nestaje. Kona\u010dno, kre\u0107e se jo\u0161 pet sekundi do zida na poziciji \\(2\\), \u0161to je poslednje odbijanje jer nakon njega vi\u0161e nema zidova na putanji loptice.</p> <p>Ukupan broj sekundi od po\u010detka je \\(2 + 3 + 3 + 5 + 5 = 18\\).</p>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/okr/01_odbijanje/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n10000000 1234567\n-10000000 12345678\n</code></pre>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#izlaz_1","title":"Izlaz","text":"<pre><code>669654326\n</code></pre>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(|X_i| \\leq 10^9\\), i sve pozicije \\(X_i\\) su razli\u010dite.</li> <li>\\(1 \\leq N \\leq 5 \\cdot 10^4\\)</li> <li>\\(1 \\leq S_i \\leq 10^9\\)</li> <li>Ne postoji zid na po\u010detnoj poziciji loptice (\\(X_i \\neq 0\\)).</li> <li>Garantuje se da \u0107e se loptica sudariti sa barem jednim zidom.</li> </ul> <p>Primeri su podeljeni u \u010detiri disjunktne grupe: </p> <ul> <li>U test primerima vrednim 30 poena: \\(N \\leq 100, S_i \\leq 100, |X_i|   \\leq 100\\).</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 1000, S_i \\leq 1000\\)</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 5000\\)</li> <li>U test primerima vrednim 30 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#resenje-za-30-poena","title":"Re\u0161enje za 30 poena","text":"<p>Dovoljna je prosta simulacija ovog kretanja: dok god kuglica ima apsolutnu vrednost svoje pozicije ne ve\u0107u od 100, svaka sekunda kretanja se simulira. Vodi se ra\u010duna o trenutnoj poziciji \\(x\\), vremenu od po\u010detka \\(t\\), brzini \\(\\mathit{dx}\\) (koja je ili \\(1\\) ili \\(-1\\)) i trenutku najskorijeg sudara \\(T\\). U svakom koraku se a\u017eurira pozicija (\\(x := x + \\mathit{dx}\\)) i proveri da li pozicija odgovara nekoj od prepreka \u2013 a u tom slu\u010daju se a\u017euriraju otpornost prepreke, brzina i vreme najskorijeg sudara. Ovo re\u0161enje daje ta\u010dan odgovor u vremenskoj slo\u017eenosti \\(O(N \\cdot \\max_i S_i \\cdot \\max_i |X_i|)\\).</p>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#resenje-za-50-poena","title":"Re\u0161enje za 50 poena","text":"<p>Re\u010d je o jednostavnoj optimizacija prethodnog pristupa. Umesto da se u svakom koraku pozicija promeni za 1, dovoljno je voditi ra\u010duna o narednoj udarenoj prepreci sa leve i sa desne strane. Vreme izme\u0111u dva sudara je tada jednako apsolutnoj vrednosti razlike izme\u0111u pozicija te dve prepreke. Najpre treba podeliti prepreke u dva niza: prepreke sa negativnom pozicijom i prepreke sa pozitivnom pozicijom. U ta dva niza se zatim odrede prepreke najbli\u017ee kuglici i vr\u0161i se simulacija kretanja. Kada otpornost neke prepreke postane jednaka nuli, tada se ta prepreka ozna\u010di kao nepostoje\u0107a i bira se najbli\u017ea prepreka sa nenultom otpornosti. Vremenska slo\u017eenost ovog pristupa je \\(O(N \\cdot \\max_i S_i \\cdot \\max_i |X_i|)\\).</p>"},{"location":"takprog/2021_2022/okr/01_odbijanje/#resenja-za-70-i-100-poena","title":"Re\u0161enja za 70 i 100 poena","text":"<p>Ova dva re\u0161enja su maltene identi\u010dna i razlikuju se po tome \u0161to koriste razli\u010dite algoritme sortiranja: \\(O(N^2)\\) vremenske slo\u017eenosti i \\(O(N \\log N)\\) vremenske slo\u017eenosti. Najpre se, kao u prethodnom re\u0161enju, razdvoje nizovi prepreka levo od nule i prepreka desno od nule. Zatim se ti nizovi sortiraju po apsolutnoj vrednosti pozicije i tako se odre\u0111uje redosled kojim se kuglica sudara sa preprekama. Da li je poslednje odbijanje sa nekim levim zidom ili desnim zidom se odre\u0111uje pore\u0111enjem ukupnih otpornosti desnih zidova i levih zidova: * ako je ukupna otpornost desnih zidova \\(r\\) manja ili jednaka ukupnoj otpornosti levih \\(l\\), tada sa leve strane imamo \\(l\\) odbijanja, a sa desne \\(l+1\\) odbijanje; * u suprotnom, sa leve strane i desne strane imamo po \\(r\\) odbijanja. Na osnovu ukupnog broja odbijanja sa obe strane je mogu\u0107e odrediti za svaku \u201cdeonicu\u201d (prostor izme\u0111u dve uzastopne prepreke) koliko je puta pre\u0111ena. Na primer, ako je do\u0161lo do \\(m\\) odbijanja sa leve strane, tada je prva deonica (od 0 do prvog zida) pre\u0111ena \\(2m\\) puta, druga \\(2(m-\\mathit{otp\\_levih}[0])\\) puta itd, dokle god preostali broj odbijanja ne postane negativan. Neophodno je posvetiti pa\u017enju poslednjem sudaru i oduzeti \\(1\\) od broja prelazaka poslednje deonice.</p> 01_odbijanje.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nconst int N = 500005;\nconst long long MOD = 1000000007;\n\nstruct wall {\n    int x, hp;\n} ;\n\nwall left[N], right[N];\n\nlong long totalside(wall *walls, int n, long long todo, bool exit) {\n    long long res = 0;\n\n    for(int i = 0; i &lt; n; i++) {\n        int take = std::min(todo, (long long)walls[i].hp);\n        walls[i].hp -= take; todo -= take;\n\n        long long mult = (todo == 0 &amp;&amp; take &gt; 0 &amp;&amp; exit) ? (2*take - 1) : 2*take;\n        res += mult * walls[i].x;\n        res %= MOD;\n    }\n\n    return res;\n}\n\nint main() {\n    int n, nleft = 0, nright = 0;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) {\n        int x, hp;\n        scanf(\"%d %d\", &amp;x, &amp;hp);\n        if(x &lt; 0) {\n            left[nleft++] = {x, hp};\n        } else {\n            right[nright++] = {x, hp};\n        }\n    }\n\n    std::sort(left, left + nleft, [](wall a, wall b) { return a.x &gt; b.x; });\n    std::sort(right, right + nright, [](wall a, wall b) { return a.x &lt; b.x; });\n\n    long long l = 0, r = 0;\n    for(int i = 0; i &lt; nleft; i++) l += left[i].hp;\n    for(int i = 0; i &lt; nright; i++) r += right[i].hp;\n\n    bool exitright = r &lt;= l;\n    if(r &gt; l) r = l + 1;\n    else if(r &lt; l) l = r;\n\n    long long res = totalside(right, nright, r, !exitright) - totalside(left, nleft, l, exitright);\n    res = (res + MOD) % MOD;\n    printf(\"%lld\\n\", res);\n\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/okr/02_stale/","title":"B2 - \u0160tale","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>U ovom zadatku opusti\u0107emo se od u\u017eurbanog gradskog \u017eivota i baviti se konjima i \u0161talama. Trenutno obilazite farmu koju predstavlja dvodimenzionalna ravan sa \u0161talama koje predstavljaju ta\u010dke u ovoj ravni. Vi ste na konju koji mnogo voli ceo broj \\(c\\) i u jednom koraku mo\u017ee pre\u0107i du\u017e od ta\u010dke \\((x,y)\\) do \\((x+ac,y+bc)\\), gde \\(a,b \\in \\{-1,0,1\\}\\) (dakle, mo\u017ee oti\u0107i \\(c\\) polja u levo, desno, gore ili dole, kao i \"po dijagonali\"). Ukoliko se neka \u0161tala na\u0111e na putu konja (na krajevima ove du\u017ei ili negde na njoj), smatramo da smo je obi\u0161li. \u017delimo da znamo koliko najvi\u0161e \u0161tala mo\u017eemo obi\u0107i ako kre\u0107emo iz proizvoljne \u0161tale od onih datih u ulazu (nije va\u017ean broj koraka, niti iko brani konju da vi\u0161e puta bude u istoj ta\u010dki).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107 Vladimir Milovanovi\u0107 Andrej Iva\u0161kovi\u0107 <p>Prema postavci zadatka, konj se, iz proizvoljne ta\u010dke, mo\u017ee kretati horizontalno, vertikalno, kao i (anti-)dijagonalno. Dodatno ograni\u010denje je da se konj, polaze\u0107i iz neke ta\u010dke, isklju\u010divo kre\u0107e po dvodimenzionalnoj re\u0161etki puteva, odnosno mre\u017ei ta\u010daka koje su me\u0111usobno udaljene \\(s\\) jedna od druge. Nije te\u0161ko uvideti da iz odre\u0111ene ta\u010dke u kojoj se trenutno nalazi, konj mo\u017ee pro\u0107i kroz bilo koju drugu ta\u010dku koja se nalazi na pomenutoj re\u0161etki puteva.</p>"},{"location":"takprog/2021_2022/okr/02_stale/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu dati su razmakom razdvojeni brojevi \\(n\\) i \\(c\\) (\\(n\\) je broj \u0161tala, a \\(c\\) omiljeni broj konja). Zatim se unose \\(n\\) redova, i u \\(i\\)-tom od njih dati su razmakom razdvojeni celi brojevi \\(x_i\\) i \\(y_i\\), koji predstavljaju \\(x\\) i \\(y\\) koordinatu \\(i\\)-te \u0161tale (nikoje dve \u0161tale se ne preklapaju).</p>"},{"location":"takprog/2021_2022/okr/02_stale/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu izlaza potrebno je ispisati tra\u017eeni rezultat.</p>"},{"location":"takprog/2021_2022/okr/02_stale/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/okr/02_stale/#ulaz","title":"Ulaz","text":"<pre><code>4 3\n0 0\n0 5\n6 4\n2 1\n</code></pre>"},{"location":"takprog/2021_2022/okr/02_stale/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/okr/02_stale/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako krenemo od \u0161tale \\((0,5)\\), u dva koraka sti\u017eemo do \\((0,-1)\\), kre\u0107u\u0107i se du\u017e \\(y\\) ose, tako prolaze\u0107i kroz prvu \u0161talu. Na dijagonali od \\((0,-1)\\) do \\((3,2)\\) nalazi se i \u0161tala \\((2,1)\\), te tako nju obi\u0111emo. Sada smo u \\((3,2)\\) i idemo u jednom koraku do \\((6,2)\\) kre\u0107u\u0107i se \"na desno\" dok onda odemo \"na gore\" i do\u0111emo do \\((6,5)\\), pro\u0161av\u0161i kroz poslednju \u0161talu, \u010dime je na\u0161 obilazak svih 4 \u0161tala zavr\u0161en.</p>"},{"location":"takprog/2021_2022/okr/02_stale/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/okr/02_stale/#ulaz_1","title":"Ulaz","text":"<pre><code>5 4\n1 1\n1 6\n4 12\n-1 0\n-1 -2\n</code></pre>"},{"location":"takprog/2021_2022/okr/02_stale/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2021_2022/okr/02_stale/#ogranicenja","title":"Ograni\u010denja:","text":"<ul> <li>\\(n \\leq 200.000\\)</li> <li>\\(1 &lt; c &lt; 100\\)</li> <li>\\(-10^9 &lt; x_i,y_i &lt; 10^9\\)</li> </ul> <p>Primeri su podeljeni u 5 disjunktnih grupa: </p> <ul> <li>U test primerima vrednim 15 poena: \\(n \\leq 8\\)</li> <li>U test primerima vrednim 25 poena: \\(n \\leq 18\\)</li> <li>U test primerima vrednim 10 poena: \\(c = 2\\)</li> <li>U test primerima vrednim 25 poena: \\(n \\leq 2000\\)</li> <li>U test primerima vrednim 25 poena: nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/okr/02_stale/#kvadratno-resenje-za-65-poena","title":"Kvadratno re\u0161enje za 65 poena","text":"<p>Dovoljno je u dve ugne\u017e\u0111ene petlje pro\u0107i po svim \u0161talama i ispitati da li je mogu\u0107e do\u0107i od jedne do druge, ra\u010dunaju\u0107i da se od \\(i\\)-te do \\(j\\)-te \u0161tale (naravno, samo za indekse \\(i \\neq j\\)) mo\u017ee do\u0107i ako im se poklapaju horizontalne (\\(x\\)) ili vertikalne (\\(y\\)) koordinate ili se pak poklapa razlika ili zbir vertikalnih i horizonalnih koordinata (to jest nalaze se dijagonalno/antidijagonalno jedna od druge), pri \u010demu se 4 pomenutih jednakosti (jednake vrednosti \\(x\\), \\(y\\), \\(x-y\\), \\(x+y\\)) ra\u010dunaju po modulu \\(c\\) uz uslov da moduo bude pozitivan. Kako se u svakoj od dve petlje prolazi kroz sve \u0161tale i \u010duva maksimum, ovo re\u0161enje ima kvadratnu vremensku slo\u017eenost, odnosno \\(\\mathcal{O}(n^2)\\), gde \\(n\\) predstavlja broj \u0161tala.</p>"},{"location":"takprog/2021_2022/okr/02_stale/#glavno-resenje-u-linearnoj-slozenosti","title":"Glavno re\u0161enje u linearnoj slo\u017eenosti","text":"<p>Da bi se zadatak uradio na efikasan na\u010din, svrsishodno je makar prividno preslikati dvodimenzionalnu ravan \\((x, y)\\) na matricu dimenzija \\(c \\times s\\). Preslikavanje se vr\u0161i tako \u0161to se polje u \\(i\\)-toj vrsti i \\(j\\)-oj koloni pomenute matrice popunjava sa onoliko \u0161tala koliko ih se nalazi na koordinatama \\(x \\mod c = i\\) i \\(y \\mod c = j\\). Sve \u0161to je tada potrebno u\u010diniti jeste prona\u0107i polje u matrici sa najve\u0107im zbirom ostalih elemenata koji se nalaze u istoj vrsti i koloni, kao i na istoj dijagonali i antidijagonali, ta\u010dnije sam zbir pomenutih elemenata sa trenutnim poljem koji zapravo predstavlja tra\u017eeno re\u0161enje zadatka. Prilikom prolaska kroz matricu treba biti pa\u017eljiv i obratiti pa\u017enju da se samo polje kroz koje se prolazi ne ura\u010duna vi\u0161e puta, kao i to da se, za parno \\(c\\), polja na (produ\u017eenoj) dijagonali i antidijagonali mogu poklapati, odnosno da se (produ\u017eene) dijagonale mogu se\u0107i. Kako je sama operacija preslikavanja ravni na matricu linearna po \\(n\\), to jest \\(\\mathcal{O}(n)\\), a prolazak kroz matricu u op\u0161tem slu\u010daju kvadratan po njenim dimenzijama, preciznije \\(\\mathcal{O}(c^2)\\), jasno je iz postavke zadatka u kojoj se ka\u017ee da je \\(n\\leq200'000\\), a \\(c\\leq100\\), pa je \\(n&gt;c^2\\), prvi \u010dlan dominantan, te je i ukupna vremenska slo\u017eenost re\u0161enja, pod ovakvim pretpostavkama, linearna po broju \u0161tala.</p>"},{"location":"takprog/2021_2022/okr/02_stale/#alternativno-resenje","title":"Alternativno re\u0161enje","text":"<p>Kako je uslov da se iz ta\u010dke \\((x_1,y_1)\\) ta\u010dka \\((x_2, y_2)\\) mo\u017ee obi\u0107i: \\(x_1 = x_2 \\lor y_1 = y_2 \\lor x_1-y_1 = x_2-y_2 \\lor x_1+y_1 = x_2+y_2\\), gde je jednakost po modulu \\(c\\), to mo\u017eemo za svaku ta\u010dku tra\u017eiti broj ta\u010daka za koji va\u017ei ovaj uslov kao broj elemenata unije 4 skupa (skup svih sa odre\u0111enom \\(x\\) ili \\(y\\) koordinatom, ili odre\u0111enom razlikom/zbirom dveju koordinata). Ovo se mo\u017ee re\u0161iti formulom uklju\u010denja-isklju\u010denja za 4 skupa, gde veli\u010dine preseka brojimo vi\u0161edimenzionalnim matricama (ukupna memorijska slo\u017eenost je \\(\\mathcal{O}(c^4)\\), \u0161to je u praksi i dosta manje od \\(512\\) MB, dok je vremenska linearna jer svaku \u0161talu ubacujemo u konstantan broj skupova koji slu\u017ee za prebrojavanje).</p> 02_stale.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nvoid fix(int &amp;x, int c){\n    if(x &lt; 0){\n        x += c;\n    }\n}//A - x\n//B - y\n//C - x+y\n//D - x-y\nint x[200100], y[200010];\nint A[100],B[100],C[100],D[100],AB[100][100],AC[100][100],AD[100][100],BC[100][100],BD[100][100],CD[100][100],ABC[100][100][100],ABD[100][100][100],ACD[100][100][100],BCD[100][100][100],ABCD[100][100][100][100];\n\nint main(){\n        int n, c;\n        cin &gt;&gt; n &gt;&gt; c;\n        for(int j = 0; j &lt; n; ++j){\n            cin &gt;&gt; x[j] &gt;&gt; y[j];\n            int xMod = x[j]%c, yMod = y[j]%c, xmyMod = (x[j]-y[j])%c, xpyMod = (x[j]+y[j])%c;\n            fix(xMod,c);\n            fix(yMod,c);\n            fix(xmyMod,c);\n            fix(xpyMod, c);\n            A[xMod]++;\n            B[yMod]++;\n            C[xpyMod]++;\n            D[xmyMod]++;\n            AB[xMod][yMod]++;\n            AC[xMod][xpyMod]++;\n            AD[xMod][xmyMod]++;\n            BC[yMod][xpyMod]++;\n            BD[yMod][xmyMod]++;\n            CD[xpyMod][xmyMod]++;\n            ABC[xMod][yMod][xpyMod]++;\n            ABD[xMod][yMod][xmyMod]++;\n            ACD[xMod][xpyMod][xmyMod]++;\n            BCD[yMod][xpyMod][xmyMod]++;\n            ABCD[xMod][yMod][xpyMod][xmyMod]++;\n        }\n        int ans = 1;\n        for(int j = 0; j &lt; n; ++j){\n            int xMod = x[j]%c, yMod = y[j]%c, xmyMod = (x[j]-y[j])%c,xpyMod = (x[j]+y[j])%c;\n            fix(xMod,c);\n            fix(yMod,c);\n            fix(xmyMod,c);\n            fix(xpyMod, c);\n            ans = max(ans, A[xMod] + B[yMod]+ C[xpyMod] + D[xmyMod] -\n                      AB[xMod][yMod] - AC[xMod][xpyMod] - AD[xMod][xmyMod] - BC[yMod][xpyMod] - BD[yMod][xmyMod] - CD[xpyMod][xmyMod] +\n                      ABC[xMod][yMod][xpyMod] + ABD[xMod][yMod][xmyMod] + ACD[xMod][xpyMod][xmyMod] + BCD[yMod][xpyMod][xmyMod] -\n                      ABCD[xMod][yMod][xpyMod][xmyMod] );\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    }\n</code></pre>"},{"location":"takprog/2021_2022/okr/03_okram/","title":"B3 - Okram","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 512MB <p>Prethodnih godina, duologija o velikom \u0161efu mafije ekskluzivne disjunkcije Okram \u0106ivas postali su neki od najpopularnijih i najvoljenijih filmova na tr\u017ei\u0161tu. Duologija se sastoji od, kao \u0161to ime ka\u017ee, dva filma, koji se zovu Okram i \u0106ivas. U ovom zadatku bavi\u0107emo se prvim delom duologije - Okramom.</p> <p>U prvoj avanturi na\u0161eg heroja, on se zatekao u misterioznoj matrici, dimenzija \\(M\\times N\\). Ova matrica je po mnogo tome misteriozna, a jedan od glavnih razloga je \u0161to se smatra da su u njoj dva polja susedna ako dele stranicu. Jo\u0161 misterioznije, dva polja u istoj koloni, od kojih je jedan u prvom redu, a drugi u poslednjem redu, kao i dva polja u istom redu od kojih je jedan u prvoj koloni, a drugi u poslednjoj koloni se tako\u0111e smatraju susednim! Ovo zna\u010di da je svako polje susedno sa ta\u010dno \\(4\\) polja.  Na po\u010detku, svako polje ima svoju vrednost, koja je Okramu \u0106ivasu poznata. Svake sekunde, iz nepoznatih razloga, svako polje promeni vrednost u ekskluzivnu disjunkciju (poznatu i kao <code>xor</code>) vrednosti svojih suseda u prethodnoj sekundi.</p> <p>Kako je Okram \u0106ivas poznat po svojoj majstoriji sa ekskluzivnom disjunkcijom, on je sebi postavio \\(Q\\) pitanja slede\u0107e sadr\u017eine: koju vrednost ima polje u preseku reda \\(x\\) i kolone \\(y\\), posle \\(2^k\\) sekundi (svaki \u010dovek koji voli bitovske operacije voli i stepene dvojke)?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Mom\u010dilo To\u0161i\u0107"},{"location":"takprog/2021_2022/okr/03_okram/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei tri broja, broj redova \\(N\\), broj kolona \\(M\\) i broj upita \\(Q\\). Narednih \\(N\\) linija sadr\u017ee po \\(M\\) prirodnih brojeva: gde \\(j\\)-ti broj u \\((i+1)\\)-voj liniji predstavlja broj \\(A_{ij}\\), koji ozna\u010dava po\u010detnu vrednost (u \\(0\\)-toj sekundi) polja u \\(i\\)-tom redu i \\(j\\)-toj koloni. Narednih \\(Q\\) linija sadr\u017ei po \\(3\\) broja: \\(x,y,k\\), koji predstavljaju pitanja iz teksta.</p>"},{"location":"takprog/2021_2022/okr/03_okram/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je postrebno ispisati \\(Q\\) linija: u \\(i\\)-toj liniji treba odgovoriti na \\(i\\)-to pitanje.</p>"},{"location":"takprog/2021_2022/okr/03_okram/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/okr/03_okram/#ulaz","title":"Ulaz","text":"<pre><code>3 3 2\n1 2 3\n4 5 6\n7 8 9\n1 1 0\n2 2 1\n</code></pre>"},{"location":"takprog/2021_2022/okr/03_okram/#izlaz","title":"Izlaz","text":"<pre><code>2\n8\n</code></pre>"},{"location":"takprog/2021_2022/okr/03_okram/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Posle prve sekunde matrica \u0107e izgledati ovako: <pre><code>2 15 12\n5 8 11\n4 9 10\n</code></pre> Vrednost u sredini posle druge sekunde \u0107e biti jednaka \\(15\\text{ xor }11\\text{ xor }9\\text{ xor }5=8\\).</p>"},{"location":"takprog/2021_2022/okr/03_okram/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N,M \\leq 1500\\)</li> <li>\\(1\\leq Q\\leq 200.000\\)</li> <li>\\(0\\leq A_{ij}\\leq 1.000.000\\)</li> <li>\\(1\\leq x\\leq N\\)</li> <li>\\(1\\leq y\\leq M\\)</li> <li>\\(0\\leq k\\leq 1.000.000\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N,M\\leq5\\) i \\(A_{ij}\\leq 1\\)</li> <li>U test primerima vrednim \\(10\\) poena: \\(K\\leq5\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(K\\leq200\\)</li> <li>U test primerima vrednim \\(30\\) poena: Sve po\u010detne vrednosti su \\(0\\) osim jedne koja je \\(1\\).</li> <li>U test primerima vrednim \\(30\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/okr/03_okram/#napomena","title":"Napomena","text":"<p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa  <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola  <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in {1, \\ldots, k }\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\ y\\).</p> <p>Ako \u017eelite da saznate \u0161ta se desi u nastavku, pogledajte drugi zadatak za \\(A\\) kategoriju: \u0106ivas</p>"},{"location":"takprog/2021_2022/okr/03_okram/#resenje-kada-n-m-leq-5-a_i-leq-1","title":"Re\u0161enje kada \\(N, M \\leq 5, A_i \\leq 1\\)","text":"<p>Po\u0161to su dimenzije matrice male, a jedine mogu\u0107e vrednosti u matrici \\(0\\) i \\(1\\), postoji dosta malo stanja u kojima se mo\u017ee na\u0107i matrica. Simuliramo proces sekundu po sekundu, dok se ne desi da smo ve\u0107 videli dato stanje. Po\u0161to znamo da \u0107emo na dalje da se vrtimo u krug, znamo da \u0107e re\u0161enje biti jedno od datih stanja. Koje ta\u010dno stanje \u0107e to biti mo\u017eemo dobiti koriste\u0107enjem formula.</p>"},{"location":"takprog/2021_2022/okr/03_okram/#resenje-kada-k-leq-5","title":"Re\u0161enje kada \\(K \\leq 5\\)","text":"<p>Po\u0161to je \\(K \\leq 5\\), zna\u010di da nam je bitno samo pona\u0161anje matrice u prvih \\(2^5 = 32\\) sekundi. Pre svih pitanja, izra\u010duna\u0107emo sve matrice, i onda za svako pitanje mo\u017eemo samo ispisati tra\u017eeno polje odgovaraju\u0107e matrice.</p> <p>Vremenska slo\u017eenost je \\(O(2^KNM + Q)\\), a memorijska \\(O(2^KNM)\\). </p>"},{"location":"takprog/2021_2022/okr/03_okram/#resenje-kada-k-leq-200","title":"Re\u0161enje kada \\(K \\leq 200\\)","text":"<p>Ponovo \u0107emo \u010duvati matrice za svako \\(K\\), ali ovaj put \u0107emo ih ra\u010dunati na na\u010din koji \u0107e biti opisan u slede\u0107a dva re\u0161enja. </p>"},{"location":"takprog/2021_2022/okr/03_okram/#resenje-kada-su-sve-pocetne-vrednosti-0-sem-jedne-koja-je-1","title":"Re\u0161enje kada su sve po\u010detne vrednosti \\(0\\), sem jedne koja je \\(1\\)","text":"<p>Posmatranjem kako se ova jedinica pona\u0161a kroz vreme u beskona\u010dnoj matrici mo\u017eemo zaklju\u010diti da \u0107e nakon \\(2^K\\) sekundi da se nalazi na pozicijama \\((x+2^K, y)\\), \\((x-2^K, y)\\), \\((x, y+2^K)\\) i \\((x, y-2^K)\\). Ovo mo\u017eemo i jednostavno dokazati indukcijom. Za bazu \\(K = 0\\) ovo je o\u010digledno ta\u010dno. Ako pretpostavimo da je ta\u010dno za neko \\(K\\), i primenimo induktivnu hipotezu na \\(4\\) tako dobijene ta\u010dke, vide\u0107emo da se de\u0161ava ne\u0161to zanimljivo - sva polja sem ona \\(4\\) koja su nam potrebna se skrate (xor je inverz sam sebi), pa smo dokazali tvr\u0111enje. </p> <p>Sada, za svako pitanje je dovoljno proveriti da li je u pitanju jedno od najvi\u0161e \u010detiri polja koji sadr\u017ee jedinicu. Po\u0161to ova matrica nije beskona\u010dna, moramo koriste\u0107i formule da dobijemo ta\u010dne koordinate jedinica u njoj. </p> <p>Vremenska slo\u017eenost je \\(O(NM+M+K)\\), a memorijska \\(O(NM+K)\\). </p>"},{"location":"takprog/2021_2022/okr/03_okram/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo da \u0107e sva polja u matrici biti xor nekih polja po\u010detne matrice. Koriste\u0107i prethodno re\u0161enje, za svako polje po\u010detne matrice mo\u017eemo prona\u0107i u xor-u kojih polja matrice \u0107e se nalaziti nakon \\(2^K\\) sekundi. Tako mo\u017eemo zaklju\u010diti da \u0107e vrednost polja \\((x, y)\\) nakon \\(2^K\\) sekundi biti xor vrednosti polja \\((x+2^K, y)\\), \\((x-2^K, y)\\), \\((x, y+2^K)\\) i \\((x, y-2^K)\\) u po\u010detnoj matrici. </p> <p>Vremenska slo\u017eenost je \\(O(NM+M+K)\\), a memorijska \\(O(NM+K)\\). matrici. </p> 03_okram.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint a[1500][1500],stn[1000007],stm[1000007];\nint main()\n{\n    int n,m,q;\n    scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q);\n    for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf(\"%d\",&amp;a[i][j]);\n    stn[0]=stm[0]=1;\n    for(int i=1;i&lt;1000007;i++) stn[i]=(stn[i-1]*2)%n;\n    for(int i=1;i&lt;1000007;i++) stm[i]=(stm[i-1]*2)%m;\n    while(q--)\n    {\n        int x,y,k;\n        scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;k); x--; y--;\n        printf(\"%d\\n\",a[(x+stn[k])%n][y]^a[(x+n-stn[k])%n][y]^a[x][(y+stm[k])%m]^a[x][(y+m-stm[k])%m]);\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/okr/04_slicice/","title":"A1 - Sli\u010dice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Jakov skuplja sli\u010dice za album. U ovoj ekskluzivnoj kolekciji postoji \\(N\\) razli\u010ditih vrsta sli\u010dica koje je mogu\u0107e skupiti i na njima su naslikani razli\u010diti prirodni brojevi od \\(1\\) do \\(N\\). Svaka od tih \\(N\\) vrsta sli\u010dica je od\u0161tampana u vi\u0161e primeraka. Jakov je do sada ve\u0107 skupio \\(N\\) sli\u010dica, a na svakoj od njih je napisan broj \\(2\\) (tj. Jakov je skupio \\(N\\) primeraka vrste sli\u010dice sa brojem \\(2\\)).</p> <p>Sre\u0107om po Jakova on mo\u017ee da razmenjuje svoje sli\u010dice sa dru\u0161tvom. Me\u0111utim, pravila razmene su stroga. Dva druga mogu da razmene sli\u010dice samo ukoliko je najve\u0107i zajedni\u010dki delilac brojeva nacrtanim na njima strogo ve\u0107i od \\(1\\). Kada se razmeni sa nekim, Jakov vi\u0161e nema sli\u010dicu koju je dao, ali mo\u017ee da koristi sli\u010dicu koju je upravo dobio za druge trampe. Jakov se pita koliko najvi\u0161e razli\u010ditih vrsta sli\u010dica mo\u017ee skupiti nakon svih razmena?</p> <p>Jakov se tako\u0111e pita i koliko bi sli\u010dica uspeo da skupi za neke druge vrednosti broja \\(N\\). Potrebno je odgovoriti na \\(Q\\) ovakvih pitanja. Upiti su nezavisni, tj. na svaki se posebno odgovara i za svaki od upita, Jakov na po\u010detku ima \\(N\\) sli\u010dica sa vredno\u0161\u0107u \\(2\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Plav\u0161i\u0107 <p>Za po\u010detak odredimo koje karte Jakov mo\u017ee skupiti, a koje ne mo\u017ee.</p> <p>Jakov mo\u017ee skupiti kartu sa bilo kojim parnim brojem, jer je najve\u0107i zajedni\u010dki delilac za \\(2\\) (Jakov ima na raspolaganju proizvoljno mnogo karti sa brojem \\(2\\)) i tog parnog broja jednak \\(2\\) \u0161to je ve\u0107e od \\(1\\).</p> <p>Jakov mo\u017ee skupiti i karte sa neparnim brojevima \\(p\\) ne ve\u0107im od \\(\\lfloor\\frac{n}{2}\\rfloor\\) (naravno, ve\u0107im od \\(1\\)), jer prvo mo\u017ee kartu sa brojem \\(2\\) razmeniti za kartu sa brojem \\(2p\\), a nakon toga kartu sa brojem \\(2p\\) za kartu sa brojem \\(p\\).</p> <p>Na kraju mo\u017ee skupiti i karte sa bilo kojim slo\u017eenim neparnim brojem \\(m\\) iz intervala \\(\\left[\\lceil\\frac{n}{2}\\rceil,n\\right]\\). Svaki takav neparan slo\u017een broj ima bar jedan prost faktor \\(p\\leq \\sqrt{m} \\leq \\sqrt{n} \\leq \\lfloor\\frac{n}{2}\\rfloor\\). Zbog toga kartu sa brojem \\(2\\) mo\u017ee razmeniti za kartu sa brojem \\(2p\\leq n\\), zatim kartu sa brojem \\(2p\\) za kartu sa brojem \\(p\\) i na kraju kartu sa brojem \\(p\\) za kartu sa brojem \\(m\\).</p> <p>Jakov ne mo\u017ee skupiti karte sa neparnim prostim brojem \\(p\\) ve\u0107im od \\(\\lfloor\\frac{n}{2}\\rfloor\\). Da bi skupio tu kartu morao bi da ima kartu sa brojem deljivim sa brojem \\(p\\). Ali najmanji broj (razli\u010dit od \\(p\\)) koji je deljiv brojem \\(p\\) je \\(2p\\) koji je ve\u0107i od \\(n\\).</p> <p>Zbog toga je broj karti koje Jakov mo\u017ee skupiti jednak razlici brojeva \\(n-1\\) (broj brojeva ve\u0107ih od \\(1\\), ali manjih od ili jednakih \\(n\\)) i broja prostih brojeva ve\u0107ih od \\(\\lfloor\\frac{n}{2}\\rfloor\\) i manjih od ili jednakih \\(n\\).</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei ceo pozitivan broj \\(Q\\) - broj upita na koje je potrebno dati odgovor. U narednih \\(Q\\) linija dat je po jedan ceo pozitivan broj \\(N\\) - broj razli\u010ditih sli\u010dica u kolekciji.</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je postrebno ispisati \\(Q\\) linija - u \\(i\\)-toj od njih odgovor na \\(i\\)-ti upit.</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/okr/04_slicice/#ulaz","title":"Ulaz","text":"<pre><code>2\n5\n7\n</code></pre>"},{"location":"takprog/2021_2022/okr/04_slicice/#izlaz","title":"Izlaz","text":"<pre><code>2\n4\n</code></pre>"},{"location":"takprog/2021_2022/okr/04_slicice/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom upitu, postoji \\(5\\) razli\u010ditih vrsta sli\u010dica u kolekciji, a Jakov je do sada skupio \\(5\\) sli\u010dica sa brojem \\(2\\). Od tih \\(5\\) sli\u010dica na kojima je napisan broj \\(2\\), mo\u017ee jednu da razmeni za sli\u010dicu sa brojem \\(4\\). Na kraju, Jakov \u0107e imati \\(2\\) razli\u010dite vrste sli\u010dica i to sa brojevima \\(2\\) i \\(4\\). Primetite da on ima ukupno \\(2\\) razli\u010dite vrste, iako ima \\(4\\) primerka sli\u010dice na kojoj je napisan broj \\(2\\).</p> <p>U drugom upitu, postoji \\(7\\) razli\u010ditih vrsta sli\u010dica u kolekciji, a Jakov je do sada skupio  \\(7\\) sli\u010dica sa brojem \\(2\\). Potom razmeni jednu od njih za sli\u010dicu sa brojem \\(4\\), a dve za dve sli\u010dice sa brojem \\(6\\). Kona\u010dno, on mo\u017ee da razmeni jednu sli\u010dicu sa brojem \\(6\\) za sli\u010dicu sa brojem \\(3\\). Na kraju, Jakov \u0107e imati \\(4\\) vrste sli\u010dica i to sa brojevima \\(2\\), \\(3\\), \\(4\\) i \\(6\\).</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(4 \\leq N \\leq 10.000.000\\)</li> <li>\\(1 \\leq Q \\leq 200.000\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N \\leq 10\\)</li> <li>U test primerima vrednim \\(10\\) poena: \\(N, Q \\leq 200\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(N, Q \\leq 2.000\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(N \\leq 100.000\\)</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/okr/04_slicice/#resenje-kad-je-n-leq-10","title":"Re\u0161enje kad je \\(N \\leq 10\\)","text":"<p>Sve karte koje mo\u017ee skupiti Jakov se mogu odrediti varijacijom pretrage u \u0161irinu.</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#resenje-kad-je-n-q-leq-200-n-q-leq-2000","title":"Re\u0161enje kad je \\(N, Q \\leq 200\\), \\(N, Q \\leq 2000\\)","text":"<p>Za svaki upit se odre\u0111uje broj prostih brojeva u intervalu \\(\\left[\\lfloor\\frac{n}{2}\\rfloor+1,n\\right]\\).</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#resenje-kad-je-n-leq-100000","title":"Re\u0161enje kad je \\(N \\leq 100.000\\)","text":"<p>Neposredno nakon u\u010ditavanja vrednosti broja \\(N\\) za sve upite, odre\u0111uje se najve\u0107a vrednost za \\(N\\) (neka je to \\(N_{\\max}\\)), a nakon toga za svaku vrednost \\(N \\leq N_{\\max}\\) broj prostih brojeva koji nisu ve\u0107i od \\(N\\) (ozna\u010dimo taj broj sa \\(p(N)\\)).  Vrednost \\(p(N)\\) se odre\u0111uje na osnovu vrednosti \\(p(N-1)\\). Naime, vrednost \\(p(N)\\) je jednaka \\(p(N-1)+1\\), ako je \\(N\\) prost broj, odnosno \\(p(N-1)\\), ako je \\(N\\) slo\u017een broj. Provera da li je broj \\(N\\) prost se mo\u017ee izvesti u slo\u017eenosti \\(O(\\sqrt{N})\\), pa je slo\u017eenost odre\u0111ivanje svih vrednosti \\(p(N)\\) jednaka \\(O(N_{\\max}\\sqrt{N_{\\max}})\\).  Nakon toga se broj prostih brojeva u intervalu  \\(\\left[\\lfloor\\frac{n}{2}\\rfloor+1,n\\right]\\) odre\u0111uje po formuli \\(p(N)-p\\left(\\frac{N}{2}\\right)\\), tj. u slo\u017eenosti \\(O(1)\\). Slo\u017eenost kompletnog algoritma je \\(O(N_{\\max}\\sqrt{N_{\\max}}+Q)\\).</p>"},{"location":"takprog/2021_2022/okr/04_slicice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Neposredno nakon u\u010ditavanja vrednosti broja \\(N\\) za sve upite, odre\u0111uje se najve\u0107a vrednost za \\(N\\) (neka je to \\(N_{\\max}\\)), a nakon toga za svaku vrednost \\(N \\leq N_{\\max}\\) broj prostih brojeva koji nisu ve\u0107i od \\(N\\) (ozna\u010dimo taj broj sa \\(p(N)\\)).  Za razliku od prethodnog podzadatka, provera da li su prirodni brojevi prosti se izvodi primenom Eratostenovog sita. Zahvaljuju\u0107i tome, slo\u017eenost izra\u010dunavanja svih vrednosti \\(p(N)\\) je \\(O(N_{\\max}\\log N_{\\max})\\), a slo\u017eenost kompletnog re\u0161enja je \\(O(N_{\\max}\\log N_{\\max} + Q)\\).</p> 04_slicice.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 10000000\nusing namespace std;\nbool nopr[maxn+5];\nint cnt[maxn+5];\nint main() {\n    for(long long i=2;i&lt;=maxn;i++) {\n        cnt[i]=cnt[i-1];\n        if(!nopr[i]) {\n            cnt[i]+=1;\n            for(long long j=i*i;j&lt;=maxn;j+=i) {\n                nopr[j]=true;\n            }\n        }\n    }\n    int q;\n    scanf(\"%d\",&amp;q);\n    for(int i=1;i&lt;=q;i++) {\n        int n;\n        scanf(\"%d\",&amp;n);\n        printf(\"%d\\n\",n-1-cnt[n]+cnt[n/2]);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/okr/05_civas/","title":"A2 - \u0106ivas","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Prethodnih godina, duologija o velikom \u0161efu mafije ekskluzivne disjunkcije Okram \u0106ivas postali su neki od najpopularnijih i najvoljenijih filmova na tr\u017ei\u0161tu. Duologija se sastoji od, kao \u0161to ime ka\u017ee, dva filma, koji se zovu Okram i \u0106ivas. U ovom zadatku bavi\u0107emo se drugim delom duologije - \u0106ivasom.</p> <p>U najnovijoj avanturi na\u0161eg heroja, on se na\u0161ao na tajanstvenoj kru\u017enoj traci. Ova traka je podeljena na \\(N\\) delova, koji su redom numerisani brojevima od \\(1\\) do \\(N\\), a u svakom delu trake se nalazio po jedan nenegativan ceo broj. Broj u \\(i\\)-tom delu kruga ozna\u010davamo sa \\(A_i\\). Nije ni stigao da se pribere kad su krenuli da se menjaju brojevi po traci. Desilo se \\(Q\\) promena, gde se u \\(i\\)-toj promeni, broj u delu trake sa oznakom \\(p_i\\) promenio u novu vrednost \\(v_i\\). Svi ozbiljniji filmofili mogli su da uo\u010de da va\u017ei ne\u0161to interesantno: ni u jednom trenutku nije postojao broj \\(D&lt;N\\) tako da je kru\u017eni niz \\(A_i\\) bio \\(D\\)-periodi\u010dan (to jest ne postoji \\(D\\) tako da svaka dva dela na distanci \\(D\\) imaju isti broj napisan na sebi, tj. \\(A_i=A_{(i+D) \\text{mod }N}\\)). Iz nekog razloga je izme\u0111u svaka dva dela trake \\(i\\) i \\(i+1\\) pisao broj \\(B_i\\) koji je bio jednak ekskluzivnoj disjunkciji (poznatoj i kao <code>xor</code>)  dva broja napisana na ta dva dela (preciznije \\(B_i=A_i\\text{ xor }A_{i+1}\\)). Promenama vrednosti \\(A_i\\) su se, naravno, meljale i vrednosti \\(B_i\\).</p> <p>Kako je Okram \u0106ivas poznat po svojoj majstoriji sa ekskluzivnom disjunkcijom, on je sebi zadao slede\u0107i zadatak: Pre svih promena, kao i posle svake promene, \u017eeleo je da na\u0111e periodu kru\u017enog niza \\(B\\), to jest najmanji prirodan broj \\(D\\) tako da va\u017ei \\(B_i=B_{(i+D)\\text{ mod }N}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Tadija \u0160ebez"},{"location":"takprog/2021_2022/okr/05_civas/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva broja, broj delova trake \\(N\\) i broj upita \\(Q\\). U narednoj liniji nalazi se \\(N\\) prirodnih brojeva: gde \\(i\\)-ti broj predstavlja broj \\(S_i\\), koji ozna\u010dava po\u010detnu vrednost broja u \\(i\\)-tom delu trake. Narednih \\(Q\\) linija sadr\u017ee po dva broja: \\(p_i,v_i\\), koji predstavljaju promenu vrednosti u nizu \\(A\\) iz teksta.</p>"},{"location":"takprog/2021_2022/okr/05_civas/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je potrebno ispisati \\(Q+1\\) linija: u prvoj liniji treba na\u0107i periodu pre ikakvih upita, a u \\(i+1\\)-oj liniji treba na\u0107i periodu posle \\(i\\)-te promene.</p>"},{"location":"takprog/2021_2022/okr/05_civas/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2021_2022/okr/05_civas/#ulaz","title":"Ulaz","text":"<pre><code>6 1\n0 1 3 1 0 1\n6 2\n</code></pre>"},{"location":"takprog/2021_2022/okr/05_civas/#izlaz","title":"Izlaz","text":"<pre><code>6\n3\n</code></pre>"},{"location":"takprog/2021_2022/okr/05_civas/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2021_2022/okr/05_civas/#ulaz_1","title":"Ulaz","text":"<pre><code>5 2\n2 3 4 1 2\n3 3\n4 4\n</code></pre>"},{"location":"takprog/2021_2022/okr/05_civas/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n5\n5\n</code></pre>"},{"location":"takprog/2021_2022/okr/05_civas/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom primeru je niz \\(B\\) na po\u010detku <code>1 2 2 1 1 1</code>, \u010dija je najmanja perioda o\u010dito ceo niz, dok posle promene niz je <code>1 2 2 1 2 2</code>, kada je \\(3\\) periodi\u010dno.</p> <p>U drugom primeru kako je \\(5\\) prost, a period deli du\u017einu niza, va\u017ei da je period uvek \\(1\\) ili \\(5\\), a kako ovde nikad nije \\(1\\) onda je odgovor \\(5\\) posle svake promene.</p>"},{"location":"takprog/2021_2022/okr/05_civas/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N,M \\leq 200.000\\)</li> <li>\\(1\\leq Q\\leq 200.000\\)</li> <li>\\(0\\leq A_i,v_i&lt;2^{30}\\)</li> <li>\\(1\\leq p_i\\leq N\\)</li> </ul> <p>Test primeri su podeljeni u 5 disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N\\leq500\\) i \\(Q\\leq 500\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(Q\\leq25\\)</li> <li>U test primerima vrednim \\(30\\) poena: \\(Q\\leq3.000\\)</li> <li>U test primerima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/okr/05_civas/#napomena","title":"Napomena","text":"<p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa  <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola  <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in {1, \\ldots, k }\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\ y\\).</p> <p>Ako \u017eelite da saznate pri\u010du o poreklu na\u0161eg heroja, pogledajte tre\u0107i zadatak za \\(B\\) kategoriju: Okram</p>"},{"location":"takprog/2021_2022/okr/05_civas/#resenje-kada-n-q-leq-500","title":"Re\u0161enje kada \\(N, Q \\leq 500\\)","text":"<p>Za svaku promenu niza, izra\u010dunamo niz \\(b\\) i na njemu probamo svaku mogu\u0107u periodu, od kojih uzimamo najmanju. </p> <p>Vremenska slo\u017eenost je \\(O(QN^2)\\),  a memorijska slo\u017eenost \\(O(N)\\).  </p>"},{"location":"takprog/2021_2022/okr/05_civas/#resenje-kada-q-leq-25","title":"Re\u0161enje kada \\(Q \\leq 25\\)","text":"<p>Primetimo da su jedine mogu\u0107e periode delioci broja \\(N\\). Sada primenjujemo prethodno re\u0161enje, samo \u0161to isprobavamo samo te delioce.</p> <p>Vremenska slo\u017eenost je \\(O(QNd(N))\\), gde je \\(d(N)\\) broj delioca \\(N\\), a memorijska slo\u017eenost \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/okr/05_civas/#resenje-kada-q-leq-3000","title":"Re\u0161enje kada \\(Q \\leq 3000\\)","text":"<p>Mo\u017eemo primetiti da za svako \\(d\\) i \\(x\\) va\u017ei: </p> \\[ a_i \\text{ xor } a_{i+d} = b_i \\text{ xor } b_{i+1} \\text{ xor } \\ldots b_{i+d-1} \\] <p>Analogno, va\u017ei i:</p> \\[ a_{i+d} \\text{ xor } a_{i+2d} = b_{i+d} \\text{ xor } b_{i+d+1} \\text{ xor } \\ldots b_{i+2d-1} \\] <p>Ako za \\(d\\) uzmemo periodu niza \\(b\\), va\u017ei da su desne strane ovih jedna\u010dina jednake, pa va\u017ei i da su leve strane jednake. Odatle zaklju\u010dujemo, da za takvo \\(d\\) i proizvoljno \\(x\\) va\u017ei \\(a_i = a_{i+2d}\\),  \u0161to nam govori da je \\(2d\\) perioda niza \\(a\\). </p> <p>Po\u0161to nam je poznato da je perioda niza \\(a\\) ba\u0161 \\(n\\), onda imamo dva slu\u010daja. Ukoliko je \\(n\\) neparno, perioda niza \\(b\\) je uvek \\(n\\), u suprotnom, perioda mo\u017ee biti i \\(\\frac{N}{2}\\), a ako nije, onda mora biti \\(n\\). Zato, nakon svake promene, dovoljno je proveriti da li je u novom nizu \\(\\frac{N}{2}\\) perioda. </p> <p>Vremenska slo\u017eenost \\(O(NQ)\\), a memorijska slo\u017eenost \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/okr/05_civas/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Poput prethodnog re\u0161enja, dovoljno je proveriti periodu \\(\\frac{N}{2}\\), samo \u0107emo ovde to uraditi na br\u017ei na\u010din. Pre svih promena, odradimo proveru u \\(O(N)\\), pamte\u0107i u koliko odgovaraju\u0107ih parova su isti elementi. Nakon svake promene, dovoljno je proveriti samo da li se neki od dva para na koje promena uti\u010de popravio ili pokvario, tj. a\u017eurirati broj parova u kojima su elementi isti. Kad god je broj takvih parova ta\u010dno \\(\\frac{N}{2}\\), perioda je \\(\\frac{N}{2}\\), u suprotnom, perioda je \\(N\\). </p> <p>Vremenska slo\u017eenost je \\(O(N+Q)\\), a memorijska slo\u017eenost \\(O(N)\\).</p> 05_civas.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint a[200007],b[200007],n,q,cnt;\nbool bad[200007];\nvoid check(int x)\n{\n    if(x&gt;=n/2) {check(x-n/2); return;}\n    if(bad[x]) cnt--;\n    if(b[x]==b[x+n/2]) bad[x]=false;\n    else bad[x]=true;\n    if(bad[x]) cnt++;\n}\nint main()\n{\n    scanf(\"%d%d\",&amp;n,&amp;q);\n    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]);\n    for(int i=0;i&lt;n;i++) b[i]=a[i]^a[(i+1)%n];\n    for(int i=0;i&lt;n;i++) check(i);\n    if(cnt==0) printf(\"%d\\n\",n/2);\n    else printf(\"%d\\n\",n);\n    while(q--)\n    {\n        int p,v;\n        scanf(\"%d%d\",&amp;p,&amp;v);\n        p--;\n        a[p]=v;\n        b[(p+n-1)%n]=a[(p+n-1)%n]^a[p];\n        b[p]=a[p]^a[(p+1)%n];\n        check(p); check((p+n-1)%n);\n        if(cnt==0) printf(\"%d\\n\",n/2);\n        else printf(\"%d\\n\",n);\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/","title":"A3 - AdVenture Communist","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 512MB <p>AdVenture Communist 2 je igrica u kojoj igra\u010d kupuje fabrike sa ciljem da prikupi \u0161to vi\u0161e krompira za najkra\u0107e vreme. Ukupno postoji \\(N\\) razli\u010ditih tipova fabrika.</p> <p>Broj krompira \\(a_0\\) se svake sekunde pove\u0107a prvo \\(C\\) puta, a zatim se doda broj krompira koji proizvede fabrika prvog tipa. Fabrika prvog tipa svake sekunde proizvodi \\(K_1\\) krompira, dakle ukoliko u trenutku \\(t\\) imate \\(a_0\\) krompira i \\(a_1\\) fabrika prvog tipa u trenutku \\(t+1\\) \u0107ete imati \\(C \\cdot a_0 + K_1 \\cdot a_1\\) krompira. Broj fabrika tipa tipa \\(i\\) se tako\u0111e svake sekunde prvo pove\u0107a \\(C\\) puta, a zatim se doda broj fabrika tipa \\(i\\) koje je proizvela fabrika tipa \\(i+1\\). Fabrike tipa \\(i+1\\) gde je \\(i&gt;0\\) svake sekunde proizvode \\((i+1) \\cdot K_{i+1}\\) fabrika tipa \\(i\\),  dakle ukoliko u trenutku \\(t\\) imate \\(a_i\\) fabrika tipa \\(i\\) i  \\(a_{i+1}\\) fabrika tipa \\(i+1\\) u trenutku \\(t+1\\) \u0107ete imati \\(C \\cdot a_i + (i+1) \\cdot K_{i+1} \\cdot a_{i+1}\\) fabrika tipa \\(i\\).</p> <p>Zavisnost opisanog niza \\(a_0, a_1, ... , a_N\\) od vremena se mo\u017ee formalno zapisati pomo\u0107u formule:</p> \\[a_i(t+1) = C \\cdot a_i(t) + (i+1) \\cdot K_{i+1} \\cdot a_{i+1}(t)\\] <p>Va\u0161 zadatak je da odredite ukupan broj krompira u trenutku \\(T\\), to jest \\(a_0(T)\\), po modulu \\(10^9+7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Igor Pavlovi\u0107 Igor Pavlovi\u0107 Igor Pavlovi\u0107 Tadija \u0160ebez"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei tri broja, broj elemenata niza \\(N\\), trenutak \\(T\\) i konstanta \\(C\\). U drugom redu nalazi se \\(N\\) celih brojeva koji predstavljaju vrednosti elemenata niza u trenutku \\(t=0\\). U tre\u0107em redu nalazi se \\(N\\) celih brojeva koji predstavljaju niz \\(K_0, K_1, ... , K_N\\).</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je postrebno ispisati jedan ceo broj \\(a_0(T)\\) po modulu \\(10^9+7\\).</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#primer","title":"Primer","text":""},{"location":"takprog/2021_2022/okr/06_adventure_communist/#ulaz","title":"Ulaz","text":"<pre><code>3 3 2\n1 1 1\n1 1 1\n</code></pre>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#izlaz","title":"Izlaz","text":"<pre><code>32\n</code></pre>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>Posle prve sekunde niz \u0107e izgledati ovako: <pre><code>a = {3, 4, 2}\n</code></pre> Posle druge sekunde niz \u0107e izgledati ovako: <pre><code>a = {10, 12, 4}\n</code></pre> Posle tre\u0107e sekunde niz \u0107e izgledati ovako: <pre><code>a = {32, 32, 8}\n</code></pre> Kako tra\u017eimo vrednost u \\(a_0\\) posle tre\u0107e sekunde, odgovor je 32.</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N\\leq 200000\\)</li> <li>\\(1\\leq T\\leq 10^9\\)</li> <li>\\(1\\leq C \\leq 10^9\\)</li> <li>\\(0\\leq a_{i}\\leq 10^9\\)</li> <li>\\(0\\leq K_{i}\\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u 4 disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N,T\\leq2000\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(N\\leq200\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(C=1\\)</li> <li>U test primerima vrednim \\(20\\) poena: \\(N\\leq1000\\)</li> <li>U test primerima vrednim \\(30\\) poena: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#resenje-za-n-t-leq-2000","title":"Re\u0161enje za \\(N, T \\leq 2000\\)","text":"<p>Ovde je dovoljno simulirati de\u0161avanja trenutak po trenutak u slo\u017eenosti \\(O(NT)\\).</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#resenje-za-nleq-200","title":"Re\u0161enje za \\(N\\leq 200\\)","text":"<p>U ovom slu\u010daju je potrebno primetiti da je opisana rekurenta veza zapravo linearna transformacija koja se mo\u017ee predstaviti u matri\u010dnom obliku kao</p> \\[ A(t+1)=K \\cdot A(t) \\] <p>gde je</p> \\[ A(t) = [a_0(t), a_1(t), ..., a_n(t)]^T \\] \\[ K_{i,i} = C \\text{  ,  } K_{i,i+1} = (i+1) \\cdot K_{i+1} \\] \\[ K_{ij}=0 \\text{  za  } (j!=i) \\wedge (j!=i+1) \\] <p>Odavde se dobija slede\u0107a jednakost:</p> \\[ A(t)=K^t \\cdot A(0) \\] <p>iz koje mo\u017eemo odrediti vrednost \\(a_0(T)\\) u slo\u017eenosti \\(O(N^3\\log T)\\) brzim stepenovanjem matrica.</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#resenje-za-c-1","title":"Re\u0161enje za \\(C = 1\\)","text":"<p>Primetimo prvo da se doprinos svake pojedina\u010de fabrike mo\u017ee posmatrati odvojeno od ostalih zato \u0161to je opisana transformacija linearna. Ukupan broj krompira u trenutku \\(T\\) dobijamo kao zbir doprinosa svake fabrike.</p> <p>Za transformaciju</p> \\[ a_i(t+1)=a_i(t)+(i+1) \\cdot K_{i+1} \\cdot  a_{i+1}(t) \\] <p>se mo\u017ee indukcijom dokazati da je doprinos \\(i\\)-te fabrike ukupnom broju krompira nakon \\(t\\) sekundi zapravo:</p> \\[ d_i = \\prod_{j=1}^{i} K_j \\cdot (t-j+1) \\] <p>Sumiranjem svih doprinosa dobijamo: $$ a_0(T) = a_0(0) + \\sum_{i=1}^{N} a_i(0) \\cdot d_i = a_0(0) + \\sum_{i=1}^{N} a_i(0) \\cdot \\prod_{j=1}^{i} K_j \\cdot (T-j+1) $$</p> <p>Na osnovu ovog izraza mo\u017eemo odrediti \\(a_0(T)\\) u slo\u017eenosti \\(O(N)\\).</p>"},{"location":"takprog/2021_2022/okr/06_adventure_communist/#glavno-resenje","title":"Glavno re\u0161enje:","text":"<p>Primetimo da se zadata rekurentna veza mo\u017ee zapisati kao:</p> \\[ a_i(t+1)=C \\cdot a_i(t)+(i+1) \\cdot K_{i+1} \\cdot a_{i+1}(t)= C \\cdot (a_i(t)+(i+1) \\cdot \\frac{K_{i+1}}{C} \\cdot a_{i+1}(t)) \\] <p>U matri\u010dnom obliku ova rekurentna veza mo\u017ee se zapisati kao kompozicija dve linearne transformacije na slede\u0107i na\u010din:</p> \\[ A(t+1)=C \\cdot I \\cdot K' \\cdot A(t) \\] <p>gde je</p> \\[ A(t) = [a_0(t), a_1(t), ..., a_n(t)]^T \\] \\[ K_{i,i} = 1 \\text{  ,  } K_{i,i+1} = (i+1) \\cdot \\frac{K_{i+1}}{C} \\] \\[ K_{ij}=0 \\text{  za  } (j!=i) \\wedge (j!=i+1) \\] <p>i matrica \\(I\\) je jedini\u010dna matrica.</p> <p>Odavde se dobija slede\u0107a jednakost:</p> \\[ A(t)=C^t \\cdot K'^{t} \\cdot A(0) \\] <p>Po\u0161to je matrica \\(K'\\) ista kao u slu\u010daju kada je \\(C=1\\) mo\u017eemo zaklju\u010diti da je doprinos \\(i\\)-te fabrike:</p> \\[ d_i = C^t \\prod_{j=1}^{i} \\frac{K_j}{C} \\cdot (t-j+1) = C^{t-i} \\cdot \\prod_{j=1}^{i} K_j \\cdot (t-j+1) \\] <p>Sumiranjem svih doprinosa dobijamo:</p> \\[ a_0(T) = a_0(0) + \\sum_{i=1}^{N} a_i(0) \\cdot d_i = a_0(0) + \\sum_{i=1}^{N} a_i(0) \\cdot C^{T-i} \\cdot \\prod_{j=1}^{i} K_j \\cdot (T-j+1) \\] <p>Na osnovu ovog izraza mo\u017eemo odrediti \\(a_0(T)\\) u slo\u017eenosti \\(O(N)\\).</p> 06_adventure_communist.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int maxN = 1000005;\nconst int mod = 1000000007;\n\nint n, t;\nlong long a[maxN], k[maxN], c, powC[maxN];\n\nlong long modPow(long long a, long long p) {\n    if (p == 0) return 1;\n\n    long long ans, tmp = modPow(a, p / 2);\n    ans = tmp * tmp;\n    ans %= mod;\n\n    if (p % 2) {\n        ans *= a;\n        ans %= mod;\n    }\n\n    return ans%mod;\n}\n\nlong long solve() {\n    long long p = 1, ans = (a[0] * modPow(c,t))%mod;\n\n    powC[0]=modPow(c,t-n+1);\n\n    for(int i=1;i&lt;n;i++){\n        powC[i]=powC[i-1]*c;\n        powC[i]%=mod;\n    }\n\n    ans = (a[0] * powC[n-1])%mod;\n\n    for (int i = 1; i &lt; n; i++) {\n        p *= k[i];\n        p %= mod;\n        p *= (t - i + 1);\n        p %= mod;\n\n        long long tmp = a[i] * p;\n        tmp %= mod;\n\n        tmp *= powC[n-1-i];\n        tmp %= mod;\n\n        ans += tmp;\n        ans %= mod;\n    }\n\n    if (ans &lt; 0) ans += mod;\n    return ans;\n}\n\nlong long solveBrute() {\n\n    for (int i = 0; i &lt; t; i++) {\n        for (int j = 0; j &lt; n - 1; j++) {\n            long long tmp = a[j + 1] * k[j + 1];\n            tmp %= mod;\n            tmp *= (j + 1);\n            tmp %= mod;\n            tmp += c * a[j];\n            tmp %= mod;\n            a[j] = tmp;\n        }\n        a[n - 1] *= c;\n        a[n - 1] %= mod;\n    }\n\n    if (a[0] &lt; 0) a[0] += mod;\n    return a[0];\n}\n\nint main()\n{\n    std::ios_base::sync_with_stdio(false);\n    cin&gt;&gt;n&gt;&gt;t&gt;&gt;c;\n\n    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n\n    for(int i=0;i&lt;n;i++) cin&gt;&gt;k[i];\n\n    cout&lt;&lt;solve()&lt;&lt;endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2021_2022/sio/01_laz/","title":"1 - La\u017e","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U dalekoj zemlji Bajtoviji \u017eivi \\(n\\) programera. Za ovu zemlju je karakteristi\u010dno to da su njeni stanovnici ili istinoljupci, oni koji uvek govore istinu, ili la\u017eljivci, oni koji uvek govore la\u017ei. </p> <p>Na\u0161li ste se na odmoru u ovoj \u010dudnovatoj zemlji i \u017eelite da otkrijete jednog od la\u017eljivaca. Kako ne biste tro\u0161ili previ\u0161e vremena, \u017eelite to da uradite tako \u0161to \u0107ete postaviti najvi\u0161e \\(q\\) pitanja. Svako pitanje treba da postavite jednom od stanovnika Bajtovije i da ga pitate da li me\u0111u stanovnicima iz skupa \\(S = \\{ s_1, s_2, \\dots, s_k \\}\\) postoji neparno la\u017eljivaca. Skup \\(S\\) mo\u017ee da bude prazan, a mo\u017ee i da sadr\u017ei stanovnika kome postavljate pitanje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Tadija \u0160ebez Pavle Martinovi\u0107 Mladen Puzi\u0107"},{"location":"takprog/2021_2022/sio/01_laz/#opis-funkcija","title":"Opis funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(\\text{NadjiLazova}(n, q)\\)</li> </ul> <p>gde je \\(n\\) broj stanovnika Bajtovije, \\(q\\) dozvoljeni broj pitanja, a funkcija vra\u0107a indeks jednog od la\u017eova, ili \\(-1\\) ukoliko svi stanovnici govore istinu.</p> <p>Va\u0161 program mo\u017ee da koristi funkciju</p> <p>\\(\\text{Pitaj}(x, s)\\)</p> <p>koja vra\u0107a odgovor stanovnika sa indeksom \\(x\\) na pitanje \"da li se u skupu \\(s\\) nalzi neparno stanovnika Bajtovije koji la\u017eu?\"</p> <ul> <li>Skup \\(s\\) treba da prosledite kao niz me\u0111usobno razli\u010ditih indeksa stanovnika.</li> </ul> <p>Stanovnici Bajtovije su indeksirani od 1.</p> <p>Informacija o tome ko su istiniljupci, a ko la\u017eljivci je fiksirana pre pokretanja va\u0161e funkcije i ne zavisi od pitanja koje postavljate.</p>"},{"location":"takprog/2021_2022/sio/01_laz/#ogranicenja","title":"Ograni\u010denja","text":"<p>Test primeri su podeljeni u nekoliko podzadataka. U svakom podzadatku je dato ograni\u010denje \\(q\\), koje predstavlja dozvoljen broj poziva funkcije \\(\\text{Pitaj}\\).</p> <ul> <li>[10 poena]: \\(n = 1000\\), \\(q = 2000\\)</li> <li>[12 poena]: \\(n = 1000\\), \\(q = 1000\\)</li> <li>[25 poena]: \\(n = 1000\\), \\(q = 30\\), ta\u010dno jedan stanovnik Bajtovije la\u017ee.</li> <li>[33 poena]: \\(n = 1000\\), \\(q = 30\\), neparan broj stanovnika Bajtovije su la\u017eovi.</li> <li>[20 poena]: \\(n = 1000\\), \\(q = 30\\)</li> </ul>"},{"location":"takprog/2021_2022/sio/01_laz/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee da sadr\u017ei i dodatne globale promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int NadjiLazova(int n, int q)</code></p> <p>Va\u0161 program mora ullju\u010divati header <code>code.h</code>, u kom je definisana funkcija \\(\\text{Pitaj}\\) slede\u0107eg potpisa:</p> <p><code>bool Pitaj(int koga, vector&lt;int&gt; skup)</code></p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom i jedinom redu, brojeve \\(n\\) i \\(q\\), i string \\(s\\) du\u017eine \\(n\\) sa\u010dinjen od jedinica i nula. Svaki karakter stringa \\(s\\) odnosi se na jednog stanovnika Bajtovije tako da jedinica ozna\u010dava one stanovnike koji la\u017eu, a nula one koji govore istinu.</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa povratnu vrednost na ekran. Ukoliko va\u0161e re\u0161enje koristi funkciju \\(\\text{Pitaj}\\) vi\u0161e od \\(q\\) puta, bi\u0107e prekinuto sa statusom <code>RTE</code> (runtime error).</p>"},{"location":"takprog/2021_2022/sio/01_laz/#resenje-kada-q-2000","title":"Re\u0161enje kada \\(q = 2000\\)","text":"<p>Ovaj podzadatak je tu za takmi\u010dare koji na neoptimalan na\u010din iskucaju re\u0161enje iz slede\u0107eg podzadatka.</p>"},{"location":"takprog/2021_2022/sio/01_laz/#resenje-kada-q-1000","title":"Re\u0161enje kada \\(q = 1000\\)","text":"<p>Mo\u017eemo da saznamo da li je neko la\u017eov ili istinoljubac sa samo jednim pitanjem. Ako osoba \\(x\\) pitamo za skup \\(\\{x, y\\}\\), gde je \\(y\\) bilo koja druga osoba, sazna\u0107emo da li je \\(y\\) la\u017eov ili istinoljubac (samo ukoliko ka\u017ee da u njemu ima neparno la\u017eova, onda je osoba \\(y\\) la\u017eov). Ovo znamo, jer ako osoba \\(x\\) govori istinu, onda odgovor zavisi samo od toga da li je \\(y\\) la\u017eov. Ako la\u017ee, i ako su obojica la\u017eovi, \\(x\\) \u0107e jo\u0161 uvek re\u0107i da je neparno la\u017eova. U suprotnom, re\u0107i \u0107e da ima neparno la\u017eova.</p> <p>Sad mo\u017eemo pro\u0107i kroz niz i za svaku osobu saznati da li je istinoljubac ili la\u017eov sa po jednim pitanjem.</p>"},{"location":"takprog/2021_2022/sio/01_laz/#resenje-kada-q-30-i-postoji-tacno-jedan-lazov","title":"Re\u0161enje kada \\(q = 30\\) i postoji ta\u010dno jedan la\u017eov","text":"<p>Koriste\u0107i ideju iz prethodnog podzadatka, odredimo da li je osoba \\(1\\) istinoljubac ili la\u017eov. Ukoliko je la\u017eov, mo\u017eemo vratiti njegov indeks, u suprotnom, mo\u017eemo ga koristiti da saznamo informacije o ostalim ljudima.</p> <p>Ako je istinoljubac, onda je la\u017eov neka od osoba na intervalu \\([2, N]\\). Podelimo ovaj interval na pola. La\u017eov se mora nalaziti u jednoj od te dve polovine. Pitajmo osobu \\(1\\) da li je la\u017eov u prvoj polovini. Ukoliko jeste, dalje razmatramo samo nju, u suprotnom, razmatramo samo drugu polovinu.</p> <p>Ovom metodom nalik na binarnu pretragu, mo\u017eemo na\u0107i la\u017eova sa jo\u0161 desetak pitanja.</p>"},{"location":"takprog/2021_2022/sio/01_laz/#resenje-kada-q-30-i-postoji-neparno-lazova","title":"Re\u0161enje kada \\(q = 30\\) i postoji neparno la\u017eova","text":"<p>Sli\u010dno prethodnom podzadatku, prvo nalazimo informaciju o osobi \\(1\\). Nakon toga, ponovo radimo binarnu pretragu na intervalu \\([2, N]\\). Ovaj put, umesto da odr\u017eavamo samo jednog la\u017eova, \u017eelimo da interval koji posmatramo uvek ima neparan broj la\u017eova. Kada podelimo interval koji ima neparan broj la\u017eova na dve polovine, jedna polovina ima\u0107e paran broj la\u017eova, a druga neparan. Pretragu nastavljamo u onoj polovini koja ima neparan broj. Tako radimo dok ne do\u0111emo do jednog la\u017eova.</p>"},{"location":"takprog/2021_2022/sio/01_laz/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Poslednji podzadatak re\u0161avamo kao prethodni, samo \u0161to je prvo potrebno da na\u0111emo neki podskup ljudi u kojem ima neparno la\u017eova. To mo\u017eemo uraditi nasumi\u010dnim (randomiziranim) pristupom. </p> <p>Svaki element ubacujemo u na\u0161 podskup sa verovatno\u0107om \\(50\\%\\). Samim tim, verovatno\u0107a da \u0107e taj podskup imati neparno la\u017eova je tako\u0111e \\(50\\%\\). Ukoliko podskup koji smo dobili ima parno mnogo la\u017eova, onda konstrui\u0161emo novi podskup, dok ne dobijemo neki koji nam odgovara. </p> <p>Verovatno\u0107a da \u0107e nam za to trebati preko \\(19\\) poku\u0161aja je jako mala, \\(\\frac{1}{2^{19}}\\), pa je mo\u017eemo zanemariti. Ostala pitanja mo\u017eemo iskoristiti na drugi deo re\u0161enja, gde opet radimo ne\u0161to nalik na binarnu pretragu, samo ovaj put delimo skup na dva, umesto interval. </p> 01_laz.cpp<pre><code>#include \"code.h\"\n\n#include &lt;vector&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nbool Pitaj(vector&lt;int&gt; s) {\n    int x = s.back();\n    s.pop_back();\n    return Pitaj(x, s);\n}\n\nint NadjiLazova(int n, int q) {\n    mt19937 rng;\n\n    vector&lt;int&gt; svi;\n    for (int i = 1; i &lt;= n; ++i)\n        svi.push_back(i);\n\n    vector&lt;int&gt; podskup;\n    bool nasao = false;\n\n    for (int pokusaj = 1; pokusaj &lt;= 20; ++pokusaj) {\n        podskup.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (rng() % 2 == 0)\n                podskup.push_back(i);\n        if (Pitaj(podskup)) {\n            nasao = true;\n            break;\n        }\n    }\n\n    if (!nasao)\n        return -1;\n\n    while (podskup.size() &gt; 1) {\n        vector&lt;int&gt; levo, desno;\n        int mid = podskup.size() / 2;\n        for(int i = 0; i &lt; podskup.size(); ++i) {\n            if (i &lt; mid)\n                levo.push_back(podskup[i]);\n            else\n                desno.push_back(podskup[i]);\n        }\n        if (Pitaj(levo))\n            podskup = levo;\n        else\n            podskup = desno;\n    }\n\n    return podskup[0];\n}\n</code></pre>"},{"location":"takprog/2021_2022/sio/02_tsm/","title":"2 - TSM","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>\u0110ole Programer, biv\u0161i takmi\u010darski programer, a sada gradona\u010delnik Bajtgrada, prestonice Bajtovije, treba da smisli plan za novi gradski metro. Ve\u0107 je odre\u0111eno da \u0107e postojati \\(N\\) stanica, kao i gde \u0107e se nalaziti.</p> <p>Postoji \\(M\\) razli\u010ditih predloga za metro linije, od kojih \u0110ole mora da izabere podskup. Svaki predlog se sastoji od dve stanice koje linija direktno povezuje, kao i cenu izgradnje linije. Sve cene izgradnje metro linija su me\u0111usobno razli\u010dite. Poznato je da je za svaki dobar metro potrebno da bude zadovoljen slede\u0107i uslov: - mo\u017ee se sti\u0107i od bilo koje stanice do bilo koje druge, na ta\u010dno jedan na\u010din.</p> <p>Tako\u0111e, \u0110ole \u017eeli da ukupna cena metroa (zbir cena izabranih metro linija) bude \u0161to manja.</p> <p>Kada je ovako formalno definisao problem, \u0110ole se odmah setio sli\u010dnih zadataka iz svojih takmi\u010darskih dana, ali nije mogao da se seti ta\u010dno algoritma koji treba da koristi. Setio se da algoritam glasi ovako: - pore\u0111amo sve planove za metro linije u niz, nekim redosledom; - prolazimo kroz linije jednu po jednu tim redosledom i obavezno prihvatamo plan za tu metro liniju ukoliko nije u konfliktu sa do sada prihva\u0107enim linijama; - ka\u017eemo da je linija u konfliktu sa do sada prihva\u0107enim linijama ukoliko, kada dodamo tu liniju me\u0111u prihva\u0107ene linije, postoji vi\u0161e od jednog na\u010dina da se stigne izme\u0111u neke dve stanice.</p> <p>\u0110ole nije uspeo da se seti ta\u010dno koji redosled linija (poredak) treba da koristi, ali znamo da voli velike brojeve i voleo bi da budu \u0161to bli\u017ee po\u010detku poretka. Iako je ipak najbitnija cena, vi \u017eelite i da \u0110ole bude sre\u0107an. Zato, va\u0161 zadatak je da na\u0111ete leksikografski najve\u0107i poredak linija po ceni koji \u0107e, prate\u0107i gorenavedeni algoritam, jo\u0161 uvek da na\u0111e najjeftiniji mogu\u0107 metro.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Tadija \u0160ebez"},{"location":"takprog/2021_2022/sio/02_tsm/#opis-funkcije","title":"Opis funkcije","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(NadjiPoredak(N, M, X[\\ldots], Y[\\ldots], W[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj stanica u Bajtgrada, a \\(M\\) broj predloga linija. Nizovi \\(X\\), \\(Y\\) i \\(W\\) opisuju predloge linija, gde su \\(X\\) i \\(Y\\) indeksi stanica koje povezuje, a \\(W\\) cena da se linija napravi. Potrebno je da funkcija vrati tra\u017eeni poredak. Vra\u0107eni niz treba da sadr\u017ei cene linija, pore\u0111ane u odgovaraju\u0107i redosled. Nizovi \\(X\\), \\(Y\\) i \\(W\\) su indeksirani od \\(1\\), poredak je indeksiran od \\(0\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#primeri","title":"Primeri","text":"<p>Neka su \\(N=4\\) i \\(M = 5\\), i neka su nizovi \\(X=\\{1, 2, 2, 3, 1\\}\\), \\(Y=\\{ 2, 3, 4, 4, 4\\}\\) i \\(W=\\{50, 10, 20, 30, 40\\}\\). Leksikografski najve\u0107i poredak koji daje najjeftiniji metro plan je \\(\\{40, 20, 50, 10, 30\\}\\). Ovim poretkom dobijamo najjeftiniji metro plan koji sadr\u017ei grane \\(2\\), \\(3\\) i \\(5\\), ukupne cene \\(70\\).</p> <p>Neka su \\(N=5\\) i \\(M = 5\\), i neka su nizovi \\(X=\\{2, 2, 1, 1, 3\\}\\), \\(Y=\\{ 5, 4, 2, 4, 4\\}\\) i \\(W=\\{12, 3, 50, 11, 36\\}\\). Leksikografski najve\u0107i poredak koji daje najjeftiniji metro plan je \\(\\{36, 12, 11, 3, 50\\}\\). Ovim poretkom dobijamo najjeftiniji metro plan koji sadr\u017ei grane \\(1\\), \\(2\\), \\(4\\) i \\(5\\), ukupne cene \\(62\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 3\\cdot10^5\\).</li> <li>\\(1 \\leq X_i, Y_i \\leq N\\).</li> <li>\\(1 \\leq W_i \\leq 10^9\\).</li> <li>Garantuje se da \u0107e biti mogu\u0107e napraviti makar jedan metro plan.</li> <li>\\(W_i \\neq W_j\\), za \\(i \\neq j\\).</li> <li>\\(X_i \\neq Y_i\\), za \\(1 \\leq i \\leq M\\).</li> <li>Dozvoljeno je da vi\u0161e planova predla\u017ee liniju izme\u0111u neke dve stanice (ali sa razli\u010ditom cenom).</li> </ul>"},{"location":"takprog/2021_2022/sio/02_tsm/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[7 poena]: \\(M \\leq 9\\).</li> <li>[11 poena]: Svaki plan metro linije pripada najvi\u0161e jednom ciklusu (pogledati napomenu)</li> <li>[9 poena]: \\(N, M \\leq 5000\\) i postoji najjeftiniji metro plan tako da iz svake stanice postoji najvi\u0161e dve metro linije.</li> <li>[12 poena]: Postoji najjeftiniji metro plan tako da iz svake stanice postoji najvi\u0161e dve metro linije.</li> <li>[20 poena]: \\(N, M \\leq 5000\\).</li> <li>[41 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/sio/02_tsm/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>tsm.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>vector&lt;int&gt; NadjiPoredak(int N, int M, int* X, int* Y, int* W);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(M\\).</li> <li>U narednih \\(M\\) redova po tri broja u svakom redu, \\(X_i\\) \\(Y_i\\) \\(W_i\\).</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa poredak koji je vratila va\u0161a funkcija.</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#napomena","title":"Napomena","text":"<p>Ka\u017eemo da je poredak grana \\(a\\) leksikografski ve\u0107i od poretka \\(b\\) ako va\u017ei da je te\u017eina grane \\(a_i\\) ve\u0107a od te\u017eine grane \\(b_i\\), za najmanje \\(i\\) za koje te te\u017eine nisu jednake.</p> <p>Ciklus je niz stanica \\(x_1 x_2 \\ldots x_k\\) za neko \\(k\\), gde va\u017ei da \\(x_1 = x_k\\), nijedna druga stanica se ne pojavljuje vi\u0161e od jedanput i postoji plan metro linija koji direktno povezuje stanice \\(x_i\\) i \\(x_{i+1}\\) za svako \\(1 \\leq i &lt; k\\). Ka\u017eemo da ti planovi metro linija pripadaju tom ciklusu.</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#resenje-kada-m-leq-9","title":"Re\u0161enje kada \\(M \\leq 9\\)","text":"<p>Prvo na\u0111imo neko minimalno razapinju\u0107e stablo grafa koji dobijemo kada kao grane dodamo svaki metro plan (u daljem tekstu MST). Za to mo\u017eemo koristiti neki poznati algoritam, poput Kruskalovog ili Primovog. Nakon toga, za svaki mogu\u0107i poredak proverimo da li nam daje MST i od takvih uzimamo leksikografski najve\u0107i.</p> <p>Vremenska slo\u017eenost je \\(O(M! \\cdot M \\cdot \\alpha(M))\\), a memorijska \\(O(M)\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#resenje-kada-se-svaki-plan-linije-nalazi-u-najvise-jednom-ciklusu","title":"Re\u0161enje kada se svaki plan linije nalazi u najvi\u0161e jednom ciklusu","text":"<p>Ovakav graf se zove kaktus graf. Mo\u017eemo lako zaklju\u010diti da je u kaktus grafu, da bismo dobili MST, potrebno da u svakom ciklusu u grafu izbacimo najskuplju granu. \u0160to zna\u010di, da se najskuplja grana mora na\u0107i u poretku nakon svih drugih grana u tom ciklusu.</p> <p>Po\u0161to je u pitanju kaktus graf, lako mo\u017eemo DFS algoritmom na\u0107i sve cikluse (npr. posmatranjem svih povratnih grana), i tako svesti problem na spajanje \\(K\\) nizova na leksikografski najve\u0107i na\u010din, \u0161to je poznat problem koji se mo\u017ee re\u0161iti primenom prioritetnog reda (std::priority_queue).</p> <p>Vremenska slo\u017eenost je \\(O(MlogN)\\), a memorijska \\(O(M)\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#resenje-kada-je-mst-put-i-nm-leq-5000","title":"Re\u0161enje kada je MST put i \\(N,M \\leq 5000\\)","text":"<p>Po\u0161to su cene svih grana razli\u010dite, MST je jedinstven. Dakle, na\u0111imo MST i znamo da \u0107e on biti put. Postavimo njegove grane redom u niz tako da je jedan kraj puta indeksiran sa \\(1\\), a drugi sa \\(N-1\\).</p> <p>Sada, za svaku granu koja nije u MST, recimo da povezuje stanice \\(x\\) i \\(y\\), mora da va\u017ei da se nalazi u permutaciji nakon svih grana na putu izme\u0111u \\(x\\) i \\(y\\) u MST. Ako to ne va\u017ei, dodali bismo skuplju granu, a kasnije ne bismo mogli da dodamo jeftiniju, \u0161to zna\u010di da ne bismo dobili MST. Taj put odgovara nekom intervalu u na\u0161em nizu.</p> <p>Sada mo\u017eemo konstruisati novi, usmereni, graf, gde su planirane metro linije \u010dvorovi, a grana od \u010dvora \\(u\\) do \u010dvora \\(v\\) postoji isklju\u010divo ako linija \\(u\\) mora da se na\u0111e pre linije \\(v\\) u krajnjem poretku. Ove grane mo\u017eemo lako na\u0107i prolaskom kroz niz za svaku granu van MST.</p> <p>Sada se problem svodi na leksikografski najve\u0107e topolo\u0161ko sortiranje, koje je mogu\u0107e jer svi \u010dvorovi imaju razli\u010dite cene. Mo\u017eemo ga uraditi prioritetnim redom.</p> <p>Vremenska slo\u017eenost: \\(O(M^2\\log M\\)), a memorijski \\(O(M^2)\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#resenje-kada-je-mst-put","title":"Re\u0161enje kada je MST put","text":"<p>Sli\u010dno prethodnom podzadatku, nalazimo MST i za svaku granu van njega znamo da sve grane na tom putu se moraju nalaziti pre nje. Ono \u0161to je potrebno da primetimo jeste da \u0107emo grane na tom putu dodavati opadaju\u0107e po ceni, tj. ako \u017eelimo leksikografski najve\u0107i poredak, nema razloga da dodamo manju granu MST-a pre ve\u0107e.</p> <p>Zato, umesto da konstrui\u0161emo sve grane usmerenog grafa, dovoljno je konstruisati granu izme\u0111u najjeftinije grane na odre\u0111enom intervalu i grane koju posmatramo. To je dovoljno ograni\u010dava, jer znamo da po tranzitivnosti onda ne\u0107e se javiti pre nijedne grane na putu.</p> <p>Sada mo\u017eemo raditi topolo\u0161ko sortiranje kao u prethodnom podzadatku, samo \u0161to ovaj put imamo mnogo manje grana. Tako\u0111e, mo\u017eemo primetiti da je mogu\u0107e i raditi leksikografsko spajanje \\(K\\) nizova kao u drugom zadatku.</p> <p>Vremenska slo\u017eenost je \\(O(MlogN)\\), a memorijska \\(O(M)\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#resenje-kada-n-m-leq-5000","title":"Re\u0161enje kada \\(N, M \\leq 5000\\)","text":"<p>Sli\u010dno podzadatku u kome je MST put, samo kako bismo na\u0161li grane usmerenog grafa, potrebno je da pro\u0111emo kroz put na MST, umesto kroz interval niza. Ovo mo\u017eemo uraditi tako \u0161to korenujemo stablo u nekom \u010dvoru, pa pamtimo roditelja za svaki \u010dvor.</p> <p>Vremenska slo\u017eenost: \\(O(M^2\\log M\\)), a memorijski \\(O(M^2)\\).</p>"},{"location":"takprog/2021_2022/sio/02_tsm/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sli\u010dno podzadatku u kome je MST put, samo kako bismo na\u0161li grane usmerenog grafa, potrebno je da efikasno na\u0111emo najmanju granu na putu MST, umesto na intervalu niza. Ovo mo\u017eemo uraditi preko tehnike binarnog podizanja (binary lifting). Korenujemo MST u proizvoljnom \u010dvoru, na\u0111emo pretka svakog \u010dvora (za pretka korena stavimo samog sebe). Nakon toga, za svaki \u010dvor i za svako \\(l\\) od \\(0\\) do \\(\\log N\\) pamtimo najmanju granu ako se \\(2^l\\) grana penjemo na gore. To nam mo\u017ee pomo\u0107i da u \\(O(\\log N)\\) na\u0111emo minimum na bilo kom putu (sli\u010dno algoritmu tra\u017eenja minimalnog zajedni\u010dkog pretka).</p> <p>Vremenska slo\u017eenost je \\(O(MlogN)\\), a memorijska \\(O(M)\\).</p> 02_tsm.cpp<pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define PRINT(x) cerr&lt;&lt;#x&lt;&lt;'='&lt;&lt;x&lt;&lt;endl;\n#define pii pair&lt;int, int&gt;\n#define fi first\n#define se second\n#define MAXN 300010\n#define MAXL 20\n#define INF 1000000001\nusing namespace std;\nvector&lt;pii&gt; adj[MAXN], e;\nvector&lt;int&gt; v[MAXN];\nvector&lt;pair&lt;int, pii&gt; &gt; ec, add;\npriority_queue&lt;pii&gt; pq;\nint dsu[MAXN], anc[MAXN][MAXL], minn[MAXN][MAXL], in[MAXN], out[MAXN], timer;\n\nint root(int x) {\n  while(x != dsu[x]) {\n    dsu[x] = dsu[dsu[x]];\n    x = dsu[x];\n  }\n  return x;\n}\nbool connect(int x, int y) {\n  int rtX = root(x), rtY = root(y);\n  if(rtX == rtY) return false;\n  dsu[rtX] = rtY;\n  return true;\n}\n\nvoid dfs(int node, int prev, int nodeIdx) {\n  in[node] = ++timer;\n  anc[node][0] = prev;\n  minn[node][0] = nodeIdx;\n  for(auto x : adj[node]) {\n    if(x.fi != prev) {\n      dfs(x.fi, node, x.se);\n    }\n  }\n  out[node] = ++timer;\n}\nint W(int idx) {\n  return ec[idx].fi;\n}\n\nbool inSubtree(int x, int y) { ///da li je x u y\n  return in[y] &lt;= in[x] &amp;&amp; out[x] &lt;= out[y];\n}\nint find_min(int x, int y) {\n  int minIdx = 0;\n  int _x = x, _y = y;\n  for(int l = MAXL-1; l &gt;= 0; l--) {\n    if(!inSubtree(y, anc[_x][l])) {\n      if(W(minn[_x][l]) &lt; W(minIdx)) minIdx = minn[_x][l];\n      _x = anc[_x][l];\n    }\n    if(!inSubtree(x, anc[_y][l])) {\n      if(W(minn[_y][l]) &lt; W(minIdx)) minIdx = minn[_y][l];\n      _y = anc[_y][l];\n    }\n  }\n  if(!inSubtree(y, _x)) {\n    if(W(minn[_x][0]) &lt; W(minIdx)) minIdx = minn[_x][0];\n  }\n  if(!inSubtree(x, _y)) {\n    if(W(minn[_y][0]) &lt; W(minIdx)) minIdx = minn[_y][0];\n  }\n  return minIdx;\n}\n\nvector&lt;int&gt; NadjiPoredak(int N, int M, int* X, int* Y, int* w) {\n  ec.push_back({INF, {1, 1}});\n  for(int i = 1; i &lt;= M; i++) {\n    e.push_back({w[i], i});\n    ec.push_back({w[i], {X[i], Y[i]}});\n  }\n  for(int i = 1; i &lt;= N; i++) dsu[i] = i;\n  sort(e.begin(), e.end());\n  for(auto edge : e) {\n    int w = edge.fi, x = ec[edge.se].se.fi, y = ec[edge.se].se.se;\n    if(connect(x, y)) {\n      adj[x].push_back({y, edge.se});\n      adj[y].push_back({x, edge.se});\n      pq.push({w, edge.se});\n    } else {\n      add.push_back({edge.se, {x, y}});\n    }\n  }\n  dfs(1, 1, 0);\n  for(int l = 1; l &lt; MAXL; l++) {\n    for(int i = 1; i &lt;= N; i++) {\n      anc[i][l] = anc[anc[i][l-1]][l-1];\n\n      minn[i][l] = minn[i][l-1];\n      if(W(minn[i][l]) &gt; W(minn[anc[i][l-1]][l-1])) {\n        minn[i][l] = minn[anc[i][l-1]][l-1];\n      }\n    }\n  }\n\n  for(auto edge : add) {\n    v[find_min(edge.se.fi, edge.se.se)].push_back(edge.fi);\n  }\n  vector&lt;int&gt; sol;\n  while(!pq.empty()) {\n    pii vrh = pq.top(); pq.pop();\n    sol.push_back(vrh.fi);\n    if(vrh.se != 0) {\n      for(auto x : v[vrh.se]) {\n        pq.push({W(x), 0});\n      }\n    }\n  }\n  return sol;\n}\n/*\n4 5\n1 2 50\n2 3 10\n2 4 20\n3 4 30\n1 4 40\n\n5 5\n2 5 12\n2 4 3\n1 2 50\n1 4 11\n3 4 36\n*/\n</code></pre>"},{"location":"takprog/2021_2022/sio/03_igrica/","title":"3 - Igrica","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 256MB <p>Glavna tema o kojoj se ovih dana pri\u010da u Bajtoviji je najnovija video igrica. Cilj ove igre je borba protiv YY \u010dudovi\u0161ta. Ovo stvorenje je dobilo svoje ime po tome \u0161to ne \u017eivi u XY koordinatnom sistemu kao sva ostala \u010dudovi\u0161ta, ve\u0107 u YY koordinatnom sistemu.</p> <p>Ova igrica ima \\(N\\) nivoa, i poznato je da za \\(i\\)-ti nivo, igra\u010d mo\u017ee da nanese \u0161tetu od \\(A_i\\) poena YY \u010dudovi\u0161tu, koriste\u0107i jednu jedinicu energije. Junakinja na\u0161e pri\u010de, Jovana, planira da narednih \\(Q\\) dana igra ovu igricu. Za svaki dan poznata je vrednost \\(T_i\\). </p> <p>Ako je \\(T_i = 1\\), Jovana \\(i\\)-tog dana prelazi nivoe \\(L_i\\), \\(L_{i+1}\\), \\(\\dots\\), \\(R_i\\) tim redom i svaki nivo zapo\u010dinje sa \\(S_i\\) energije. Kako svi vole ovu igricu, svaki put kada Jovana zapo\u010dne neki nivo jo\u0161 jedan stanovnik Bajtovije se uklju\u010di kao njen saigra\u010d, tako da na nivou \\(L_i\\) ona ima jednog saigra\u010da, na nivou \\(L_{i+1}\\) dva saigra\u010da, i tako dalje, pa na kraju na nivou \\(R_i\\) ima \\(R_i - L_i + 1\\) saigra\u010da. Na svakom nivou ona potro\u0161i najve\u0107i broj jedinica energije na pomaganje saigra\u010dima, tako da na svakog od njih potro\u0161i isti ceo broj energije, a ostatak energije potro\u0161i da nanese \u0161tetu YY \u010dudovi\u0161tu.</p> <p>Formalno, ukupna \u0161teta je \\(\\Sigma_{m=1}^{R_i - L_i + 1} A_{L_i + m - 1} \\cdot (S_i\\) \\(mod\\) \\(m)\\), gde \\(x\\) \\(mod\\) \\(y\\) predstavlja ostatak broja \\(x\\) pri deljenju brojem \\(y\\).</p> <p>Ako je \\(T_i = 2\\), \\(i\\)-tog dana se igrica a\u017eurira tako da se \\(A_{L_i}\\) promeni na \\(R_i\\). A\u017euriranje traje ceo dan i tako da nije mogu\u0107e igrati igricu.</p> <p>Za svaki dan kada Jovana igra igricu, odredite ukupnu \u0161tetu koju \u0107e da nanese YY \u010dudovi\u0161tu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Nikola Milosavljevi\u0107 Tadija \u0160ebez Tadija \u0160ebez Nikola Milosavljevi\u0107"},{"location":"takprog/2021_2022/sio/03_igrica/#primer","title":"Primer","text":"<p>Neka su \\(N = 5\\) i \\(Q = 5\\), i neka su nizovi \\(A = \\{7, 2, 3, 9, 4\\}\\), \\(T = \\{1, 1, 2, 1, 1\\}\\), \\(L = \\{3, 1, 3, 1, 1\\}\\), \\(R = \\{5, 5, 5, 5, 3\\}\\) i \\(S = \\{7, 100, \\varnothing, 100, 1\\}\\).</p> <ul> <li>Odgovor za prvi dan je \\(3 \\cdot (7\\) \\(mod\\) \\(1)\\) \\(+\\) \\(9 \\cdot (7\\) \\(mod\\) \\(2)\\) \\(+\\) \\(4 \\cdot (7\\) \\(mod\\) \\(3)\\) \\(=\\) \\(0 + 9 + 4\\) \\(=\\) \\(13\\).</li> <li>Odgovor za drugi dan je \\(7 \\cdot (100\\) \\(mod\\) \\(1)\\) \\(+\\) \\(2 \\cdot (100\\) \\(mod\\) \\(2)\\) \\(+\\) \\(3 \\cdot (100\\) \\(mod\\) \\(3)\\) \\(+\\) \\(9 \\cdot (100\\) \\(mod\\) \\(4)\\) \\(+\\) \\(4 \\cdot (100\\) \\(mod\\) \\(5)\\) \\(=\\) \\(0 + 0 + 3 + 0 + 0\\) \\(=\\) \\(3\\).</li> <li>Tre\u0107eg dana vrednost \\(A_3\\) postaje \\(5\\).</li> <li>Odgovor za \u010detvrti dan je \\(7 \\cdot (100\\) \\(mod\\) \\(1)\\) \\(+\\) \\(2 \\cdot (100\\) \\(mod\\) \\(2)\\) \\(+\\) \\(5 \\cdot (100\\) \\(mod\\) \\(3)\\) \\(+\\) \\(9 \\cdot (100\\) \\(mod\\) \\(4)\\) \\(+\\) \\(4 \\cdot (100\\) \\(mod\\) \\(5)\\) \\(=\\) \\(0 + 0 + 5 + 0 + 0\\) \\(=\\) \\(5\\).</li> <li>Odgovor za peti dan je \\(7 \\cdot (1\\) \\(mod\\) \\(1)\\) \\(+\\) \\(2 \\cdot (1\\) \\(mod\\) \\(2)\\) \\(+\\) \\(5 \\cdot(1\\) \\(mod\\) \\(3)\\) \\(=\\) \\(0 + 2 + 5\\) \\(=\\) \\(7\\).</li> </ul> <p>Nakon poziva va\u0161e funkcije niz \\(O\\) treba da bude jednak \\(\\{13, 3, \\varnothing, 5, 7\\}\\).</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#opis-funkcije","title":"Opis funkcije","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, A[\\ldots], Q, T[\\ldots], L[\\ldots], R[\\ldots], S[\\ldots], O[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj nivoa video igrice, a \\(Q\\) broj dana. Nizovi \\(T\\), \\(L\\), \\(R\\) i \\(S\\) opisuju doga\u0111aje u narednih \\(Q\\) dana. U niz \\(O\\) potebno je upisati odgovore na pitanja za sve dane kada je \\(T_i = 1\\). Nije potrebno ni\u0161ta upisivati kao vrednosti za ostale \u010dlanove niza \\(O\\) (kada je \\(T_i = 2\\)).</p> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q, A_i \\leq 10^5\\)</li> <li>Za \\(T_i = 1\\) va\u017ei \\(1 \\leq L_i \\leq R_i \\leq N\\), \\(1 \\leq S_i \\leq 10^5\\)</li> <li>Za \\(T_i = 2\\) va\u017ei \\(1 \\leq L_i \\leq N\\), \\(1 \\leq R_i \\leq 10^5\\)</li> </ul>"},{"location":"takprog/2021_2022/sio/03_igrica/#podzadaci","title":"Podzadaci","text":"<ul> <li>[8 poena]: \\(N, Q \\leq 1000\\)</li> <li>[12 poena]: Za \\(T_i = 1\\) va\u017ei \\(S_i \\leq 10\\)</li> <li>[24 poena]: \\(A_i = 1\\) za sve \\(1 \\leq i \\leq N\\) i \\(T_i = 1\\) za sve dane</li> <li>[20 poena]: \\(T_i = 1\\) za sve dane</li> <li>[36 poena]: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2021_2022/sio/03_igrica/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee da sadr\u017ei i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int* A, int Q, int* T, int* L, int* R, int* S, long long* O);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova, ali ne smeju da pristupaju van njihovih granica.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koji mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Obaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\).</li> <li>U drugom redu niz \\(A\\) od \\(N\\) brojeva.</li> <li>U tre\u0107em redu broj \\(Q\\).</li> <li>U narednih \\(Q\\) redova po 3 ili 4 broja koji predstavljaju upite.</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju i \u0161tampa, u zasebnim redovima, odgovore na upite prvog tipa koje je va\u0161a funkcija upisala u niz \\(O\\).</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#resenje-kada-je-n-q-leq-1000","title":"Re\u0161enje kada je \\(N, Q \\leq 1000\\)","text":"<p>Na upite za ovaj podzadatak mogu\u0107e je odgovoriti direktnim izra\u010dunavanjem tra\u017eene sume.</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#resenje-kada-je-s_i-leq-10","title":"Re\u0161enje kada je \\(S_i \\leq 10\\)","text":"<p>Upite mo\u017eemo da re\u0161avamo iz dva dela. Prvih \\(S_i\\) \u010dlanova sume mo\u017eemo da ura\u010dunamo direktno po formuli kao u pro\u0161lom podzadatku, a za ostale \u010dlanove znamo da je \\(m &gt; S_i\\) pa je \\(S_i\\) \\(mod\\) \\(m = S_i\\), te je dovoljno na\u0107i njihovu sumu i pomno\u017eiti je sa \\(S_i\\). Za brze upite o sumi na podnizu mo\u017eemo da koristimo strukturu podataka binarno indeksirano stablo ili segmentno stablo. Ove strukture podr\u017eavaju izmenu \u010dlanova niza, tako da lako mo\u017eemo da podr\u017eimo i a\u017euriranja igrice. Vremenska slo\u017eenost je \\(O((N+Q)logN)\\).</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#resenje-kada-je-a_i-1-i-t_i-1","title":"Re\u0161enje kada je \\(A_i = 1\\) i \\(T_i = 1\\)","text":"<p>U ovom podzadatku upiti se svode na izra\u010dunavanje sume \\(\\Sigma_{m=1}^{R_i - L_i + 1} (S_i\\) \\(mod\\) \\(m)\\). Primetimo da je \\(S_i\\) \\(mod\\) \\(m = S_i - \\lfloor \\frac{S_i}{m} \\rfloor \\cdot m\\), pa mo\u017eemo sumu da rastavimo po minusu. Prvi deo je \\(S_i \\cdot (R_i - L_i + 1)\\) i od njega oduzimamo drugi deo koji ra\u010dunamo iz vi\u0161e delova. Prvih \\(\\sqrt{S_i}\\) \u010dlanova sume ra\u010dunamo direktno po formuli. Za ostale \u010dlanove postoji najvi\u0161e \\(\\sqrt{S_i}\\) razli\u010ditih vrednosti za \\(\\lfloor \\frac{S_i}{m} \\rfloor\\) i mo\u017eemo da odredimo levu i desnu granicu za svaku vrednost tako da mo\u017eemo da izra\u010dunamo \\(\\Sigma_{m=l}^{r} \\lfloor \\frac{S_i}{m} \\rfloor \\cdot m\\) kao \\(\\lfloor \\frac{S_i}{m} \\rfloor \\Sigma_{m=l}^{r} m\\) primenom formule za zbir uzastopnih prirodnih brojeva ili prekalkulisanjem ovih suma. Vremenska slo\u017eenost je \\(O(Q \\sqrt{S})\\).</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#resenje-kada-je-t_i-1","title":"Re\u0161enje kada je \\(T_i = 1\\)","text":"<p>Upite re\u0161avamo na sli\u010dan na\u010din kao u prethodnom podzadatku, ali su formule malo komplikovanije. Prekalkulisa\u0107emo prefiksne sume niza \\(A_i\\) i niza \\(A_i \\cdot i\\). Pronalazimo grupe kao u pro\u0161lom podzadatku i umesto zbira uzastopnih celih brojeva, koristi\u0107emo prekalkulisane vrednosti. \\(\\Sigma_{m=l}^{r} A_{L_i + m - 1} \\cdot \\lfloor \\frac{S_i}{m} \\rfloor \\cdot m\\) se svodi na izra\u010dunavanje \\(\\Sigma_{m=l}^{r} A_{L_i + m - 1} \\cdot m\\) po\u0161to je vrednost \\(\\lfloor \\frac{S_i}{m} \\rfloor\\) fiksna za svaku grupu. Izra\u010dunavanje pomenute sume mogu\u0107e je preko suma podniza niza \\(A_i\\) i \\(A_i \\cdot i\\). vremenska slo\u017eenost je \\(O(Q \\sqrt(S))\\)</p>"},{"location":"takprog/2021_2022/sio/03_igrica/#resenje-za-sve-bodove","title":"Re\u0161enje za sve bodove","text":"<p>Za celo re\u0161enje potrebno je jo\u0161 podr\u017eati operacije izmene niza. Dovoljno je umesto prekalkulisanih prefiksnih suma koristiti binarno indeksirano stablo za odr\u017eavanje suma na podnizu. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(Q \\sqrt{S} log N)\\)</p> 03_igrica.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n\nconst int N=100050;\n\nstruct BIT {\n    ll sum[N];\n    void init() {\n        for (int i = 0; i &lt; N; ++i)\n            sum[i] = 0;\n    }\n    BIT() { init(); }\n    ll Get(int i) {\n        ll ans = 0;\n        for (; i &gt; 0; i -= i &amp; -i)\n            ans += sum[i];\n        return ans;\n    }\n    ll Get(int l, int r) {\n        return Get(r) - Get(l - 1);\n    }\n    void Add(int i, ll x) {\n        for(; i &lt; N; i += i &amp; -i)\n            sum[i] += x;\n    }\n} BT1, BTi;\n\nvoid Resi(int n, int *a, int q, int *t, int *l, int *r, int *s, ll *o) {\n    for (int i = 1; i &lt;= n; ++i) {\n        BT1.Add(i, a[i]);\n        BTi.Add(i, (ll)a[i] * i);\n    }\n    for (int i = 1; i &lt;= q; ++i) {\n        if (t[i] == 1) {\n            o[i] = 0;\n            int sq = ceil(sqrt(s[i]));\n            for (int j = l[i]; j &lt;= min(r[i], l[i] + sq); ++j)\n                o[i] += (ll)a[j] * (s[i] % (j - l[i] + 1));\n            int ptr = l[i] + sq + 1;\n            while (ptr &lt;= r[i]) {\n                int m = ptr - l[i] + 1;\n                int x = s[i] / m;\n                int L = ptr, mR, R;\n                if (x == 0) {\n                    R = r[i];\n                } else {\n                    mR = s[i] / x;\n                    R = l[i] + mR - 1;\n                }\n                R = min(R, r[i]);\n\n                ll sum = BT1.Get(L, R);\n                ll sumi = BTi.Get(L, R);\n                sumi -= sum * (l[i] - 1);\n\n                o[i] += sum * s[i];\n                o[i] -= sumi * x;\n                ptr = R + 1;\n            }\n        } else {\n            BT1.Add(l[i], r[i] - a[l[i]]);\n            BTi.Add(l[i], (ll)(r[i] - a[l[i]]) * l[i]);\n            a[l[i]] = r[i];\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/sio/04_dugmici/","title":"4 - Dugmi\u0107i","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 700ms 64MB <p>Posle svih svojih dogodov\u0161tina na takmi\u010denjima iz programiranja, mali Perica je shvatio da je najzanimljiviji deo svakog takmi\u010denja kliktanje \"Refresh\" dugmeta dok \u010deka rezultate. Zato je Perica odlu\u010dio da postane profesionalni klikta\u010d dugmi\u0107a.</p> <p>U pripremama za MOKD (Me\u0111unarodnu Olimpijadu iz Kliktanja Dugmi\u0107a), Perica je dizajnirao specijalni trening. Pore\u0111ao je, na ekranu ra\u010dunara, \\(N\\) dugmi\u0107a u niz, pri \u010demu dugme \\(i\\) ima tajmer koji odbrojava \\(T_i\\) stotinki. Kada Perica startuje trening, on pomera kursor po ekranu i klik\u0107e. </p> <p>Da bi kursor pomerio izme\u0111u dva susedna dugmeta, Perici treba jedna stotinka. Peri\u010din cilj je da klikne svako dugme pre nego \u0161to tajmer tog dugmeta istekne. Tako\u0111e, kada god Perica klikne dugme \\(i\\), tajmer tog dugmeta se resetuje i kre\u0107e da odbrojava \\(T_i\\) stotinki od po\u010detka. Perica \u017eeli da prona\u0111e strategiju kojom mo\u017ee da pomera kursor i klik\u0107e dugmi\u0107e proizvoljno dugo, a da tajmer nijednog dugmeta ne istekne do kraja (to jest da izme\u0111u dva uzastopna klika dugmeta \\(i\\) ne protekne striktno vi\u0161e od \\(T_i\\) stotinki). </p> <p>Pri tome, pretpostavljamo da Perica mo\u017ee da izabere proizvoljnu startnu poziciju kursora na ekranu, kao i da svi tajmeri kre\u0107u da odbrojavaju tek kada se trening startuje. Tako\u0111e, pretpostavljamo da sam klik traje zanemarljivo kratko, pa je pomeranje kursora jedina stvar za koju je potrebno vreme.</p> <p>Po\u0161to je Perici kliktanje dugmi\u0107a dosadilo jako brzo, smislio je zadatak za Vas. Data su Vam po\u010detna vremena za tajmer svakog dugmeta \\(T_i\\), kao i \\(Q\\) upita, koji mogu do\u0107i u dva tipa. Za upite prvog tipa dat je indeks dugmeta \\(i\\) i novo trajanje tajmera za to dugme, \\(T_i\\). Za upite drugog tipa, dati su indeksi \\(L\\) i \\(R\\), i treba da odredite da li Perica mo\u017ee da klik\u0107e dugmi\u0107e sa indeksima u intervalu \\([L, R]\\) proizvoljno dugo (to jest, da li Perica mo\u017ee da uspe\u0161no obavi trening ukoliko su tajmeri aktivni samo na dugmi\u0107ima u intervalu \\([L, R]\\)).</p> <p>Ukoliko uspe\u0161no obavite ovaj zadatak, pomo\u0107i\u0107ete Perici da se spremi za MOKD, a on \u0107e sa Vama podeliti deo nagrade koje pobeda na ovom presti\u017enom takmi\u010denju donosi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Milojevi\u0107 Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107"},{"location":"takprog/2021_2022/sio/04_dugmici/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju </p> <ul> <li>\\(Trening(N, T[\\ldots], Q, X[\\ldots], Y[\\ldots], Z[\\ldots], Ans[\\ldots])\\),</li> </ul> <p>gde je \\(N\\) broj dugmi\u0107a u nizu, a \\(Q\\) broj upita. Niz \\(T[\\ldots]\\) sadr\u017ei po\u010detna vremena za svaki od tajmera - tajmer dugmeta \\(i\\) na po\u010detku treninga odbrojava \\(T[i]\\) stotinki. Niz \\(X[i]\\) predstavlja tip upita \\(i\\): ukoliko je \\(X[i]=1\\), upit \\(i\\) je prvog tipa, a ukoliko je \\(X[i]=2\\), onda je upit \\(i\\) drugog tipa. </p> <p>Ukoliko je upit \\(i\\) prvog tipa, \\(Y[i]\\) predstavlja indeks dugmeta \u010diji tajmer treba promeniti, dok \\(Z[i]\\) predstavlja novu vrednost tajmera. Ukoliko je upit \\(i\\) drugog tipa, \\(Y[i]\\) predstavlja levu, a \\(Z[i]\\) desnu granicu intervala na kome treba odrediti da li Perica mo\u017ee proizvoljno dugo da klik\u0107e dugmi\u0107e bez da ijedan tajmer istekne. Kona\u010dno, ako je upit \\(i\\) drugog tipa, u niz \\(Ans\\) treba upisati \\(Ans[i]=1\\) ako Perica mo\u017ee da trenira na intervalu \\([Y[i], Z[i]]\\) proizvoljno dugo. U suprotnom, treba upisati \\(Ans[i]=0\\). Za upite prvog tipa, vrednost \\(Ans[i]\\) neophodno je ostaviti nepromenjenu.</p> <p>Svi nizovi su indeksirani od 1.</p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#primer","title":"Primer","text":"<p>Neka je \\(N=5\\) i \\(Q=5\\). Neka su po\u010detna vremena tajmera \\(T=[4, 5, 6, 2, 3]\\) i neka su nizovi \\(X=[2, 2, 2, 1, 2], Y=[1, 1, 4, 3, 1]\\), \\(Z=[5, 3, 5, 2, 3]\\) i \\(Ans=[-1, -1, -1, -1, -1]\\). Prvi upit je drugog tipa, i odgovor na njega je NE, jer ne postoji na\u010din da Perica proizvoljno dugo klik\u0107e sve dugmi\u0107e bez da ijedan tajmer istekne. Na drugi upit je odgovor DA, jer Perica mo\u017ee da klik\u0107e dugmi\u0107e po u rasporedu 1, 2, 1, 2, 3, 2, 1, 2, 1, 2, 3, 2, 1, 2, 1... Na tre\u0107i upit je odgovor DA tako\u0111e, jer Perica mo\u017ee kliktati po rasporedu 4, 5, 4, 5, 4... U \u010detvrom upitu se tajmer tre\u0107eg dugmeta postavlja na 2 stotinke, pa je odgovor na peti upit NE. </p> <p>Dakle, niz \\(Ans\\) treba postaviti na \\(Ans=[0, 1, 1, -1, 0]\\).</p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N, Q\\leq 2\\cdot 10^5\\),</li> <li>\\(1\\leq T[i] \\leq 10^9\\), za sve \\(i\\in [1, N]\\),</li> <li>\\(1\\leq X[i] \\leq 2\\), za sve \\(i\\in [1, Q]\\),</li> <li>Ako je \\(X[i]=1\\), tada \\(1\\leq Y[i] \\leq N\\) i \\(1\\leq Z[i] \\leq 10^9\\),</li> <li>Ako je \\(X[i]=2\\), tada \\(1\\leq Y[i] \\leq Z[i] \\leq N\\),</li> <li>\\(Ans[i]=-1\\) za sve \\(i\\in [1, Q]\\).</li> </ul>"},{"location":"takprog/2021_2022/sio/04_dugmici/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(4\\) podzadatka:</p> <ul> <li>[6 poena]: \\(T[i]\\leq 6\\) i \\(Z[i]\\leq 6\\) kadgod je \\(X[i]=1\\).</li> <li>[15 poena]: \\(N, Q\\leq 2\\cdot 10^3\\).</li> <li>[23 poena]: Svi su upiti drugog tipa, to jest va\u017ei \\(X[i]=2\\) za sve \\(i \\in [1, Q]\\).</li> <li>[56 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/sio/04_dugmici/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>dugmici.cpp</code> koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Trening(int N, int* T, int Q, int* X, int* Y, int* Z, int* Ans);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(Q\\).</li> <li>U drugom redu \\(N\\) brojeva koji predstavljaju po\u010detne vrednosti tajmera.</li> <li>U narednih \\(Q\\) redova po tri broja, \\(X[i], Y[i], Z[i]\\) koji opisuju upit.</li> </ul> <p>Zatim ovaj program poziva va\u0161u funkciju uz niz \\(Ans=[-1, \\ldots, -1]\\) i \u0161tampa niz \\(Ans\\) koji je vratila va\u0161a funkcija.</p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#resenje-kada-t_i-leq-6-i-z_i-leq-6-za-x_i-1","title":"Re\u0161enje kada \\(T_i \\leq 6\\), i \\(Z_i \\leq 6\\) za \\(X_i = 1\\):","text":"<p>U ovom slu\u010daju treba razmatrati jedino kratke segmente \\([L,R]\\), jer ukoliko je odgovor DA, mora\u0107emo u jednom trenutku da odemo od krajnjeg levog do krajnjeg desnog dugmeta, \u0161to bi ugasilo po\u010detni tajmer ukoliko je \\(T_L &lt; (R-L)\\). Na ovim segmentima mo\u017eemo da poku\u0161amo da idemo levo-desno par puta, menjaju\u0107i na svakom koraku sve tajmere u segmentu.</p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#resenje-kada-nq-leq-2000","title":"Re\u0161enje kada \\(N,Q \\leq 2000\\):","text":"<p>Uo\u010dimo da, ukoliko postoji re\u0161enje, \u0107emo do svakog dugmeta morati u nekom trenutku da do\u0111emo do levog, kao i do desnog kraja segmenta, i nazad. Dakle, za trajanje svakog tajmera u tra\u017eenom segmentu mora da va\u017ei \\(T_i \\geq 2(i-L)\\) (dugme-levi kraj-dugme) i \\(T_i \\geq 2(R-i)\\) (analogno za desni kraj). Obilazak 'levo-desno' nam upravo garantuje da uspevamo \u010dak i ako va\u017ei \\(T_i = 2(i-L)\\) i \\(T_i = 2(R-i)\\). Ove nejednakosti mo\u017eemo ru\u010dno da proverimo za svako dugme u segmentu. </p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#resenje-kada-x_i-2","title":"Re\u0161enje kada \\(X_i = 2\\)","text":"<p>\u010cinjenica da nema promena u nizu implicira offline re\u0161enje. Naime, potrebno je na\u0107i odgovore za sve segmente \\([L,R]\\) prolaskom kroz niz jednom. Primetimo da ako va\u017ei nejednakost \\(T_i \\geq 2(i-L)\\), za neko \\(L\\), ona va\u017ei i za sve manje \\(L\\). Shodno tome, obilazimo sve dugmi\u0107e od \\(1\\) ka \\(N\\) i na svakom dodajemo u neku strukturu sve leve krajeve segmenata koji u njemu po\u010dinju, dok bri\u0161emo redom (od manjih ka ve\u0107im) sve leve po\u010detke za koje ne va\u017ei \\(T_i \\geq 2(i-L)\\) (\u0161to posti\u017eemo tako \u0161to npr. u multiset dr\u017eimo vrednosti \\(2L\\) i pore\u0111ujemo ih sa \\(2i-T_i\\)), a potvr\u0111ujemo mogu\u0107nost re\u0161enja za neki segment kad do\u0111emo do dugmeta koje predstavlja njegov desni kraj. Ovo je potrebno uraditi i u drugom smeru (od kraja ka po\u010detku).</p>"},{"location":"takprog/2021_2022/sio/04_dugmici/#resenje-za-pun-broj-poena","title":"Re\u0161enje za pun broj poena","text":"<p>Kako u svim dugmi\u0107ima segmenta treba da va\u017ei \\(T_i \\geq 2(i-L), T_i \\geq 2(R-i)\\) (\u0161to je ekvivalentno sa \\(2L \\geq 2i-T_i, 2R \\leq T_i+2i\\)), to zna\u010di da nam je potreban na\u010din da odredimo da li postoji vrednost \\(2i-T_i \\leq 2L\\) i \\(2i+T_i \\geq 2R\\) za \\(i\\) u segmentu \\([L, R]\\) (vrednost za koje ne va\u017ei nejednakost), kao i da promenimo vrednost na nekoj poziciji. Ovo nam omogu\u0107avaju dva segmentna stabla, gde \u010duvamo vrednosti \\(2i+T_i\\) i \\(2i-T_i\\) i pore\u0111ujemo maksimum, odnosno minimum na tra\u017eenim segmentima sa \\(2R\\) i \\(2L\\). </p> 04_dugmici.cpp<pre><code>//SIO 2022 - Zadatak 4 - Dugmici \n\n#include &lt;bits/stdc++.h&gt;\n#define INF INT_MAX\n#define MAX_N 200005\n\nusing namespace std;\n\nint A[4*MAX_N], B[4*MAX_N];\nint N, Q;\nint *X, *Y, *Z, *T;\n\nvoid segtree(int* tree, int v, int l, int r, int sign){\n    if(l+1 == r){\n        tree[v]=T[l]+2*sign*l;\n        return;\n    }\n    int m=(l+r)/2;\n    segtree(tree, 2*v+1, l, m, sign);\n    segtree(tree, 2*v+2, m, r, sign);\n    tree[v]=tree[2*v+1]&lt;tree[2*v+2]?tree[2*v+1]:tree[2*v+2];\n}\n\nint query(int* tree, int v, int tl, int tr, int l, int r){\n    if(l &gt;= tr || r &lt;= tl){\n        return INF;\n    }\n    if(tl &gt;= l &amp;&amp; tr &lt;= r){\n        return tree[v];\n    }\n    int tm=(tl+tr)/2;\n    int val1=query(tree, 2*v+1, tl, tm, l, r);\n    int val2=query(tree, 2*v+2, tm, tr, l, r);\n    return val1&lt;val2?val1:val2;\n}\n\nvoid update(int* tree, int v, int l, int r, int i, int val, int sign) {\n    if (l+1 == r) {\n        tree[v] = val+2*sign*l;\n        return;\n    } \n    int m = (l+r)/2;\n    if (i &lt; m)\n        update(tree, v*2+1, l, m, i, val, sign);\n    else\n        update(tree, v*2+2, m, r, i, val, sign);  \n    tree[v]=tree[2*v+1]&lt;tree[2*v+2]?tree[2*v+1]:tree[2*v+2];\n}\n\nvoid Trening(int n, int* t, int q, int* x, int* y, int* z, int* Ans){\n\n    X=x+1, Y=y+1, Z=z+1, T=t+1;\n    N=n, Q=q;\n\n    segtree(A, 0, 0, N, -1);\n    segtree(B, 0, 0, N, 1);\n\n    for(int i=0; i&lt;Q; ++i){\n        if(X[i]==1){\n            update(A, 0, 0, N, Y[i]-1, Z[i], -1);\n            update(B, 0, 0, N, Y[i]-1, Z[i], +1);\n        }\n\n        if(X[i]==2){\n            int L=Y[i]-1;\n            int R=Z[i]-1;\n            int Aquery=query(A, 0, 0, N, L, R+1);\n            int Bquery=query(B, 0, 0, N, L, R+1);\n            if(Aquery&gt;=-2*L &amp;&amp; Bquery&gt;=2*R)\n                Ans[i+1]=1;\n            else \n                Ans[i+1]=0;\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2021_2022/sio/05_us_open/","title":"5 - US Open","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>U finalu \u017eenske divizije pro\u0161logodi\u0161njeg Otvorenog prvenstva Sjedinjenih Ameri\u010dkih Dr\u017eava u tenisu (poznatijem u narodu kao Ju Es Open) sastale su se Ema Radukanu i Lejla Fernandez. Neki posve\u0107eniji obo\u017eavatelji su primetili da je najdu\u017ei me\u010d koji je igrala Radukanu na putu do finala (97 minuta) bio kra\u0107i od najkra\u0107eg me\u010da koji je odigrala Fernandez na putu do finala (105 minuta).  Ceo teniski svet se slo\u017eio da je ova \u010dinjenica interesantna.</p> <p>Vi trenutno organizujete svoj turnir sa \\(N+1\\) kola, na kom se ve\u0107 odigralo prvo kolo. Ostalo je jo\u0161 \\(2^N\\) igra\u010da, koji su redom numerisani brojevima \\(1,2,3,\\cdots,2^N\\). Turnir je organizovan kao kompletno binarno stablo, a \\(i\\)-ti igra\u010d se nalazi u \\(i\\)-tom listu tog stabla pri standardnom (levo-koren-desno) obilasku, i u svakom me\u010du pobednik ide dalje, dok gubitnik otpada. Po ugledu na prethodno navedeno finale, vi ste odlu\u010dili da je me\u010d interesantan ako je du\u017eine barem kao najdu\u017ei me\u010d koji je do sada igrao igra\u010d sa leve strane \u017ereba (to jest onaj sa manjim indeksom), a du\u017eine najvi\u0161e najkra\u0107eg me\u010da koji je do sada igrao igra\u010d sa desne strane \u017ereba (to jest onaj sa ve\u0107im indeksom).</p> <p>Poznate su vam du\u017eine trajanja svih me\u010deva iz prvog kola, a ba\u0161 cilj je da turnir bude \u0161to interesantiji. Za svaki me\u010d potrebno je da izaberete pobednika i du\u017einu trajanja, tako da bude maksimalno mogu\u0107e interesantnih me\u010deva. Igra\u010di \u0107e se, naravno, slo\u017eiti sa va\u0161im predlogom o du\u017eini me\u010da i pobedniku. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Tadija \u0160ebez <p>Prva stvar koju je potrebno da primetimo jeste   kako da dodelimo vreme trajanja nekom konkretnim me\u010du. Primetimo da nam se uvek isplati da to bude vreme trajanja prvog me\u010da pobednika. Takav me\u010d jo\u0161 uvek ima potencijal da bude interesantan, a ne ograni\u010davamo se za budu\u0107e me\u010deve vi\u0161e nego \u0161to moramo. Sada je potrebno samo odrediti pobednika svakog me\u010da dok zami\u0161ljamo da se njegovo vreme propagira na slede\u0107e kolo.</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Interesantnost(N,  A[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj kola koje treba jo\u0161 odigrati,  a \\(A[\\ldots]\\) niz du\u017eine \\(2^N\\) koji predstavlja du\u017eine trajanja me\u010deva prvog kola - prvi me\u010d igra\u010da \\(i\\) je trajao \\(A[i]\\) minuta.  Niz je indeksiran od 1.</p> <p>Funkcija treba da vrati najve\u0107i mogu\u0107i broj interesantnih me\u010deva.</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#primer","title":"Primer","text":"<p>Neka je \\(N=2\\),  \\(A=\\{6,8,10,2\\}\\).  Prvi me\u010d se igra izme\u0111u igra\u010da \u010diji su me\u010devi u prvom kolu  trajali \\(6\\) i \\(8\\) minuta, tako da taj me\u010d mora trajati barem \\(6\\) a najvi\u0161e \\(8\\) minuta da bi bio interesantan - neka je na primer trajao \\(7\\) minuta, i neka je pobedio igra\u010d broj \\(2\\). Drugi me\u010d da bi bio interesantan, mora da traje barem \\(10\\) a najvi\u0161e \\(2\\) minuta, tako da o\u010dito nikada ne\u0107e biti interesantan, neka je na primer u njemu pobedio igra\u010d broj \\(4\\) i da je me\u010d trajao \\(9\\) minuta. Sada, u finalu \u0107e se sresti igra\u010d \\(2\\) sa leve strane \u017ereba, \u010diji je najdu\u017ei me\u010d trajao \\(8\\) minuta, i igra\u010d \\(4\\) sa desen strane \u017ereba, \u010diji je najkra\u0107u me\u010d trajao \\(9\\) minuta. Ako finale traje \\(8\\) minuta, onda \u0107e i ono biti interesantno tako da mo\u017ee biti najvi\u0161e \\(2\\) interesantna me\u010da, pa funkcija treba da vrati \\(2\\). </p>"},{"location":"takprog/2021_2022/sio/05_us_open/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 20\\)</li> <li>\\(1 \\leq A[i] \\leq 10^9\\)</li> </ul>"},{"location":"takprog/2021_2022/sio/05_us_open/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(5\\) podzadatka:</p> <ul> <li>[10 poena]: \\(N\\le4\\).</li> <li>[17 poena]: \\(A[i]\\le2\\). </li> <li>[18 poena]: \\(N\\le 17\\) i \\(A[i]\\le100\\).  </li> <li>[26 poena]: \\(N\\le17\\).  </li> <li>[29 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/sio/05_us_open/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>us_open.cpp</code>  koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Interesantnost(int N, int* A);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu broj \\(N\\).</li> <li>U narednom redu \\(2^N\\) brojeva: \\(A[i]\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje rezultat koji va\u0161a funkcija vrati.</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#resenje-kada-n-leq-4","title":"Re\u0161enje kada \\(N \\leq 4\\)","text":"<p>Po\u0161to ima \\(16\\) preostalih igra\u010da, postoja\u0107e jo\u0161 ukupno \\(15\\) me\u010deva. Za svaki me\u010d mo\u017eemo da odaberemo da li pobe\u0111uje levi ili desni igra\u010d, jer postoji samo \\(2^{15} = 32768\\) kombinacija.</p> <p>Vremenska slo\u017eenost je \\(O(2^ {2^N})\\), a memorijska \\(O(2^N)\\).</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#resenje-kada-ai-leq-2","title":"Re\u0161enje kada \\(A[i] \\leq 2\\)","text":"<p>Jasno je po gornjoj obzervaciji da \u0107e svaki me\u010d trajati ili \\(1\\) ili \\(2\\) minuta (mora da igra \u0110okovi\u0107). Numeri\u0161emo sve me\u010deve od \\(1\\) do \\(2^{N+1}-1\\). Sada, mo\u017eemo raditi dinami\u010dko programiranje oblika: </p> \\[ dp[i][1/2] = \\text{optimalno re\u0161enje ako me\u010d }i\\text{ traje 1, odnosno 2 minuta} \\] <p>Bazni slu\u010dajevi su o\u010digledno me\u010devi prvog kola, za koje znamo koliko su trajali (i onda na jedan slu\u010daj tih me\u010deva stavljamo \\(0\\), a na drugi \\(-\\infty\\)). </p> <p>Posmatrajmo neki fiksni me\u010d \\(i\\) koji nije me\u010d prvog kola. Neka je \\(l\\) me\u010d iz kojeg je do\u0161ao pobednik leve strane \u017ereba, a \\(d\\) me\u010d iz kojeg je do\u0161ao pobednik leve strane \u017ereba.</p> <p>Va\u017ee slede\u0107e rekurentne veze: </p> \\[ dp[i][1] = \\max(dp[l][1]+dp[r][1]+1, dp[l][1]+dp[r][2]+1, dp[l][2]+dp[r][1]) $$ $$ dp[i][2] = \\max(dp[l][2]+dp[r][2]+1, dp[l][1]+dp[r][2]+1, dp[l][2]+dp[r][1]) \\] <p>Dakle, svaka kombinacija, sem kada je me\u010d \\(l\\) trajao \\(2\\) minuta, a me\u010d \\(r\\) trajao \\(1\\) minut, daje jedan novi interesantan me\u010d. Krajnji rezultat, ako je finale numerisano brojem \\(f\\), je \\(\\max(dp[f][1], dp[f][2])\\).</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(2^N)\\).</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#resenje-kada-n-leq-17-i-ai-leq-100","title":"Re\u0161enje kada \\(N \\leq 17\\) i \\(A[i] \\leq 100\\)","text":"<p>Sli\u010dno prethodnom podzadatku, radi\u0107emo dinami\u010dko programiranje nad numerisanim me\u010devima:</p> \\[ dp[i][j] = \\text{optimalno re\u0161enje ako me\u010d }i\\text{ traje } j \\text{ minuta} \\] <p>Ponovo imamo tri slu\u010daja: - Prvi slu\u010daj je ako ne \u017eelimo da trenutni me\u010d bude interesantan. Onda jedan me\u010d (levi ili desni) mora trajati \\(j\\) minuta, za drugi mo\u017eemo uzeti bilo koju vrednost, pa \u0107emo uzeti onu koja daje najvi\u0161e interesantnih me\u010deva.  - Drugi slu\u010daj je da \u017eelimo da me\u010d \\(i\\) bude interesantan, a da levi me\u010d traje \\(j\\) minuta. Zato, desni me\u010d mora trajati makar toliko, da bismo dobili novi interesantan me\u010d. Uze\u0107emo naravno optimalnu du\u017einu desnog me\u010da. - Tre\u0107i slu\u010daj je tako\u0111e da \u017eelimo da me\u010d \\(i\\) bude interesantan, a da desni me\u010d traje \\(j\\) minuta. Levi me\u010d onda mora trajati najvi\u0161e toliko. Ponovo uzimamo optimalnu du\u017einu levog me\u010da.</p> <p>Sve ovo mo\u017eemo efikasno implementirati \u010duvaju\u0107i prefiksne, odnosno sufiksne maksimume nad dinami\u010dkim programiranjem za svaki me\u010d.</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(2^N\\cdot maxA)\\).</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#resenje-kada-n-leq-17","title":"Re\u0161enje kada \\(N \\leq 17\\)","text":"<p>Zadatak ponovo radimo dinami\u010dkim programiranjem, mada ovaj put numeri\u0161emo i me\u010deve i igra\u010de:</p> \\[ dp[i][j] = \\text{optimalno re\u0161enje ako je pobednika me\u010da }i\\text{ igra\u010d } j \\] <p>Ovde na prvi pogled ima \\(O(2^N\\cdot 2^N)\\) stanja, ali to nije ta\u010dno - broj igra\u010da koji mogu biti pobednici nekog me\u010da (koji su u tom delu \u017ereba) dosta varira. U zbiru, zato, postoji samo \\(O(2^N \\cdot N)\\) stanja, jer svaki igra\u010d mo\u017ee biti pobednik u samo \\(N\\) razli\u010ditih me\u010deva. Dinami\u010dko programiranje mo\u017eemo raditi kolo po kolo, krenuv\u0161i od drugog kola (prvo je ve\u0107 odigrano).</p> <p>Sada, sli\u010dno prethodnom podzadatku, ako nam je pobednik sa leve strane \u017ereba i \u017eelimo interesantan me\u010d, desno moramo odabrati igra\u010da kojem je prvi me\u010d trajao makar koliko prvi me\u010d pobednika. Analogno radimo i ako \u017eelimo da pobednik bude iz desne strane \u017ereba.</p> <p>Kako bismo to efikasno uradili, moramo u obe polovine imati igra\u010de sortirane po du\u017eini prvog me\u010da. Nakon doga, poput prethodnog zadatka mo\u017eemo koriste\u0107i prefiksne/sufiksne maksimume nad nizom dinami\u010dkog programiranja, kao i tehniku dva pokaziva\u010da ili binarnu pretragu, mo\u017eemo na\u0107i odgovaraju\u0107e vrednosti. Sve ovo mo\u017eemo jednostavno implementirati rekurzijom.</p> <p>Vremenska slo\u017eenost je \\(O(2^N \\cdot N^2)\\), a memorijska \\(O(2^N)\\) (ako pamtimo uvek samo rezultate prethodnog kola).</p>"},{"location":"takprog/2021_2022/sio/05_us_open/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sli\u010dno prethodnom podzadatku, samo \u0161to umesto da koristimo sortiranje na svakom nivou rekurzije, mi odr\u017eavamo sortirani niz i spajamo ih tehnikom dva pokaziva\u010da, poput algoritma merge sort. Time smanjujemo vremensku slo\u017eenost za \\(N\\) faktor.</p> <p>Vremenska slo\u017eenost je \\(O(2^N\\cdot N)\\), a memorijska \\(O(2^N)\\).</p> 05_us_open.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN (1&lt;&lt;20)+7\nusing namespace std;\nint a[MAXN],b[MAXN],dp[MAXN],aux[MAXN];\nvoid rek(int l,int r)\n{\n    if(l==r) {dp[l]=0; return;}\n    int s=(l+r)/2;\n    rek(l,s); rek(s+1,r);\n    int t1=l,t2=r;\n    int mx=0,pmax=-500;\n    for(int i=s+1;i&lt;=r;i++) mx=max(mx,dp[i]);\n    for(int i=s;i&gt;=l;i--)\n    {\n        while(t2!=s &amp;&amp; a[t2]&gt;=a[i]) pmax=max(pmax,dp[t2--]);\n        aux[i]=dp[i]+max(pmax+1,mx);\n    }\n    mx=0; pmax=-500;\n    for(int i=l;i&lt;=s;i++) mx=max(mx,dp[i]);\n    for(int i=s+1;i&lt;=r;i++)\n    {\n        while(t1!=s+1 &amp;&amp; a[i]&gt;=a[t1]) pmax=max(pmax,dp[t1++]);\n        aux[i]=dp[i]+max(pmax+1,mx);\n    }\n    t1=l; t2=s+1;\n    while(t1&lt;=s || t2&lt;=r)\n    {\n        if(t1==s+1) {b[t1+t2-s-1]=a[t2]; dp[t1+t2-s-1]=aux[t2]; t2++; continue;}\n        if(t2==r+1) {b[t1+t2-s-1]=a[t1]; dp[t1+t2-s-1]=aux[t1]; t1++; continue;}\n        if(a[t1]&lt;a[t2]) {b[t1+t2-s-1]=a[t1]; dp[t1+t2-s-1]=aux[t1]; t1++; continue;}\n        b[t1+t2-s-1]=a[t2]; dp[t1+t2-s-1]=aux[t2]; t2++;\n    }\n    for(int i=l;i&lt;=r;i++) a[i]=b[i];\n}\nint Interesantnost(int N,int *A)\n{\n    int n=1&lt;&lt;N;\n    for(int i=1;i&lt;=n;i++) a[i]=A[i];\n    rek(1,n);\n    int res=0;\n    for(int i=0;i&lt;n;i++) res=max(res,dp[i]);\n    return res;\n}\n</code></pre>"},{"location":"takprog/2021_2022/sio/06_metropole/","title":"6 - Metropole","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>U nekoj dalekoj zemlji ima \\(N\\) metropola, koji su me\u0111usobno povezane sa \\(M\\) puteva. Svaki put spaja \\(2\\) metropole i dvosmeran je.  Me\u0111utim, prostorno planiranje u ovoj dr\u017eavi je jako neobi\u010dno. Naime, centralna tema tamo su ture - nizovi metropola \\(a_1,a_2,\\cdots,a_n\\) tako da su sve te metropole razli\u010dite i da su \\(a_1-a_2\\), \\(a_2-a_3\\), \\(\\cdots\\), \\(a_n-a_1\\) spojeni putevima. Kako je vlast jako sujeverna, putevi su konstruisani tako se svaka tura sastoji od ta\u010dno \\(4\\) metropola.</p> <p>Vi kao turista u ovoj zemlji \u017eelite da vidite \u0161to vi\u0161e metropola. Standardno bi turista obi\u0161ao neku od tura, ali kako su sve ture du\u017eine \\(4\\) to deluje malko dosadno, pa vi \u017eelite da izaberete va\u0161 obilazak kao najdu\u017ei niz razli\u010ditih metropola tako da su svake dve uzastopne spojene putem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Plav\u0161i\u0107"},{"location":"takprog/2021_2022/sio/06_metropole/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(NajduziPut(N, M, U[\\ldots], V[\\ldots])\\)</li> </ul> <p>gde je \\(N\\) broj koji predstavlja broj metropola,  a \\(M\\) broj koji predstavlja broj puteva. Nizovi \\(U[\\ldots]\\) i \\(V[\\ldots]\\) opisuju te puteve - \\(i\\)-ti put spaja gradove \\(U[i]\\) i \\(V[i]\\).  Svi nizovi su indeksirani od 1.</p> <p>Funkcija treba da vra\u0107a broj puteva na najdu\u017eem mogu\u0107em obilasku).</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#primer","title":"Primer","text":"<p>Neka je \\(N=4\\), i neka je niz \\(M=4\\) i grane \\(U=\\{1,2,3,4\\}\\), \\(V=\\{2,3,4,1\\}\\): tada je najdu\u017ei obilazak \\(1-2-3-4\\), \u0161to ima \\(3\\) puta, pa je odgovor \\(3\\)</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 200.000\\)</li> <li>\\(1 \\leq U[i], V[i] \\leq N\\)</li> <li>\\(U[i]\\neq V[i]\\)</li> <li>Mogu\u0107e je od svake metropole sti\u0107i do svake druge nizom puteva.</li> </ul>"},{"location":"takprog/2021_2022/sio/06_metropole/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[11 poena]: \\(N\\le20\\).</li> <li>[12 poena]: \\(N\\le2500\\).</li> <li>[6 poena]: Ne postoji nijedna tura.</li> <li>[21 poena]: Svaki put se nalazi u najvi\u0161e jednoj turi.</li> <li>[22 poena]: Svaki put koji se nalazi u barem jednoj turi se nalazi u barem dve ture.</li> <li>[28 poena]: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2021_2022/sio/06_metropole/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>metropole.cpp</code>  koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int NajduziPut(int N, int M, int* U, int* V);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojeve \\(N\\) i \\(M\\).</li> <li>U narednih \\(M\\) redova po jedan par brojeva: \\(U[i]\\) i \\(V[i]\\) .</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i \u0161tampa du\u017einu puta koju va\u0161a funkcija vrati.</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#resenje-kada-n-leq-20","title":"Re\u0161enje kada \\(N \\leq 20\\)","text":"<p>Ovo je klasi\u010dan zadatak iz dinami\u010dkog programiranja sa bitmaskama - tra\u017eenje najdu\u017eeg puta u grafu. Imamo dinami\u010dko programiranje \\(dp[i][mask]\\), gde je  \\(i\\) predstavlja \u010dvora do kog smo stigli, a \\(mask\\) je bitmaska koja predstavlja koje smo \u010dvorove posetili do sad. Slo\u017eenost \\(O(N^2\\cdot2^N)\\) </p>"},{"location":"takprog/2021_2022/sio/06_metropole/#resenje-kada-nema-tura","title":"Re\u0161enje kada nema tura","text":"<p>U ovom slu\u010daju, dati graf je stablo, a re\u0161enje u tom slu\u010daju je poznato: mo\u017eemo ili raditi dinami\u010dkim programiranjem, ili naprosto krenemo od proizvoljnog \u010dvora i na\u0111emo od njega najdalji, a zatim od tog najdaljeg na\u0111emo najdalji, \u0161to \u0107e nam dati najdu\u017ei put.</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#kako-dalje","title":"Kako dalje?","text":"<p>Sada treba da na\u0111emo neku ozbiljnu strategiju kako da tra\u017eimo najdu\u017ei put. U tu svrhu \u0107emo prona\u0107i blokove na\u0161eg grafa. To su maksimalni podskupovi \u010dvorova tako da u tim skupovima nema artikulacionih ta\u010daka. Za ovo postoji generalni algoritam, ali u na\u0161em slu\u010daju to mo\u017ee da se uradi lak\u0161e. Naime, pustimo pretragu po dubili (DFS) u na\u0161em grafu, i za svaku granu van stabla uzmemo put na stablu koji spaja njene krajeve (koji je du\u017eine \\(3\\) zbog uslova sa du\u017einama ciklusa) i utrvdimo da su te \\(4\\) grane u istom bloku (svaka grana je najvi\u0161e u jednom bloku). Kada tako na\u0111emo sve mogu\u0107e \u010detvorke, tranzitivno zatvorimo relaciju \"u istom bloku\" (u prevodu, napravimo graf nad granama i u njemu na\u0111emo povezane komponente - \u010dvorovi koje one obuhvataju nam predstavljaju blokove grafa). Sporije implementacije ovog dela su obuhva\u0107ena podzadatkom \\(N\\le2500\\).</p> <p>Sada, u proizvoljnom grafu mo\u017eemo uvesti pojam block-cut stabla tako \u0161to izbacimo sve grane koje su deo nekog bloka i onda za svaki blok napravimo novi \u010dvor koji je povezan sa svim \u010dvorovima u tom bloku. Ovo je interesantno, jer ako je po\u010detni graf povezan, onda nam je block-cut stablo zaista stablo (ako nije povezan onda je u pitanju \u0161uma). Svaki put u ovom grafu mo\u017ee da se preslika u put na block-cut stablu, samo svaki fragment puta koji predstavlja kretanje unutar jednog bloka zamenimo sa putem od po\u010detnog do \u010dvora koji predstavlja taj blok, i onda od tog do zavr\u0161nog.</p> <p>Sada nam je cilj da  modifikujemo block-cut stablo. Za svaki blok \u017eelimo da prona\u0111emo stablo tako da su nam \u010dvorovi bloka listovi, i da je najdu\u017ei put od \\(u\\) do \\(v\\) unutar bloka jednak du\u017eini puta od \\(u\\) do \\(v\\) u na\u0161em stablu. Ako svaki blok \u010dvor u block-cut stablu zamenimo sa ovom mre\u017eom koja enkodira optimizaciju tra\u017eenja najdu\u017eeg puta na onom fragmentu puta koji se nalazi unutar stabla, onda nam se zadatak samo svodi na prethodni podzadatak - tra\u017eenje najdu\u017eeg puta na stablu (ovde konkretno na tom na\u0161em modifikovanom block-cut stablu), jer svaki put u stablu mo\u017eemo na isti na\u010din da preslikamo na put na modifikovanom block-cut stablu, a po konstrukciji \u0107e se najdu\u017ei put preslikati u put iste du\u017eine.</p> <p>Sada nam treba detaljan opis blokova na\u0161eg grafa. Za to nam treba slede\u0107a lema: Lema: Svaki blok u na\u0161em grafu je kompletan bipatritivan graf gde je jedna particija veli\u010dine \\(2\\). Dokaz: Po\u0161to svaki ciklus parne du\u017eine, graf je bipartitivan - neka je u na\u0161em bloku \\(b\\) belih i \\(c\\) crnih. Mogu\u0107e je dokazati da unutar bloka, za svake dve grane postoji ciklus koji ih sadr\u017ei. Pretpostavimo da postoje crni \u010dvor \\(u\\) i beli \u010dvor \\(v\\) koji nisu spojeni granom, i neka iz njih izlaze grane \\(ua\\) i \\(vb\\). Po prethodno navedenom, postoji ciklus koji sadr\u017ei, a to jedino mo\u017ee biti ciklus \\(u-a-b-v\\), tako da su \\(u\\) i \\(v\\) ipak povezani granom, pa je graf kompletan i bipartitivan. Najzad, onda trivijalno postoji ciklus du\u017eine \\(2\\min(b,c)=4\\), pa je zaista u jednoj particiji samo \\(2\\) \u010dvora.  </p> <p>Sada smo ve\u0107 blizu kraja. Za konstrukciju na\u0161ih stabala razlikujemo dva slu\u010daja (i to ba\u0161 oni iz podzataka!!)</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#svaka-grana-se-nalazi-u-najvise-jednom-ciklusu","title":"Svaka grana se nalazi u najvi\u0161e jednom ciklusu","text":"<p>U ovom slu\u010daju su  nam blokovi samo \\(K_{2,2}\\) to jest ciklusi du\u017eine \\(4\\). Posmatrajmo ciklus \\(a-b-c-d\\), tu suprotni na ciklusu treba da budu na distanci \\(2\\), a susedni na ciklusu treba da budu na distanci \\(3\\). Dodajmo \u010dvorove \\(e\\) i \\(f\\) i pove\u017eemo parove \\(a-e\\), \\(c-e\\), \\(b-f\\), \\(d-f\\) i \\(e-f\\). Lako se proverava da je ova konstrukcija ba\u0161 ono \u0161to smo tra\u017eili.</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#svaka-grana-koja-se-nalazi-u-jednom-ciklusu-se-nalazi-u-barem-dva-ciklusa","title":"Svaka grana koja se nalazi u jednom ciklusu se nalazi u barem dva ciklusa","text":"<p>U ovom slu\u010daju su  nam blokovi samo \\(K_{2,t}\\) sa \\(t\\ge3\\), neka su nam ova \\(2\\) \u010dvora bela, a ostalih \\(t\\) crni. Mo\u017eemo da vidimo da najdu\u017ea putanja izme\u0111u \\(2\\) crna \u010dvora du\u017eine \\(4\\), izme\u0111u crnog i belog du\u017eine \\(3\\) i izme\u0111u dva dela du\u017eine \\(2\\). Zato je dovoljno da uzmemo jedan novi \u010dvor koji spojimo sa svim belima direktno granom, a sa svim crnima putem du\u017eine \\(2\\).</p>"},{"location":"takprog/2021_2022/sio/06_metropole/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Naprosto spojimo konstrukcije iz predhotna dva slu\u010daja, i onda na dobijenom stablu na\u0111emo najdu\u017ei put. Slo\u017eenost \\(O(N)\\).</p> 06_metropole.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 200007\nusing namespace std;\nvector&lt;int&gt; g[3*MAXN], ind[MAXN],c[2],ge[MAXN];\nint p[MAXN], a[MAXN], d[MAXN], u[MAXN], v[MAXN], b[MAXN];\nbool vi[MAXN], uc[MAXN], ve[MAXN];\nvoid dfs(int s,int f,int du)\n{\n    d[s]=du;\n    p[s]=f;\n    b[s]=du&amp;1;\n    vi[s]=true;\n    for(int i=0;i&lt;g[s].size();i++) if(g[s][i]!=f)\n    {\n        int v=g[s][i];\n        if(vi[v])\n        {\n            if(d[v]&gt;d[s]) continue;\n            uc[ind[s][i]]=true;\n            uc[a[s]]=true;\n            ge[ind[s][i]].push_back(a[s]);\n            ge[a[s]].push_back(ind[s][i]);\n            uc[a[p[s]]]=true;\n            ge[a[s]].push_back(a[p[s]]);\n            ge[a[p[s]]].push_back(a[s]);\n            uc[a[p[p[s]]]]=true;\n            ge[a[p[s]]].push_back(a[p[p[s]]]);\n            ge[a[p[p[s]]]].push_back(a[p[s]]);\n        }\n        else {a[v]=ind[s][i]; dfs(v,s,du+1);}\n    }\n}\nvoid dfsd(int s,int f,int du)\n{\n    d[s]=du;\n    for(int i=0;i&lt;g[s].size();i++) if(g[s][i]!=f) dfsd(g[s][i],s,du+1);\n}\nvoid dfsblok(int s)\n{\n    ve[s]=true;\n    if(!vi[u[s]]) {c[b[u[s]]].push_back(u[s]); vi[u[s]]=true;}\n    if(!vi[v[s]]) {c[b[v[s]]].push_back(v[s]); vi[v[s]]=true;}\n    for(int i=0;i&lt;ge[s].size();i++) if(!ve[ge[s][i]]) dfsblok(ge[s][i]);\n}\nint NajduziPut(int N, int M, int* U, int* V)\n{\n    for(int i=1;i&lt;=M;i++) {u[i]=U[i]; v[i]=V[i];}\n    for(int i=1;i&lt;=M;i++) g[U[i]].push_back(V[i]);\n    for(int i=1;i&lt;=M;i++) ind[U[i]].push_back(i);\n    for(int i=1;i&lt;=M;i++) g[V[i]].push_back(U[i]);\n    for(int i=1;i&lt;=M;i++) ind[V[i]].push_back(i);\n    dfs(1,1,0);\n    for(int i=1;i&lt;=N;i++) g[i].clear();\n    for(int i=1;i&lt;=M;i++)\n    {\n        if(!uc[i])\n        {\n            g[U[i]].push_back(V[i]);\n            g[V[i]].push_back(U[i]);\n        }\n    }\n    fill(vi+1,vi+N+1,false);\n    for(int i=1;i&lt;=M;i++) if(!ve[i] &amp;&amp; uc[i])\n    {\n        dfsblok(i);\n        if(c[0].size()&gt;c[1].size()) swap(c[0],c[1]);\n        if(c[1].size()==2)\n        {\n            N++;\n            g[N].push_back(c[0][0]); g[N].push_back(c[0][1]);\n            g[c[0][0]].push_back(N); g[c[0][1]].push_back(N);\n            N++;\n            g[N].push_back(c[1][0]); g[N].push_back(c[1][1]);\n            g[c[1][0]].push_back(N); g[c[1][1]].push_back(N);\n            g[N-1].push_back(N); g[N].push_back(N-1);\n        }\n        else\n        {\n            N++;\n            g[N].push_back(c[0][0]); g[N].push_back(c[0][1]);\n            g[c[0][0]].push_back(N); g[c[0][1]].push_back(N);\n            int x = N;\n            for(int i=0;i&lt;c[1].size();i++)\n            {\n                N++;\n                g[c[1][i]].push_back(N);\n                g[N].push_back(x);\n                g[N].push_back(c[1][i]);\n                g[x].push_back(N);\n            }\n        }\n        for(int i=0;i&lt;2;i++) for(int j=0;j&lt;c[i].size();j++) vi[c[i][j]]=false;\n        c[0].clear(); c[1].clear();\n    }\n    dfsd(1,1,0);\n    int mx=0,mxi;\n    for(int i=1;i&lt;=N;i++) if(d[i]&gt;mx) {mx=d[i]; mxi=i;}\n    dfsd(mxi,mxi,0);\n    for(int i=1;i&lt;=N;i++) if(d[i]&gt;mx) mx=d[i];\n    return mx;\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/01_bakterijada/","title":"B1 - Bakterijada","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Osim Dr\u017eavnog takmi\u010denja iz informatike, Kragujevac je doma\u0107in i ovogodi\u0161nje Bakterijade. Nau\u010dnica Ma\u0161a je odlu\u010dila da ove godine pobedi na Bakterijadi i osvoji ogromnu koli\u010dinu vrednih nagrada. Bakterijada je takmi\u010denje gde svaki takmi\u010dar donosi \\(N\\) bakterija i meri im te\u017eine na specifi\u010dan na\u010din:</p> <ul> <li>Nau\u010dnik prvo izmeri te\u017einu svih bakterija odjednom i zapi\u0161e rezultat na tablu</li> <li>Zatim, od izmerenih bakterija pravi dve neprazne disjunktne grupe bakterija na merenje</li> <li>Za novodobijene grupe ponavlja proces</li> <li>Ukoliko izmerena grupa bakterija se sastoji od samo jedne bakterije, ona se ne deli, ve\u0107 se vra\u0107a u laboratoriju i zavr\u0161ava takmi\u010denje </li> <li>Suma svih brojeva napisanih na tabli predstavlja rezultat na takmi\u010denju koji je nau\u010dnik ostvario</li> </ul> <p>Ma\u0161u interesuje kako da izvr\u0161i podele bakterija u grupe posle svakog merenja tako da joj rezultat bude \u0161to ve\u0107i. Kako je ona prezauzeta silnim obavezama, zamolila je vas da joj pomognete, a za uzvrat \u0107e vam dati poene na Dr\u017eavnom takmi\u010denju iz informatike preko veze.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko Milenkovi\u0107 Marko Milenkovi\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2022_2023/drz/01_bakterijada/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se prirodan broj \\(T\\) - broj test primera.</p> <p>Svaki test primer je u slede\u0107em formatu:</p> <ul> <li>U prvoj liniji test primera nalazi se prirodan broj \\(N\\) - broj bakterija koje Ma\u0161a dovodi na takmi\u010denje;</li> <li>U drugoj liniji test primera se nalazi niz od \\(N\\) prirodnih brojeva \\(A_1, A_2, \\ldots, A_N\\) - gde broj \\(A_i\\) predstavlja te\u017einu \\(i\\)-te bakterije u nanonjutnima, za \\(1 \\leq i \\leq n\\).</li> </ul>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(T\\) linija izlaza ispisati po jedan prirodan broj koji predstavlja najve\u0107i rezultat koji Ma\u0161a mo\u017ee da ostvari na Bakterijadi u tom test primeru.</p>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/01_bakterijada/#ulaz","title":"Ulaz","text":"<pre><code>1\n3\n20 20 20\n</code></pre>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#izlaz","title":"Izlaz","text":"<pre><code>160\n</code></pre>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/drz/01_bakterijada/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n3\n12 7 18\n</code></pre>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#izlaz_1","title":"Izlaz","text":"<pre><code>104\n</code></pre>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, Ma\u0161a prvo izmeri ukupnu te\u017einu \\(20+20+20=60\\), i zatim podeli na dve grupe. Prva grupa sadr\u017ei bakterije te\u017eina \\(20\\) i \\(20\\), a druga grupa sadr\u017ei bakteriju te\u017eine \\(20\\). Zatim, Ma\u0161a izmeri prvu grupu i zapi\u0161e rezultat \\(20+20=40\\) i podeli je na dve grupe (tre\u0107u i \u010detvrtu grupu) od po jednu bakteriju te\u017eine \\(20\\). Nakon merenja druge grupe, Ma\u0161a zapisuej na tablu \\(20\\) i ta bakterija odlazi sa takmi\u010denja. Isto se desi i za tre\u0107u i \u010detvrtu grupu. Na tabli se sada nalaze brojevi \\(60\\), \\(40\\), \\(20\\), \\(20\\), \\(20\\) i njihov zbir je \\(160\\).</p>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(1 \\leq A_i \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena, \\(T = 1\\) i \\(1 \\leq N \\leq 20\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(1 \\leq N \\leq 1000\\).</li> <li>U test primerima vrednim \\(20\\) poena, sve bakterije imaju istu te\u017einu.</li> <li>U test primerima vrednim \\(50\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#resenje-kada-t-1-i-n-leq-20","title":"Re\u0161enje kada \\(T = 1\\) i \\(N \\leq 20\\)","text":"<p>U ovom podzadatku je dovoljno u svakom potezu generisati sve mogu\u0107e podele bakterija, njih \\(2^N\\). Svaka bakterija mo\u017ee da u\u010destvuje u najvi\u0161e \\(N\\) merenja. Vremenska slo\u017eenost je \\(O(N2^N)\\).</p>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#resenje-kada-sve-bakterije-imaju-istu-tezinu","title":"Re\u0161enje kada sve bakterije imaju istu te\u017einu","text":"<p>Mo\u017eemo uo\u010diti da je optimalno odvajati po jednu bakteriju u jednu grupu i preostale u drugu. Na ovaj na\u010din maksimizujemo ukupnu sumu (dokaz ostavljamo \u010ditaocu za ve\u017ebu - pomo\u0107: kada quick sort radi najsporije?). Suma \u0107e iznositi \\(X(N + N + N - 1 + N - 2 + \\ldots + 3 + 2) = X\\left(\\frac{N(N+1)}{2} + N - 1\\right)\\), gde je \\(X\\) te\u017eina bakterija. Vremenska slo\u017eenost je \\(O(1)\\).</p>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#resenje-kada-1-leq-n-leq-1000","title":"Re\u0161enje kada \\(1 \\leq N \\leq 1000\\)","text":"<p>Sli\u010dno, kao u prethodnom podzadatku, odvaja\u0107emo po jednu bakteriju i to ba\u0161 onu sa najmanjom te\u017einom (dokaz sli\u010dan kao u prethodnom podzadatku). Posle svakog merenja nalazi\u0107emo najlak\u0161u bakteriju i shodno tome ra\u010dunati sumu, a deljenja \u0107e biti ta\u010dno \\(N\\). Vremenska slo\u017eenost je \\(O(N^2)\\).</p>"},{"location":"takprog/2022_2023/drz/01_bakterijada/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Umesto simulacije biranja u prethodnom podzadatku, lak\u0161e je izanalizirati da \u0107e se najlak\u0161a bakterija brojati dva puta, druga najlak\u0161a tri puta, ..., druga najte\u017ea \\(N\\) puta i najte\u017ea \\(N\\) puta. Vremenska slo\u017eenost je \\(O(N)\\).</p> 01_bakterijada.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n    ios_base::sync_with_stdio(false); \n    cin.tie(nullptr); \n    cout.tie(nullptr); \n    cerr.tie(nullptr);  \n\n    int t;\n    cin &gt;&gt; t;\n\n    for (int e = 0; e &lt; t; ++e){\n\n        int n;\n        cin &gt;&gt; n;\n\n        vector&lt;ll&gt; a(n);\n        for (auto&amp; i : a)\n            cin &gt;&gt; i;\n\n        sort(a.begin(), a.end());\n\n        ll sol = 0;\n        for (int i = 0; i &lt; n; ++i)\n            sol += (i + 2) * 1ll * a[i];\n\n        sol -= a[n-1];\n\n        cout &lt;&lt; sol &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/","title":"B2 - XOR fabrika","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U deonici za razvrstavanje delova u kutije poznate kragujeva\u010dke fabrike automobila, odlu\u010deno je da se zbog povoljnosti XOR-robota, oni ubace na mesto nekih standardnih robota dodava\u010da. XOR-roboti dodaju deo u kutiju ako se u njoj nalazi paran broj delova, a uzimaju deo iz nje ukoliko se u njoj nalazi neparan broj delova, dok standardni roboti dodava\u010di uvek dodaju deo u kutiju. Kao \u0161to to obi\u010dno biva u fabrikama automobila, ovi roboti se nalaze du\u017e pokretne trake, ima ih \\(N\\) i numerisani su redom od \\(1\\) do \\(N\\). Kutije se na pokretnu traku ubacuju i skidaju sa nje na proizvoljnim mestima i sa proizvoljnim brojem delova koji su ve\u0107 u njoj. Pre zamene nekih od starih robota sa novim robotima, bilo je lako predvideti sa koliko delova \u0107e kutija iza\u0107i sa trake ako je ubacimo na poziciji \\(L\\) a skinemo nakon pozicije \\(R\\), ali sada to nije toliko lako, \u0161to upravnicima fabrike predstavlja zna\u010dajan problem, pa su vas zamolili da napi\u0161ete program koji re\u0161ava njigov problem.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Marko \u0160i\u0161ovi\u0107 Pavle Martinovi\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu se unose brojevi \\(N\\) i \\(Q\\), broj robota na pokretnoj traci kao i broj upita. U slede\u0107em redu se unosi niz \\(s\\) od \\(N\\) karaktera. U ovom nizu se nalaze isklju\u010divo karakteri '+' i '^', koji redom predstavljaju robote dodava\u010de i XOR-robote. U narednih \\(Q\\) redova se nalaze po tri broja: \\(L\\), \\(R\\) i \\(X\\), koji predstavljaju upit slede\u0107eg tipa: ako stavimo kutiju koja inicijalno ima \\(X\\) delova u sebi na poziciju pre robota numerisanog sa \\(L\\), a skinemo je nakon robota numerisanog sa \\(R\\) (dakle kutija \u0107e pro\u0107i pored \\(R - L + 1\\) robota), koliko delova \u0107e biti u njoj nakon toga?</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(Q\\) brojeva koji predstavljaju odgovore na zadate upite.</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#ulaz","title":"Ulaz","text":"<pre><code>11 3\n^^++^+^+++^\n2 3 5\n2 3 6\n1 11 3\n</code></pre>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#izlaz","title":"Izlaz","text":"<pre><code>5\n8\n6\n</code></pre>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N, Q \\le 2 \\times 10^5\\).</li> <li>\\(1 \\le L \\le R \\le N\\).</li> <li>\\(X \\le 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena, na pokretnoj traci se nalaze samo roboti dodava\u010di (u nizu se nalaze samo karakteri '+').</li> <li>U test primerima vrednim \\(10\\) poena, \\(N, Q \\le 2000\\).</li> <li>U test primerima vrednim \\(20\\) poena, na pokretnoj traci se nalaze samo XOR-roboti (u nizu se nalaze samo karakteri '^').</li> <li>U test primerima vrednim \\(30\\) poena, Na pokretnoj traci se nalazi najvi\u0161e \\(500\\) XOR-robota.</li> <li>U test primerima vrednim \\(30\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#resenje-kada-su-sve-operacije","title":"Re\u0161enje kada su sve operacije +","text":"<p>U ovom podzadatku va\u017ei da je svaka operacija \\(+1\\), tako da \u0107e sve \u0161to \u0107e se desiti \\(+1\\) ta\u010dno \\(R-L+1\\) puta, odnosno potrebno je ispisati \\(X+R-L+1\\)</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#resenje-kada-nqleq-2000","title":"Re\u0161enje kada \\(N,Q\\leq 2000\\)","text":"<p>U ovom podzadatku naprosto mo\u017eemo da idemo redom za svaki upit i izsimuliramo sve operacije za slo\u017eenost \\(O(NQ)\\)</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#resenje-kada-su-sve-operacije_1","title":"Re\u0161enje kada su sve operacije ^","text":"<p>U ovom podzadatku re\u0161avamo sli\u010dno kao prvi podzadatak. Primetimo da svaka operacija broj ksoruje sa \\(1\\), a dva ksora se poni\u0161tavaju, tako da je bitna samo parnost \\(R-L+1\\): ako je parno onda ispi\u0161emo \\(X\\), a u suprotnom \\(X\\text{ xor }1\\).</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#resenje-kada-ima-najvise-500-operacija","title":"Re\u0161enje kada ima najvi\u0161e \\(500\\) operacija ^","text":"<p>Podelimo na\u0161 interval na (najvi\u0161e \\(500\\)) intervala sa svim operacijama +. Svaki od njih simuliramo po prvom podzadatku, i onda samo primenimo po jednu operaciju ^. Slo\u017eenost \\(O(500Q)\\)</p>"},{"location":"takprog/2022_2023/drz/02_xor_fabrika/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo da nam se u svakom potezu zapravo menja parnost. Tako da \u0107e svaka operacija biti \\(+1\\) osim nekih ^ operacija koja \u0107e biti \\(-1\\) ako je tada broj na kom vr\u0161imo inicijalne poteze neparan. Me\u0111utim, ono \u0161to treba primetiti da nam je onda samo potreban broj ^ na mestima odre\u0111ene parnosti  (ta odre\u0111ena parnost zavisi od \\(L\\) i \\(X\\): ako je \\(X\\) parno onda iste parnost kao \\(L\\) nam treba, a u suprotnom suprotna parnost). Zato je dovoljno samo zapamtiti dva niza parcijalnih suma: za parne i neparne pozicije broj operacija ^, i onda klasi\u010dnim oduzimanjem desnog kraja od levog na\u0111emo koliko ih je u intervalu. Slo\u017eenost \\(O(N+Q)\\) </p> 02_xor_fabrika.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAXN 200005\n\nint ps[MAXN][2];\n\nint n, q;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin &gt;&gt; n &gt;&gt; q;\n    string s;\n    cin &gt;&gt; s;\n    for(int i = 1; i &lt;= n; i++){\n        if(s[i-1] == '+'){\n            ps[i][0] = ps[i-1][0] + 1;\n            ps[i][1] = ps[i-1][1] + 1;\n        }\n        else if(s[i-1] == '^'){\n            ps[i][0] = ps[i-1][0] + (i % 2 == 1 ? 1 : -1);\n            ps[i][1] = ps[i-1][1] + (i % 2 == 0 ? 1 : -1);\n        }\n    }\n    while(q--){\n        int l, r, x;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n        int pr = (x + l + 1) % 2;\n        cout &lt;&lt; x + ps[r][pr] - ps[l-1][pr] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/03_kirbi/","title":"B3 - Kirbi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 64MB <p>Mo\u017eda ste primetili kako se ovogodi\u0161nje Dr\u017eavno takmi\u010denje radi u vrlo prijatnom okru\u017eenju i glavna zasluga toga je \u0161to su Prirodno-matemati\u010dki fakultet i Fakultet in\u017eenjerskih nauka veoma \u010disti. Na tome je radilo puno ljudi, ali kako ima mnogo takmi\u010dara, morao je u pomo\u0107 da usko\u010di i Kirbi Usisiva\u010d.</p> <p>Prostor koji Kirbi treba da o\u010disti mo\u017ee da se predstavi kao matrica sa \\(N\\) redova i \\(M\\) kolona. Ta\u010dno \\(P\\) polja ove matrice su prljava, dok su ostala \u010dista. Na po\u010detku \u010di\u0161\u0107enja, Kirbi se nalazi u polju koje je u prvom redu i prvoj koloni. Zbog toga \u0161to je roze, on mo\u017ee da se kre\u0107e samo na polje direktno ispod trenutnog ili direktno desno od trenutnog.</p> <p>Verovatno ste to ve\u0107 znali, ali Kirbi je vrsan programer, i zna da odredi koliko najvi\u0161e uprljanih polja da o\u010disti kre\u0107u\u0107i se kroz matricu. Ono \u0161to njega interesuje (zato \u0161to je opsednut statistikom) jeste koliko polja postoji, tako da kada bi ona bila \u010dista, najve\u0107i broj uprljanih polja koje Kirbi mo\u017ee da o\u010disti prolaskom kroz matricu se smanjio. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko Milenkovi\u0107 Marko Milenkovi\u0107 Dimitrije Erdeljan"},{"location":"takprog/2022_2023/drz/03_kirbi/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se prirodan broj \\(T\\) - broj test primera.</p> <p>Svaki test primer je u slede\u0107em formatu:</p> <p>U prvoj liniji test primera nalaze se tri prirodna broja \\(N\\), \\(M\\) i \\(P\\) - broj redova u matrici, broj kolona u matrici i broj uprljanih polja u matrici</p> <p>U narednih \\(P\\) linija se nalaze po dva prirodna broja \\(X_i\\) i \\(Y_i\\) koji predstavljaju koordinate \\(i\\)-tog uprljanog polja.</p>"},{"location":"takprog/2022_2023/drz/03_kirbi/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(T\\) linija izlaza ispisati po jedan ceo broj koji predstavlja broj uprljanih polja koja kada bi bila \u010dista, umanjio bi se najve\u0107i broj uprljanih polja koje Kirbi mo\u017ee da o\u010disti u tom primeru.</p>"},{"location":"takprog/2022_2023/drz/03_kirbi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/03_kirbi/#ulaz","title":"Ulaz","text":"<pre><code>1\n5 5 5\n1 1\n2 2\n3 3\n4 4\n5 5\n</code></pre>"},{"location":"takprog/2022_2023/drz/03_kirbi/#izlaz","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2022_2023/drz/03_kirbi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/drz/03_kirbi/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n4 4 5\n1 2\n1 3\n1 4\n2 1\n3 1\n</code></pre>"},{"location":"takprog/2022_2023/drz/03_kirbi/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2022_2023/drz/03_kirbi/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi primer:</p> <ul> <li>Inicijalno, Kirbi mo\u017ee da da o\u010disti svih pet uprljanih polja, tako da uklanjanje bilo kog taj broj umanjuje na \u010detiri. Dakle, odgovor je pet.</li> </ul> <p>Drugi primer:</p> <ul> <li>Inicijalno, Kirbi mo\u017ee da da o\u010disti najvi\u0161e tri uprljanih polja. Uklanjanje nekog od uprljanih polja iz prve kolone ne uti\u010de na najve\u0107i broj polja koje Kirbi mo\u017ee da o\u010disti, jer on mo\u017ee da se kre\u0107e samo kroz prvi red. Sa druge strane, uklanjanje bilo kog od tri polja iz prvog reda smanjuje taj broj sa tri na dva, pa je i kona\u010dan odgovor tri.</li> </ul>"},{"location":"takprog/2022_2023/drz/03_kirbi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(1 \\leq N,M \\leq 10^9\\).</li> <li>\\(1 \\leq P \\leq \\min(N\\cdot M, 2\\cdot 10^5)\\).</li> <li>\\(1 \\leq X_i \\leq N\\).</li> <li>\\(1 \\leq Y_i \\leq M\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena, \\(1 \\leq N,M,P \\leq 5\\).</li> <li>U test primerima vrednim 20 poena, \\(N = 2\\) ili \\(M=2\\).</li> <li>U test primerima vrednim 20 poena, \\(1 \\leq N,M,P \\leq 100\\).</li> <li>U test primerima vrednim 50 poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/03_kirbi/#resenje-kada-1-leq-nmp-leq-5","title":"Re\u0161enje kada \\(1 \\leq N,M,P \\leq 5\\)","text":"<p>U ovom podzadatku koristimo to da su sve vrednosti male brojke. Mo\u017eemo izbrisati svako prljavo polje i zatim isprobati sve putanje da vidimo koja sadr\u017ei najve\u0107i broj uprljanih polja i da li se to razlikuje od po\u010detnog maksimalnog broja polja koje Kirbi mo\u017ee da o\u010disti. Vremenska slo\u017eenost je \\(O(TP2^{N+M})\\).</p>"},{"location":"takprog/2022_2023/drz/03_kirbi/#resenje-kada-n-2-ili-m-2","title":"Re\u0161enje kada \\(N = 2\\) ili \\(M = 2\\)","text":"<p>Posmatra\u0107emo slu\u010daj \\(N=2\\), jer se drugi slu\u010daj analogno re\u0161ava. Primetimo da \u0107e se Kirbi ta\u010dno jednom spustiti u drugi red. Pamtimo prefiksni niz prljvih polja za prvi red i pamtimo sufiksni niz prljavih polja za drugi red. Maksimalan broj polja koje Kirbi mo\u017ee da o\u010disti je \\(S = \\max_{1 \\leq i \\leq M}\\{pref_i + suf_i\\}\\). Neka je \\(i_{min}\\) prva kolona u kojoj izraz \\(pref_{i_{min}} + suf_{i_{min}}\\) dosti\u017ee vrednost \\(S\\) i neka je \\(i_{max}\\) poslednja kolona u kojoj izraz \\(pref_{i_{max}} + suf_{i_{max}}\\) dosti\u017ee vrednost \\(S\\). Tra\u017eeno re\u0161enje je \\(pref_{i_{min}} + suf_{i_{max}}\\). Vremenska slo\u017eenost je \\(O(T(P+M))\\).</p>"},{"location":"takprog/2022_2023/drz/03_kirbi/#resenje-kada-1-leq-nmp-leq-100","title":"Re\u0161enje kada \\(1 \\leq N,M,P \\leq 100\\)","text":"<p>Neka je \\(S\\) ponovo maksimalan broj polja koje Kirbi mo\u017ee da o\u010disti u startu. To mo\u017eemo izra\u010dunati standardnim dinami\u010dkim programiranjem. Stanje \\(dp_{i,j}\\) predstavlja maksimalan broj polja koje Kirbi mo\u017ee da o\u010disti kre\u0107u\u0107i sa polja \\((1,1)\\) do polja \\((i,j)\\). Krenemo \"redom\" da obilazimo matricu po redovima, pa po kolonama (kao u ulazu) i vr\u0161imo prelaz \\(dp_{i,j} = \\max(dp_{i-1,j}, dp_{i,j-1}) + a_{i,j}\\), gde je \\(a_{i,j}\\) binarni indikator da li je polje \\((i,j)\\) urljano (\\(1\\) ako jeste, \\(0\\) ako nije). Sada mo\u017eemo da izbacujemo jedno po jedno uprljano polje i ra\u010dunamo iznova celu \\(dp\\) matricu i vidimo kada je vrednost \\(dp_{N,M} &lt; S\\). Vremenska slo\u017eenost \\(O(TPNM)\\).</p>"},{"location":"takprog/2022_2023/drz/03_kirbi/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Mo\u017eemo primetiti da kada posmatramo redom polja koja je Kirbi o\u010distio, njihove kolone formiraju neopadaju\u0107i niz. Odnosno, ukoliko sortiramo uprljana polja po redovima, maksimalan broj polja koja Kirbi mo\u017ee da o\u010disti je najdu\u017ei neopadaju\u0107i podniz kolona ovog niza. Dati problem je ekvivalentan nala\u017eenju najdu\u017eeg rastu\u0107eg podniza (\\emph{Longest increasing subsequence}, ili skra\u0107eno LIS), \u0161to je poznat problem i mo\u017ee se re\u0161iti/implementirati u vremenskoj slo\u017eenosti \\(O(P\\log P)\\). Ono \u0161to nama treba jesu prefiksni i sufiksni LIS nizovi. Formalno, \\(pref_i\\) predstavlja \\(LIS\\) od po\u010detka niza do \\(i\\)-tog elementa, ali tako da on zasigurno figuri\u0161e u \\(LIS\\)-u. Sli\u010dno, \\(suf_i\\) predstavlja \\(LIS\\) niza od \\(i\\)-tog elementa do kraja niza, tako da \\(i\\)-ti element u\u010destvuje u \\(LIS\\)-u. Za \\(i\\)-ti element niza uprljanih polja va\u017ei da je deo nekog od putanja koje sadr\u017ee najve\u0107i broj uprljanih polja ako i samo ako je \\(pref_i + suf_i - 1 = S\\). Sa druge strane, element niza pripada svim takvim putanjama ako i samo ako dodatno va\u017ei i da je vrednost \\(pref_i\\) jedinstvena me\u0111u svim prefiksnim \\(LIS\\)-ovima. Potrebno je samo ispisati broj takvih polja. Vremenska slo\u017eenost je \\(O(TP\\log P)\\). </p> 03_kirbi.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n// Postoji mnogo nacina da se implementira lis\nvector&lt;int&gt; lis(vector&lt;int&gt;&amp; a) {\n    int n = a.size();\n    vector&lt;int&gt; d(n+1, 2e9);\n\n    vector&lt;int&gt; sol;\n    for (int i = 0; i &lt; n; i++) {\n        int ind = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n        if (d[ind] != 2e9){\n            sol.push_back(ind+1);\n            d[ind] = a[i];\n        } else {\n            d[ind] = a[i];\n            sol.push_back(lower_bound(d.begin(), d.end(), 2e9) - d.begin());\n        }\n    }\n\n    return sol;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false); \n    cin.tie(nullptr); \n    cout.tie(nullptr); \n    cerr.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n\n    for (int e = 0; e &lt; t; ++e){\n        int n, m, p;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n\n        vector&lt;pair&lt;int, int&gt;&gt; a;\n        for (int i = 0; i &lt; p; ++i){\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n\n            a.push_back({x, y});\n        }\n\n        sort(a.begin(), a.end());\n\n        vector&lt;int&gt; col;\n        for (int i = 0; i &lt; p; ++i){\n            col.push_back(a[i].second);\n        }\n\n        vector&lt;int&gt; pref = lis(col);\n\n        vector&lt;int&gt; rev;\n        for (int i = 0; i &lt; p; ++i){\n            rev.push_back(-1 * a[p-1-i].second);\n        }\n\n        vector&lt;int&gt; suf = lis(rev);\n        reverse(suf.begin(), suf.end());\n\n        vector&lt;int&gt; candidates;\n        vector&lt;int&gt; cnt(p+1,0);\n\n        int max_lis = *max_element(pref.begin(), pref.end());\n\n        for (int i = 0; i &lt; p; ++i){\n            if (pref[i] + suf[i] - 1 == max_lis){\n                candidates.push_back(i);\n                cnt[pref[i]]++;\n            }\n        }\n\n        int sol = 0;\n        for (int c : candidates){\n            if (cnt[pref[c]] == 1){\n                ++sol;\n            }\n        }\n\n        cout &lt;&lt; sol &lt;&lt; '\\n';\n    }\n\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/","title":"A1 - \u017divot u gradu","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>(\u017divot u gradu) Zna\u0161 da mora\u0161 da pre\u017eivi\u0161  (\u017divot u gradu) Mora\u0161 da odr\u017ei\u0161 taj san \u017eivim  (\u017divot u gradu) Gde sve je besplatno  (\u017divot u gradu) Zar ne mo\u017ee\u0161 da vidi\u0161 </p> <p>Gore je naveden autorov slobodni prevod teksta pesme \"\u017divot u gradu\", koja je izvorno pesma za drugi nivo, \"Radikalni grad\", u igrici Sonik R iz 1997. Muzi\u010dke kriti\u010dare i analiti\u010dare \u0161irom sveta je godinama bunilo ta\u010dno zna\u010denje re\u010di. Me\u0111utim, danas je dan kada se kona\u010dno otkriva \u0161ta se krilo iza ovih ve\u0161to napisanih stihova - pesma se odnosi na dr\u017eavno takmi\u010denje iz informatike srednjih \u0161kola 2023. godine nove ere. Zaista, navedeni grad se o\u010digledno odnosi na Kragujevac, pre\u017eivljavanje na izbegavanje bu\u010dnih Kragujeva\u010dkih koncerta, san je ni\u0161ta drugo nego 300 poena na takmi\u010denju, dok je interpretacija \u0161ta je ta\u010dno to sve besplatno, i \u010din opa\u017eanja istog jednostavna i ostavlja se kao ve\u017eba \u010ditaocu.</p> <p>Postavka je slede\u0107a. Takmi\u010dari dolaze u Kragujevac, na dr\u017eavno takmi\u010denje. Kao \u0161to to \u010desto biva sa gradovima u informati\u010dkim zadacima, Kragujevac mo\u017ee zamisliti kao matricu dimenzija \\(N\\times M\\) . Takmi\u010dari ulaze u grad na polje \\((1,1)\\), dok se takmi\u010denje odr\u017eava u polju \\((N,M)\\). Kako takmi\u010denje uskoro kre\u0107e, nema vremena za gubljenje, tako da takmi\u010dari moraju da stignu do takmi\u010denja tako \u0161to u svakom potezu pre\u0111u na polje direktno desno ili direktno ispod trenutnog. </p> <p>Me\u0111utim, u nekim poljima se odr\u017eavaju koncerti. Mnogi bi savetovali mladim takmi\u010darima da se klone ovih polja, ali kako je ovo prvo takmi\u010denje iz informatike van Beograda u ko zna koliko vremena, oni su odlu\u010dili da moraju da iskuse svaki deo lokalne kulture i samim tim posete ta\u010dno \\(K\\) polja sa koncertima. Va\u0161 cilj je da va\u0161im kolegama takmi\u010darima ka\u017eete da li je ovo mogu\u0107e i (u nekim podzadacima), ukoliko jeste, date primer takvog puta.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Dragan Uro\u0161evi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se dva cela broja \\(T\\), broj test primera i \\(Z\\) koji je jednak nula ukoliko dati test primer ne zahteva rekonstrukciju, a \\(1\\) ukoliko zahteva. Svaki test primer je slede\u0107eg formata: U prvom redu nalaze se \\(3\\) cela broja \\(N\\), \\(M\\) i \\(K\\). U \\(i\\)-tom od narednih \\(N\\) redova se po \\(M\\) celih brojeva, gde je \\(j\\)-ti jednak \\(1\\) ukoliko se odr\u017eava koncert na polju \\((i,j)\\), a jednak \\(0\\) u suprotnom.</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(T\\) test primera je potrebno u prvom redu ispisati \"DA\" (bez navodnika), ukoliko je mogu\u0107e ispuniti uslove zadatka, a \"NE\" (bez navodnika) ukoliko nije. Dalje, ukoliko je \\(Z=1\\) i odogvor je bio \"DA\", potrebno je ispisati nisku od \\(M+N-2\\) karatkera, gde je \\(i\\)-ti karakter \\(S\\) ukoliko takmi\u010dari treba da idu na dole, a ukoliko treba da idu desno, karatker treba da bude \\(D\\). Ukoliko postoji vi\u0161e re\u0161enja ispisati bilo koje.</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#ulaz","title":"Ulaz","text":"<pre><code>3 1\n3 3 1\n000\n000\n100\n3 3 2\n001\n010\n100\n3 4 0\n0011\n1000\n1100\n</code></pre>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#izlaz","title":"Izlaz","text":"<pre><code>DA\nSSDD\nNE\nDA\nDSDDS\n</code></pre>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru se odr\u017eava samo jedan koncert u Kragujevcu, i to u donjem levom uglu. Da bi ga takmi\u010dari posetili, moraju prva dva poteza da idu na dole, a zatim da produ\u017ee do mesta takmi\u010denja sa 2 poteza desno (kako je \\(Z=1\\) potrebno je ispisati i konstrukciju puta). U drugom ne postoji na\u010din da posete dve koncerta, pa je odgovor \"NE\".</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(1 \\leq N,M \\leq 1.500\\).</li> <li>\\(0 \\leq K \\leq 3.000\\).</li> </ul> <p>Test primeri su podeljeni u osam disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(8\\) poena, \\(N,M\\leq 10\\).</li> <li>U test primerima vrednim \\(6\\) poena, sva polja sa koncertima formiraju podmatricu i \\(Z=0\\).</li> <li>U test primerima vrednim \\(10\\) poena, sva polja sa koncertima formiraju podmatricu.</li> <li>U test primerima vrednim \\(13\\) poena, \\(N,M\\leq 150\\), \\(Z=0\\).</li> <li>U test primerima vrednim \\(13\\) poena, \\(N,M\\leq 150\\).</li> <li>U test primerima vrednim \\(11\\) poena, \\(K=0\\).</li> <li>U test primerima vrednim \\(20\\) poena, \\(Z=0\\).</li> <li>U test primerima vrednim \\(19\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#resenje-prvog-podzadatka","title":"Re\u0161enje prvog podzadatka","text":"<p>U ovom slu\u010daju, zbog ograni\u010denja na du\u017einu veli\u010dinu table mogu\u0107e je u datom vremenskom ograni\u010denju proveriti sve puteve i odrediti za svaki od njih koliko se koncerta odr\u017eava na tom putu. Naime broj raznih putvea je \\(2^{N+M-2}\\leq 2^{18}\\). Naravno, ako je na nekom putu broj koncerta ba\u0161 \\(K\\), prekida se proveravanje puteva, ispisuje odgovor  \"DA\" i ako je potrebno ispisuje odgovaraju\u0107i put. Ako ni na jednom putu nije bilo \\(K\\) koncerta, ispisuje se odgovor \"NE\". Slo\u017eenost opisanog re\u0161enja je \\({\\mathcal O}(2^{N+M})\\).</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#resenje-drugog-i-treceg-podzadatka","title":"Re\u0161enje drugog i tre\u0107eg podzadatka","text":"<p>Za po\u010detak je potrebno odrediti podmatricu koju \u010dine polja na kojima se odr\u017eavaju koncerti. Nakon toga treba diskutovati (razlikovati) nekoliko slu\u010dajeva, u zavisnosti od dimenzija i pozicije podmatrice i broja \\(K\\). Mislimo da nema potrebe da izvodimo kompletnu diskusiju. Slo\u017eenost opisanog re\u0161enja je \\({\\mathcal O}(NM)\\).</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#resenje-cetvrtog-i-petog-podzadatka","title":"Re\u0161enje \u010detvrtog i petog podzadatka","text":"<p>Ovi podzadaci se mogu re\u0161iti primenom dinami\u010dkog programiranja. Neka je \\(dp[i][j][l]=true\\), ako postoji put od polja \\((1,1)\\) do polja \\((i,j)\\) na kome postoji \\(l\\) polja na kojima se odr\u017eava koncert i \\(dp[i][j][l]=false\\) u suprotnom. Tada je \\(dp[N][M][K]\\) odgovor na pitanje da li postoji tra\u017eeni put ili ne. Niz \\(dp\\) popunjavama (ra\u010dunamo) vrsta po vrsta:</p> <ul> <li>\\(dp[1][1][1]=true\\), ako se na polju \\((1,1)\\) odr\u017eava koncert i \\(dp[1][1][1]=false\\), ako se na polju \\((1,1)\\) ne odr\u017eava koncert.</li> <li>\\(dp[1][1][0]=true\\), ako se na polju \\((1,1)\\) ne odr\u017eava koncert i \\(dp[1][1][0]=false\\), ako se na polju \\((1,1)\\) odr\u017eava koncert.</li> <li>\\(dp[1][1][l]=false\\), za \\(2\\leq l \\leq K\\).</li> <li>Ako se na polju \\((i,j)\\)  odr\u017eava koncert, onda je \\(dp[i][j][l]=true\\), ako i samo ako je \\(dp[i-1][j][l-1]=true\\) ili \\(dp[i][j-1][l-1]=true\\) (naravno, ako je \\(i \\geq 2\\) i \\(j \\geq 2\\), u suprotnom, odgovaraju\u0107i element ne postoji). Primetimo tako\u0111e da je u ovom slu\u010daju \\(dp[i][j][0]=false\\).</li> <li>Ako se na polju \\((i,j)\\)  ne odr\u017eava koncert, onda je \\(dp[i][j][l]=true\\), ako i samo ako je \\(dp[i-1][j][l]=true\\) ili \\(dp[i][j-1][l]=true\\) (naravno, ako je \\(i \\geq 2\\) i \\(j \\geq 2\\), u suprotnom, odgovaraju\u0107i element ne postoji).</li> </ul> <p>Ako tra\u017eeni put postoji, on se mo\u017ee rekonstrisati kori\u0161\u0107enjem niza  \\(dp\\). Naime, kre\u0107emo od polja \\((N,M)\\) i tra\u017eimo put na kome se odr\u017eava \\(K\\) koncerta. Ako se nalazimo na polju \\((i,j)\\) i tra\u017eimo put na kome se odr\u017eava \\(l\\) koncerta, onda mora biti \\(dp[i][j][l]=true\\) i mogu nastupiti slede\u0107a dva slu\u010daja:</p> <ul> <li>Na polju \\((i,j)\\) se od\u017eava koncert. Tada broj koncerata smanjujemo za jedan, tj. \\(l\\) se smanjuje za jedan (\\(l \\leftarrow l-1\\)) i pomeramo se na polje levo ili gore (ako postoji) za koje odgovaraju\u0107i element niza \\(dp\\) (\\(dp[i-1][j][l-1]\\) ili \\(dp[i][j-1][l-1]\\)) ima vrednost \\(true\\).</li> <li>Na polju \\((i,j)\\) se ne od\u017eava koncerta. Tada broj kocerta ostaje nepromenjen, a pomeramo se na polje levo ili gore (ako postoji) za koje odgovaraju\u0107i element niza \\(dp\\) (\\(dp[i-1][j][l]\\) ili \\(dp[i][j-1][l]\\)) ima vrednost \\(true\\).</li> <li>Postupak prekidamo kada stignemo do polja \\((1,1)\\).</li> </ul> <p>Slo\u017eenost opisanog re\u0161enja je odre\u0111ena slo\u017eeno\u0161\u0107u popunjavanja niza \\(dp\\) i iznosi \\({\\mathcal O}(NMK)\\).</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#resenje-sestog-podzadatka","title":"Re\u0161enje \u0161estog podzadatka","text":"<p>U ovom slu\u010daju mo\u017eemo formirati graf u kome su \u010dvorovi polja na koja je podeljen grad, a ivice postoje od polja do njegovih suseda levo i dole. Polja na kojima se odr\u017eavaju koncerti su zabranjena i na njih se ne mo\u017ee stati. Tra\u017eeni put postoji, ako postoji put u grafu (put zaobilazi zabranjena polja). Taj put mo\u017eeo prona\u0107i, na primer, primenom obilaska u \u0161irinu. Za svako polje mo\u017eemo pamtiti odakle smo stigli i na taj na\u010din rekonstruisati re\u0161enje. Slo\u017eenost opisanog re\u0161enja je  \\({\\mathcal O}(NM)\\).</p>"},{"location":"takprog/2022_2023/drz/04_zivot_u_gradu/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Neka je \\(dp_1[i][j]\\) minimalni broj \\(l\\) takav da postoji put od polja \\((1,1)\\) do polja \\((i,j)\\), na kome se odr\u017eava \\(l\\) koncerata. Neka je \\(dp_2[i][j]\\) maksimalni broj \\(l\\) takav da postoji put od polja \\((1,1)\\) do polja \\((i,j)\\), na kome se odr\u017eava \\(l\\) koncerata. Tada za svako polje \\((i,j)\\) va\u017ei da postoji put od polja \\((1,1)\\) do polja \\((i,j)\\) na kome se odr\u017eava \\(l\\) koncerta, gde je \\(l\\) bilo koji broj izme\u0111u \\(dp_1[i][j]\\) i \\(dp_2[i][j]\\)  (\\(dp_1[i][j]\\leq l  \\leq dp_2[i][j]\\)). Naime od bilo kog po\u010detnog puta izme\u0111u dva polja se mo\u017ee sti\u0107i do bilo kog zavr\u0161nog, tako \u0161to se prelazi preko niza puteva od kojih se svaka dva uzastopna razlikuju u samo jednom polju. Kada se na putu promeni samo jedno polje i broj polja na kojima se odr\u017eava koncert se mo\u017ee promeniti (smanjiti ili pove\u0107ati) za najvi\u0161e jedan (1). Ako krenemo od puta sa minimalnim brojem koncerta prema putu sa maksimalnim brojem koncerta, pro\u0107i \u0107emo preko puteva na kojima je broj koncerta bilo koji broj izme\u0111u ta dva broja.  Zbog toga, postoji put sa ta\u010dno \\(K\\) koncerata, ako i samo ako je \\(dp_1[N][M]\\leq K  \\leq dp_2[N][M]\\). Nizove \\(dp_1\\) i \\(dp_2\\) ra\u010dunamo na sli\u010dan na\u010din kao niz \\(dp\\) u \u010detvrtom i petom podzadatku:</p> <ul> <li>Ako se na polju \\((1,1)\\) odr\u017eava koncert, onda je \\(dp_1[1][1]=dp_2[1][1]=1\\).</li> <li>Ako se na polju \\((1,1)\\) ne odr\u017eava koncert, onda je \\(dp_1[1][1]=dp_2[1][1]=0\\).</li> <li>Ako se na polju \\((i,j)\\) odr\u017eava koncert, onda je \\(dp_1[i][j]=\\min(dp_1[i-1][j],dp_1[i][j-1])+1\\) i \\(dp_2[i][j]=\\max(dp_2[i-1][j],dp_2[i][j-1])+1\\).</li> <li>Ako se na polju \\((i,j)\\) ne odr\u017eava koncert, onda je \\(dp_1[i][j]=\\min(dp_1[i-1][j],dp_1[i][j-1])\\) i \\(dp_2[i][j]=\\max(dp_2[i-1][j],dp_2[i][j-1])\\).</li> </ul> <p>Ako postoji put sa ta\u010dno \\(K\\) koncerata, onda se on rekonstrui\u0161e tako \u0161to se krene od polja \\((N,M)\\) i tra\u017ei put koji ima \\(l=K\\) koncerata. Ako se nalazimo na polju \\((i,j)\\) i tra\u017eimo put koji ima \\(l\\) koncerata (\\(dp_1[i][j]\\leq l \\leq dp_2[i][j]\\)), onda mogu nastupiti dva slu\u010daja:</p> <ul> <li>Ako se na polju \\((i,j)\\) odr\u017eava koncert, onda treba smanjiti broj koncerata \\(l\\) za jedan i pre\u0107i na polje iznad ili polje levo, tako da broj koncerata bude izme\u0111u \\(dp_1\\) i \\(dp_2\\) za to novo polje.</li> <li>Ako se na polju \\((i,j)\\) ne odr\u017eava koncert, onda se broj koncerata \\(l\\) ne menja, a treba pre\u0107i na polje iznad ili polje levo, tako da broj koncerata bude izme\u0111u \\(dp_1\\) i \\(dp_2\\) za to novo polje.</li> <li>Postupak prekidamo kada stignemo do polja \\((1,1)\\).</li> </ul> <p>Slo\u017eenost opisanog re\u0161enja je odre\u0111ena slo\u017eeno\u0161\u0107u popunjavanja nizova \\(dp_1\\) i \\(dp_2\\) i iznosi \\({\\mathcal O}(NM)\\).</p> 04_zivot_u_gradu.cpp<pre><code>#include &lt;bits\\stdc++.h&gt;\n#define MAXN 3007\nusing namespace std;\nconst string folder=\"testcases\\\\\";\nint a[MAXN][MAXN],dp[2][MAXN][MAXN];\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t,z;\n    for(int i=0;i&lt;MAXN;i++) dp[0][0][i]=dp[0][i][0]=1000000000;\n    cin&gt;&gt;t&gt;&gt;z;\n    while(t--)\n    {\n        int n,m,k;\n        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n        for(int i=1;i&lt;=n;i++)\n        {\n            string s;\n            cin&gt;&gt;s;\n            for(int j=1;j&lt;=m;j++) a[i][j]=s[j-1]-'0';\n        }\n        dp[0][1][1]=dp[1][1][1]=a[1][1];\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)\n        {\n            if(i==1 &amp;&amp; j==1) continue;\n            dp[0][i][j]=min(dp[0][i-1][j],dp[0][i][j-1])+a[i][j];\n            dp[1][i][j]=max(dp[1][i-1][j],dp[1][i][j-1])+a[i][j];\n        }\n        if(k&lt;dp[0][n][m] || k&gt;dp[1][n][m]) {cout&lt;&lt;\"NE\"&lt;&lt;endl; continue;}\n        cout&lt;&lt;\"DA\\n\";\n        if(!z) continue;\n        int x=n,y=m,cur=k;\n        string res=\"\";\n        while(x!=1 || y!=1)\n        {\n            assert(cur&gt;=dp[0][x][y] &amp;&amp; cur&lt;=dp[1][x][y]);\n            cur-=a[x][y];\n            if(cur&gt;=dp[0][x-1][y] &amp;&amp; cur&lt;=dp[1][x-1][y]) {x--; res+='S';}\n            else {y--; res+='D';}\n        }\n        reverse(res.begin(),res.end());\n        cout&lt;&lt;res&lt;&lt;endl;\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/05_bekstvo/","title":"A2 - Bekstvo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 512MB <p>Ispostavlja se da obilazak previ\u0161e koncerta pred takmi\u010denje u Kragujevcu mo\u017eda i nije bila najpametnija ideja. Nakon \u0161to ste se zatekli na koncertu po ko zna koji put, shvatili ste da takmi\u010denje uskoro po\u010dinje i da je mo\u017eda bolje da nastavite put \u0161to pre. Jedini problem koji morate da prevazi\u0111ete predstavlja \u010dinjenica da ste okru\u017eeni vernom publikom benda, koja ne namerava da se pomeri do kraja performansa.</p> <p>Sre\u0107om, ni Vi niste nespremni! Br\u017ee-bolje ste posegnuli rukom u ranac i izvadili magi\u010dno stablo koje uvek dr\u017eite blizu sebe, ba\u0161 zbog ovakvih neprilika. Va\u0161e magi\u010dno stablo, naravno, ima \\(N\\) \u010dvorova i \\(N-1\\) granu. Grane povezuju parove \u010dvorova tako da postoji ta\u010dno jedan put izme\u0111u svaka dva \u010dvora. \u010caskom ste posadili stablo, primenili najvi\u0161e \\(K\\) magi\u010dnih operacija i zbrisali \u0161to ste dalje mogli. </p> <p>U jednoj operaciji, dozvoljeno je izabrati proizvoljnu granu stabla i pomeriti je, ali tako da graf i nakon primenjene operacije ostane stablo. Formalno, u jednoj operaciji, dozvoljeno je izabrati proizvoljnu granu stabla, izbrisati je, i potom dodati ta\u010dno jednu novu granu, tako da nakon brisanja i dodavanja graf ostane stablo (tj. tako da postoji ta\u010dno jedan put izme\u0111u bilo koja dva \u010dvora). Va\u0161 cilj je da pobegnete \u0161to dalje, te \u017eelite da maksimizujete dijametar krajnjeg stabla (dakle stabla posle svih operacija). Dijametar stabla se defini\u0161e kao maksimalan broj grana na putu izme\u0111u neka dva \u010dvora. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Jovan Bengin Andrej Iva\u0161kovi\u0107"},{"location":"takprog/2022_2023/drz/05_bekstvo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalazi se ceo broj \\(T\\), broj test primera. Svaki test primer je slede\u0107eg formata: U prvom redu nalaze se dva cela broja \\(N\\) i \\(K\\). U \\(i\\)-tom od narednih \\(N - 1\\) redova nalaze se po dva cela broja, \\(u_i\\) i \\(v_i\\), koji opisuju \u010dvorove stabla povezane granom.</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(T\\) test primera, potrebno je u jednom redu ispisati jedan ceo broj, koji predstavlja maksimalni dijametar nakon primene najvi\u0161e \\(K\\) operacija.</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/05_bekstvo/#ulaz","title":"Ulaz","text":"<pre><code>2\n5 0\n1 4\n3 4\n2 4\n5 2\n5 1\n1 4\n3 4\n2 4\n5 2\n</code></pre>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#izlaz","title":"Izlaz","text":"<pre><code>3\n4\n</code></pre>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvom primeru \\(K = 0\\), te nije mogu\u0107e promeniti izgled stabla. Najve\u0107e rastojanje je \\(3\\) i posti\u017ee se izme\u0111u \u010dvorova \\(3\\) i \\(5\\). Put izme\u0111u ta dva \u010dvora je: \\(3 - 4 - 2 - 5\\) i sadr\u017ei \\(3\\) grane. U drugom primeru, dozvoljeno je primeniti najvi\u0161e jednu operaciju. Ukoliko izbri\u0161emo granu izme\u0111u \u010dvorova \\(4\\) i \\(1\\), te je dodamo izme\u0111u \u010dvorova \\(1\\) i \\(3\\), dobijamo stablo sa dijametrom \\(4\\), koji se posti\u017ee na putu izme\u0111u \u010dvorova \\(1\\) i \\(5\\).  Put izme\u0111u ta dva \u010dvora je: \\(1 - 3 - 4 - 2 - 5\\) i sadr\u017ei \\(4\\) grane.</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/drz/05_bekstvo/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n7 1\n1 4\n3 4\n2 4\n5 2\n6 4\n7 5\n</code></pre>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#izlaz_1","title":"Izlaz","text":"<pre><code>5\n</code></pre>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>U jedinom primeru je maksimalni dijametar nakon jedne primenjene operacije upravo jednak \\(5\\). Ovaj dijametar se posti\u017ee nakon preme\u0161tanja grane izme\u0111u \u010dvorova \\(3\\) i \\(4\\), tako da povezuje \u010dvorove \\(1\\) \\(3\\). Tada je rastojanje izme\u0111u \\(7\\) i \\(3\\) upravo jednako \\(5\\). Put izme\u0111u \\(7\\) i \\(3\\) je \\(7 - 5 - 2 - 4 - 1 - 3\\) i sadr\u017ei \\(5\\) grana.</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(1 \\leq N \\leq 3.000\\).</li> <li>\\(0 \\leq K \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(6\\) poena, \\(N \\leq 7\\).</li> <li>U test primerima vrednim \\(14\\) poena, \\(N \\leq 20\\).</li> <li>U test primerima vrednim \\(27\\) poena, \\(N \\leq 200\\).</li> <li>U test primerima vrednim \\(7\\) poena, \\(K=0\\), \\(N \\leq 1.000\\).</li> <li>U test primerima vrednim \\(11\\) poena, \\(K=1\\), \\(N \\leq 1.000\\).</li> <li>U test primerima vrednim \\(35\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#analiza","title":"Analiza","text":"<p>Primena \\(K\\) operacija se zapravo mo\u017ee uraditi odjednom: izbri\u0161emo najvi\u0161e \\(K\\) grana, i dodamo nove tako da nam graf ponovo postane stablo.  Primetimo da je optimalno da nove grane dodajemo na krajeve dijametara \"izrezanih\" stabala (stabla na koja smo podelili originalno stablo kada smo izbrisali neke grane) tako da od njih napravimo put. Tada \u0107e, u optimalnom re\u0161enju, krajnji dijametar stabla biti jednak sumi dijametara izrezanih stabala plus broj dodatih grana.</p> <p>Slu\u010daj \\(K=N\\) je ekvivalentan sa \\(K=N-1\\), pa \u0107emo razmatrati samo \\(0 \\leq K &lt; N\\).</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#resenje-prvog-i-drugog-podzadatka","title":"Re\u0161enje prvog i drugog podzadatka","text":"<p>Bira\u0107emo grane koje bri\u0161emo i za sva stabla koja nam ostanu izra\u010dunati dijametre, i te dijametre \u0107emo sumirati. Mogu\u0107ih podela u najgorem slu\u010daju ima \\(2^{N-1}\\) (svaku granu ili bri\u0161emo ili ne bri\u0161emo), a dijametar stabla mo\u017eemo na\u0107i u \\(O(N)\\) - pustimo pretragu iz nasumi\u010dnog \u010dvora, obele\u017eimo najdalji \u010dvor od njega kao prvi kraj dijametra, pustimo pretragu iz tog \u010dvora i obele\u017eimo najdalji \u010dvor kao drugi kraj dijametra. Ovaj algoritam radi jer je najdalji \u010dvor od proizvoljnog \u010dvora uvek kraj nekog dijametra, a najdalji \u010dvor od kraja dijametra je drugi kraj tog dijametra.</p> <p>Vremenska slo\u017eenost ovog algoritma je \\(O(2^NTN)\\), \u0161to prolazi prvi podzadatak. Me\u0111utim, ne moramo razmatrati svih \\(2^{N-1}\\) podela - dovoljne su samo one gde bri\u0161emo ta\u010dno \\(K\\) grana (ako smo izbrisali neki broj grana, nikad ne mo\u017eemo dobiti lo\u0161ije re\u0161enje ako izbri\u0161emo jo\u0161 neke). Ovako \u0107emo razmatrati samo \\({N \\choose K} \\leq {N \\choose N/2}\\) podela, i re\u0161enje nam lako prolazi drugi podzadatak.</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#resenje-cetvrtog-podzadatka","title":"Re\u0161enje \u010detvrtog podzadatka","text":"<p>Po\u0161to je \\(K = 0\\), re\u0161enje je samo dijametar po\u010detnog stabla. Ovde dijametar ne moramo ni tra\u017eiti \\(O(N)\\) algoritmom: dovoljno je da iz svakog \u010dvora pustimo po pretragu.</p> <p>Vremenska slo\u017eenost: \\(O(TN)\\) ili \\(O(TN^2)\\)</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#resenje-petog-podzadatka","title":"Re\u0161enje petog podzadatka","text":"<p>Iterira\u0107emo kroz sve grane, i za svaku u \\(O(N)\\) ra\u010dunati dijametre dva stabla koja dobijemo njenim brisanjem.</p> <p>Vremenska slo\u017eenost: \\(O(TN^2)\\)</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#resenje-treceg-podzadatka","title":"Re\u0161enje tre\u0107eg podzadatka","text":"<p>Nije potrebno eksplicitno tra\u017eiti dijametre izrezanih stabala. Lak\u0161e nam je da uz svako izrezano stablo samo izaberemo neki put koje mu pripada - u optimalnom re\u0161enju \u0107e se svakako ispostaviti da su to dijametri.</p> <p>Defini\u0161imo \\(dp[u][k][x]\\) kao najve\u0107u mogu\u0107u sumu izabranih puteva u podstablu \u010dvora \\(u\\) ako smo u njemu primenili \\(k\\) operacija, a \\(x\\) je \\(0\\), \\(1\\), ili \\(2\\) u zavisnosti od toga koliko jo\u0161 mo\u017eemo da \"dodajemo\" na na\u0161 izabran put. Drugim re\u010dima, ako je izabran put trenutnog podstabla samo \u010dvor \\(u\\), onda na njega mo\u017eemo dodati puteve koji dolaze iz dva razli\u010dita sina, pa je \\(x = 0\\).  Ako se izabran put trenutnog podstabla zavr\u0161ava u \\(u\\), onda je \\(x=1\\), a ako je put ve\u0107 u potpunosti izabran i ne dodajemo mu ni\u0161ta, onda je \\(x=2\\).</p> <p>\\(dp[u][k][x]\\) se nalazi dinami\u010dkim programiranjem po stablu: iteriramo kroz sinove, neka je trenutni sin \\(v\\). U \\(dp[u]\\) imamo izra\u010dunat \\(dp\\) za podstablo od \\(u\\), a u \\(dp[u]\\) imamo izra\u010dunat \\(dp\\) za stablo sa\u010dinjeno od \\(u\\) i podstabala svih sinova kroz koje smo do sada iterirali. \u017delimo da \"spojimo\" \\(dp\\) vrednosti za \\(u\\) i \\(v\\), pa da u \\(dp[u]\\) posle bude izra\u010dunat \\(dp\\) za stablo kome je dodato i podstablo od \\(v\\).</p> <p>Spajanje \\(dp\\)-ova dva stabla se mo\u017ee uraditi u \\(O(N^2)\\): iteriramo kroz broj grana koje \u0107emo brisati u prvom stablu (\\(i\\)), nakon toga kroz broj grana koje bri\u0161emo u drugom (\\(j\\)), i u neki novi \\(dp\\) niz a\u017euriramo vrednosti za \\(i + j\\) ili \\(i +j +1\\) izbrisanih grana (u zavisnosti od toga da li bri\u0161emo granu od \\(u\\) do \\(v\\)). Postoji nekoliko slu\u010dajeva: da bri\u0161emo granu od \\(u\\) do \\(v\\) i dodajemo du\u017eine njihovih izabranih puteva,  da ne bri\u0161emo granu od \\(u\\) do \\(v\\) ve\u0107 na put koji se zavr\u0161ava u \\(u\\) dodajemo put koji se zavr\u0161ava u \\(v\\), ili da ne bri\u0161emo granu ali da izaberemo samo jedan od dva izabrana puta podstabala \\(u\\) i \\(v\\).</p> <p>Krajnje re\u0161enje \u0107e biti \\(max(dp[1][K][0], dp[1][K][1], dp[1][K][2]) + K\\). Ako razmatramo da svako stanje u \\(dp[u][k][0]\\) pripada i \\(dp[u][k][1]\\), i da svako stanje u \\(dp[u][k][1]\\) pripada i \\(dp[u][k][2]\\) (\u0161to zna\u010dajno olak\u0161ava implementaciju), re\u0161enje je \\(dp[1][K][2] + K\\).</p> <p>Vremenska slo\u017eenost: \\(O(TN^3)\\)</p>"},{"location":"takprog/2022_2023/drz/05_bekstvo/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Glavno re\u0161enje je isto kao za tre\u0107i podzadatak, samo \u0161to tokom spajanja podstabala ne iteriramo kroz vrednosti koje su sigurno nemogu\u0107e. Drugim re\u010dima, za sina (\\(v\\)) \u0107emo samo iterirati do veli\u010dine njegovog podstabla, a za koren podstabla (\\(u\\)) \u0107emo samo iterirati do veli\u010dine trenutnog stabla koje njegov \\(dp\\) predstavlja (jer je nemogu\u0107e izbrisati vi\u0161e grana od toga).</p> <p>Nije te\u0161ko dokazati da slo\u017eenost algoritma sada postaje \\(O(N^2)\\). Kada spajamo \\(dp\\)-ove dva stabla, iteriramo do njihovih veli\u010dina - \u0161to mo\u017eemo predstaviti kao da se svaki \u010dvor koji pripada prvom stablu uparuje sa svakim iz drugog. Po\u0161to \u0107e nakon toga svi ti \u010dvorovi pripadati istom stablu, mo\u017eemo primetiti da \u0107e svaka dva \u010dvora da se upare ta\u010dno jednom - \u0161to daje ukupno \\(O(N^2)\\) uparivanja.</p> <p>Vremenska slo\u017eenost: \\(O(TN^2)\\)</p> <p>Bonus: Re\u0161ite zadatak u \\(O(TNlogN)\\).</p> 05_bekstvo.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define maxn 3005\nusing namespace std;\nint t;\nint n,k;\nvector&lt;int&gt; a[maxn];\nint dp[maxn][maxn][3];\nint gp[maxn][3];\nint sz[maxn];\nvoid dfs(int u,int pr=-1) {\n    sz[u]=1;\n    dp[u][0][0]=dp[u][0][1]=dp[u][0][2]=0;\n    dp[u][1][0]=-1e9;\n    dp[u][1][1]=0;\n    dp[u][1][2]=0;\n    for(auto v:a[u]) {\n        if(v!=pr) {\n            dfs(v,u);\n\n            for(int i=sz[u]+1;i&lt;=sz[u]+sz[v] &amp;&amp; i&lt;=k+1;i++) {\n                dp[u][i][0]=dp[u][i][1]=dp[u][i][2]=0;\n            }\n            dp[u][sz[u]+sz[v]][0]=-1e9;\n            for(int i=0;i&lt;=sz[u]+sz[v] &amp;&amp; i&lt;=k+1;i++) {\n                gp[i][0]=gp[i][1]=gp[i][2]=0;\n            }\n            gp[sz[u]+sz[v]][0]=-1e9;\n\n            for(int i=0;i&lt;=sz[u] &amp;&amp; i&lt;=k+1;i++) {\n                for(int j=0;j&lt;=sz[v] &amp;&amp; i+j&lt;=k+1;j++) {\n                    gp[i+j][0]=max(gp[i+j][0],dp[u][i][0]+dp[v][j][2]);\n                    if(i) {\n                        gp[i+j][1]=max(gp[i+j][1],dp[u][i][1]+dp[v][j][2]);\n                    }\n                    if(j) {\n                        gp[i+j][1]=max(gp[i+j][1],dp[u][i][0]+dp[v][j][1]+1);\n                    }\n                    if(i&gt;0 &amp;&amp; j&gt;0) {\n                        gp[i+j-1][2]=max(gp[i+j-1][2],dp[u][i][1]+dp[v][j][1]+1);\n                    }\n                    gp[i+j][2]=max(gp[i+j][2],dp[u][i][2]+dp[v][j][2]);\n                }\n            }\n\n            for(int i=0;i&lt;=sz[u]+sz[v] &amp;&amp; i&lt;=k+1;i++) {\n                for(int j=0;j&lt;=2;j++) {\n                    dp[u][i][j]=max(dp[u][i][j],gp[i][j]);\n                }\n            }\n\n\n            sz[u]+=sz[v];\n\n        }\n    }\n    for(int i=0;i&lt;=sz[u];i++) {\n        dp[u][i][2]=max(dp[u][i][0],max(dp[u][i][1],dp[u][i][2]));\n    }\n    /*cout&lt;&lt;u&lt;&lt;\" \"&lt;&lt;sz[u]&lt;&lt;endl;\n    for(int i=0;i&lt;=sz[u];i++) {\n        cout&lt;&lt;\"dp[\"&lt;&lt;u&lt;&lt;\"][\"&lt;&lt;i&lt;&lt;\"][0]=\"&lt;&lt;dp[u][i][0]&lt;&lt;\", \"&lt;&lt;\"dp[\"&lt;&lt;u&lt;&lt;\"][\"&lt;&lt;i&lt;&lt;\"][1]=\"&lt;&lt;dp[u][i][1]&lt;&lt;\", \"&lt;&lt;\"dp[\"&lt;&lt;u&lt;&lt;\"][\"&lt;&lt;i&lt;&lt;\"][2]=\"&lt;&lt;dp[u][i][2]&lt;&lt;\", \"&lt;&lt;endl;\n    }*/\n}\nint main() {\n\n    scanf(\"%d\",&amp;t);\n    while(t--) {\n        scanf(\"%d %d\",&amp;n,&amp;k);\n        k=min(k+1,n);\n        for(int i=0;i&lt;n-1;i++) {\n            int u,v;\n            scanf(\"%d %d\",&amp;u,&amp;v);\n            a[u].push_back(v);\n            a[v].push_back(u);\n        }\n\n        dfs(1);\n\n        int ans=0;\n        for(int i=0;i&lt;=k;i++) {\n            for(int j=0;j&lt;=2;j++) {\n                ans=max(ans,dp[1][i][j]+max(i-1,0));\n            }\n        }\n\n        printf(\"%d\\n\",ans);\n\n        for(int i=1;i&lt;=n;i++) a[i].clear();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/drz/06_turizam/","title":"A3 - Turizam","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2500ms 512MB <p>Dr\u017eavno takmi\u010denje iz informatike, lokalni bendovi, kao i Va\u0161e legendarno bekstvo, doprineli su tome da Vam Kragujevac ostane u vrlo lepom se\u0107anju. Zbog toga ste odlu\u010dili da ostanete tu jo\u0161 \\(Q\\) dana, kako bi ste u potpunosti iskusili svaki deo grada.</p> <p>Ovog puta se, zbog mnogobrojnih radova na sporednim ulicama, Kragujevac mo\u017ee predstaviti kao niz od \\(N\\) polja. Nekim danima \u0107ete krenuti iz jednog od polja i odatle \u0161etati po gradu. Me\u0111utim, opasnost vreba iza svakog \u0107o\u0161ka! Kao \u0161to ste mogli da pretpostavite, u svakom polju odr\u017eava generalnu probu po jedan stra\u0161ni kragujeva\u010dki bend, koji ne\u0107e u potpunosti da toleri\u0161e va\u0161e prisustvo. Preciznije, svaka bend ima svoj nivo tolerancije, gde je nivo tolerancije \\(i\\)-tog benda jednak \\(A_i\\).</p> <p>Tokom svakog od narednih \\(Q\\) dana desi se jedan od slede\u0107a dva doga\u0111aja:</p> <ul> <li><code>1 x y</code>: Nivo tolerancije \\(x\\)-te benda, \\(A_x\\), postaje \\(y\\).</li> <li><code>2 x</code>: Zapo\u010dinjete put iz polja \\(x\\), sa nivoom radoznalosti (skra\u0107eno NR) jednakim \\(A_x\\). U jednom koraku iz polja \\(i\\) mo\u017eete pre\u0107i ili na polje \\(i - 1\\) ili na \\(i + 1\\), pod uslovom da je polje u koje prelazite u okviru niza. Kada u\u0111ete u polje \\(i\\) sa nivoom radoznalosti \\(X\\), Va\u0161 NR se menja u \\(X \\ \\text{and} \\ A_i\\), tj. bitovsku konjunkciju brojeva \\(X\\) i \\(A_i\\). Ovo radite sve dok NR ne postane nula.</li> </ul> <p>Po\u0161to biste hteli da se pripremite za najnepovoljniji slu\u010daj, interesuje Vas za svaki doga\u0111aj drugog tipa minimalan broj koraka potreban da nivo radoznalosti (NR) postane nula.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Jovan Bengin Jovan Bengin Jovan Bengin Igor Pavlovi\u0107"},{"location":"takprog/2022_2023/drz/06_turizam/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei ceo broj \\(N\\), broj polja u Kragujevcu. </p> <p>U narednom redu se nalazi \\(N\\) celih brojeva koji predstavljaju niz \\(A_i\\).</p> <p>Naredni red sadr\u017ei ceo broj \\(Q\\), broj dana.</p> <p>Svaki od narednih \\(Q\\) redova sadr\u017ei dva ili tri broja: \\(1, x_i, y_i\\) ili  \\(2, x_i\\), odvojena razmakom, koji opisuju \\(i\\)-ti doga\u0111aj.</p> <p>Garantuje se da postoji barem jedan doga\u0111aj drugog tipa.</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki doga\u0111aj drugog tipa potrebno je ispisati jedan ceo broj \u2014 ukoliko je mogu\u0107e da NR postane nula, ispisati minimalan broj potrebnih koraka, uostalom ispisati <code>-1</code>. </p>"},{"location":"takprog/2022_2023/drz/06_turizam/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/drz/06_turizam/#ulaz","title":"Ulaz","text":"<pre><code>7\n7 2 2 7 5 4 4\n10\n2 4\n1 4 6\n2 1\n1 7 4\n2 7\n1 2 4\n1 3 4\n2 5\n1 5 0\n2 5\n</code></pre>"},{"location":"takprog/2022_2023/drz/06_turizam/#izlaz","title":"Izlaz","text":"<pre><code>3\n4\n4\n-1\n0\n</code></pre>"},{"location":"takprog/2022_2023/drz/06_turizam/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvog dana zapo\u010dinjete put iz polja \\(4\\) sa nivoom radoznalosti jednakim \\(7\\). Potrebno je najmanje \\(3\\) koraka da NR postane nula, a jedan od mogu\u0107ih puteva je \\(4 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5\\). </p> <p>Drugog dana nivo tolerancije \u010detvrtog benda postaje 6, pa niz \\(A\\) postaje \\([7, 2, 2, 6, 5, 4, 4]\\).</p> <p>Tre\u0107eg dana po\u010dinjete put iz polja 1 sa nivoom radoznalosti jednakim 7. Potrebno je najmanje \\(4\\) koraka da NR postane nula, \u0161to se dosti\u017ee putem \\(1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5\\).</p> <p>\u010cetvrtog dana nivo tolerancije sedmog benda postaje \\(4\\) (kao \u0161to je i ranije bio), pa niz \\(A\\) ostaje \\([7, 2, 2, 6, 5, 4, 4]\\).</p> <p>Petog dana po\u010dinjete put iz polja 7 sa nivoom radoznalosti jednakim 4. Potrebno je najmanje \\(4\\) koraka da NR postane nula, \u0161to se dosti\u017ee putem \\(7 \\rightarrow 6 \\rightarrow 5 \\rightarrow 4 \\rightarrow 3\\).</p> <p>Nakon doga\u0111aja \u0161estog i sedmog dana, niz \u0107e biti \\([7, 4, 4, 6, 5, 4, 4]\\).</p> <p>Osmog dana po\u010dinjete put iz polja 5 sa nivoom radoznalosti jednakim 5. Mo\u017ee se pokazati da nijedan niz koraka ne mo\u017ee smanjiti NR na nulu. Devetog dana niz postaje \\([7, 4, 4, 6, 0, 4, 4]\\).</p> <p>Desetog dana po\u010dinjete put iz polja 5 sa nivoom radoznalosti jednakim 0. Kako je NR ve\u0107 0, nije potrebno napraviti nijedan korak.</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 10^5\\).</li> <li>\\(0 \\leq A_i &lt; 2^{20}\\) za \\(1 \\leq i \\leq N\\).</li> <li>\\(T_i \\in \\{1, 2\\}\\) za \\(1 \\leq i \\leq Q\\).</li> <li>\\(1 \\leq X_i \\leq N\\) za \\(1 \\leq i \\leq Q\\).</li> <li>\\(0 \\leq Y_i &lt; 2^{20}\\) za \\(1 \\leq i \\leq Q\\) i \\(T_i = 1\\). </li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(4\\) poena, \\(N, Q \\leq 100\\).</li> <li>U test primerima vrednim \\(11\\) poena, \\(N, Q \\leq 500\\).</li> <li>U test primerima vrednim \\(14\\) poena, sve vrednosti \\(A_i\\) i \\(Y_i\\) \u0107e biti \\(0\\), \\(1\\), \\(2\\) ili \\(3\\).</li> <li>U test primerima vrednim \\(15\\) poena, \\(N,Q \\leq 5000\\).</li> <li>U test primerima vrednim \\(19\\) poena, svi doga\u0111aji su drugog tipa.</li> <li>U test primerima vrednim \\(37\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/drz/06_turizam/#napomena","title":"Napomena","text":"<p>Operator konjunkcije u Pascal-u je ozna\u010den sa <code>and</code>, dok u C++ ga zapisujemo pomo\u0107u simbola <code>&amp;</code>. Ova operacija \\(x\\ \\text{and} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{and} \\  y\\).</p> <p>Bitovska konjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{and} \\ x_{2}  \\ \\text{and} \\  ...  \\ \\text{and} \\  x_{n} = (...(((x_{1}  \\ \\text{and} \\  x_{2})  \\ \\text{and} \\  x_{3}) \\ \\text{and} \\ x_{4})...)  \\ \\text{and} \\  x_{n}\\).</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#analiza","title":"Analiza","text":"<p>Prvo, primetimo da \u0107emo uvek posetiti neki podniz koji sadr\u017ei po\u010detno polje \\(x\\). Ako je podniz koji posetimo \\([L, R]\\), NR na kraju \u0107e biti \\(A_L \\ \\text{and} \\ A_{L+1} \\ \\text{and} \\ \\ldots{} \\ \\text{and} \\ A_R\\) (zapisa\u0107emo kao \\(f(L, R)\\)), a minimalan broj koraka da se poseti je \\(R - L + min(x - L, R - x)\\) (tako \u0161to iz po\u010detka odemo do leve granice, pa do desne, ili obrnuto).</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#resenje-prvog-podzadatka","title":"Re\u0161enje prvog podzadatka","text":"<p>U ovom podzadatku mo\u017eemo iterirati kroz svaku mogu\u0107u levu i desnu granicu, i ukupnu \\(\\text{and}\\) vrednost ra\u010dunati jednim prolaskom kroz podniz.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(QN^3)\\)</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#resenje-drugog-podzadatka","title":"Re\u0161enje drugog podzadatka","text":"<p>Isto \u0107emo iterirati kroz svaku mogu\u0107u levu i desnu granicu, ali \u0107emo \u010duvati vrednosti \\(f(L, x)\\) i \\(f(x, R)\\) i a\u017eurirati ih tokom iteracija. Sada ne moramo da iteriramo kroz ceo podniz da bismo na\u0161li \\(f(L, R)\\), ve\u0107 ga dobijemo iz sa\u010duvane dve vrednosti.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(QN^2)\\)</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#resenje-treceg-podzadatka","title":"Re\u0161enje tre\u0107eg podzadatka","text":"<p>Za naredne podzadatke potrebna nam je jo\u0161 jedna klju\u010dna opservacija: optimalni podniz \u0107e uvek imati levu i desnu granicu u poljima gde se ukupan NR menja, tj. u \\(L\\) i \\(R\\) takvim da va\u017ei \\(f(L, x) \\neq f(L + 1, x)\\) (ili \\(L = x\\)) i \\(f(x, R) \\neq f(x, R - 1)\\) (ili \\(R = x\\)). Ovo je ta\u010dno jer, ako je na granici polje koje ne menja NR, mo\u017eemo ga samo izbaciti iz podniza.</p> <p>U ovom podzadatku je, dakle, mogu\u0107e samo nekoliko slu\u010dajeva: da direktno idemo iz \\(x\\) u najbli\u017eu nulu, da idemo iz \\(x\\) do najbli\u017ee leve jedinice i do najbli\u017ee desne dvojke (ili obrnuto), ili da, ako su \u017eeljena jedinica i dvojka sa iste strane, odemo iz \\(x\\) do dalje od njih.</p> <p>Pozicije najbli\u017ee leve i desne nule, jedinice i dvojke mo\u017eemo na\u0107i preko strukture std::set i njene funkcije upper_bound.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(QlogN)\\)</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#resenje-cetvrtog-podzadatka","title":"Re\u0161enje \u010detvrtog podzadatka","text":"<p>Pozicije koje menjaju NR su zapravo one za koje va\u017ei da postoji neki bit koji se ne nalazi u njenom elementu, ali se nalazi u elementima na svim pozicijama od nje do \\(x\\).</p> <p>Za svaki bit mo\u017eemo jednim prolaskom kroz niz na\u0107i najbli\u017eu levu i desnu poziciju \u010diji element ne sadr\u017ei taj bit, neka su za \\(i\\)-ti bi te dve pozicije \\(l_i\\) i \\(r_i\\), a na\u0161 interval mora da sadr\u017ei ili jednu ili drugu. Drugim re\u010dima, uslov mo\u017eemo da formuli\u0161emo kao: ako je leva granica ve\u0107a od \\(l_i\\), onda je desna granica ve\u0107a jednaka \\(r_i\\). Zato mo\u017eemo da iteriramo kroz sortiran niz potencijalnih levih granica (kojih ima \\(log(A_i)\\)) i da odr\u017eavamo trenutnu minimalnu desnu granicu, i tako nalazimo minimalno re\u0161enje.</p> <p>Slo\u017eenost ovog algoritma je  \\({\\mathcal O}(QNlog(A_i))\\), \u0161to bi uz pokoju optimizaciju pro\u0161lo. Me\u0111utim, nala\u017eenje levih i desnih granica mo\u017ee da se uradi u \\({\\mathcal O}(N + log(A_i))\\) umesto \\({\\mathcal O}(Nlog(A_i))\\), tako \u0161to po\u010dnemo iz \\(x\\) i kre\u0107emo se levo ili desno (u zavisnosti od toga koju granicu nalazimo), \u010duvaju\u0107i trenutnu \\(\\text{and}\\) vrednost tog intervala. Kada se ta vrednost promeni, iteriramo kroz one bitove gde se promenila i za njih odre\u0111ujemo da im je granica na toj poziciji.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(Q(N + log(A_i)))\\)</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#resenje-petog-podzadatka","title":"Re\u0161enje petog podzadatka","text":"<p>U ovom podzadatku \u0107emo br\u017ee nalaziti pozicije nula: za svaki bit \u010duvamo niz pozicija \u010diji elementi nemaju taj bit. Sada mo\u017eemo binarnom pretragom da brzo na\u0111emo \u017eeljene elemente.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(Qlog(N)log(A_i))\\)</p>"},{"location":"takprog/2022_2023/drz/06_turizam/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Glavno re\u0161enje se radi na isti na\u010din kao peti podzadatak, samo \u0161to se umesto niza pozicija koristi struktura std::set, koja se lako mo\u017ee a\u017eurirati u slu\u010daju doga\u0111aja prvog tipa.</p> <p>Ukupna slo\u017eenost: \\({\\mathcal O}(Qlog(N)log(A_i))\\)</p> 06_turizam.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 200000;\n\nint a[N+5];\nset &lt;int&gt; nule[20];\n\nint calc(int l, int p, int r){\n    return r - l + min(p - l, r - p);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0);\n    cout.precision(10);\n    cout &lt;&lt; fixed;\n\n    int n;\n    cin &gt;&gt; n;\n    for(int i=1; i&lt;=n; i++){\n        cin &gt;&gt; a[i];\n        for(int j=0; j&lt;20; j++){\n            if(!((1 &lt;&lt; j) &amp; a[i])) nule[j].insert(i);\n        }\n    }\n    int q;\n    cin &gt;&gt; q;\n    while(q--){\n        int typ;\n        cin &gt;&gt; typ;\n        if(typ == 1){\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            for(int j=0; j&lt;20; j++){\n                bool pre = ((1 &lt;&lt; j) &amp; a[x]);\n                bool posle = ((1 &lt;&lt; j) &amp; y);\n                if(pre &amp;&amp; !posle) nule[j].insert(x);\n                if(!pre &amp;&amp; posle) nule[j].erase(x);\n            }\n            a[x] = y;\n        }\n        else{\n            int id;\n            cin &gt;&gt; id;\n            vector &lt;pair &lt;int, int&gt;&gt; vec;\n            int res = 2*n;\n            bool bad = 0;\n            for(int j=0; j&lt;20; j++){\n                if(!((1 &lt;&lt; j) &amp; a[id])) continue;\n                if(!nule[j].size()){\n                    bad = 1;\n                    break;\n                }\n                auto x = nule[j].upper_bound(id);\n                if(x == nule[j].begin()){\n                    vec.push_back({0, *x});\n                    continue;\n                }\n                auto p = x;\n                p--;\n                if(x == nule[j].end()){\n                    vec.push_back({*p, n + 1});\n                }\n                else{\n                    assert(*p &lt;= id);\n                    vec.push_back({*p, *x});\n                }\n            }\n            if(bad){\n                cout &lt;&lt; \"-1\\n\";\n                continue;\n            }\n            int mxd = id;\n            sort(vec.begin(), vec.end());\n            for(auto c : vec){\n                if(c.first &gt;= 1 &amp;&amp; mxd &lt;= n) res = min(res, calc(c.first, id, mxd));\n                mxd = max(mxd, c.second);\n            }\n            if(mxd &lt;= n){\n                res = min(res, calc(id, id, mxd));\n            }\n            cout &lt;&lt; res &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/","title":"1 - Sudar brojeva","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 32MB <p>Mala Danica, potpuno revoltirana odlukom Komisije da ove godine ukine jedan krug kvalifikacija, krenula je da razbija sve oko sebe, uklju\u010duju\u0107i i brojeve koji joj padnu pod ruku. Naime, kada ugleda dva prirodna broja ona baci jedan broj na drugi tako da se brojevi sudare. Sudarom dva broja, nastaje nov prirodan broj.</p> <p>Prilikom sudara dva prirodna broja \\(X\\) i \\(Y\\), svaka cifra jednog broja upore\u0111uje se s odgovaraju\u0107om cifrom drugog broja, to jest, jedinica se uporedi s jedinicom, desetica s deseticom, stotina sa stotinom, itd. Manja od dve cifre u tom pore\u0111enju ispadne, dok ve\u0107a ulazi u sastav novoformiranog broja. Ukoliko su odgovaraju\u0107e cifre jednake, prilikom sudara obe ulaze u novostvoreni broj te \u0107e stoga on imati vi\u0161e cifara od \\(X\\) i \\(Y\\). Ukoliko u nekom od dva prirodna broja koja se sudaraju nema odgovaraju\u0107e cifre, smatra se da ta cifra ne postoji te se bez pore\u0111enja uvek uzima cifra drugog broja, pa makar ona bila i nula.</p> <p>Po\u0161to je brojeva previ\u0161e, mala Danica ne mo\u017ee sama da se izbori s njima, pa vas je zamolila da joj pomognete tako \u0161to \u0107ete sudarati brojeve zajedno s njom. Da biste to u\u010dinili morate odgovoriti na pitanje koji \u0107e se broj stvoriti prilikom sudara dva prirodna broja?</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2022_2023/kv1/01_sudar/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalaze prvi prirodan broj \\(X\\), dok se u drugom redu standardnog ulaza nalazi drugi prirodan broj \\(Y\\). Ova dva prirodna broja treba sudariti na na\u010din opisan u tekstu zadatka.</p>"},{"location":"takprog/2022_2023/kv1/01_sudar/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati novostvoreni broj koji se dobija prilikom sudara dva broja sa ulaza.</p>"},{"location":"takprog/2022_2023/kv1/01_sudar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv1/01_sudar/#ulaz","title":"Ulaz","text":"<pre><code>73\n28\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#izlaz","title":"Izlaz","text":"<pre><code>78\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv1/01_sudar/#ulaz_1","title":"Ulaz","text":"<pre><code>64\n357\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#izlaz_1","title":"Izlaz","text":"<pre><code>367\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2022_2023/kv1/01_sudar/#ulaz_2","title":"Ulaz","text":"<pre><code>234\n135\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#izlaz_2","title":"Izlaz","text":"<pre><code>2335\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#primer-4","title":"Primer 4","text":""},{"location":"takprog/2022_2023/kv1/01_sudar/#ulaz_3","title":"Ulaz","text":"<pre><code>99099\n9999\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#izlaz_3","title":"Izlaz","text":"<pre><code>99999999\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#primer-5","title":"Primer 5","text":""},{"location":"takprog/2022_2023/kv1/01_sudar/#ulaz_4","title":"Ulaz","text":"<pre><code>2\n100\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#izlaz_4","title":"Izlaz","text":"<pre><code>102\n</code></pre>"},{"location":"takprog/2022_2023/kv1/01_sudar/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom primeru se sudaraju brojevi \\(73\\) i \\(28\\). Oba broja su dvocifrena, te se me\u0111usobno upore\u0111uju cifre desetica, odnosno \\(7\\) i \\(2\\), i cifre jedinica, odnosno \\(3\\) i \\(8\\), i od ve\u0107ih cifara stvara se novi broj koji ima vrednost \\(78\\), po\u0161to je \\(7\\) ve\u0107e od \\(2\\), a \\(8\\) ve\u0107e od \\(3\\).</p> <p>U drugom primeru sudaraju se brojevi \\(64\\) i \\(357\\). Prvi broj je dvocifren, a drugi trocifren, pa se stoga cifra stotina, \\(3\\), preuzima iz ve\u0107eg broja. Zatim se prilikom sudara me\u0111usobno upore\u0111uju cifre desetica, \\(6\\) i \\(5\\), kao i cifre jedinica \\(4\\) i \\(7\\), i od ve\u0107ih cifara formira se novi broj koji ima vrednost \\(367\\), po\u0161to je \\(3\\) preuzeto, a \\(6\\) ve\u0107e od \\(5\\) i \\(7\\) ve\u0107e od \\(4\\).</p> <p>U tre\u0107em primeru sudaraju se trocifreni brojevi \\(234\\) i \\(135\\). Me\u0111usobno se upore\u0111uju cifre stotina, \\(2\\) i \\(1\\), cifre desetica \\(3\\) i \\(3\\), i kona\u010dno cifre jedinica \\(4\\) i \\(5\\). Pored odgovaraju\u0107ih ve\u0107ih cifara koje sa\u010dinjavaju nov broj, a to su cifre \\(2\\) i \\(5\\), u sastav novog broja ulaze i sve me\u0111usobno jednake cifre na odgovaraju\u0107im mestima, odnosno u ovom konkretnom slu\u010daju obe cifre \\(3\\) s mesta desetica, pa je vrednost novostvorenog broja \\(2335\\).</p> <p>U \u010detvrtom primeru sudaraju se brojevi \\(99099\\) i \\(9999\\). Kako je prvi petocifreni, a drugi \u010detvorocifreni, porede se \u010detiri najni\u017ee cifre, a po najvi\u0161a se cifra preuzima iz prvog broja. Prilikom upore\u0111ivanja postoje samo dva slu\u010daja: u prvom se poredi \\(9\\) i \\(0\\) te se u novoformiranom broju prenosi jedna devetka, a u drugom slu\u010daju se poredi \\(9\\) i \\(9\\) pa u novostvoreni broj ulaze obe devetke. Stoga je rezultat sudara \\(99999999\\) jer u dva po\u010detna broja imamo ukupno osam devetki i sve one ulaze u sastav rezultuju\u0107eg broja.</p> <p>Najzad, u petom test primeru sudaraju se brojevi \\(2\\) i \\(100\\). Po\u0161to je prvi broj jednocifren, a drugi trocifren, to se prve dve cifre \\(1\\) i \\(0\\) svakako preuzimaju iz drugog broja, a u pore\u0111enju cifara jedinica, \\(2\\) je ve\u0107e od \\(0\\), te se kona\u010dno dobija vrednost \\(102\\).</p>"},{"location":"takprog/2022_2023/kv1/01_sudar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq X, Y \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim \\(10\\) poena: \\(1 \\leq X, Y &lt; 10\\), odnosno \\(X\\) i \\(Y\\) su jednocifreni.</li> <li>U testovima vrednim \\(15\\) poena: \\(10 \\leq X, Y &lt; 100\\), odnosno \\(X\\) i \\(Y\\) su dvocifreni.</li> <li>U testovima vrednim \\(15\\) poena: \\(100 \\leq X, Y &lt; 1000\\), odnosno \\(X\\) i \\(Y\\) su trocifreni.</li> <li>U testovima vrednim \\(20\\) poena: \\(10^3 \\leq X, Y \\leq 10^9\\) i da \\(X\\) i \\(Y\\) imaju jednak broj cifara.</li> <li>U testovima vrednim \\(40\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv1/01_sudar/#napomena","title":"Napomena","text":"<p>Zadati i ispisani brojevi su uvek u dekadnom zapisu bez vode\u0107ih nula.</p>"},{"location":"takprog/2022_2023/kv1/01_sudar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Zadatak je najlak\u0161e re\u0161iti posmatraju\u0107i date prirodne brojeve \\(X\\) i \\(Y\\) kao niske. Naime, u jednoj petlji treba porediti znakove (karaktere) niski \\(X\\) i \\(Y\\), koji zapravo predstavljaju cifre brojeva na odgovaraju\u0107im indeksima. Kre\u0107u\u0107i se unazad, po\u010dev\u0161i od cifara najmanje te\u017eine i idu\u0107i ka cifrma najve\u0107e te\u017eine, ideja je dodavati ve\u0107u od njih u neku novostvorenu nisku. Ukoliko se pak desi da su cifre odgovaraju\u0107e te\u017eine jednake, neophodno ih je obe dodati u pomenutu novoformiranu nisku, to jest tu jednu cifru dva puta. Nisku napravljenu u prethodnom postupku na kraju zadatka potrebno je ispisati. Slu\u010dajevi kada su zadati ulazni brojevi razli\u010ditih du\u017eina re\u0161ava se tako da kada se tokom prolaska kroz opisanu petlju broj cifara jednog od brojeva iscrpi, rezultuju\u0107u nisku samo treba dopuniti preostalim ciframa ve\u0107eg broja koje nisu bile iskori\u0161\u0107ene u pore\u0111enju.</p> <p>Pod pretpostavkom da se zadat broj \\(X\\) sastoji iz \\(M\\) cifara, dok zadati broj \\(Y\\) sadr\u017ei \\(N\\) cifara, slo\u017eenost opisanog algoritma je \\(\\mathcal{O}(M+N)\\), odnosno linearna po broju cifara.</p> 01_sudar.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nlong long a, b;\nstring A, B, res=\"\";\n\nint main() {\n    cin &gt;&gt; a&gt;&gt;b;\n\n    if(b&gt;a) swap(a,b);\n\n    A = to_string(a);\n    B = to_string(b);\n\n    reverse(A.begin(), A.end());\n    reverse(B.begin(), B.end());\n\n    for(int i=0;i&lt;A.size();i++){\n        if(i&gt;=B.size()){\n            res+=A[i];\n            continue;\n        }\n        if(A[i]&gt;=B[i]) res+=A[i];\n        if(A[i]&lt;=B[i]) res+=B[i];\n    }\n\n    reverse(res.begin(),res.end());\n\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/","title":"2 - Name\u0161tanje granice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Glasa se za granicu za prolaz na dr\u017eavno takmi\u010denje iz atletike. Svi \u010dlanovi komisije \u0107e napisati na papiri\u0107 neki broj, koji \u0107e potom ubaciti u kutiju za glasove. Granica \u0107e se odrediti tako \u0161to \u0107e se uzeti medijana svih glasova koji su uba\u010deni u kutiju.</p> <p>Kada je najpopularniji \u010dlan komisije Markos, poznatiji kao \u201ebog i batina\u201c do\u0161ao da glasa, primetio je da niko ne obra\u0107a pa\u017enju na kutiju sa glasovima. Odlu\u010dio je da, nakon \u0161to ostatak komisije glasa, do\u0111e i proviri u kutiju, otkrije \u0161ta su ostali \u010dlanovi komisije glasali i zatim napi\u0161e onoliko glasova koliko je minimalno potrebno da granica bude ba\u0161 broj \\(X\\) koji je on zamislio.</p> <p>Posmatramo \\(Q\\) scenarija gde je u \\(i\\)-tom scenariju broj koji je Markos zamislio \\(B[i]\\). Pomozite Markosu da za svaki scenario otkrije koliko minimalno glasova mora da ubaci u kutiju za glasove. Glasovi koji su ve\u0107 bili u kutiji su dati nizom \\(A\\), du\u017eine \\(N\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Toni \u0160krijelj Dragan Uro\u0161evi\u0107 Vladimir Milovanovi\u0107"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalaze dva pozitivna cela broja \\(N\\) i \\(Q\\). U drugom redu se nalazi niz celih brojeva \\(A\\). U tre\u0107em redu se nalazi niz celih brojeva \\(B\\).</p>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki scenario ispisati re\u0161enje u novom redu.</p>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#ulaz","title":"Ulaz","text":"<pre><code>5 3\n1 3 5 7 9\n5 7 10\n</code></pre>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n5\n</code></pre>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#objasnjenja-primera","title":"Obja\u0161njenja primera","text":"<p>U prvom scenariju medijana je ve\u0107 5 te je odgovor 0. U drugom scenariju Markos mo\u017ee da ubaci glas sa brojem 8 da bi medijana postala 7 te je odgovor 1. Kona\u010dno, u tre\u0107em scenariju, neophodno je da Markos ubaci jo\u0161 najmanje pet glasova sa brojem 10 ili vi\u0161e, da bi medijana postala 10, te je odgovor 5.</p>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 2*10^5\\)</li> <li>\\(0\\leq A[i] \\leq 10^9\\) za svako \\(0 \\leq i &lt; N\\)</li> <li>\\(0\\leq B[i] \\leq 10^9\\) za svako \\(0 \\leq i &lt; Q\\) </li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 25 poena: \\(Q = 1\\).</li> <li>U testovima vrednim 25 poena: Svaki broj \\(X\\) koji je Markos zamislio \u0107e biti ve\u0107 ne\u010diji glas.</li> <li>U testovima vrednim 25 poena: \\(N,Q \\leq 1000\\).</li> <li>U testovima vrednim 25 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#napomena","title":"Napomena","text":"<p>Neka je dat niz \\(A\\) sa \\(N\\) \u010dlanova. Kao medijana ovog niza se uzima \u010dlan koji bi se na\u0161ao u sredini kada bi se niz \\(A\\) sortirao. Formalnije, neka je \\(A^\\prime\\) niz koji se dobija kada se niz \\(A\\) sortira. Neka je \\(A^\\prime\\) indeksiran od \\(1\\). Medijana niza \\(A\\) se defini\u0161e kao element \\(A^\\prime[\\lfloor\\dfrac{N}{2}\\rfloor + 1]\\). Na primer, ukoliko je \\(A = [5,7,3,6]\\), niz \\(A^\\prime\\) bi bio \\([3,5,6,7]\\), a medijana bi imala vrednost \\(6\\).</p>"},{"location":"takprog/2022_2023/kv1/02_namestanje_granice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Pretpostavimo da je niz \\(A\\) sortiran u neopadaju\u0107em poretku, da je ukupan broj elemenata niza \\(N\\) i da su elementi niza indeksirani brojevima od \\(0\\) do \\(N-1\\). Tada je medijana niza element sa indeksom \\(N/2\\) (pri \u010demu se ra\u010duna celobrojni deo koli\u010dnika). Neka je \\(B\\) broj poena koji Markos \u017eeli kao granicu. Tada razlikujemo tri slu\u010daja:</p> <ul> <li> <p>Ako je \\(A[N/2] = B\\), onda je medijana ve\u0107 jednaka broju \\(B\\) i Markos glasa \\(0\\) puta.</p> </li> <li> <p>Ako je \\(B\\) \\(&lt;\\) \\(A[N/2]\\) odre\u0111ujemo indeks \\(i\\) poslednjeg elementa koji nije ve\u0107i od \\(B\\) (ako takav ne postoji, onda je \\(i=-1\\)). Tada postoji  \\(i+1\\) elemenata koji su manji od ili jednaki \\(B\\) i \\(N-i-1\\) elemenata koji su ve\u0107i od \\(B\\), pri \u010demu je \\(i+1 \\leq N-i-1\\). Da bi obezbedili da \\(B\\) bude medijana potrebno je da grupa manjih ili jednakih ima bar jedan element vi\u0161e od grupe ve\u0107ih, pa je potrebno ubaciti \\(N-i-1-(i+1)+1 = N-2i-1\\) glasova.</p> </li> <li>Ako je \\(B&gt;A[N/2]\\) odre\u0111ujemo indeks \\(i\\) prvog elementa koji nije manji od \\(B\\) ( ako takav ne postoji, onda je \\(i=N\\)). Tada postoji  \\(i\\) elemenata koji su manji od \\(B\\) i \\(N-i\\) elemenata koji su ve\u0107i od ili \\(B\\), pri \u010demu je \\(i \\geq N-i\\). Da bi obezbedili da \\(B\\) bude medijana potrebno je da grupa ve\u0107ih ili jednakih ima bar onoliko elementa koliko ima manjih, pa je potrebno ubaciti \\(i - (N - i) = 2i-N\\) glasova.</li> </ul> <p>Slo\u017eenost algoritma je odre\u0111ena slo\u017eeno\u0161\u0107u sortiranja (koja mo\u017ee biti \\(\\Theta(N\\log N)\\)) i slo\u017eeno\u0161\u0107u pronala\u017eenja poslednjeg elementa koji nije ve\u0107i od \\(B\\), odnosno prvog elementa koji nije manji od \\(B\\). Ako ovo realizujemo kao sekvencijalno pretra\u017eivanje, slo\u017eenost dela koji se odnosi na odre\u0111ivanje odgovora na pitanja \u0107e biti \\(\\Theta(QN)\\), pa \u0107e ukupna slo\u017eenost biti \\(\\Theta(N\\log N + NQ)\\). Ako pronala\u017eenje opisanog elementa realizujemo kori\u0161\u0107enjem binarne pretrage (koju svakako mo\u017eemo koristiti, ako smo niz sortirali), onda je slo\u017eenost odre\u0111ivanja odgovora na pitanja \\(\\Theta(Q\\log N)\\), pa je slo\u017eenost kompletnog algoritma \\(\\Theta((N+Q)\\log N)\\).</p> 02_namestanje_granice.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mxN=2e5;\nint a[mxN];\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n,q; cin &gt;&gt; n &gt;&gt; q;\n    for(int i=0; i&lt;n; i++) cin &gt;&gt; a[i];\n    sort(a,a+n);\n    for(int i=0; i&lt;q; i++)\n    {\n        int x; cin &gt;&gt; x;\n        int mn=lower_bound(a,a+n,x)-a;\n        int mx=upper_bound(a,a+n,x)-a;\n        int l=-1, r=1e6;\n        while(r-l&gt;1)\n        {\n            int m=(l+r)/2;\n            if((n+m)/2&gt;=mn&amp;&amp;(n+m)/2&lt;=mx-1+m) r=m;\n            else l=m;\n        }\n        cout &lt;&lt; r &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv1/03_sante/","title":"3 - Sante","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Mali Mika se nalazi na Severnom polu i stoji na jednoj od mnogobrojnih santi leda. On \u017eeli da do\u0111e do svog prijatelja Laze koji se nalazi na drugoj santi. Izme\u0111u nekih parova santi se nalazi voda koja je ili u potpunosti te\u010dna, ili puna malih komada leda (te\u0161ko je pro\u0107i kroz nju). Mika ima ma\u0161inu koja uni\u0161tava male komade leda (samo njih, ne i sante), i ona je na po\u010detku uga\u0161ena, a on mo\u017ee da je pali i gasi proizvoljan broj puta.</p> <p>Sve dok je ma\u0161ina upaljena, on mo\u017ee pre\u0107i put izme\u0111u dve sante koji ima komadi\u0107e leda (koji se nakon njegovog prolaska misteriozno vrate), a ne sme da prelazi put koji nema (jer bi se ma\u0161ina pokvarila), te je mora ugasiti za ovakav put (i ne treba da je pali dok ne do\u0111e ponovo do nekog puta sa ledom).</p> <p>Potrebno je na\u0107i na\u010din da Mika do\u0111e do Laze tako da najmanji broj puta menja stanje svoje ma\u0161ine (napomena: ma\u0161ina mo\u017ee biti u bilo kom stanju kada Mika do\u0111e do Lazine sante).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107 Marko Milenkovi\u0107 <p>Korisno je uo\u010diti da sante formiraju graf od \\(N\\) \u010dvorova i \\(M\\) grana, gde svaka grana ima te\u017einu 0 ili 1. Mogu\u0107e je bez promene stanja ma\u0161ine kretati se samo preko grana one te\u017eine koje je trenutno stanje (0 - ma\u0161ina ne radi, 1 - ma\u0161ina radi). Po\u010detno stanje je 0.</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji dati su broj santi \\(N\\), broj puteva izme\u0111u santi \\(M\\) (ako ne postoji put izme\u0111u neke dve sante smatramo da je previ\u0161e neprohodan i da Mika ne mo\u017ee direktno do\u0107i od jedne do druge).</p> <p>Zatim je dato \\(M\\) linija gde su \\(a\\), \\(b\\), i \\(t\\) razdvojeni razmakom, ovi brojevi zna\u010de da postoji put izme\u0111u \\(a\\)-te sante i \\(b\\)-te sante, dok broj \\(t\\) predstavlja tip puta - \\(1\\) ako je pun leda, a \\(0\\) ako nije.</p> <p>Na kraju se u\u010ditavaju dva broja \\(u,v\\) koja predstavljaju redni broj sante gde se nalaze Mika i Laza (redom).</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardnom izlazu ispisati jedan broj - najmanji mogu\u0107i broj promena stanja ma\u0161ine. Ukoliko ne postoji na\u010din da Mika do\u0111e do Laze, ispisati -1.</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv1/03_sante/#ulaz","title":"Ulaz","text":"<pre><code>4 4\n1 2 1\n1 3 1\n2 3 0\n3 4 0\n1 4\n</code></pre>"},{"location":"takprog/2022_2023/kv1/03_sante/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2022_2023/kv1/03_sante/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv1/03_sante/#ulaz_1","title":"Ulaz","text":"<pre><code>7 6\n1 2 0\n1 3 1\n2 4 1\n3 5 0\n5 6 1\n6 7 0\n1 7\n</code></pre>"},{"location":"takprog/2022_2023/kv1/03_sante/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2022_2023/kv1/03_sante/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom test primeru mo\u017eemo oti\u0107i u santu \\(2\\) ili \\(3\\) (\u0161to svakako zahteva paljenje ma\u0161ine), a kasnije ili iz \\(2\\) u \\(3\\) i dalje u \\(4\\) (\u0161to zahteva \\(1\\) ga\u0161enje), ili iz \\(3\\) u \\(4\\) (\u0161to tako\u0111e zahteva ga\u0161enje), i da tako promenimo stanje dva puta.</p> <p>Jedino smer pose\u0107ivanja \\(1-3-5-6-7\\) nas dovodi do sante broj \\(7\\).</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N,M \\leq 200000\\).</li> <li>\\(1 \\leq a,b,u,v \\leq N\\).</li> <li>\\(t = 0 \\lor t = 1\\).</li> </ul> <p>Test primeri su podeljeni u slede\u0107ih pet grupa:</p> <ul> <li>U testovima vrednim \\(10\\) poena - \\(M=N-1\\), iz svake sante ide najvi\u0161e \\(2\\) puta.</li> <li>U testovima vrednim \\(10\\) poena - svi putevi su te\u0161ko prohodni.</li> <li>U testovima vrednim \\(25\\) poena - \\(M=N-1\\) i od svake sante se mo\u017ee do\u0107i do svake druge (kori\u0161\u0107enjem jednog ili vi\u0161e puteva izme\u0111u dve sante).</li> <li>U testovima vrednim \\(30\\) poena - \\(N,M \\leq 5000\\).</li> <li>U testovima vrednim \\(25\\) poena - nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv1/03_sante/#resenje-kada-m-n-1-i-iz-svake-sante-ide-jedna-ili-dve-grane","title":"Re\u0161enje kada \\(M = N-1\\) i iz svake sante ide jedna ili dve grane","text":"<p>Ovako zadate sante formiraju niz gde je svaka povezana sa prethodnom i slede\u0107om (osim prve i poslednje). Mo\u017eemo do\u0107i od jedne do druge sante na jedinstven na\u010din (poku\u0161amo da idemo levo od Mike dok ne stignemo do kraja, ili do Laze, i isto tako na desno), i simulirati promene stanja.</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#resenje-kad-je-put-izmeu-svake-dve-sante-tesko-prohodan","title":"Re\u0161enje kad je put izme\u0111u svake dve sante te\u0161ko prohodan","text":"<p>Ovde je jedini mogu\u0107i odgovor 1 ili -1, zavisno od toga da li je mogu\u0107e do\u0107i od Mikine do Lazine sante. Ovo mo\u017eemo proveriti nekim algortimom poput \\(DFS\\)-a (rekurzivni obilazak svake sante sa pam\u0107enjem pose\u0107enih).</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#resenje-kad-je-m-n-1-i-uvek-se-moze-doci-od-jedne-do-druge-sante","title":"Re\u0161enje kad je \\(M = N-1\\) i uvek se mo\u017ee do\u0107i od jedne do druge sante","text":"<p>Graf koji sante opisuju u ovoj grupi primera je stablo. Kao u prvom podzadatku, jedinstven je na\u010din da se do\u0111e od jedne sante do druge (osobina stabla), samo je ovaj put potrebno koristiti neki algoritam za nala\u017eenje puta (ovde je put skup grana, a ne termin iz teksta) izme\u0111u dva \u010dvora (kao \\(BFS\\)), i simulirati promene stanja ma\u0161ine na njemu.</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#resenje-za-pun-broj-poena","title":"Re\u0161enje za pun broj poena","text":"<p>Primetimo da ukoliko je stanje ma\u0161ine \\(s\\), a nalazimo se u \u010dvoru \\(u\\), mogu\u0107e je slobodno (bez pove\u0107anja kona\u010dnog odgovora) se kretati po svim \u010dvorovima do kojih se granama te\u017eine \\(s\\) mo\u017ee do\u0107i iz \\(u\\). Dakle, konstrukcija na\u0161eg re\u0161enja mo\u017ee izgledati tako \u0161to prvo obi\u0111emo sve \u010dvorove do kojih se mo\u017ee do\u0107i iz po\u010detnog koriste\u0107i grane te\u017eine 0, zatim promeniti te\u017einu i na\u0107i sve dosti\u017ene preko grana te\u017eine jedan od prethodno dostignutih itd. (naravno ne obilaze\u0107i ve\u0107 pose\u0107ene \u010dvorove). Elegantnu implementaciju ove ideje nam pru\u017ea takozvani \\(0-1\\) \\(BFS\\). U redu sa dva kraja (double ended queue) pamtimo \u010dvor kao i stanje u kom se nalazimo kad ga pose\u0107ujemo (na po\u010detku dodamo Mikinu santu i 0), i na po\u010detak reda dodajemo one \u010dvorove koji su povezani granama te\u017eine koja odgovara stanju \u010dvora,  dok se na kraj dodaju \u010dvorovi povezani granama suprotne te\u017eine (i u oba slu\u010daja a\u017euriramo cenu dolaska do nekog \u010dvora). Ovako smo se osigurali da prvo prolazimo kroz sve dostupne iz prvog \u010dvora bez promene stanja, a da dalje ne menjamo stanje dok nismo obi\u0161li sve koji se dosti\u017eu jednom promenom stanja, itd. Na kraju jednostavno proverimo da li je obi\u0111en Lazin \u010dvor, i koja je cena njegovog obilaska. Vremenska i memorijska slo\u017eenost su \\(O(N+M)\\).</p>"},{"location":"takprog/2022_2023/kv1/03_sante/#resenje-2-za-pun-broj-poena","title":"Re\u0161enje 2 (za pun broj poena)","text":"<p>Kako je mogu\u0107e slobodno se kretati od nekog \u010dvora po odre\u0111enoj grupi \u010dvorova, mo\u017eemo grupisati \u010dvorove u 0-komponente i 1-komponente (zavisno od toga kakvim se granama kre\u0107emo) \\(DFS\\)-om, a zatim formirati novi graf u kom povezujemo dve komponente ukoliko ne postoji \u010dvor preko kog je mogu\u0107e pre\u0107i iz jedne u drugu (u ovom \u010dvoru menjamo stanje ma\u0161ine). Kasnije nalazimo najkra\u0107i put izme\u0111u odgovaraju\u0107ih komponenti u ovom grafu \\(BFS\\)-om (s tim \u0161to je po\u010detna udaljenost 1 ukoliko kre\u0107emo od 1-komponente). Svaka komponenta je ili 1 ili 0 komponenta i ima najmanje jedan \u010dvor, te  njih ima reda veli\u010dine \\(N\\), dok grana izme\u0111u njih ima najvi\u0161e \\(N\\) (jer jedan \u010dvor predstavlja granu izme\u0111u komponenti) - dakle red veli\u010dine slo\u017eenosti je ponovo linearan.</p> <p>Napomena: sporija implementacija ideje za 100 poena (npr Dajkstrin algoritam u kvadratnoj slo\u017eenosti umesto 0-1 BFS) \u0107e raditi za vrednosti N i M do 5000</p> 03_sante.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint n, m;\nvector&lt;vector&lt;pair&lt;int, bool&gt;&gt;&gt; gr;\n\nint main(){\n    cin &gt;&gt; n &gt;&gt; m;\n    gr.clear();\n    gr.resize(n);\n    for(int i = 0; i &lt; m; ++i){\n        int x, y, t;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;\n        --x;\n        --y;\n        gr[x].push_back({y,t});\n        gr[y].push_back({x,t});\n    }\n    int u, v;\n    cin &gt;&gt; u &gt;&gt; v;\n    --u,--v;\n    deque&lt;pair&lt;int, int&gt; &gt; dq;\n    dq.push_back({u,0});\n    vector&lt;int&gt; was(n,-1);\n\n    was[u] = 0;\n    vector&lt;int&gt; par(n);\n    while(!dq.empty()){\n        auto x = dq.front();\n        dq.pop_front();\n        int x1 = x.first;\n        for(auto i : gr[x1]){\n            if(i.second == x.second and (was[i.first]==-1 or was[i.first] &gt; was[x1])){\n                dq.push_front({i.first, x.second});\n                was[i.first] = was[x1];\n                par[i.first] = x1;\n            } else if(i.second != x.second and (was[i.first]==-1 or was[i.first] &gt; (was[x1]+1))){\n                dq.push_back({i.first, i.second});\n                was[i.first] = was[x1]+1;\n                par[i.first] = x1;\n            }\n        }\n    }\n    cout &lt;&lt; was[v] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv1/04_vage/","title":"4 - Vage","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Miladin prosto ne mo\u017ee da veruje koliko se ugojio. Nije verovao svojoj vagi, pa je kupio novu. Ali onda nije verovao ni novoj vagi, pa je kupio jo\u0161 jednu. Ovaj proces se nastavio dok kona\u010dno nije imao \\(N\\) vaga u svom posedu. Tada je odlu\u010dio da mora na objektivan na\u010din proveriti da li su u pravu njegove vage ili on.</p> <p>Pore\u0111ao je sve svoje vage u jedan niz, tako da za vagu koja je \\(i\\)-ta sleva ka\u017eemo da ima indeks \\(i\\). Nakon toga, za svaku vagu saznao je koje te\u017eine ona mo\u017ee da izmeri. Preciznije, za svako \\(i\\), saznao je da vaga sa indeksom \\(i\\) mo\u017ee da izmeri te\u017eine izme\u0111u \\(d_i\\) i \\(u_i\\), uklju\u010duju\u0107i i njih (za ostale te\u017eine izbacuje gre\u0161ku).</p> <p>Za svoje dalje prora\u010dune, potrebni su mu odgovori na \\(M\\) pitanja oblika: </p> <ul> <li>Za dato \\(l\\), \\(r\\) i \\(x\\), koliko vaga sa indeksima od \\(l\\) do \\(r\\) (ra\u010dunaju\u0107i i ta dva) mo\u017ee da izmeri te\u017einu \\(x\\)?</li> </ul> <p>Pomozite Miladinu sa ovim prora\u010dunima kako bi se \u0161to pre prebacio na salate. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/kv1/04_vage/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalaze se dva cela broja \\(N\\) i \\(M\\) - broj vagi koje je prikupio i broj pitanja na koje mu je potreban odgovor. </p> <p>Linija \\(i\\) od narednih \\(N\\) linija sadr\u017ei \\(2\\) cela broja \\(d_i\\) i \\(u_i\\) - donju i gornju te\u017einsku granicu koju mo\u017ee da izmeri vaga sa indeksom \\(i\\). </p> <p>Narednih \\(M\\) linija sadr\u017ee po tri cela broja \\(l_i\\), \\(r_i\\) i \\(x_i\\), tim redom - opise pitanja. </p>"},{"location":"takprog/2022_2023/kv1/04_vage/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati odgovore na pitanja istim redom kao \u0161to su data, svaki u svom redu.</p>"},{"location":"takprog/2022_2023/kv1/04_vage/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv1/04_vage/#ulaz","title":"Ulaz","text":"<pre><code>3 4\n21 34\n100 100\n56 78\n2 3 25\n1 2 100\n1 3 50\n2 3 70\n</code></pre>"},{"location":"takprog/2022_2023/kv1/04_vage/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n0\n1\n</code></pre>"},{"location":"takprog/2022_2023/kv1/04_vage/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv1/04_vage/#ulaz_1","title":"Ulaz","text":"<pre><code>8 5\n1 2\n4 7\n7 12\n1 8\n7 7\n4 6\n6 9\n9 10\n2 6 6\n4 6 7\n5 8 12\n1 8 10\n2 7 7\n</code></pre>"},{"location":"takprog/2022_2023/kv1/04_vage/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n2\n0\n2\n5\n</code></pre>"},{"location":"takprog/2022_2023/kv1/04_vage/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi primer:</p> <ul> <li>Prvo pitanje: Nijedna vaga sa indeksom od \\(1\\) do \\(2\\) ne mo\u017ee da izmeri te\u017einu \\(25\\).</li> <li>Drugo pitanje: Vaga \\(2\\) mo\u017ee da izmeri te\u017einu \\(100\\).</li> <li>Tre\u0107e pitanje: Nijedna vaga sa indeksom od \\(1\\) do \\(3\\) ne mo\u017ee da izmeri te\u017einu \\(50\\).</li> <li>\u010cetvrto pitanje: Vaga \\(3\\) mo\u017ee da izmeri te\u017einu \\(70\\).</li> </ul> <p>Drugi primer:</p> <ul> <li>Prvo pitanje: izme\u0111u indeksa \\(2\\) i \\(6\\) vage sa indeksima \\(2\\), \\(4\\) i \\(6\\) mogu da izmere te\u017einu \\(6\\).</li> <li>Drugo pitanje: izme\u0111u indeksa \\(4\\) i \\(6\\) vage sa indeksima \\(4\\) i \\(5\\) mogu da izmere te\u017einu \\(7\\).</li> <li>Tre\u0107e pitanje: izme\u0111u indeksa \\(5\\) i \\(8\\) nijedna vaga ne mo\u017ee da izmeri te\u017einu \\(12\\).</li> <li>\u010cetvrto pitanje: izme\u0111u indeksa \\(1\\) i \\(8\\) vage sa indeksima \\(3\\) i \\(8\\) mogu da izmere te\u017einu \\(10\\).</li> <li>Peto pitanje: izme\u0111u indeksa \\(2\\) i \\(7\\) vage sa indeksima \\(2\\), \\(3\\), \\(4\\), \\(5\\) i \\(7\\) mogu da izmere te\u017einu \\(7\\).</li> </ul>"},{"location":"takprog/2022_2023/kv1/04_vage/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 2 \\cdot 10^5\\).</li> <li>\\(0 \\leq d_i \\leq u_i \\leq 10^9\\), za \\(1 \\leq i \\leq N\\).</li> <li>\\(1 \\leq l_i \\leq r_i \\leq N\\), za \\(1 \\leq i \\leq M\\).</li> <li>\\(0 \\leq x_i \\leq 10^9\\), za \\(1 \\leq i \\leq M\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N, M \\leq 1000\\).</li> <li>U testovima vrednim 15 poena: \\(d_i = u_i\\), za \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 20 poena: Ne postoji \\(x\\) koje mogu da izmere dve razli\u010dite vage.</li> <li>U testovima vrednim 20 poena: \\(u_i \\leq 20\\),  za \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv1/04_vage/#resenje-kada-n-m-leq-1000","title":"Re\u0161enje kada \\(N, M \\leq 1000\\)","text":"<p>Za svako pitanje mo\u017eemo jednostavno pro\u0107i kroz sve bitne vage i proveriti da li mogu izmeriti trenutno \\(x_i\\). </p> <p>Vremenska slo\u017eenost je \\(O(NM)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv1/04_vage/#resenje-kada-d_iu_i","title":"Re\u0161enje kada \\(d_i=u_i\\)","text":"<p>U ovom slu\u010daju potrebno je odrediti, za svako pitanje, koliko vaga kojima je \\(d_i\\) jednako \\(x_i\\) ima indeks od \\(l_i\\) do \\(r_i\\). Po\u0161to nam nisu bitne konkretne vrednosti \\(d_i\\), \\(u_i\\) i \\(x_i\\), ve\u0107 samo da li su jednaki, ove vrednosti mo\u017eemo kompresovati, na primer koriste\u0107i std::map, tako da sve budu najvi\u0161e \\(N\\). Kada to uradimo, mo\u017eemo za svaki razli\u010dit element u nizu \\(d_i\\) da napravimo novi niz, koji sadr\u017ei, sortirano rastu\u0107e, sve indekse vaga kojima odgovara ta vrednost \\(d_i\\). </p> <p>Sada, kad je potrebno da odgovorimo na pitanje, mo\u017eemo koriste\u0107i binarnu pretragu da na\u0111emo koliko elemenata u nizu indeksa koji odgovara vrednosti \\(x_i\\) se nalazi na intervalu \\([l_i, r_i]\\).</p> <p>Vremenska slo\u017eenost je \\(O((N+M)logN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv1/04_vage/#resenje-kada-ne-postoji-x-koje-mogu-da-izmere-dve-razlicite-vage","title":"Re\u0161enje kada ne postoji \\(x\\) koje mogu da izmere dve razli\u010dite vage","text":"<p>Ovaj uslov se druga\u010dije mo\u017ee napisati da su intervali \\([d_i, u_i]\\) disjunktni. Sortirajmo intervale po levoj granici, tako\u0111e \u010duvaju\u0107i indeks svakog intervala. Nakon toga re\u0161avamo pitanja jedno po jedno, tako \u0161to binarnom pretragom tra\u017eimo poslednji interval kome je leva granica manja od trenutnog \\(x_i\\).  </p> <p>Ukoliko se \\(x_i\\) ne nalazi u tom intervalu ili se indeks tog intervala ne nalazi u intervalu \\([l_i, r_i]\\), rezultat za trenutno pitanje je \\(0\\). U suprotnom, rezultat je \\(1\\).</p> <p>Vremenska slo\u017eenost je \\(O((N+M)logN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv1/04_vage/#resenje-kada-u_i-leq-20","title":"Re\u0161enje kada \\(u_i \\leq 20\\)","text":"<p>Ovaj slu\u010daj se re\u0161ava sli\u010dno slu\u010daju kada va\u017ei \\(d_i = u_i\\), s tim \u0161to, umesto da ubacimo svaki indeks u niz indeksa samo za vrednost \\(d_i\\), mi \u0107emo ga ubaciti u niz indeksa za svaku vrednost u intervalu \\([d_i, u_i]\\). Nakon toga, odgovor na pitanje nalazimo na isti na\u010din kao ranije. Potrebno je posebno paziti za slu\u010daj kada \\(x_i &gt; 20\\). </p> <p>Vremenska slo\u017eenost je \\(O(N\\cdot max(u_i) + MlogN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv1/04_vage/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Kako bismo re\u0161ili zadatak za sve bodove, potrebno je da na pitanja odgovaramo offline, odnosno u druga\u010dijem redosledu nego \u0161to su data, pa \u0107emo ih na kraju ispisati u ta\u010dnom redosledu. Na pitanja \u0107emo odgovarati u redosledu rastu\u0107e po \\(x_i\\) (ukoliko vi\u0161e pitanja ima isto \\(x_i\\), nije bitno na koje odgovaramo prvo). </p> <p>Znamo da nam je vaga \\(j\\) bitna samo ako va\u017ei \\(d_j \\leq x_i \\leq u_j\\). Dakle, kako idemo kroz pitanja rastu\u0107e po \\(x_i\\), postoje dve vrste doga\u0111aja: </p> <ul> <li>Vaga \\(j\\) postaje bitna prvi put kada postavljamo pitanje za koje va\u017ei \\(x_i \\geq d_j\\);</li> <li>Vaga \\(j\\) prestaje da bude bitna pri put kada postavljamo pitanje za koje va\u017ei \\(x_i \\geq u_j+1\\).</li> </ul> <p>Ubacimo svih \\(2N\\) doga\u0111aja u jedan niz i sortirajmo ga rastu\u0107e po njihovim granicama za \\(x_i\\). Sada mo\u017eemo zajedno prolaziti kroz niz pitanja i niz doga\u0111aja metodom dva pokaziva\u010da i odr\u017eavati niz nula i jedinica du\u017eine \\(N\\) koji na \\(i\\)-toj poziciji sadr\u017ei \\(1\\) ako i samo ako je vaga sa indeksom \\(i\\) trenutno bitna. Naravno, ovaj niz \u0107emo menjati svaki put kada na red do\u0111e neki novi doga\u0111aj.</p> <p>Kako bismo efikasno odgovorili na pitanje, potrebno je da efikasno na\u0111emo zbir na intervalu \\([l_i, r_i]\\) ovog niza, u trenutku kada smo obradili sve doga\u0111aje koji dolaze pre ovog pitanja. Za ovo mo\u017eemo koristiti segmentno ili Fenvikovo stablo kako bismo ostvarili dobru slo\u017eenost.</p> <p>Vremenska slo\u017eenost je \\(O((N+M)logN)\\), a memorijska \\(O(N)\\).</p> 04_vage.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n#define MAXN 200010\nusing namespace std;\nint N, M, l[MAXN], r[MAXN], rez[MAXN];\nvector&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; delta; // {granica, {tip, indeks}}\nvector&lt;pair&lt;int, int&gt; &gt; q; // {x, indeks}\nint bit[MAXN];\nvoid update(int idx, int val) {\n  while(idx &lt; MAXN) {\n    bit[idx] += val;\n    idx += idx&amp;-idx;\n  }\n}\nint query(int idx) {\n  int rez = 0;\n  while(idx &gt; 0) {\n    rez += bit[idx];\n    idx -= idx&amp;-idx;\n  }\n  return rez;\n}\nint main() {\n  //ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  scanf(\"%d%d\", &amp;N, &amp;M); //cin &gt;&gt; N &gt;&gt; M;\n  for(int i = 1; i &lt;= N; i++) {\n    int d, u; scanf(\"%d%d\", &amp;d, &amp;u); //cin &gt;&gt; d &gt;&gt; u;\n    delta.push_back({d, {+1, i}});\n    delta.push_back({u+1, {-1, i}});\n  }\n  for(int i = 1; i &lt;= M; i++) {\n    int x; scanf(\"%d%d%d\", &amp;l[i], &amp;r[i], &amp;x); //cin &gt;&gt; l[i] &gt;&gt; r[i] &gt;&gt; x;\n    q.push_back({x, i});\n  }\n  sort(delta.begin(), delta.end());\n  sort(q.begin(), q.end());\n  int idx = 0;\n  for(int i = 0; i &lt; M; i++) {\n    while(idx &lt; delta.size() &amp;&amp; delta[idx].first &lt;= q[i].first) {\n      update(delta[idx].second.second, delta[idx].second.first);\n      idx++;\n    }\n    rez[q[i].second] = query(r[q[i].second]) - query(l[q[i].second]-1);\n  }\n  for(int i = 1; i &lt;= M; i++) {\n    printf(\"%d\\n\", rez[i]);\n    //cout &lt;&lt; rez[i] &lt;&lt; endl;\n  }\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/","title":"5 - Zlatnici 3","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 800ms 256MB <p>Savez \u010carobnja\u010dkih Bankara (S\u010cB) ima mre\u017eu banaka povezanih portalima, ta\u010dnije minimalnim brojem portala potrebnih da se od svake banke mo\u017ee do\u0107i u svaku drugu banku (portali su skupi za odr\u017eavanje, pa graf banaka predstavlja stablo), u kojima \u010duvaju zlatnike. Pomo\u0107u ovih portala mogu slati zlatnike iz jedne banke do druge, portalom koji ih povezuje, ali za jedno prebacivanje jednog zlatnika kroz jedan portal, potreban im je jedan kristal timpestina, retkog minerala, koji se koristi kao gorivo za ovaj proces. Savez \u017eeli u svakom trenutku da bude spreman za nepredvi\u0111ene okolnosti, i to na slede\u0107i na\u010din: plan je da se u slu\u010daju uzbune svi zlatnici prebace u jednu banku, kako bi se svi \u010darobnjaci ujedinili u njihovoj za\u0161titi. Pri tome \u017eelimo da ovo uradimo tako da potro\u0161imo najmanje kristala timpestina, sa obzirom da je on jako dragocen. Kako su ovi bankari \u010darobnjaci, a ne programeri, i kako ljudi stalno dolaze i stavljaju novac u banku, oni ne umeju dovoljno brzo da izra\u010dunaju u koju banku bi trebalo prebaciti sve zlatnike u slu\u010daju uzbune. Pomozite im i odredite u koju banku je najbolje prebaciti sve resurse u bilo kom trenutku!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Marko \u0160i\u0161ovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza nalazi broj \\(N\\),  broj banaka.  U narednih \\(N-1\\) redova se nalaze po dva cela broja \\(x_i\\) i \\(y_i\\), u opsegu od \\(1\\) do \\(N\\), koji predstavljaju povezanost banke \\(x_i\\) i \\(y_i\\) portalom. U slede\u0107em redu nalazi se \\(N\\) brojeva, po\u010detni broj zlatnika u svakoj banci. U narednom redu se nalazi \\(Q\\), broj upita. U slede\u0107ih \\(Q\\) redova nalaze se po dva broja \\(z_i\\) i \\(b_i\\), koji predstavljaju dolazak osobe koja stavlja \\(z_i\\) zlatnika u banku \\(b_i\\).</p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(Q+1\\) brojeva. Prvi broj je optimalna banka u koju treba prebaciti  sve zlatnike ako do\u0111e do uzbune pre dolaska prvog \u010doveka koji prila\u017ee novac, dok su narednih \\(Q\\) brojeva indeksi optimalnih banaka nakon dolazaka svakog od zalaga\u010da redom, to jest nakon svakog od upita. Ako ima vi\u0161e optimalnih banaka, ispisati onu sa najmanjim indeksom.</p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#ulaz","title":"Ulaz","text":"<pre><code>5\n1 2\n2 3\n3 4\n4 5\n1 1 1 1 1\n2\n8 5\n6 2\n</code></pre>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#izlaz","title":"Izlaz","text":"<pre><code>3\n5\n4\n</code></pre>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 2\n1 3\n1 4\n1 1 1 100\n0\n</code></pre>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi primer:</p> <ul> <li>Pre dolaska prvog \u010doveka banka \\(3\\) je optimalna i trebalo bi nam \\(6\\) kristala da sve zlatnike prebacimo u nju.</li> <li>Nakon dolaska prvog \u010doveka banka \\(5\\) postaje optimalna, i trebalo bi nam \\(10\\) kristala da sve zlatnike prebacimo u nju.</li> <li>Nakon dolaska drugog \u010doveka banka \\(4\\) postaje optimalna, i treba nam \\(15\\) kristala ako \u017eelimo da prebacimo sve zlatnike u nju.</li> </ul> <p>Drugi primer:</p> <ul> <li>Po\u0161to u poslednjoj banci ima ubedljivo najvi\u0161e zlatnika, jasno je da je neisplativo da ih preme\u0161tamo iz nje.</li> </ul>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq200.000\\), po\u010detni broj zlatnika u svakoj banci je bar 1.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N \\leq 1000, Q=0\\).</li> <li>U testovima vrednim 15 poena: \\(Q=0\\).</li> <li>U testovima vrednim 20 poena: Svaka banka je povezana sa najvi\u0161e dve druge banke.</li> <li>U testovima vrednim 20 poena: Graf banaka predstavlja kompletno binarno stablo.</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#resenje-u-oqn2","title":"Re\u0161enje u \\(O(QN^2)\\)","text":"<p>Poku\u0161ajmo da prona\u0111emo za svaki \u010dvor \\(u\\) koliko treba poteza da bismo sve zlatnike preneli u njega. Ovo je suma \\(\\sum_{i=1}^nd(u,i)\\cdot w_i\\), gde \\(w_i\\) broj zlatnika u \\(i\\), a \\(d(u,v)\\) du\u017eina puta izme\u0111u \u010dvorova \\(u\\) i \\(v\\). Ovo se lako mo\u017ee izra\u010dunati pu\u0161tanjem DFS iz svakog \u010dvora.</p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#resenje-u-oqn","title":"Re\u0161enje u \\(O(QN)\\)","text":"<p>Potrebno je da malo dublje analiziramo koji \u010dvor \u0107e biti odgovor. Neka sa \\(V_v\\) ozna\u010davamo broj poteza koji je potreban da bi svi zlatnici stigli u \u010dvor \\(v\\). Potrebno je na\u0107i \u010dvor tako da je \\(V_u=\\sum_{i=1}^nd(u,i)\\cdot w_i\\) minimalno. Posmatrajmo vrednost \\(V_u-V_v\\) za neku granu \\(uv\\). Iz gorenavedene formule vidimo da je ovo zapravo jednako razlici suma te\u017eina u dva stabla koja dobijemo kada ise\u010demo granu \\(uv\\) (uverite se!). Kada smo u optimalnom \u010dvoru, ova vrednost treba da bude negativna za sve grane, \u0161to je ekvivalentno sa tim da kad ise\u010demo taj \u010dvor, u svakom od dobijenih stabala je najvi\u0161e pola od ukupne te\u017eine (ovakav \u010dvor se zove centroidom stabla). Sada lako se vidi da je ovakav \u010dvor jedinstven, ili ih je dva koja su spojena granom sa razlikom renjenja od \\(0\\) (a u tom slulaju su oba validno re\u0161enje). Stoga, sveli smo zadatak na tra\u017eenje \u0161ta je centroid u ovom stablu, \u0161to mo\u017ee da se uradi DFS i \u010duvaju se veli\u010dine svih podstabala, a zatim se uradi jednostavna provera.</p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#resenje-kada-je-stablo-put","title":"Re\u0161enje kada je stablo put","text":"<p>U ovom slu\u010daju je re\u0161enje ternarno pretra\u017eivo po putu, i sve dist funkcije se mogu izra\u010dunati lako. Mogu\u0107e je uraditi tad u zadatak \\(O(N\\log N + Q\\log^2 N)\\), za jednu ta\u010dku pretrage u ternarnoj nam treba samo sume po prefiksima i sufiksima, a promeni tih mo\u017eemo da pratimo u segmentnom stablu. </p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#resenje-kada-je-stablo-kompletno-binarno","title":"Re\u0161enje kada je stablo kompletno binarno","text":"<p>Nastavljamo na re\u0161enje iz drugog podzadatka. Ono \u0161to treba primetiti je da je vrednost \\(V_v-V_u\\) mogu\u0107e izra\u010dunati brzo za neku granu. Zaista ako smestimo \u010dvorove u niz po ulaznom ili izlaznom poretku DFS, i imamo segmentno stablo nad tim nizom, po\u0161to \u0107e svi \u010dvorovi u nekom stablu formirati interval. Nama je potrebna samo te\u017eina u dva stabla koja dobihemo kad ise\u010demo ovu granu, a jedno od tih stabala \u0107e morati da bude podtablo ukorenjenog stabla. Te\u017einu u drugom mo\u017eemo izra\u010dunati kao ukupna te\u017eina minus to \u0161to smo izra\u010dunali. Stoga, promenu rezultata prolaskom iz jednog \u010dvora u drugi, (to jest da li je bolje ako pre\u0111emo) mo\u017eemo izra\u010dunati u \\(O(\\log N)\\).</p> <p>Sada kad dodamo novi \u010dvor, novo re\u0161enje \u0107e se nalaziti na putu od trenutnog re\u0161enja do tog novog na koji smo dodali zlatnike. Stoga, na tom putu \u0107e promene rezultata biti pozitivne, pa negativne. Da bismo re\u0161ili zadatak potrebno je samo iterirati kroz put i na\u0107i sve grane kroz koje kad pro\u0111emo pobolj\u0161avamo rezultat. Po\u0161to su na ovom stablu svi putevi kratki, nalazimo re\u0161enje u \\(O(N\\log N + Q\\log^2 N)\\).</p>"},{"location":"takprog/2022_2023/kv1/05_zlatnici3/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Kona\u010dno re\u0161enje je mala nadogradnja prethodnog. Naime, umesto da idemo redom po putu izme\u0111u starog i novog \u010dvora, uraidmo binarnu pretragu na tom putu da bismo prona\u0161li poslednju granu koja nam daje pozitivan skor na rezultat. Po svemu opisanom u prethodnom podzadatku, ovo \u0107e zaista biti binarno pretra\u017eivo i stoga \u0107e ovo re\u0161enje raditi u \\(O(N\\log N + Q\\log^2 N)\\).</p> 05_zlatnici3.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MAXN 200005\n#define MAXQ 200005\n#define MAXLOGN 20\n\nint n,q;\nvector&lt;int&gt; graph[MAXN];\nbool visited[MAXN];\nint dfsInd1[MAXN], dfsInd2[MAXN], parent[MAXN];\nlong long totalSum;\n\nlong long bitArr[MAXN];\nlong long nodeCoins[MAXN];\n\nlong long bitGetSum(int idx){\n    long long sum=0;\n    for(int i=idx;i&gt;0;i-=(i&amp;-i)){\n        sum+=bitArr[i];\n    }\n    return sum;\n}\n\nvoid bitUpdate(int idx, int val){\n    for(int i=idx;i&lt;=MAXN;i+=(i&amp;-i)){\n        bitArr[i]+=val;\n    }\n}\n\nlong long getSubtrSum(int node){\n    return bitGetSum(dfsInd2[node]-1) - bitGetSum(dfsInd1[node]-1);\n}\nvoid updateNode(int node, int val){\n    bitUpdate(dfsInd1[node], val);\n    nodeCoins[node]+=val;\n    totalSum+=val;\n}\n\nint lg[2*MAXN];\npair&lt;int,int&gt; sparseTable[MAXLOGN][2*MAXN];\nint first[MAXN];\nvector&lt;int&gt; euler;\nvector&lt;pair&lt;int,int&gt;&gt; heights;\nint height[MAXN];\nint par[MAXLOGN][MAXN];\n\nint findLCA(int a, int b){\n    int l=first[a], r=first[b];\n    if(r&lt;l){\n        swap(l,r);\n    }\n    int i = lg[r - l + 1];\n    pair&lt;int,int&gt; minimum = min(sparseTable[i][l], sparseTable[i][r - (1 &lt;&lt; i) + 1]);\n    return euler[minimum.first];\n}\n\nint dfsCnt;\nvoid dfs(int cur, int hg, int parent){\n    par[0][cur] = parent;\n    height[cur]=hg;\n    euler.push_back(cur);\n    heights.push_back({hg, euler.size()-1});\n    first[cur]=euler.size()-1;\n    dfsInd1[cur]=dfsCnt++;\n    visited[cur]=true;\n    for(auto i:graph[cur]){\n        if(!visited[i]){\n            dfs(i, hg+1, cur);\n            euler.push_back(cur);\n            heights.push_back({hg, euler.size()-1});\n        }\n    }\n    dfsInd2[cur]=dfsCnt;\n}\n\nint findCentroid(int cur, int last){\n    long long curSum = getSubtrSum(cur);\n    long long curVal = nodeCoins[cur];\n    int maxNode=-1;\n    long long maxVal = 0;\n    for(auto i:graph[cur]){\n        if(i==last){\n            continue;\n        }\n        long long potentialVal = getSubtrSum(i);\n        if(maxNode==-1 || maxVal&lt;potentialVal){\n            maxVal = potentialVal;\n            maxNode = i;\n        }\n    }\n    if(maxVal&lt;=totalSum/2){\n        if(totalSum%2==0 &amp;&amp; maxVal==totalSum/2){\n            return min(cur, maxNode);\n        }\n        return cur;\n    }\n    return findCentroid(maxNode, cur);\n}\n\nint bsNode;\n\nbool bsCondition(int curCentroid, int changedNode, int lca, int leftPathLen, int rightPathLen, int m){\n    if(m==0){\n        return true;\n    }\n    long long vertexVal, potNode;\n    if(m&lt;=leftPathLen){\n        m--;\n        potNode = curCentroid;\n        while(m&gt;0){\n            potNode = par[lg[m]][potNode];\n            m-=(1&lt;&lt;lg[m]);\n        }\n        vertexVal = totalSum - 2*getSubtrSum(potNode);\n        if(vertexVal==0 &amp;&amp; par[0][potNode]&lt;potNode){\n            vertexVal++;\n        }\n        potNode = par[0][potNode];\n    }\n    else{\n        m -= leftPathLen;\n        m = rightPathLen - m;\n        potNode = changedNode;\n        while(m&gt;0){\n            potNode = par[lg[m]][potNode];\n            m-=(1&lt;&lt;lg[m]);\n        }\n        vertexVal = 2*getSubtrSum(potNode)-totalSum;\n        if(vertexVal==0 &amp;&amp; par[0][potNode]&gt;potNode){\n            vertexVal++;\n        }\n    }\n    if(vertexVal&gt;0){\n        bsNode = potNode;\n    }\n    return (vertexVal&gt;0);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n-1;i++){\n        int in1,in2;\n        cin&gt;&gt;in1&gt;&gt;in2;\n        graph[in1].push_back(in2);\n        graph[in2].push_back(in1);\n    }\n\n    dfsCnt=1;\n    dfs(1,0,1);\n\n    for (int i = 2; i &lt; 2*MAXN; i++){\n        lg[i] = lg[i/2] + 1;\n    }\n    for (int j = 0; j &lt; heights.size(); j++){\n        sparseTable[0][j]=heights[j];\n    }\n    for (int i = 1; i &lt; MAXLOGN; i++){\n        for (int j = 0; j + (1 &lt;&lt; i) &lt; heights.size(); j++){\n            sparseTable[i][j] = min(sparseTable[i - 1][j], sparseTable[i - 1][j + (1 &lt;&lt; (i - 1))]);\n        }\n    }\n    for(int i=1;i&lt;MAXLOGN;i++){\n        for(int j=1;j&lt;=n;j++){\n            par[i][j]=par[i-1][par[i-1][j]];\n        }\n    }\n\n    for(int i=1;i&lt;=n;i++){\n        int in;\n        cin&gt;&gt;in;\n        updateNode(i,in);\n    }\n\n    totalSum = getSubtrSum(1);\n    int curCentroid = findCentroid(1,0);\n    cout&lt;&lt;findCentroid(1,0)&lt;&lt;\"\\n\";\n\n    cin&gt;&gt;q;\n    for(int i=0;i&lt;q;i++){\n        int in1, in2;\n        cin&gt;&gt;in2&gt;&gt;in1;\n        updateNode(in1,in2);\n        int changedNode = in1;\n        int lca = findLCA(curCentroid, changedNode);\n        int pathLen = height[curCentroid] + height[changedNode] - 2*height[lca];\n        int leftPathLen = height[curCentroid] - height[lca];\n        int rightPathLen = height[changedNode] - height[lca];\n        bsNode = curCentroid;\n        int l=-1, r = pathLen+1;\n        while(r - l &gt; 1){\n             int m = (l + r) / 2;\n             if(bsCondition(curCentroid, changedNode, lca, leftPathLen, rightPathLen, m)){\n                l = m;\n             }\n             else{\n                r = m;\n             }\n        }\n        curCentroid = bsNode;\n        cout&lt;&lt;curCentroid&lt;&lt;\"\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/","title":"1 - Spojler","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 256MB <p>Na tvoju adresu stigla je misteriozna poruka od nepoznatog po\u0161iljaoca. Ono \u0161to je posebno neobi\u010dno jeste da je poruka poslata po\u010detkom 2023. godine, a ova poruka sti\u017ee sredinom decembra 2022. godine. Otvoriv\u0161i poruku, vidi\u0161 da je u prilogu video zapis finala svetskog prvenstva u fudbalu, koje \u0107e tek biti odigrano, i u\u010destvova\u0107e reprezentacije Argentine i Francuske. Poruka tako\u0111e sadr\u017ei i \"spojlovan\" kona\u010dan rezultat utakmice. Ipak, odlu\u010duje\u0161 da pogleda\u0161 ovaj neobi\u010dan video zapis iz budu\u0107nosti.</p> <p>Na poluvremenu utakmice, pogleda\u0161 trenutni rezultat utakmice \\(x:y\\) i seti\u0161 se najavljenog kona\u010dnog rezultata \\(a:b\\) iz poruke. Tog trenutka pomisli\u0161 da li je mogu\u0107e odrediti koji tim \u0107e slede\u0107i dati gol, pretpostavljaju\u0107i da je kona\u010dan rezultat naveden u misterioznoj poruci ispravan.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Andrej Iva\u0161kovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107"},{"location":"takprog/2022_2023/kv2/01_spojler/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza se nalaze dva prirodna broja \\(a\\) i \\(b\\) (spojlovan rezultat), dok se u drugom redu standardnog ulaza nalaze dva prirodna broja \\(x\\) i \\(y\\) (rezultat na poluvremenu).</p>"},{"location":"takprog/2022_2023/kv2/01_spojler/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati: </p> <ul> <li><code>prvi</code> ukoliko je mogu\u0107e zaklju\u010diti da \u0107e prvi tim (opisan brojevima \\(a\\) i \\(x\\)) dati slede\u0107i gol</li> <li><code>drugi</code> ukoliko je mogu\u0107e zaklju\u010diti da \u0107e drugi tim (opisan brojevima \\(b\\) i \\(y\\)) dati slede\u0107i gol</li> <li><code>nijedan</code> ukoliko je mogu\u0107e zaklju\u010diti da u nastavku utakmice ne\u0107e biti vi\u0161e nijednog gola</li> <li><code>?</code> ukoliko nije mogu\u0107e jednozna\u010dno zaklju\u010diti koji tim \u0107e posti\u0107i naredni gol</li> </ul>"},{"location":"takprog/2022_2023/kv2/01_spojler/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv2/01_spojler/#ulaz","title":"Ulaz","text":"<pre><code>1 2\n1 0\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#izlaz","title":"Izlaz","text":"<pre><code>drugi\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv2/01_spojler/#ulaz_1","title":"Ulaz","text":"<pre><code>1 1\n1 1\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#izlaz_1","title":"Izlaz","text":"<pre><code>nijedan\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2022_2023/kv2/01_spojler/#ulaz_2","title":"Ulaz","text":"<pre><code>4 4\n3 2\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#izlaz_2","title":"Izlaz","text":"<pre><code>?\n</code></pre>"},{"location":"takprog/2022_2023/kv2/01_spojler/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru je prvi tim ve\u0107 postigao sve golove u toj utakmici, a drugi nije. Jedini mogu\u0107i dalji ishod utakmice je \\(1:0 \\to 1:1 \\to 1:2\\). Prema tome, drugi tim je slede\u0107i koji \u0107e dati gol.</p> <p>U drugom primeru su na poluvremenu dati svi golovi koji \u0107e biti ostvareni tokom utakmice. Prema tome, nijedan tim ne\u0107e posti\u0107i jo\u0161 jedan gol.</p> <p>U tre\u0107em primeru nije mogu\u0107e odrediti koji tim \u0107e dati slede\u0107i gol -- mogu\u0107i dalji ishodi utakmice su: * \\(3:2 \\to 4:2 \\to 4:3 \\to 4:4\\) * \\(3:2 \\to 3:3 \\to 4:3 \\to 4:4\\) * \\(3:2 \\to 3:3 \\to 3:4 \\to 4:4\\)</p> <p>tim ve\u0107 postigao sve golove u toj utakmici, a drugi nije. Prema tome, drugi tim je slede\u0107i koji \u0107e dati gol.</p>"},{"location":"takprog/2022_2023/kv2/01_spojler/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq a, b \\leq 100\\)</li> <li>\\(0 \\leq x \\leq a\\)</li> <li>\\(0 \\leq y \\leq b\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U testovima vrednim 20 poena: na osnovu kona\u010dnog rezultata \\(a:b\\) se vidi da je ukupno dat jedan gol.</li> <li>U testovima vrednim 20 poena: na osnovu kona\u010dnog rezultata \\(a:b\\) se vidi da jedan tim nije dao nijedan gol.</li> <li>U testovima vrednim 60 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv2/01_spojler/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Nije te\u0161ko uo\u010diti da na osnovu rezultata \\(a:b\\) na kraju utakmice, kao i rezultata \\(x:y\\) na poluvremenu, postoji \u010detiri razli\u010dita slu\u010daja:</p> <ul> <li>\\(x = a\\) i \\(y = b\\), odnosno da je rezultat na kraju jednak rezultatu na poluvremenu, pa u nastavku ne\u0107e biti golova;</li> <li>\\(x &lt; a\\) i \\(y &lt; b\\), \u0161to dalje zna\u010di da \u0107e obe ekipe posti\u0107i gol, pa na osnovu rezultata nije mogu\u0107e utvrditi koja \u0107e ekipa zabiti naredni;</li> <li>\\(x &lt; a\\) i \\(y = b\\), \u0161to implicira da \u0107e prva ekipa posti\u0107i naredni gol;</li> <li>\\(x = a\\) i \\(y &lt; b\\), \u0161to zna\u010di da \u0107e druga ekipa posti\u0107i naredni gol.</li> </ul> <p>Jednostavnim postavljanjem ova \u010detiri uslova i odgovaraju\u0107im ispisima dolazi se do tra\u017eenog re\u0161enja u konstantnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(1)\\).</p> 01_spojler.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid write_sol(std::ostream&amp; f, int a, int b, int x, int y) {\n  if (a == x &amp;&amp; b == y) {\n    f &lt;&lt; \"nijedan\" &lt;&lt; std::endl;\n  } else if (a == x) {\n    f &lt;&lt; \"drugi\" &lt;&lt; std::endl;\n  } else if (b == y) {\n    f &lt;&lt; \"prvi\" &lt;&lt; std::endl;\n  } else {\n    f &lt;&lt; \"?\" &lt;&lt; std::endl;\n  }\n}\n\nint main() {\n  int a, b, x, y;\n  std::cin &gt;&gt; a &gt;&gt; b;\n  std::cin &gt;&gt; x &gt;&gt; y;\n  write_sol(std::cout, a, b, x, y);\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv2/02_finale/","title":"2 - Finale","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 32MB <p>Bli\u017ei se finale svetskog prvenstva i organizatori su zabrinuti za bezbednost na tribinama. Naime postoji \u0161ansa da do\u0111e do sukoba izme\u0111u navija\u010da suparni\u010dkih timova. Zato je odlu\u010deno da se napravi revolucionarni raspored tribina. </p> <p>Sedi\u0161ta tribina su raspore\u0111ena u \\(N\\) redova sa po \\(M\\) sedi\u0161ta. Mogu\u0107e je prolaziti izme\u0111u bilo koja dva sedi\u0161ta, kao i sa spolja\u0161njih strana ivi\u010dnih sedi\u0161ta (ovo mo\u017eemo posmatrati kao \\(N \\times M\\) matricu, gde polja predstavljaju sedi\u0161ta, a ivice puteve). Organizatori \u017eele da postave redare na neka od sedi\u0161ta tako da svi putevi budu obezbe\u0111eni. Svaki redar \u010duva 4 puta oko svog sedi\u0161ta. Organizatori od vas tra\u017ee da na\u0111ete minimalan broj redara koji je potreban da se ovo uradi.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko \u0160i\u0161ovi\u0107 Jovan Bengin Vladimir Milovanovi\u0107"},{"location":"takprog/2022_2023/kv2/02_finale/#opis-ulaza","title":"Opis ulaza","text":"<p>U jedinom redu standardnog ulaza se nalaze brojevi \\(N\\) i \\(M\\) - broj redova i broj sedi\u0161ta po redu.</p>"},{"location":"takprog/2022_2023/kv2/02_finale/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati minimalan broj redara potreban da se obezbede tribine.</p>"},{"location":"takprog/2022_2023/kv2/02_finale/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv2/02_finale/#ulaz","title":"Ulaz","text":"<pre><code>5 5\n</code></pre>"},{"location":"takprog/2022_2023/kv2/02_finale/#izlaz","title":"Izlaz","text":"<pre><code>20\n</code></pre>"},{"location":"takprog/2022_2023/kv2/02_finale/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv2/02_finale/#ulaz_1","title":"Ulaz","text":"<pre><code>7 5\n</code></pre>"},{"location":"takprog/2022_2023/kv2/02_finale/#izlaz_1","title":"Izlaz","text":"<pre><code>27\n</code></pre>"},{"location":"takprog/2022_2023/kv2/02_finale/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, numeri\u0161imo tribine na slede\u0107i na\u010din:</p> <p></p> <p>Jedan mogu\u0107 raspored redara je da se redari smeste na sedi\u0161ta \\(1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 14, 15, 16, 18, 20, 21, 22, 23, 24, 25\\).</p> <p>U drugom primeru numeri\u0161imo tribine na slede\u0107i na\u010din:</p> <p></p> <p>Jedan mogu\u0107 raspored redara je da se redari smeste na sedi\u0161ta \\(1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 28, 30, 31, 32, 33, 34, 35\\).</p>"},{"location":"takprog/2022_2023/kv2/02_finale/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 10^9\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 20 poena: \\(N = 3\\).</li> <li>U testovima vrednim 20 poena: \\(N, M \\leq 5\\).</li> <li>U testovima vrednim 20 poena: \\(N = M\\).</li> <li>U testovima vrednim 20 poena: \\(N \\times M \\leq 2 \\times 10^5\\).</li> <li>U testovima vrednim 20 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv2/02_finale/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Ako posmatramo puteve na rubu matrice, vidimo da i sva polja na rubu (tj. prvi i poslednji red i kolona) moraju imati redara. Ako je \\(N \\leq 2\\) ili \\(M \\leq 2\\), to zna\u010di da \u0107e sva polja u matrici imati redara, pa je u tom slu\u010daju re\u0161enje \\(N \\times M\\).</p> <p>Nadalje pretpostavljamo da va\u017ei \\(N, M \\geq 3\\). Posmatrajmo matricu dobijenu brisanjem prvog i poslednjeg reda i kolone - u ovoj novoj \\((N-2) \\times (M-2)\\) matrici \u0107emo tra\u017eiti maksimalan broj polja gde ne moramo postaviti redare, ako znamo da su svi putevi na rubu ve\u0107 pokriveni.  Za svaka dva susedna polja va\u017ei da barem jedno od njih ima redara, jer ina\u010de put koji ih razdvaja ne bi bio pokriven. Ovaj uslov je i dovoljan, jer \u0107e tada i svi putevi biti pokriveni.</p> <p>Dakle, potrebno je na\u0107i najve\u0107i skup polja u kome ne postoje dva susedna. Ovo je poznat zadatak: obojimo matricu \u0161ahovski crno-belo i uzmemo sva polja one boje koja se vi\u0161e puta pojavljuje. Po\u0161to se broj polja crne i bele boje razlikuje za najvi\u0161e jedan, bi\u0107e \\(\\lceil \\frac{(N-2) \\cdot (M-2)}{2} \\rceil\\) polja jedne, i \\(\\lfloor \\frac{(N-2) \\cdot (M-2)}{2} \\rfloor\\) polja druge boje. To zna\u010di da mo\u017eemo imati maksimalno \\(\\lceil \\frac{(N-2) \\cdot (M-2)}{2} \\rceil\\) polja bez redara, pa je minimalan broj redara \\(N \\cdot M - \\lceil \\frac{(N-2) \\cdot (M-2)}{2} \\rceil\\).</p> 02_finale.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n    int n, m;\n    cin&gt;&gt;n&gt;&gt;m;\n    if(n == 1){\n        cout&lt;&lt;m;\n    }\n    else if(m == 1){\n        cout&lt;&lt;n;\n    }\n    else\n    {\n        cout&lt;&lt;2ll*n + 2ll*m - 4 + 1ll*(n-2)*(m-2)/2;\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv2/03_guzva/","title":"3 - Gu\u017eva","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>Janko se sprema za odlazak na finale svetskog prvenstva u fudbalu 2022. godine. Me\u0111utim, kako su svi navija\u010di pohrlili na utakmicu, u Dohi su velike gu\u017eve. Da stvari budu gore, Jankov hotel je na suprotnom kraju grada u odnosu na stadion. </p> <p>Poznato je da Doha izgleda kao matrica dimenzija \\(N \\times M\\). Polje \\((i,j)\\) ozna\u010dava polje u \\(i\\)-tom redu i \\(j\\)-toj koloni. Jankov hotel se nalazi na polju \\((1,1)\\), dok se stadion nalazi na polju \\((N, M)\\). Na svakom polju matrice (uklju\u010duju\u0107i i polja na kojem su hotel i stadion) se nalazi neka grupa navija\u010da - na polju \\((i,j)\\) ima ta\u010dno \\(a_{i,j}\\) navija\u010da. </p> <p>Janko sa polja \\((i,j)\\) isklju\u010divo mo\u017ee da ode na polje \\((i+1,j)\\) ili na polje \\((i,j+1)\\) (ukoliko je odgovaraju\u0107e polje na koje bi do\u0161ao unutar matrice). Po\u0161to Janko ne voli gu\u017eve, odlu\u010dio je da svoj put isplanira tako da na njemu susretne najmanji broj navija\u010da (gde je broj navija\u010da koje je sreo suma svih \\(a_{i,j}\\) po poljima kroz koja je pro\u0161ao na putu do stadiona, uklju\u010duju\u0107i i polja hotela i stadiona).  </p> <p>\u010cim je Janko napravio plan, \u010duo je na vestima da \u0107e ta\u010dno jedno polje biti blokirano za javnost, te on ne\u0107e mo\u0107i da pro\u0111e kroz njega na putu do stadiona. Janko na\u017ealost nije siguran o kojem polju je re\u010d, te vas moli da odgovorite na \\(Q\\) razli\u010ditih scenarija. U \\(i\\)-tom scenariju, Janko \u017eeli da zna koliko \u0107e navija\u010da morati da sretne, ako polje \\((x_i,y_i)\\) bude blokirano.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 i Mladen Puzi\u0107 Aleksa Milisavljevi\u0107 Mladen Puzi\u0107 Dragan Uro\u0161evi\u0107 <p>Dalje u re\u0161enjima \u0107emo re\u0107i da se kre\u0107emo na dole ukoliko se pomeramo sa polja \\((i, j)\\) na polje \\((i+1, j)\\), u suprotnom se kre\u0107emo udesno.</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, nalaze se dva cela broja, \\(N\\) i \\(M\\), koji predstavljaju dimenzije Dohe.</p> <p>Linija \\(i\\) od narednih \\(N\\) linija sadr\u017ei \\(M\\) celih brojeva, od kojih \\(j\\)-ti predstavlja \\(a_{i,j}\\) - broj navija\u010da na polju \\((i,j)\\).</p> <p>Naredna linija sadr\u017ei jedan ceo broj, \\(Q\\), koji predstavlja broj razli\u010ditih scenarija koje Janko razmatra. </p> <p>Narednih \\(Q\\) linija sadr\u017ee po dva broja, \\(x_i\\) i \\(y_i\\), koji opisuju polje koje je blokirano u \\(i\\)-tom scenariju.</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(Q\\) redova, u \\(i\\)-tom od njih potrebno je ispisati jedan ceo broj, koji predstavlja minimalan broj navija\u010da koje \u0107e Janko sresti na putu do stadiona, ukoliko bude blokirano polje \\((x_i,y_i)\\).</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv2/03_guzva/#ulaz","title":"Ulaz","text":"<pre><code>3 4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n2\n1 2\n2 4\n</code></pre>"},{"location":"takprog/2022_2023/kv2/03_guzva/#izlaz","title":"Izlaz","text":"<pre><code>39\n36\n</code></pre>"},{"location":"takprog/2022_2023/kv2/03_guzva/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<ul> <li>prvi scenario: Ukoliko je blokirano polje \\((1,2)\\), optimalan put za Janka je \\((1,1) \\rightarrow (2,1) \\rightarrow (2,2) \\rightarrow (2,3) \\rightarrow (2,4) \\rightarrow (3,4)\\). Na tom putu, on \u0107e ukupno sresti \\(39\\) navija\u010da.</li> <li>drugi scenario: Ukoliko je blokirano polje \\((2,4)\\), optimalan put za Janka je \\((1,1) \\rightarrow (1,2) \\rightarrow (1,3) \\rightarrow (2,3) \\rightarrow (3,3) \\rightarrow (3,4)\\). Na tom putu, on \u0107e ukupno sresti \\(36\\) navija\u010da.</li> </ul>"},{"location":"takprog/2022_2023/kv2/03_guzva/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N, M\\).</li> <li>\\(4 \\leq N \\cdot M \\leq 10^6\\).</li> <li>\\(1 \\leq Q \\leq 5 \\cdot 10^5\\).</li> <li>\\(1 \\leq a_{i,j} \\leq 10^9\\).</li> <li>\\(1 \\leq x_i \\leq N\\).</li> <li>\\(1 \\leq y_i \\leq M\\).</li> <li>Garantuje se da hotel i stadion nikada ne\u0107e biti blokirani za javnost i da \u0107e Janko uvek mo\u0107i da stigne od hotela do stadiona.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N = 2\\).</li> <li>U testovima vrednim 10 poena: \\(Q \\leq 100\\), \\(N, M \\leq 7\\).</li> <li>U testovima vrednim 15 poena: \\(Q \\leq 2000\\), \\(N \\cdot M \\leq 2000\\).</li> <li>U testovima vrednim 20 poena: \\(Q \\leq 10^4\\).</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv2/03_guzva/#resenje-kada-n-2","title":"Re\u0161enje kada \\(N = 2\\)","text":"<p>Na ta\u010dno jednoj poziciji \u0107emo se pomeriti na dole, svi ostali potezi bi\u0107e udesno. Ozna\u010dimo sa \\(d_i\\) broj navija\u010da koje sretnemo ukoliko se u koloni \\(i\\) pomerimo na dole. Ovaj niz mo\u017eemo izra\u010dunati koriste\u0107i prefiksni zbir nad gornjim redom i sufiksni zbir nad donjim redom.</p> <p>Ukoliko je blokirano neko polje u prvom redu, npr. \\((1, i)\\), onda se moramo pomeriti na dole pre \\(i\\)-te kolone, pa je re\u0161enje \\(\\min(d_1, d_2, \\ldots d_{i-1})\\). Ukoliko je blokirano neko polje u drugom redu, npr. \\((2, j)\\), onda se moramo pomeriti na dole posle \\(i\\)-te kolone, pa je re\u0161enje \\(\\min(d_{i+1}, d_{i+2}, d_M)\\).</p> <p>Vremenska slo\u017eenost je \\(O(M+Q)\\), a memorijska \\(O(M)\\).</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#resenje-kada-q-leq-100-n-m-leq-7","title":"Re\u0161enje kada \\(Q \\leq 100\\), \\(N, M \\leq 7\\)","text":"<p>Re\u0161enje mo\u017eemo dobiti brute force metodom, odnosno isprobavanjem svih mogu\u0107ih puteva od prvog do poslednjeg polja, za svako blokirano polje. Takvih puteva postoji \\({N+M-2 \\choose N-1}\\) (imamo ukupno \\(N+M-2\\) koraka, od kojih biramo \\(N-1\\) da budu usmereni na dole). Sve puteve mo\u017eemo proveriti rekurzijom. </p> <p>Vremenska slo\u017eenost je \\(O(Q\\cdot{N+M-2 \\choose N-1})\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#resenje-kada-q-leq-2000-n-cdot-m-leq-2000","title":"Re\u0161enje kada \\(Q \\leq 2000\\), \\(N \\cdot M \\leq 2000\\)","text":"<p>Za svako blokirano polje, koristi\u0107emo dinami\u010dko programiranje - izra\u010duna\u0107emo \\(dp_{i, j}\\), najmanji broj navija\u010da koje moramo da sretnemo na putu od \\((1, 1)\\) do \\((i, j)\\), ako ne posetimo trenutno blokirano polje. Jasno je da va\u017ei \\(dp_{1, 1} = a_{1, 1}\\) i \\(dp_{i, j} = dp_{i-1, j} + dp_{i, j-1}\\), s tim \u0161to prilikom ra\u010dunanja uvek preska\u010demo polja koja su van matrice i trenutno blokirano polje. Re\u0161enje se onda nalazi u \\(dp_{N, M}\\). </p> <p>Vremenska slo\u017eenost je \\(O(QNM)\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#resenje-kada-q-leq-104","title":"Re\u0161enje kada \\(Q \\leq 10^4\\)","text":"<p>Kao u prethodnom re\u0161enju, izra\u010dunajmo niz \\(A_{i, j}\\) - najmanji broj navija\u010da koje moramo da sretnemo na putu od \\((1, 1)\\) do \\((i, j)\\), i sli\u010dno \\(B_{i, j}\\) - najmanji broj navija\u010da koje moramo da sretnemo na putu od \\((i, j)\\) do \\((N, M)\\). </p> <p>Recimo da blokiramo polje \\((x, y)\\). Posmatrajmo sva polja \\((x', y')\\) za koja va\u017ei \\(x+y = x' + y'\\). Mo\u017eemo videti da se zapravo sva ova polja nalaze na istoj dijagonali, kao i da na svakom putu od \\((1, 1)\\) do \\((N, M)\\) prolazimo kroz ta\u010dno jedno od ovih polja. </p> <p>Ovo nam govori da, kako bismo garantovali da ne prolazimo kroz polje \\((x, y)\\), dovoljno je da garantujemo da prolazimo kroz neko drugo polje na ovoj dijagonali. Mo\u017eemo na\u0107i put sa najmanje navija\u010da koji prolazi kroz polje \\((i, j)\\) sa \\(A_{i, j} + B_{i, j} - a_{i, j}\\). </p> <p>Mo\u017eemo, dakle, pro\u0107i kroz sva polja na dijagonali blokiranog polja i videti za koje dobijamo najmanji put. Bitno je primetiti da je broj polja na toj dijagonali najvi\u0161e \\(\\min(N, M)\\), \u0161to je manje od \\(\\sqrt{NM}\\).</p> <p>Vremenska slo\u017eenost je \\(O(Q\\cdot \\sqrt{N M} + NM)\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2022_2023/kv2/03_guzva/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Uradimo sve isto kao u prethodnom re\u0161enju, sem \u0161to \u0107emo efikasnije na\u0107i minimum na dijagonali bez jednog polja. To \u0107emo uraditi tako \u0161to \u0107emo \u010duvati prefiksni i sufiksni minimum za svaku dijagonalu. Za blokirano \\((x, y)\\) uze\u0107emo minimum od prefiksa do \\((x-1, y+1)\\) i sufiksa od \\((x+1, y-1)\\).</p> <p>Vremenska slo\u017eenost je \\(O(Q + NM)\\), a memorijska \\(O(NM)\\).</p> 03_guzva.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define ll long long\n#define inf 1e18\nusing namespace std;\nint n,m,q;\nvector&lt;vector&lt;ll&gt; &gt; a,dp_top,dp_bot,pref,suf;\nint main() {\n    scanf(\"%d %d\",&amp;n,&amp;m);\n    a.resize(n+2);dp_top.resize(n+2);dp_bot.resize(n+2);pref.resize(n+2);suf.resize(n+2);\n    for(int i=0;i&lt;=n+1;i++) {\n        a[i].resize(m+2);dp_top[i].resize(m+2);dp_bot[i].resize(m+2);pref[i].resize(m+2);suf[i].resize(m+2);\n        for(int j=0;j&lt;=m+1;j++) a[i][j]=dp_top[i][j]=dp_bot[i][j]=pref[i][j]=suf[i][j]=inf;\n    }\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(\"%lld\",&amp;a[i][j]);\n    dp_top[1][1]=a[1][1]; dp_bot[n][m]=a[n][m];\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) dp_top[i][j]=min(dp_top[i][j],min(dp_top[i-1][j],dp_top[i][j-1])+a[i][j]);\n    for(int i=n;i&gt;=1;i--) for(int j=m;j&gt;=1;j--) dp_bot[i][j]=min(dp_bot[i][j],min(dp_bot[i+1][j],dp_bot[i][j+1])+a[i][j]);\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) pref[i][j]=min(pref[i-1][j+1],dp_top[i][j]+dp_bot[i][j]-a[i][j]);\n    for(int i=n;i&gt;=1;i--) for(int j=1;j&lt;=m;j++) suf[i][j]=min(suf[i+1][j-1],dp_top[i][j]+dp_bot[i][j]-a[i][j]);\n    scanf(\"%d\",&amp;q);\n    while(q--) {\n        int x,y;\n        scanf(\"%d %d\",&amp;x,&amp;y);\n        printf(\"%lld\\n\",min(pref[x-1][y+1],suf[x+1][y-1]));\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv2/04_formacija/","title":"4 - Formacija","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>FIFA je uvela neo\u010dekivano pravilo pred finale svetskog prvenstva u fudbalu. Umesto \\(11\\) igra\u010da na terenu, sada svaki tim ima \\(N\\) igra\u010da i igra\u010di su numerisani brojevima od \\(1\\) do \\(N\\) (brojevi im se, naravno, nalaze na dresu).</p> <p>Finale je u toku i Mesi ima ozbiljnu \u0161ansu za gol. Ukoliko teren posmatramo kao koordinatni sistem, Mesijeva trenutna koordinata je \\((0, 0)\\), a koordinata francuskog fudbalera sa dresom broj \\(k\\) je \\((x_k, y_k)\\) (za svako \\(1 \\leq k \\leq N)\\).</p> <p>Mesi je veoma inteligentan igra\u010d i malo je poznato da je zapravo i sjajan takmi\u010darski programer. Zato, uzeo je da posmatra svoje protivnike kako bi na\u0161ao slabost.</p> <p>On posmatra svih \\(2^N - 1\\) nepraznih podskupova francuskih igra\u010da. Da bi odredio kvalitet svoje \u0161anse, potrebno mu je da sazna koliko podskupova postoji, takvih da konveksni omota\u010d ta\u010daka fudbalera tog podskupa - sadr\u017ei ta\u010dku \\((0,0)\\). Po\u0161to ovaj broj mo\u017ee biti veoma velik, potrebno je ispisati njegov ostatak pri deljenju brojem \\(10^9+7\\).</p> <p>Ovo mu ne bi pravilo problem da je kod ku\u0107e za ra\u010dunarom i radi srpske kvalifikacije za okru\u017eno takmi\u010denje, ali po\u0161to je u finalu Svetskog prvenstva, potrebna mu je va\u0161a pomo\u0107.</p> <p>Napomena: Konveksni omota\u010d skupa ta\u010daka \\(S\\) defini\u0161emo na slede\u0107i na\u010din:</p> <ul> <li>ukoliko se u \\(S\\) nalazi samo jedna ta\u010dka, konveksni omota\u010d je samo ta ta\u010dka;</li> <li>ukoliko se u \\(S\\) nalazi skup kolinearnih ta\u010daka (sve ta\u010dke na istoj pravoj), konveksni omota\u010d je najkra\u0107a du\u017e koja sadr\u017ei sve ta\u010dke;</li> <li>u suprotnom, konveksni omota\u010d je konveksni mnogougao najmanje povr\u0161ine koji sadr\u017ei sve ta\u010dke skupa \\(S\\).</li> </ul> <p>Ra\u010dunamo da konveksni omota\u010d sadr\u017ei ta\u010dku i u slu\u010daju da se ta\u010dka nalazi na nekoj od ivica konveksnog omota\u010da.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mladen Puzi\u0107 Mladen Puzi\u0107 Mladen Puzi\u0107 Pavle Martinovi\u0107 <p>Za tri ta\u010dke \\(A, B\\) i \\(C\\) ka\u017eemo da trojka \\((A, B, C)\\) ima levi zaokret ukoliko ako se kre\u0107emo od \\(A\\) do \\(C\\) preko ta\u010dke \\(B\\) moramo skrenuti u levo. Sli\u010dno defini\u0161emo desni zaokret. Ta\u010dke \\(A, B\\) i \\(C\\) su kolinearne ukoliko postoji prava koja sadr\u017ei sve tri. Sve ovo mo\u017eemo proveriti koriste\u0107i vektorski proizvod vektora \\(\\overrightarrow{AB}\\) i \\(\\overrightarrow{BC}\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei jedan ceo broj \\(N\\) - broj igra\u010da u timu po novim pravilima. U \\(k\\)-toj od narednih \\(N\\) linija nalazi se po dva cela broja \\(x_k\\), \\(y_k\\) - koordinate protivni\u010dkog igra\u010da sa brojem dresa \\(k\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza, ispisati ostatak broja nepraznih podskupova francuskih igra\u010da u \u010dijem konveksnom omota\u010du se nalazi Mesi, nakon \u0161to ga podelimo brojem \\(10^9+7\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv2/04_formacija/#ulaz","title":"Ulaz","text":"<pre><code>5\n3 -1\n8 -1\n-9 1\n7 -1\n-4 1\n</code></pre>"},{"location":"takprog/2022_2023/kv2/04_formacija/#izlaz","title":"Izlaz","text":"<pre><code>9\n</code></pre>"},{"location":"takprog/2022_2023/kv2/04_formacija/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/kv2/04_formacija/#ulaz_1","title":"Ulaz","text":"<pre><code>18\n25 32\n36 40\n-13 7\n-26 -49\n3 27\n-33 -39\n-19 -9\n36 6\n-16 -31\n-17 -48\n-29 34\n-49 36\n-28 -25\n7 37\n2 45\n-18 15\n-23 -26\n41 42\n</code></pre>"},{"location":"takprog/2022_2023/kv2/04_formacija/#izlaz_1","title":"Izlaz","text":"<pre><code>239247\n</code></pre>"},{"location":"takprog/2022_2023/kv2/04_formacija/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru odgovaraju\u0107i neprazni podskupovi igra\u010da su: </p> <ul> <li>\\(\\{1, 2, 3, 4, 5\\}\\)</li> <li>\\(\\{1, 2, 3, 5\\}\\)</li> <li>\\(\\{1, 2, 4, 5\\}\\)</li> <li>\\(\\{1, 2, 5\\}\\)</li> <li>\\(\\{1, 3, 4, 5\\}\\)</li> <li>\\(\\{1, 4, 5\\}\\)</li> <li>\\(\\{2, 3, 4, 5\\}\\)</li> <li>\\(\\{2, 3, 5\\}\\)</li> <li>\\(\\{3, 4, 5\\}\\)</li> </ul>"},{"location":"takprog/2022_2023/kv2/04_formacija/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(-10^9 \\leq x_k, y_k \\leq 10^9\\), za \\(1 \\leq k \\leq N\\).</li> <li>\\((x_k, y_k) \\neq (x_j, y_j)\\), za \\(1 \\leq k &lt; j \\leq N\\).</li> <li>\\((x_k, y_k) \\neq (0, 0)\\), za \\(1 \\leq k \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 10 poena: \\(N = 3\\).</li> <li>U testovima vrednim 10 poena: \\(y_1 = 1\\) i \\(y_k = -1\\), za \\(1 &lt; k \\leq N\\).</li> <li>U testovima vrednim 25 poena: \\(y_k \\in \\{-1, 1\\}\\), za \\(1 \\leq k \\leq N\\).</li> <li>U testovima vrednim 15 poena: \\(N \\leq 18\\).</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv2/04_formacija/#resenje-kada-n-3","title":"Re\u0161enje kada \\(N = 3\\)","text":"<p>Za svaki podskup potrebno je proveriti posebno. Imamo tri podskupa sa dva igra\u010da, gde je potrebno proveriti da li se Mesi nalazi na du\u017ei izme\u0111u ta dva igra\u010da. To mo\u017eemo tako \u0161to proverimo da li je kolinearan sa ta dva igra\u010da, kao i da su mu \\(x\\) i \\(y\\) koordinate izme\u0111u njihovih.</p> <p>Tako\u0111e je potrebno proveriti za podskup od sva tri fudbalera. Ako je Mesi u ta\u010dki \\(M\\), a tri date ta\u010dke \\(A, B\\) i \\(C\\), onda je potrebno da trojke \\((A, B, M)\\), \\((B, C, M)\\) i \\((C, A, M)\\) imaju isti zaokret, kako bi se \\(M\\) nalazio u konveksnom omota\u010du ta\u010daka \\(A, B\\) i \\(C\\).</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(1)\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#resenje-kada-y_1-1-i-y_k-1-za-1-k-leq-n","title":"Re\u0161enje kada \\(y_1 = 1\\) i \\(y_k = -1\\), za \\(1 &lt; k \\leq N\\)","text":"<p>Jasno je da \u0107emo igra\u010da sa dresom broj \\(1\\) morati da uklju\u010dimo u podskup kako bi konveksni omota\u010d sadr\u017eao ta\u010dku \\((0, 0)\\). </p> <p>Posmatrajmo ta\u010dku \\((-x_1, -1)\\). Postoji dva slu\u010daja:</p> <ul> <li>Ukoliko postoji igra\u010d koji se nalazi u toj ta\u010dki, tada, ako ga uklju\u010dimo u podskup, mo\u017eemo uzeti bilo koji podskup ostalih igra\u010da, kojih ima \\(2^{N-2}\\). Sem toga, moramo dodati broj podskupova u kojima se ne nalazi taj igra\u010d;</li> <li>Ukoliko ne postoji igra\u010d u toj ta\u010dki, ne\u0107emo dodati \\(2^{N-2}\\) na re\u0161enje.</li> </ul> <p>Recimo da posmatramo broj podskupova koji ne sadr\u017ee igra\u010da u ta\u010dki \\((-x_1, -1)\\) (ako takav uop\u0161te postoji). Jasno je da onda moramo uzeti makar jednog igra\u010da levo (odnosno sa manjom \\(x\\) koordinatom) od te ta\u010dke i makar jednog igra\u010da desno (odnosno sa ve\u0107om \\(x\\) koordinatom). Ako sa \\(L\\) ozna\u010dimo broj igra\u010da levo, a sa \\(R\\) broj igra\u010da desno, onda je re\u0161enje \\((2^L-1)\\cdot (2^R - 1)\\) (na \u0161ta dodajemo \\(2^{N-2}\\) ukoliko postoji igra\u010d u ta\u010dki \\((-x_1, -1)\\)).</p> <p>Vremenska slo\u017eenost je \\(O(NlogN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#resenje-kada-y_k-in-1-1-za-1-leq-k-leq-n","title":"Re\u0161enje kada \\(y_k \\in \\{-1, 1\\}\\), za \\(1 \\leq k \\leq N\\)","text":"<p>Sli\u010dno prethodnom re\u0161enju, moramo da imamo makar po jednog igra\u010da sa obe \\(y\\) koordinate. Ako fiksiramo najlevlju i najde\u0161nju ta\u010dku sa prave \\(y = 1\\) iz podskupa koji biramo, onda ponovo nalazimo \\(L\\) i \\(R\\) i primenjujemo sli\u010dnu formulu kao u prethodnom re\u0161enju. </p> <p>Ovo je presporo pa je potrebno da primetimo da \\(L\\) zavisi samo od najlevlje odabrane ta\u010dke, a \\(R\\) samo od najde\u0161nje odabrane ta\u010dke. Ovo koristimo uz tehniku prefiksnih suma, da na\u0111emo zbir svih podskupova za fiksiranu najlevlju ta\u010dku (a kroz sve mogu\u0107e najde\u0161nje). </p> <p>Vremenska slo\u017eenost je \\(O(NlogN)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#resenje-kada-n-leq-18","title":"Re\u0161enje kada \\(N \\leq 18\\)","text":"<p>Za svaki podskup ta\u010daka, na\u0111imo konveksni omota\u010d nekim poznatim algoritmom (npr. monotoni lanac) i onda proverimo da li se ta\u010dka \\((0, 0)\\) nalazi u njemu. To mo\u017eemo uraditi tako \u0161to idemo u krug kroz ivice omota\u010da i proveravamo da li sve ivice imaju isti zaokret sa ta\u010dkom \\((0, 0)\\).</p> <p>Vremenska slo\u017eenost je \\(O(2^N \\cdot N)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2022_2023/kv2/04_formacija/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Umesto da ra\u010dunamo broj podskupova u \u010dijem konveksnom omota\u010du se Mesi nalazi, od \\(2^N - 1\\) oduzmimo broj podskupova u \u010dijem konveksnom omota\u010de se ne nalazi Mesi. To radimo zato \u0161to je lak\u0161e proveriti ovaj uslov - dovoljno je da postoji prava kroz \\((0, 0)\\), tako da su sve ta\u010dke podskupa sa iste strane ove prave.</p> <p>Pretpostavi\u0107emo da nema kolinearnih ta\u010daka (\u010dak ni kad ra\u010dunamo Mesijevu poziciju). Re\u0161anje kolinearnih ta\u010daka svede se detalje implementacije. Krenuv\u0161i od pozitivne \\(x\\) ose, sortirajmo ta\u010dke po polarnom uglu oko ta\u010dke \\((0, 0)\\), rastu\u0107e. Ozna\u010dimo sa \\(M\\) ta\u010dku \\((0, 0)\\). </p> <p>Fiksirajmo svaku ta\u010dku \\(p_i\\) i sa \\(cnt\\) ozna\u010dimo broj drugih ta\u010daka koje imaju levi zaokret sa vektorom od \\(p_i\\) do \\(M\\). Onda je broj podskupova u kojima je \\(p_i\\) najlevlja ta\u010dka (ta\u010dka takva da nije zaokret \\((M, x, p_i)\\) nije nadesno, za svako \\(x\\) u podskupu),  a da konveksni omota\u010d ne sadr\u017ei ta\u010dku \\(M\\) - \\(2^{cnt}\\). Kada od \\(2^N - 1\\) oduzmemo ovaj rezultat za svaku ta\u010dku \\(p_i\\), dobijemo kona\u010dno re\u0161enje. Broj \\(cnt\\) mo\u017eemo odr\u017eavati tehnikom dva pokaziva\u010da.</p> <p>Vremenska slo\u017eenost je \\(O(NlogN)\\), a memorijska \\(O(N)\\).</p> 04_formacija.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define MAXN 100010\n#define MOD 1000000007\n#define x first\n#define y second\n#define Point pair&lt;int, int&gt;\nusing namespace std;\nPoint p[2*MAXN], o;\nint st2[MAXN];\n\nlong long crossProduct(Point a, Point b, Point c) {\n  return (long long)(b.x-a.x)*(c.y-b.y) - (long long)(b.y-a.y)*(c.x-b.x);\n}\n\nbool collinear(Point a, Point b, Point c) {\n  return crossProduct(a, b, c) == 0;\n}\nbool leftTurn(Point a, Point b, Point c) {\n  return crossProduct(a, b, c) &gt; 0;\n}\nbool rightTurn(Point a, Point b, Point c) {\n  return crossProduct(a, b, c) &lt; 0;\n}\n\nint quadrant(Point a) {\n  if(a.x &gt; 0) {\n    if(a.y &gt;= 0) return 0;\n    if(a.y &lt;  0) return 3;\n  } else if(a.x &lt; 0) {\n    if(a.y &gt;  0) return 1;\n    if(a.y &lt;= 0) return 2;\n  } else {\n    if(a.y &gt;  0) return 1;\n    if(a.y &lt;  0) return 3;\n  }\n}\n\nbool cmp(Point a, Point b) {\n  int kA = quadrant(a), kB = quadrant(b);\n  if(kA != kB) return kA &lt; kB;\n  if(!collinear(o, a, b)) return leftTurn(o, a, b);\n  return abs(a.x) &lt;= abs(b.x) &amp;&amp; abs(a.y) &lt;= abs(b.y);\n}\n\nbool shouldPop(Point A, Point B) {\n  if(rightTurn(A, o, B)) return true;\n  if(collinear(A, o, B) &amp;&amp; quadrant(A) != quadrant(B)) return true;\n  if(collinear(A, o, B) &amp;&amp; (abs(B.x) &gt; abs(A.x) || abs(B.y) &gt; abs(A.y))) return true;\n  return false;\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int N; cin &gt;&gt; N;\n  st2[0] = 1;\n  for(int i = 1; i &lt;= N; i++) {\n    st2[i] = st2[i-1]*2;\n    if(st2[i] &gt;= MOD) st2[i] %= MOD;\n  }\n  o = {0, 0};\n  for(int i = 1; i &lt;= N; i++) {\n    cin &gt;&gt; p[i].x &gt;&gt; p[i].y;\n  }\n  sort(p+1, p+1+N, cmp);\n  int idx = 2, sol = 0;\n  for(int i = N+1; i &lt;= 2*N; i++) {\n    p[i] = p[i-N];\n    while(idx &lt; i &amp;&amp; (shouldPop(p[i], p[idx]) || idx+N == i)) idx++;\n    sol += st2[i-idx];\n    if(sol &gt;= MOD) sol %= MOD;\n  }\n  cout &lt;&lt; (st2[N]-1-sol+MOD)%MOD;\n  return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/kv2/05_opklada/","title":"5 - Opklada","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 4000ms 256MB <p>Svetsko prvenstvo u fudbalu je glavna tema svih de\u010da\u010dkih pri\u010da na velikom odmoru, pa je tako i za trojicu junaka ovog zadatka - Lazara, Momira i Uglje\u0161u. Oni svaki dan diskutuju o tome ko je najbolji igra\u010d, najbolja reprezentacija i najbitnije, ko \u0107e da pobedi. Me\u0111utim, kada se postavi pitanje pobednika nastaju ogromne nesuglasice. Da bi odlu\u010dili ko zaista najbolje predvi\u0111a rezultate utakmica, dogovorili su se da naprave opkladu.</p> <p>Svako od njih \u017eeli da predvidi gol-razliku u narednih \\(N\\cdot M\\) me\u010deva. Zarad preglednosti predvi\u0111anja, Uglje\u0161a je napravio svima tablice dimenzije \\(N\\times M\\) gde \u0107e oni upisivati svoja predvi\u0111anja. Naime, u polju \\((i,j)\\) (\\(1\\le i\\le N\\), \\(1\\le j\\le M\\)) \u0107e napisati koju gol-razliku predvi\u0111aju u \\((M*(i-1)+j)\\)-toj utakmici (unapred su fiksirali koji tim je \"prvi\", tako da gol-razlika mo\u017ee biti i negativna).</p> <p>Me\u0111utim, tajna koju Lazar i Uglje\u0161a ne znaju je da Momira ba\u0161 i ne interesuje fudbal! On nije odgledao nijednu utakmicu svetskog prvenstva, samo je jako dobar u izmi\u0161ljanju i klimanju glavom.  Zato sad kad treba da zapravo predvidi sam ne\u0161to, upao je u ozbiljan problem. Sre\u0107om, uspeo je da virne svojim prijateljima u tabele i video Lazarova predvi\u0111anja u matrici \\(l_{i,j}\\), a Uglje\u0161ina u matrici \\(u_{i,j}\\). Momir mo\u017eda ne zna ni\u0161ta o fudbalu, ali zna svoje prijatelje, tako da zna da \u0107e Lazar sigurno potceniti gol razliku (Lazar uvek ide na najsigurnije opcije), dok \u0107e ih Uglje\u0161a sigurno preceniti (Uglje\u0161u \u010desto ponese uzbu\u0111enje).  Stoga, Momir je odlu\u010dio da kad napi\u0161e njegova predvi\u0111anja u matricu \\(m_{i,j}\\) va\u017ei \\(l_{i,j}\\le m_{i,j}\\le u_{i,j}\\). Me\u0111utim, kako bi mu ovo pisanje predikcija bilo interesantnije, on je odlu\u010dio da pretvori to u igru. Naime, na po\u010detku je upisao u svoju tabelu sve nule. On \u0107e u jednom potezu ili da pove\u0107a sve vrednosti u nekom redu za \\(1\\), ili da smanji sve vrednosti  u nekoj koloni za \\(1\\). Interesuje ga da li je mogu\u0107e pomo\u0107u ovih operacija da napravi predvi\u0111anja za koja \u0107e va\u017eiti \\(l_{i,j}\\le m_{i,j}\\le u_{i,j}\\), a va\u0161 zadatak je da mu pomognete u tome.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/kv2/05_opklada/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza se nalazi broj \\(T\\) koji predstavlja broj test primera. Dalje sledi opis svakog test primera: U prvom redu se nalaze dva cela broja \\(N\\) i \\(M\\). U narednih \\(N\\) redova se nalaze po \\(M\\) celih brojeva koji predstavljaju Lazareva predvi\u0111anja - matricu \\(l_{i,j}\\). U narednih \\(N\\) redova se nalaze po \\(M\\) celih brojeva koji predstavljaju Uglje\u0161ina predvi\u0111anja - matricu \\(u_{i,j}\\).</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki primer treba dati odgovor, i to odvojen novim redom. Ukoliko nije mogu\u0107e da Momir napravi svoja predvi\u0111anja da ispunjavaju uslove zadatka, potrebno je samo ispisati \"NE\" (bez navodnika).  U suprotnom treba ispisati \"DA\" (bez navodnika) i u narednih \\(N\\) redova ispisati po \\(M\\) brojeva koji predstavljaju Momirova predvi\u0111anja. Ukoliko postoji vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/kv2/05_opklada/#ulaz","title":"Ulaz","text":"<pre><code>2\n2 2\n1 -2\n0 -3\n4 0\n1 -2\n2 2\n0 0\n0 1\n0 0\n0 1\n</code></pre>"},{"location":"takprog/2022_2023/kv2/05_opklada/#izlaz","title":"Izlaz","text":"<pre><code>DA\n1 -2\n1 -2\nNE\n</code></pre>"},{"location":"takprog/2022_2023/kv2/05_opklada/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom slu\u010daju ako primenimo operaciju na oba reda po jednom, kao i tri operacije na drugu kolonu, dobijamo ispisanu matricu, a ona ispunjava tra\u017eene nejednakosti, pa je validno re\u0161enje ispisano. U drugom slu\u010daju je mogu\u0107e dokazati da ne postoji re\u0161enje.</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq10\\)</li> <li>\\(1\\leq N\\leq 300\\)</li> <li>\\(-2\\times10^9\\le l_{i,j}\\le u_{i,j}\\le2\\times10^9\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N,M\\le10\\) i \\(u_{i,j}-l_{i,j}\\le1\\) za svako \\(1\\le i\\le N\\), \\(1\\le j\\le M\\).</li> <li>U testovima vrednim 10 poena: va\u017ei \\(l_{i,j}=u_{i,j}\\) za svako \\(1\\le i\\le N\\), \\(1\\le j\\le M\\).</li> <li>U testovima vrednim 15 poena: va\u017ei \\(l_{i,j}=u_{i,j}\\) za sva polja kada je \\(i=1\\) ili \\(j=1\\).</li> <li>U testovima vrednim 15 poena:  va\u017ei \\(l_{i,j}=u_{i,j}\\) za sva polja gde su \\(i\\) i \\(j\\) iste parnosti.</li> <li>U testovima vrednim 45 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/kv2/05_opklada/#resenje-kada-je-l_iju_ij","title":"Re\u0161enje kada je \\(l_{i,j}=u_{i,j}\\)","text":"<p>Neka je \\(c_i\\) broj operacija koje smo primenili na \\(i\\)-tu kolonu, a \\(r_i\\) broj operacija koje smo primenili na \\(i\\)-ti red. Preimtimo da je onda \\(m_{i,j}=r_{i}-c_{j}\\). iz ovoga mo\u017eemo da zaklju\u010dimo da je \\(m_{i,j}=r_{i}-c_{j}=r_{i}+r_{1}-c_{j}-c_{1}-m_{1,1}=(r_i-c_1)+(r_1-c_j)+m_{1,1}=m_{i,1}+m_{1,j}-m_{1,1}\\). Mo\u017ee se bez ve\u0107ih pote\u0161ko\u0107a dokazati da je ovaj uslov potreban i dovoljan uslov za Momirovu krajnju tabelu (su\u0161tinski re\u0161avanjem sistema jedna\u010dina za \\(r_i\\) i \\(c_i\\)). Tako da je potrebno samo proveriti uslov i nalazimo re\u0161enje u \\(O(TNM)\\).</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#resenje-kada-je-l_iju_ij-u-prvom-redu-i-koloni","title":"Re\u0161enje kada je \\(l_{i,j}=u_{i,j}\\) u prvom redu i koloni","text":"<p>Iz prethodnog podzadatka mo\u017eemo da vidimo zapravo da po\u0161to su nam fiksirani prvi red i kolona da nam je ostatak tabele fiksrian. Onda samo izra\u010dunamo koje vrednosti moraju da se nalaze na kraju u svakom polju i proverimo da li je u tra\u017eenom intervalu. Slo\u017eenost:  \\(O(TNM)\\).</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#resenje-kada-je-u_ij-l_ijleq1-i-nm10","title":"Re\u0161enje kada je \\(u_{i,j}-l_{i,j}\\leq1\\) i \\(N,M&lt;=10\\)","text":"<p>U ovom podzadatku, koristimo re\u0161enje prethodnog. Naime primetimo da za vrednosti u prvom redu i koloni imamo najvi\u0161e \\(2^{M+N-1}\\) opcija. Fiksiramo svaku od tih opcija i probamo algoritmom sli\u010dan onome u prethodnom podzadatku (sa potencijalno nekim odsecanjem zbog ubrzanja). Slo\u017eenost:  \\(O(T2^{M+N}NM)\\)</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#resenje-kada-je-l_iju_ij-u-svim-belim-poljima","title":"Re\u0161enje kada je \\(l_{i,j}=u_{i,j}\\) u svim belim poljima","text":"<p>Vratimo se na interpretaciju \\(m_{i,j}=r_{i}-c_{j}\\). Vidimo da nam polje gde je \\(l_{i,j}=u_{i,j}\\) daje jedinstvenu vezu izme\u0111u \\(r_{i}\\) i \\(c_{j}\\). Zbog uslova ovog zadatka, sve vrednosti \\(r_i\\) i \\(c_i\\) \u0107emo mo\u0107i da izrazimo samo preko \\(r_1\\) ili samo preko \\(r_2\\). Kada se te veze ispune i ubace u nejedna\u010dine ostalih polja, onda \u0107e sva preostala polja da nam daju neke nejedna\u010dine oblika \\(a\\le r_1-r_2\\le b\\). Kombinuju\u0107i ove nejednakosti po svim poljima, nalazimo u kom intervalu  \\(r_1-r_2\\) zaista treba da bude (kao presek svih gorenavedenih intervala), i odatle mo\u017eemo da uzmemo proizvoljnu vrednosti. Na kraju pustimo algoritam iz tre\u0107eg podzadatka (drugom u ovom tekstualnom re\u0161enju), da bismo videli da li je validno re\u0161enje to koje smo na\u0161li.</p>"},{"location":"takprog/2022_2023/kv2/05_opklada/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Primetimo da nam se uslovi u su\u0161tini svode na \\(l_{i,j}\\leq r_i-c_j\\leq u_{i,j}\\). Prezapi\u0161imo ovo kao \\(r_i-c_j\\leq u_{i,j}\\) i \\(c_j-r_i\\leq-l_{i,j}\\). Sada smo sveli zadatak: na re\u0161avanje sistema nejedna\u010dina po promenljivima \\(x_1,x_2\\cdots,x_{M+N}\\) gde je svaka nejedna\u010dina oblika \\(x_i-x_j\\leq c\\). Postoji generalni na\u010din na koji se ovo re\u0161ava koji \u0107emo prezentovati ovde.</p> <p>Napravimo graf \u010diji \u010dvorovi odgovaraju promenljivima na\u0161eg sistema nejedna\u010dina. Napravimo za svaku nejedna\u010dinu oblika \\(x_i-x_j\\leq c\\) granu od \u010dvora \\(j\\) do \u010dvora \\(i\\) sa te\u017einom \\(c\\). Pusti\u0107emo algoritam Belman-Ford, da bismo na\u0161li distancu od \\(1\\) do svakog drugog \u010dvora u ovom grafu. Tvrdimo da ukoliko u na\u0161em grafu postoji negativan ciklus, odgovor je da re\u0161enje ne postoji, dok ako ne postoji negativan ciklus, re\u0161enje uvek postoji i nalatimo ga kao \\(x_i=dist(1,i)\\). Ukoliko postoji negativan ciklus, onda neka je to ciklus \\(a_1,a_2,\\cdots,a_k\\). Tada za njih imamo neke nejednakosti oblika \\(x_{a_i}-x_{a_{i+1}}\\leq c_{i}\\) (indeksi uzeti po modulu \\(k\\)). Sada kad saberemo ove jedna\u010dine, svaki od promenljivih nam se skrati i dobijamo \\(0\\leq c_1+c_2+\\cdots+c_k&lt;0\\) (jer je u pitanju negativan ciklus). Iz ovoga zaklju\u010dujemo da kad ima negativan ciklus, re\u0161enje zaista ne postoji. Sada pretpostavimo da negativan ciklus ne postoji. Doka\u017eimo da je \\(x_i=dist(1,i)\\) zaista re\u0161enje. Treba da se uverimo da je \\(dist(1,i)-dist(1,j)\\leq c\\), odnosno \\(dist(1,j)+c\\geq dist(1,i)\\), \u0161to je svakako ta\u010dno jer je desna strana najkra\u0107i put od \\(1\\) do \\(i\\), dok leva strana predstavlja neki put od \\(1\\) do \\(i\\), gde prvo idemo do \\(j\\) a onda od \\(j\\) do \\(i\\) direktnom granom te\u017eine \\(c\\). Ovime smo se uverili da je ovo zaista re\u0161enje.</p> <p>Najzad da bismo fini\u0161irali zadatak, potrebno je dati dve fusnote na prethodni algoritam. Prva je da su neke vrednosti promenljivih mo\u017eda negativne, a nama trebaju samo pozitivne vrednosti. Ovo, me\u0111utim, nije problem jer mo\u017eemo svim promenljivama da dodamo neko \\(k\\) da bi smo dobili opet validno re\u0161enje sistema, gde su sve promeljive ve\u0107e za \\(k\\), pa za dovoljno veliko \\(k\\) i pozitivne. Druga bitna stvar je da re\u0161enje ovakvog sistema jedna\u010dina, u generalnom slu\u010daju, ne mora biti samo od celih brojeva. Me\u0111utim, zbog na\u010dina koji smo na\u0161li re\u0161enja, to jest kao najkra\u0107i put u nekom grafu gde su te\u017eine svih grana cele, onda \u0107e ovo re\u0161enje koje smo detektovali u gornjem algoritmu ipak biti validno.</p> <p>Ovime smo re\u0161ili zadatak u \\(O(TNM(N+M))\\).</p> 05_opklada.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 307\nusing namespace std;\nlong long ev[2*MAXN*MAXN],d[2*MAXN],dist[2*MAXN],l[MAXN][MAXN],u[MAXN][MAXN];\nint ep[2*MAXN*MAXN],ek[2*MAXN*MAXN],br,a;\nvoid bellman_ford_iter() {for(int i=0;i&lt;br;i++) d[ek[i]]=min(d[ek[i]],d[ep[i]]+ev[i]);}\nint main()\n{\n    int t;\n    scanf(\"%d\",&amp;t);\n    while(t--)\n    {\n        int n,m; br=0;\n        scanf(\"%d%d\",&amp;n,&amp;m);\n        for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)\n        {\n            scanf(\"%d\",&amp;a);\n            l[i][j]=a;\n            ep[br]=i;\n            ek[br]=n+j;\n            ev[br++]=-a;\n        }\n        for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)\n        {\n            scanf(\"%d\",&amp;a);\n            ep[br]=n+j;\n            ek[br]=i;\n            ev[br++]=a;\n        }\n        d[0]=0;\n        for(int i=1;i&lt;n+m;i++) d[i]=1000000000000000000LL;\n        for(int i=0;i&lt;n+m;i++) bellman_ford_iter();\n        for(int i=0;i&lt;n+m;i++) dist[i]=d[i];\n        bellman_ford_iter();\n        bool fail=false;\n        for(int i=0;i&lt;n+m;i++) if(d[i]!=dist[i]) fail=true;\n        if(fail) {printf(\"NE\\n\"); continue;}\n        printf(\"DA\\n\");\n        for(int i=0;i&lt;n;i++)\n        {\n            for(int j=0;j&lt;m;j++) printf(\"%lld \",d[i]-d[n+j]);\n            printf(\"\\n\");\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/01_kuvar/","title":"B1 - Kuvar","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Poznati TV kuvar Epirka planira slede\u0107u sezonu svoje emisije, u kojoj \u0107e snimiti \\(N\\) emisija o jelima \\(X_1, X_2, \\dots, X_N\\) (ne neophodno razli\u010ditim -- mogu\u0107e je da snima vi\u0161e emisija o istom jelu). Radi jednostavnosti, predstavi\u0107emo ova jela brojevima (isto od \\(1\\) do \\(N\\)): ako je \\(X_i = x\\), \\(i\\)-ta emisija \u0107e biti o jelu \\(x\\).</p> <p>Na raspolaganju mu je \\(N\\) recepata \\(Y_1, Y_2, \\dots, Y_N\\), isto predstavljeni brojevima. Po\u0161to emisija mora biti zanimljiva, nisu dovoljni recepti, ve\u0107 i scenario: smislio je (isto) \\(N\\) scenarija \\(Z_1, Z_2, \\dots, Z_K\\), gde \\(Z_i = z\\) zna\u010di da se \\(i\\)-ti scenario mo\u017ee koristiti za emisiju u kojoj \u0107e praviti jelo \\(Y_{z}\\).</p> <p>Nakon \u0161to je popisao emisije, jela i recepte, interesuje ga na koliko na\u010dina mo\u017ee da po\u010dne snimanje, odnosno na koliko na\u010dina mo\u017ee da izabere emisiju \\(i\\) i scenario \\(j\\) o receptu za odgovaraju\u0107e jelo. Drugim re\u010dima, interesuje ga broj ure\u0111enih parova \\((i, j)\\), za koje va\u017ei \\(X_i = Y_{Z_j}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Dimitrije Erdeljan Dimitrije Erdeljan Marko \u0160i\u0161ovi\u0107"},{"location":"takprog/2022_2023/okr/01_kuvar/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei jedan prirodan broj \\(N\\): broj emisija, recepata i scenarija.</p> <p>Drugi red sadr\u017ei \\(N\\) prirodnih brojeva \\(X_1, X_2, \\dots, X_N\\), gde je \\(X_i\\) jelo o kom \u0107e snimiti \\(i\\)-tu emisiju.</p> <p>Tre\u0107i red sadr\u017ei \\(N\\) prirodnih brojeva \\(Y_1, Y_2, \\dots, Y_N\\), gde je \\(Y_j\\) jelo koje se pravi po \\(j\\)-tom receptu.</p> <p>\u010cetvrti red sadr\u017ei \\(N\\) prirodnih brojeva \\(Z_1, Z_2, \\dots, Z_N\\), gde je \\(Z_k\\) recept koji se koristi u \\(k\\)-tom scenariju. Scenariji su indeksirani po\u010dev od 1.</p>"},{"location":"takprog/2022_2023/okr/01_kuvar/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je potrebno ispisati jedan ceo broj: broj na\u010dina na koje je mogu\u0107e izabrati emisiju i scenario, tako da recept koji odgovara tom scenariju pravi jelo o kom \u0107e emisija biti.</p>"},{"location":"takprog/2022_2023/okr/01_kuvar/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/okr/01_kuvar/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 1 4 3\n3 1 3 4\n1 3 2 2\n</code></pre>"},{"location":"takprog/2022_2023/okr/01_kuvar/#izlaz","title":"Izlaz","text":"<pre><code>6\n</code></pre>"},{"location":"takprog/2022_2023/okr/01_kuvar/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/okr/01_kuvar/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n1 1 1 1 1\n2 1 5 5 5\n2 1 2 3 3\n</code></pre>"},{"location":"takprog/2022_2023/okr/01_kuvar/#izlaz_1","title":"Izlaz","text":"<pre><code>10\n</code></pre>"},{"location":"takprog/2022_2023/okr/01_kuvar/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako se u prvom primeru odlu\u010di za prvu epizodu, pravi\u0107e jelo \\(1\\), koje se pravi samo po drugom receptu. Za taj recept postoje dva mogu\u0107a scenarija: tre\u0107i i \u010detvrti.</p> <p>Sli\u010dno, drugoj epizodi odgovaraju tre\u0107i i \u010detvrti scenario.</p> <p>Tre\u0107a epizoda je o jelu \\(4\\), za koje nema na raspolaganju nijedan scenario.</p> <p>\u010cetvrta epizoda je o jelu \\(3\\), koje se pravi po prvom i tre\u0107em receptu. Za prvi recept ima spreman scenario \\(1\\), a za drugi scenario \\(2\\), tako da i za ovu epizodu ima na raspolaganju dva scenarija.</p> <p>Dakle, ukupno ima \\(2 + 2 + 0 + 2 = 6\\) opcija.</p>"},{"location":"takprog/2022_2023/okr/01_kuvar/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 10^5\\).</li> <li>\\(1 \\leq X_i, Y_i, Z_i \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 20 poena: \\(N \\leq 1000\\) i \\(Z_i = i\\) za sve \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 20 poena: \\(N \\leq 1000\\).</li> <li>U testovima vrednim 10 poena: svi \\(Z_i\\) su isti.</li> <li>U testovima vrednim 20 poena: \\(Z_i = i\\) za sve \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 30 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/01_kuvar/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Prva dva podzadatka mo\u017eemo jednostavno re\u0161iti sa dve ugnje\u017edene petlje koje isprobavaju svaki par \\((i, j)\\) i broje za koliko takvih parova je \\(X_i = Z_{Y_j}\\). Vremenska slo\u017eenost ovog algoritma je \\(\\mathcal{O}(N^2)\\), \u0161to ne\u0107e biti dovoljno za preostale podzadatke.</p> <p>Algoritam mo\u017eemo pobolj\u0161ati tako \u0161to razdvojimo ove dve petlje: prvo \u0107emo prebrojati koliko postoji epizoda za svako mogu\u0107e jelo, odnosno izra\u010dunati niz \\(C\\), gde je \\(C_i\\) broj indeksa \\(j\\) gde \\(X_j = i\\). Po\u0161to su sve vrednosti \\(X_i\\) najvi\u0161e \\(N\\), ovaj niz staje u memoriju i mo\u017eemo ga popuniti jednim prolazom kroz \\(X\\).</p> <p>Sada je dovoljno da pro\u0111emo kroz \\(Z\\), i za svako \\(Z_i\\) ukupnom broju dodamo \\(C_{Z_i}\\) (broj elemenata u \\(X\\) koji bi bili odgovaraju\u0107i par). Vremenska slo\u017eenost je sada \\(\\mathcal{O}(N)\\), sasvim dovoljno za \\(N \\leq 10^5\\).</p> 01_kuvar.cpp<pre><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nconst int N = 100005;\nint x[N], y[N], z[N];\nint cnt[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;x[i]);\n    for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;y[i]);\n    for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;z[i]);\n\n    long long res = 0;\n    for(int i = 0; i &lt; n; i++) cnt[x[i]]++;\n    for(int i = 0; i &lt; n; i++) res += cnt[y[z[i] - 1]];\n\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/","title":"B2 - Razmena znaka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>\u017dika je za ro\u0111endan dobio ono \u0161to protagonisti informati\u010dkih zadataka uvek dobiju kad pisci tekstova nemaju bolju ideju o \u010demu da naprave pri\u010du u svom zadatku - niz \\(A_i\\) od \\(N\\) celih brojeva. Me\u0111utim, ovaj fenomen je toliko \u010dest, da je \u017dika i za pro\u0161li ro\u0111endan dobio niz du\u017eine \\(N\\) - niz \\(B_i\\)! \u017dika, kao i svaki normalan \u010dovek, nema potrebe za dva razli\u010dita niza du\u017eine \\(N\\), pa ho\u0107e da transformi\u0161e svoj novodobijeni niz \\(A_i\\) u \\(B_i\\). </p> <p>Po\u0161to nam je potreban zadatak za svrhu drugog zadatka u B kategoriji, \u017dika je odlu\u010dio da jedina operacija koju mo\u017ee da izvr\u0161i na nizu \\(A\\) je da izabere dva susedna broja u nizu i zameni im mesta, a zatim im promeni znakove. Ovo zna\u010di da ako je niz pre bio \\(A_1\\), \\(A_2\\), \\(\\cdots\\), \\(A_i\\), \\(A_{i+1}\\), \\(\\cdots\\), \\(A_N\\), posle jedne operacije postaje \\(A_1\\), \\(A_2\\), \\(\\cdots\\), \\(-A_{i+1}\\), \\(-A_i\\), \\(\\cdots\\), \\(A_N\\). Va\u0161 zadatak je da ka\u017eete \u017diki da li je mogu\u0107e da ovim operacijama tranformi\u0161e niz \\(A_i\\) tako da va\u017ei da je \\(A_i=B_i\\) za svako \\(i\\in\\{1,2,\\cdots,N\\}\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Dragan Uro\u0161evi\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei broj test primera \\(T\\). U narednim redovima su opisani svaki od nezavisnih \\(T\\) test primera. U prvom redu svakog test primera se nalazi jedan nenegativan ceo broj \\(N\\) koji predstavlja du\u017eine nizova \\(A_i\\) i \\(B_i\\). Zatim u naredna dva reda se nalazi po \\(N\\) celih brojeva, koji predstavljaju vrednosti u nizovima \\(A_i\\) i \\(B_i\\), redom.</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(i\\)-tom redu standardnog izlaza napisati odgovor  na \\(i\\)-ti test primer. Ako je mogu\u0107e sti\u0107i od niza \\(A_i\\) do niza \\(B_i\\) primenkom kona\u010dno mnogo opisanih operacija, napisati \"DA\" (bez navodnika), a u suprotnom \"NE\" (opet, bez navodnika).</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#primer","title":"Primer","text":""},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#ulaz","title":"Ulaz","text":"<pre><code>3\n2\n1 2\n-1 -2\n2\n1 2\n-2 -1\n4\n1 2 3 4\n-4 -3 -2 -1\n</code></pre>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#izlaz","title":"Izlaz","text":"<pre><code>NE\nDA\nDA\n</code></pre>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Ako je po\u010detni niz \\(1,2\\), jedini drugi niz koji je mogu\u0107e dobiti je \\(-2,-1\\) (primenom jo\u0161 jedne zamene, vra\u0107a se na originalni niz), tako da je odgovor u test primeru upitu \"NE\", a u drugom \"DA\". U tre\u0107em primeru je mogu\u0107e na\u0107i niz poteza koji \\(A_i\\) pretvara u \\(B_i\\) tako \u0161to redom radimo razmene na \\((1,2)\\), \\((2,3)\\), \\((3,4)\\), \\((1,2)\\), \\((2,3)\\), \\((1,2)\\). </p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 10\\).</li> <li>\\(1 \\leq N \\leq 30.000\\).</li> <li>\\(0\\leq |A_i|,|B_i|\\leq 1.000.000.000\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim \\(15\\) poena: U oba niza su sve vrednosti \\(0\\) osim jedne.</li> <li>U test primerima vrednim \\(25\\) poena: \\(A_i,B_i\\in\\{-1,1\\}\\).</li> <li>U test primerima vrednim \\(25\\) poena: \\(|A_i|\\neq|A_j|\\) i \\(|B_i|\\neq|B_j|\\) za \\(i\\neq j\\).</li> <li>U test primerima vrednim \\(35\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#analiza","title":"Analiza","text":"<p>Pretpostavimo za trenutak da se operacija koju izvr\u0161ava \u017dika sastoji samo od zamene mesta dva susedna elementa, tj. da se ne izvr\u0161ava promena znaka. Mo\u017ee se pokazati da se primenom takve operacije, od polaznog niza mo\u017ee dobiti bilo koji niz sastavljen od elemenata niza \\(A\\), tj. bilo koji raspored elemenata niza \\(A\\): $$ A_{i_1}, A_{i_2}, A_{i_3}, \\dots, A_{i_n}.  $$</p> <p>Ako operacija koju izvodi \u017dika sastoji i od promene znaka, onda je za odre\u0111ivanje vrednosti nekog elementa nakon izvo\u0111enja svih operacija dovoljno da znamo njegovu po\u010detnu poziciju i njegovu poziciju na kraju (tj. nakon svih izvedenih operacija). Naime, \u010dak i u slu\u010daju da se isti element pomerao levo-desno (prema po\u010detku i prema kraju), njegov znak na kraju \u0107e biti odre\u0111en samo rastojanjem izme\u0111u po\u010detne o krajnje pozicije (zato \u0161to se pri svakom pomeranju levo-desno ili desno-levo izvodi paran broj operacija, pa element niza promeni znak paran broj puta, a to zna\u010di da ima isti znak kao da to pomeranje levo-desno nije ni izvodio).</p> <p>Prema tome, ako se element \\(A_i\\) premestio sa pozicije \\(i\\) na poziciju \\(j\\) (\\(j\\lt i\\)), onda \u0107e njegova vrednost biti  \\(B_j = (-1)^{i-j}A_i\\), tj. \\(B_j = (-1)^i : (-1)^j A_i\\), odnosno va\u017ei\u0107e \\((-1)^j B_j = (-1)^i A_i\\). Sli\u010dno, ako se element \\(A_i\\) premestio sa pozicije \\(i\\) na poziciju \\(j\\) (\\(j&gt;i\\)), onda \u0107e njegova vrednost biti  \\(B_j = (-1)^{j-i}A_i = (-1)^{i-j}A_i\\), tj. \\(B_j = (-1)^i : (-1)^j A_i\\), odnosno va\u017ei\u0107e \\((-1)^j B_j = (-1)^i A_i\\).   Odavde zaklju\u010dujemo da \u017dika od niza \\(A\\) mo\u017ee dobiti niz \\(B\\) ako i samo ako se nizovi \\(C\\) (\\(C_i = (-1)^iA_i\\)) i \\(D\\) (\\(D_i = (-1)^iB_i\\)) sastoje od istih elemenata (naravno, ne nu\u017eno na istim pozicijama).</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#resenje-prvog-podzadatka","title":"Re\u0161enje prvog podzadatka","text":"<p>U ovom slu\u010daju je dovoljno odrediti pozicije elemenata koji su razli\u010diti od nule. Ako je \\(A_i \\ne 0\\) i \\(B_j \\ne 0\\), tada mogu nastupiti tri slu\u010daja</p> <ul> <li>Ako je \\(A_i = B_j\\) i \\(2 | (i-j)\\), onda se od niza \\(A\\) mo\u017ee dobiti niz \\(B\\);</li> <li>Ako je \\(A_i = -B_j\\) i \\(2 \\not | (i-j)\\), onda se od niza \\(A\\) mo\u017ee dobiti niz \\(B\\);</li> <li>Ako ne va\u017ei nijedan od dva gornja uslova, onda od niza \\(A\\) nije mogu\u0107e dobiti niz \\(B\\).</li> </ul> <p>Slo\u017eenost opisanog re\u0161enja je \\(\\Theta(n)\\).</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#resenje-drugog-podzadatka","title":"Re\u0161enje drugog podzadatka","text":"<p>Prema analizi, niz \\(B\\) se mo\u017ee dobiti od niza \\(A\\) ako i samo ako se nizovi \\(C\\) (\\(C_i = (-1)^iA_i\\)) i \\(D\\) (\\(D_i = (-1)^iB_i\\)) sastoje od istih elemenata. Me\u0111utim svi elementi nizova \\(C\\) i \\(D\\) imaju vrednost \\(1\\) ili \\(-1\\) i dovoljno je izbrojati da li nizovi \\(C\\) i \\(D\\) imaju isti broj elemenata \u010dija je vrednost \\(1\\) (odnosno isti broj elemenata \u010dija je vrednost \\(-1\\)), Slo\u017eenost opisanog re\u0161enja je \\(\\Theta(n)\\).</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#resenje-treceg-podzadatka","title":"Re\u0161enje tre\u0107eg podzadatka","text":"<p>U ovom slu\u010daju mo\u017eemo sortirati nizove parova \\(E\\) \\((E_i = (|A_i|, i))\\) i \\(F\\) \\((F_i=(|B_i|, i))\\), pri \u010demu parove poredimo po vrednosti prvog elementa (komponente) para. Tada od niza \\(A\\) mo\u017eemo dobiti niz \\(B\\), ako i samo ako za sve odgovaraju\u0107e parove va\u017ei -   prvi elementi parova moraju biti jednaki (jer oni predstavljaju apsolutne vrednosti odgovaraju\u0107ih elemenata nizova \\(A\\) i \\(B\\)); -   drugi elementi parova predstavljaju pozicije tih elemenata u nizovima \\(A\\) i \\(B\\); na osnovu pozicija mo\u017eemo saznati i odgovaraju\u0107e elemente nizova \\(A\\) i \\(B\\); oni treba da budu jednaki (ako je razlika pozicija parna) ili suprotnih znakova (ako je razlika pozicija neparna).</p> <p>Slo\u017eenost opisanog re\u0161enja je \\(\\Theta(n\\log n)\\), zbog sortiranja nizova.</p>"},{"location":"takprog/2022_2023/okr/02_razmena_znaka/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Koristimo \u010dinjenicu da nizovi \\(C\\) i \\(D\\), opisani u Analizi, treba da sadr\u017ee iste elemente (naravno, ako se od niza \\(A\\)  mo\u017ee dobiti niz \\(B\\)). Ako te nizove sortiramo, onda odgovaraju\u0107i elementi imaju jednake vrednosti. Zbog toga mo\u017eemo srtirati nizove \\(C\\) i \\(D\\) i proveriti da li su odgovaraju\u0107i elementi jednaki. Slo\u017eenost opisanog re\u0161enja je \\(\\Theta(n\\log n)\\), zbog sortiranja nizova.</p> 02_razmena_znaka.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 30007\nusing namespace std;\nint a[MAXN],b[MAXN];\nint main()\n{\n    int t;\n    cin&gt;&gt;t;\n    while(t--)\n    {\n        int n;\n        cin&gt;&gt;n;\n        for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n        for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i];\n        for(int i=0;i&lt;n;i++) if(i&amp;1) a[i]=-a[i];\n        for(int i=0;i&lt;n;i++) if(i&amp;1) b[i]=-b[i];\n        sort(a,a+n);\n        sort(b,b+n);\n        bool ok=true;\n        for(int i=0;i&lt;n;i++) if(a[i]!=b[i]) ok=false;\n        if(ok) cout&lt;&lt;\"DA\\n\";\n        else cout&lt;&lt;\"NE\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/03_pikado/","title":"B3 - Jednostavni pikado","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 512MB <p>Bane igra jednostavni pikado koji je organizovan tako da je tabla standardna \\(xy\\) ravan sa nekoliko (kona\u010dno mnogo) takozvanih \"kontrolnih ta\u010daka\" \\((x_1, y_1)\\), \\((x_2, y_2)\\), \\(\\ldots\\) sa celobrojnim koordinatama.</p> <p>Za ovaj pikado va\u017ee posebna pravila! Neka je broj kontrolnih ta\u010daka \\(N\\). Bane \u0107e baciti strelicu i ukoliko ta strelica pogodi ravan u ta\u010dki sa koordinatama \\((x_A, y_A)\\), tada Bane osvaja poene na slede\u0107i na\u010din: - Ako za svaku kontrolnu ta\u010dku \\((x_i, y_i)\\) va\u017ei da je \\(x_i \\neq x_A\\), Bane osvaja 0 poena; - Ako za svaku kontrolnu ta\u010dku \\((x_i, y_i)\\) va\u017ei da je \\(y_i \\neq y_A\\), Bane osvaja 0 poena;  - Ina\u010de (tj. ako me\u0111u kontrolnim ta\u010dkama postoji bar jedna sa \\(x\\) koordinatom jednakom \\(x_A\\) i bar jedna sa \\(y\\) koordinatom jednakom \\(y_A\\)) broj poena koje Bane osvaja je jednak </p> \\[\\sum_{i=1}^{N}|x_i-x_A|\\cdot|y_i-y_A|\\] <p>Dat je niz od \\(M\\) ta\u010daka sa celobrojnim koordinatama \\((x_1, y_1)\\), \\((x_2, y_2)\\), \\(\\ldots\\) \\((x_M, y_M)\\). Za svako \\(i = 1,2, \\ldots, M\\) ispisati koji je najve\u0107i broj poena koji Bane mo\u017ee da dobije u jednom bacanju ukoliko skup kontrolnih ta\u010daka sadr\u017ei samo prvih \\(i\\) ta\u010daka ovog niza. Rezultate ispisivati po modulu \\(10^9 + 7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107 Mom\u010dilo To\u0161i\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/okr/03_pikado/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se ceo broj \\(M\\) - ukupan broj ta\u010daka u nizu</p> <p>U narednih \\(M\\) linija nalaze se parovi celih brojeva odvojenih razmakom koji predstavljaju koordinate ta\u010daka \\(x_i, y_i\\)</p>"},{"location":"takprog/2022_2023/okr/03_pikado/#opis-izlaza","title":"Opis izlaza","text":"<p>U \\(M\\) linija ispisati brojeve \\(R_1, R_2, ..., R_M\\), redom, gde je \\(R_i\\) najve\u0107i mogu\u0107i broj poena po modulu \\(10^9 + 7\\) koji Bane mo\u017ee osvojiti ako skup kontrolnih ta\u010daka sadr\u017ei isklju\u010divo prvih \\(i\\) ta\u010daka iz niza. </p>"},{"location":"takprog/2022_2023/okr/03_pikado/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/okr/03_pikado/#ulaz","title":"Ulaz","text":"<pre><code>3\n2 1\n1 2\n3 3\n</code></pre>"},{"location":"takprog/2022_2023/okr/03_pikado/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n4\n</code></pre>"},{"location":"takprog/2022_2023/okr/03_pikado/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/okr/03_pikado/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 2\n2 1\n5 4\n3 5\n</code></pre>"},{"location":"takprog/2022_2023/okr/03_pikado/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n1\n17\n24\n</code></pre>"},{"location":"takprog/2022_2023/okr/03_pikado/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, ako je kontrolna samo prva ta\u010dka, gde god da strelica pogodi, dobija se \\(0\\) poena. Ako su nam kontrolne prve dve ta\u010dke mo\u017eemo \"pogoditi\" \\((1, 2)\\), i dobiti rezultat \\(1\\cdot1+0\\cdot0=1\\), a ako su sve tri ta\u010dke, optimalna je ta\u010dka \\((1, 1)\\), gde je rezultat \\(1\\cdot 0+0\\cdot 1+2\\cdot 2=4\\).</p>"},{"location":"takprog/2022_2023/okr/03_pikado/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq M \\leq 10^6\\).</li> <li>\\(|x_i|, |y_i| \\leq 10^5\\).</li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena, \\(1 \\leq M \\leq 100\\).</li> <li>U test primerima vrednim \\(10\\) poena, \\(1 \\leq M \\leq 500\\).</li> <li>U test primerima vrednim \\(15\\) poena, \\(1 \\leq M \\leq 2000\\).</li> <li>U test primerima vrednim \\(15\\) poena, \\(1 \\leq M \\leq 2\\cdot 10^5\\).</li> <li>U test primerima vrednim \\(10\\) poena, \\(1 \\leq M \\leq 10^5\\) i \\(0 \\leq x_i, y_i \\leq 10\\).</li> <li>U test primerima vrednim \\(40\\) poena nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/03_pikado/#analiza","title":"Analiza","text":"<p>Uo\u010dimo da Bane dobija poene samo ako izabere ta\u010dku sa \\(x\\) koordinatom me\u0111u unetim \\(x\\) koordinatama, i sa \\(y\\) koordinatom koja tako\u0111e pripada nekoj od kontrolnih ta\u010daka. Dakle, za re\u0161enje za prvih \\(i\\) ta\u010daka biramo \\(x_A\\) iz skupa \\(x_1,x_2,\\ldots x_i\\) i \\(y_A\\) iz skupa \\(y_1,y_2,\\ldots y_i\\) takve da je opisana suma maksimalna.</p>"},{"location":"takprog/2022_2023/okr/03_pikado/#resenje-u-om4","title":"Re\u0161enje u \\(O(M^4)\\)","text":"<p>Za svako \\(i \\leq M\\) potrebno je iterirati kroz sve mogu\u0107e parove \\(x_A,y_A\\) iz pomenutih skupova (kvadratna slo\u017eenost) i prona\u0107i zbir iz zadatka (linearna slo\u017eenost). Ukupno je potrebno \\(O(M^4)\\) koraka.</p>"},{"location":"takprog/2022_2023/okr/03_pikado/#resenje-u-om3","title":"Re\u0161enje u \\(O(M^3)\\)","text":"<p>Fiksirajmo \\(x\\) koordinatu. Tada je formula za broj poena koji maksimizujemo u obliku \\(\\sum_{j=1}^{i} const*|y_j-y_A|\\)</p> <p>Intuicija nam govori da ova suma \"odlazi u beskona\u010dnost\" kada izabrana ipsilon koordinata ili velika (ka beskona\u010dnosti) ili mala (ka minus beskona\u010dnosti) te mo\u017eemo poku\u0161ati samo vrednost najve\u0107eg \\(y_j\\) i najmanjeg \\(y_j\\), \u0161to daje br\u017ee re\u0161enje jer radimo isto kao u pro\u0161lom podzadatku samo proveravamo dve vrednosti za \\(y\\) (minimum i maksimum a\u017euriramo kako se unose nove ta\u010dke). </p>"},{"location":"takprog/2022_2023/okr/03_pikado/#resenje-u-om2","title":"Re\u0161enje u \\(O(M^2)\\)","text":"<p>Doka\u017eimo intuiciju iz prethodnog re\u0161enja. Dokaza\u0107emo gramziv pristup tako \u0161to doka\u017eemo da uvek mo\u017eemo dobiti re\u0161enje koje nije lo\u0161ije tako \u0161to umesto neke ipsilon koordinate izaberemo neku manju ili ve\u0107u (i stoga je najbolje birati najmanju ili najve\u0107u).</p> <p>Neka su svi \\(y\\) jednako razmaknuti (ovo nije problemati\u010dna pretpostavka, naime, ako nisu, dodavanjem fiktivnih me\u0111uvrednosti ni\u0161ta ne menjamo jer ove vrednosti daju skor 0). Fiksijarmo \\(x\\) koordinatu i posmatrajmo re\u0161enje za \\(N\\) ta\u010daka i odabrano \\(y=y_i\\). Tada posmatrajmo kako se suma menja ako odaberemo \\(y\\) koordinatu levo, odnosno desno, od \\(y_i\\). Naime, ako je fiksirano \\(x\\), suma je u obliku \\(\\sum_{j=1}^{N} const*|y_j-y_i|\\)</p> <p>Poku\u0161ajmo sada da vidimo \u0161ta se de\u0161ava kada izabranu ipsilon koordinatu \"pomerimo\" za \\(\\Delta y\\) koje je razlika dveju ipsilon koordinata (dalje formule ne zavise od toga da li je pozitivno ili negativno). </p> <p>Neka su i bez gubljenja op\u0161tosti ipsilon koordinate ure\u0111ene tako da je prvih \\(i-1\\) manje od \\(y_i\\), a izme\u0111u \\(i\\) i \\(k\\) su jednake, dok su nakon \\(k\\) ve\u0107e.  Tada \u0107e suma biti (\\(const\\) predstavljaju pozitivne konstante - apsolutne razlike \\(x\\) koordinata i fiksirane \\(x\\) koord.)</p> \\[ \\sum_{j=1}^{N} const*|y_j+\\Delta y-y_i| = \\sum_{j=1}^{i-1} const*(y_i-y_j-\\Delta y)+\\sum_{j=k}^{N} const*(y_j+\\Delta y-y_i) + (k-i)*const*|\\Delta y| \\] <p>Izdvojimo prethodnu sumu:</p> \\[ \\sum_{j=1}^{N} const*|y_j-y_i| - \\sum_{j=1}^{k} const*\\Delta y + \\sum_{j=k+1}^{i} const*\\Delta y + const*|\\Delta y| = \\sum_{j=1}^{i} const*|y_j-y_A| + P_i*\\Delta y + Q_i*|\\Delta y|  \\] <p>Vidimo da se Banetov skor promenio za \\(P_i*\\Delta y + Q_i*|\\Delta y|\\).</p> <p>Da li je \\(P_i\\) pozitivan, negativan, ili nula ne zavisi od toga da li poku\u0161avamo da se \"pomerimo\" u levo ili u desno ve\u0107 samo od iks vrednosti. Kako je \\(Q_i\\) uvek nenegatino, to je \\(P_i*\\Delta y + Q_i*|\\Delta y|\\) u zavisnosti od znaka \\(\\Delta y\\) (pozitivno predstavlja pomeranje u desno, ka najve\u0107em \\(y\\), a negativno u levo, ka najmanjem) ili u oba slu\u010daja nenegativna vrednost, ili u jednom slu\u010daju negativna, a u drugom nenegativna. Svakako, mo\u017eemo odabrati ono \\(y\\) za koje je ova vrednost nenegativna, odnosno Banetov skor nije manji, i stoga se \"pomeriti\" ka najve\u0107em ili najmanjem \\(y\\). Induktivno sledi da najve\u0107e ili najmanje \\(y\\) koje mo\u017eemo da odaberemo i daju najbolje re\u0161enje.</p> <p>Ako sada fiksiramo \\(y\\), zbog potpuno simetri\u010dnog izraza, analogno dokazujemo da treba odabrati najmanje ili najve\u0107e \\(x\\). Izbor jedne koordinate ne zavisi od izbora druge, te dolazimo do zaklju\u010dka da postoji samo 4 mogu\u0107nosti za \\(x_A,y_A\\) a to su najve\u0107a i najmanja \\(x\\) i \\(y\\) koordinata.</p> <p>Ove \u010detiri sume mo\u017eemo izra\u010dunati za svaki prefiks niza ta\u010daka, ili iskoristiti ideju razdvajanja na dve sume iz dokaza za pun broj poena.</p>"},{"location":"takprog/2022_2023/okr/03_pikado/#resenje-u-om","title":"Re\u0161enje u \\(O(M)\\)","text":"<p>Uo\u010dimo da ako biramo ekstremne vrednosti \\(x\\) i \\(y\\) koordinata sume gube apsolutne zagrade i mogu se raspisati tako da u njima faktori\u0161u  \\(\\sum_{i=1}^{N}x_i*y_i\\),  \\(x_A*\\sum_{i=1}^{N}y_i\\),  \\(y_A*\\sum_{i=1}^{N}y_i\\) i  \\(y_A*x_A\\), te se 4 mogu\u0107e sume mogu izra\u010dunati u konstantoj slo\u017eenosti ako se sume iz ovih faktora a\u017euriraju prilikom unosa svake nove ta\u010dke.</p> 03_pikado.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int m;\n    cin &gt;&gt; m;\n\n    long long ans = 0;\n    long long maxX = -2e6, minX = 2e6, maxY = -2e6, minY = 2e6, xS=0, yS = 0, pS = 0;\n\n    for(int i = 0; i &lt; m; ++i){\n        long long xT, yT;\n        cin &gt;&gt; xT &gt;&gt; yT;\n        minY = min(minY, yT);\n        maxY = max(yT, maxY);\n        maxX = max(xT, maxX);\n        minX = min(minX, xT);\n        xS += xT;\n        pS += xT*yT;\n        yS += yT;\n        ans = max(ans, pS - minX*yS - minY*xS + (i+1)*minX*minY);\n        ans = max(ans, -1*pS + minX*yS + maxY*xS - (i+1)*minX*maxY);\n        ans = max(ans, -1*pS + maxX*yS + minY*xS - (i+1)*maxX*minY);\n        ans = max(ans, pS - maxX*yS - maxY*xS + (i+1)*maxX*maxY);\n\n        cout &lt;&lt; ans%mod &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/04_poklon/","title":"A1 - Poklon","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 128MB <p>Kao nagradu za prolaz na okru\u017eno takmi\u010denje, komisija Vam poklanja \\(Q\\) nizova. Svaki od nizova je dobijen tako \u0161to je od glavnog niza \\(A\\), du\u017eine \\(N\\), kopiran neki uzastopni podniz. Preciznije, \\(i\\)-ti niz je odre\u0111en vrednostima \\(l_i\\) i \\(r_i\\), \u0161to zna\u010di da on sadr\u017ei elemente \\({A_{l_i}, A_{l_i+1}, ... , A_{r_i}}\\), u tom redosledu.</p> <p>Vama se, me\u0111utim, ovaj poklon ne svi\u0111a mnogo, jer Vi volite samo nizove koji su sortirani u neopadaju\u0107em poretku. Zato \u0107ete malo izmeniti nizove koje ste dobili. Po\u0161to ne \u017eelite da ispadnete nezahvalni, ne\u0107ete ih mnogo menjati, pa \u0107ete iz svakog niza izbrisati najvi\u0161e jedan element. Tako\u0111e, po\u0161to Vas ipak mrzi da sada menjate toliki broj nizova, dovoljno je da za svaki od njih samo odredite da li ga je uop\u0161te mogu\u0107e izmeniti da postane sortiran.</p> <p>Podrazumeva se da brisanje elementa iz jednog niza ne uti\u010de na druge nizove.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Jovan Bengin Jovan Bengin Dragan Uro\u0161evi\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2022_2023/okr/04_poklon/#opis-ulaza","title":"Opis ulaza","text":"<p>Prvi red standardnog ulaza sadr\u017ei ceo broj \\(N\\), broj elemenata glavnog niza.</p> <p>Drugi red sadr\u017ei \\(N\\) celih brojeva koji predstavljaju glavni niz \\(A_1, A_2, ..., A_N\\).</p> <p>Tre\u0107i red sadr\u017ei ceo broj \\(Q\\), broj poklonjenih nizova.</p> <p>Narednih \\(Q\\) redova sadr\u017ee po dva broja, \\(l_i, r_i\\), koji ozna\u010davaju da \\(i\\)-ti niz sadr\u017ei elemente \\({A_{l_i}, A_{l_i+1}, ... , A_{r_i}}\\), u tom redosledu.</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz je potrebno ispisati \\(Q\\) linija - u \\(i\\)-toj liniji ispisati \"DA\" (bez navodnika) ako je \\(i\\)-ti niz mogu\u0107e sortirati brisanjem najvi\u0161e jednog elementa, u suprotnom ispisati \"NE\" (bez navodnika).</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/okr/04_poklon/#ulaz","title":"Ulaz","text":"<pre><code>7\n1 7 2 7 2 2 3\n4\n1 4\n2 7\n4 6\n5 5\n</code></pre>"},{"location":"takprog/2022_2023/okr/04_poklon/#izlaz","title":"Izlaz","text":"<pre><code>DA\nNE\nDA\nDA\n</code></pre>"},{"location":"takprog/2022_2023/okr/04_poklon/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Prvi niz je \\([A_1, A_2, A_3, A_4]\\), tj. \\([1, 7, 2, 7]\\). Iz njega mo\u017eemo izbrisati drugi element da bismo dobili niz \\([1, 2, 7]\\).</p> <p>Drugi niz je \\([A_2, A_3, A_4, A_5, A_6, A_7]\\), tj. \\([7, 2, 7, 2, 2, 3]\\). Mo\u017ee se videti da koji god element izbri\u0161emo, niz ne\u0107e biti sortiran.</p> <p>Tre\u0107i niz je \\([A_4, A_5, A_6]\\), tj. \\([7, 2, 2]\\). Iz njega mo\u017eemo izbrisati prvi element da bismo dobili niz \\([2, 2]\\).</p> <p>\u010cetvrti niz je \\([A_5]\\), tj. \\([2]\\). On je ve\u0107 sortiran, pa ne moramo raditi ni\u0161ta.</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\cdot 10^5\\).</li> <li>\\(1 \\leq Q \\leq 10^5\\).</li> <li>\\(1 \\leq L_i \\leq R_i \\leq N\\) za \\(1 \\leq i \\leq Q\\).</li> <li>\\(1 \\leq A_i \\leq N\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 15 poena: \\(N, Q \\leq 200\\).</li> <li>U testovima vrednim 25 poena: \\(N, Q \\leq 3000\\).</li> <li>U testovima vrednim 10 poena: \\(Q = 5\\).</li> <li>U testovima vrednim 20 poena: Svi elementi niza su \\(1\\) ili \\(2\\).</li> <li>U testovima vrednim 30 poena: nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/04_poklon/#napomena","title":"Napomena","text":"<p>Niz \\([B_1, B_2, B_3, ... , B_M]\\) je sortiran u neopadaju\u0107em poretku ako i samo ako va\u017ei \\(B_1 \\leq B_2 \\leq ... \\leq B_M\\).</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#resenje-prvog-podzadatka","title":"Re\u0161enje prvog podzadatka","text":"<p>U ovom slu\u010daju, zbog ograni\u010denja na du\u017einu niza \\(A\\) (broj \\(N\\)) i broj upita \\(Q\\), mogu\u0107e je za svaki upit \\((L_i, R_i)\\) proveriti da li podniz postaje sortiran nakon izbacivanja elementa \\(A_j\\) (\\(j= L_i, L_i+1, L_i+2, \\dots R_{i-1}, R_i\\)). Provera da li je niz sortiran izvodi se tako \u0161to se porede parovi uzastopnih (naravno, uzimaju\u0107i u obzir da je izba\u010den element \\(A_j\\), pa su elementi \\(A_{j-1}\\) i \\(A_{j+1}\\), ako je \\(L_i &lt; j &lt; R_i\\), uzastopni). Slo\u017eenost ovog re\u0161enja je \\(O(QN^2)\\).</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#resenje-drugog-i-treceg-podzadatka","title":"Re\u0161enje drugog i tre\u0107eg podzadatka","text":"<p>Re\u0161enje ovih podzadataka dobija se \"profinjenjem\" re\u0161enja za prvi zadatak. To \"profinjenje\" se posti\u017ee tako \u0161to se za vrednosti \\(j\\) za koje je \\(A_{j-1}\\leq A_j \\leq A_{j+1}\\) ne proverava da li je podniz dobijen izbacivanjem elementa \\(A_j\\) sortiran (jer element \\(A_j\\) \"ne smeta\", budu\u0107i da je, po vrednosti, izme\u0111u elemenata levo i desno od njega). Tokom obrade se proverava da li je podniz koji sadr\u017ei sve elemente od pozicije  \\(L_i\\) do pozicije \\(R_i\\) sortiran i ako jeste onda je odgovor na upit \"DA\". Naravno, i u slu\u010daju da se za neko \\(j\\) ispostavi da je podniz dobijen nakon izbacivanja elementa \\(A_j\\) sortiran, odgovor je \"DA\".</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#resenje-cetvrtog-podzadatka","title":"Re\u0161enje \u010detvrtog podzadatka","text":"<p>U ovom podzadatku je mogu\u0107e sa svaki indeks \\(i\\)  (\\(1\\leq i \\leq N\\)) odrediti: - indeks \\(j\\) (\\(j\\geq i\\)) prvog elementa u delu niza koga \u010dine elementi \\(A_i, A_{i+1}, A_{i+2}, \\dots, A_N\\) koji ima vrednost  \\(1\\); ozna\u010dimo tu vrednost sa \\(next_{i,1}\\); ako takav element ne postoji onda \u0107e odgovaraju\u0107i indeks imati vrednost \\(N+1\\).  - indeks \\(j\\) (\\(j\\geq i\\)) prvog elementa u delu niza koga \u010dine elementi \\(A_i, A_{i+1}, A_{i+2}, \\dots, A_N\\) koji ima vrednost  \\(2\\); ozna\u010dimo tu vrednost sa \\(next_{i,2}\\); ako takav element ne postoji onda \u0107e odgovaraju\u0107i indeks imati vrednost \\(N+1\\).</p> <p>Ovaj deo se mo\u017ee odraditi nakon u\u010ditavanja elemenata niza, a pre odgovaranja na upite.</p> <p>Kada odgovaramo na upit za par brojeva \\((L,R)\\), onda odre\u0111ujemo indeks \\(X\\) prvog elementa od pozicije \\(L\\) koji ima vrednost \\(2\\) (\\(X=next_{L,2}\\)) i indeks \\(Y\\) prvog elementa od pozicije \\(X\\) koji ima vrednost \\(1\\) (\\(Y=next_{X,1}\\)). Mo\u017ee se pokazati da \u0107e odgovor biti \"DA\" samo u slede\u0107im slu\u010dajevima</p> <ul> <li>ako je \\(Y&gt;R\\) (jer su elementi od pozicije \\(L\\) do pozicije \\(X-1\\) jednaki \\(1\\), a od pozicije \\(X\\) pa do pozicije \\(Y-1\\geq R\\) jednaki \\(2\\); </li> <li>ako je \\(next_{Y+1,1}&gt;R\\), jer se mo\u017ee izbaciti jedinica sa pozicije \\(Y\\), i tako \u0107e se dobiti blok dvojki od pozicije \\(X\\) pa do pozicije \\(next_{Y+1,1}-1 \\geq R\\) i podniz \u0107e biti sortiran;</li> <li>ako je \\(Y=X+1\\) i  \\(next_{next_{Y,2},1}&gt;R\\), jer se na poziciji \\(X\\) nalazi broj \\(2\\), ali odmah nakon toga broj \\(1\\), a nakon prve dvojke posle pozicije \\(Y\\) sledi blok dvojki koji se zavr\u0161ava nakon pozicije \\(R\\); brisanjem dvojke na poziciji \\(X\\) dobija se sortiran podniz.</li> </ul> <p>U svim ostalim slu\u010dajevima, odgovor je \"NE\". Matrica \\(next\\) mo\u017ee biti izra\u010dunata u vremenu \\(\\Theta(N)\\), a kako je slo\u017eenost odgovora na svaki upit \\(\\Theta(1)\\), to je ukupna slo\u017eenost \\(\\Theta(N+Q)\\).</p>"},{"location":"takprog/2022_2023/okr/04_poklon/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za svaki indeks \\(i\\) (\\(1\\leq i \\leq N\\)) se mo\u017ee odrediti najve\u0107i indeks \\(j\\) tako da je podniz od indeksa \\(i\\) do indeksa \\(j\\) neopadaju\u0107i:  $$  A_i \\leq A_{i+1} \\leq A_{i+2} \\leq \\dotsb \\leq A_{j-1} \\leq A_j.  $$  Ozna\u010dimo indeks \\(j\\) koji ima gornju osobinu  sa \\(last_i\\). Primetimo da je \\(last_i = N\\) ili je \\(A_{last_i} &gt; A_{last_i+1}\\).  Tada \u0107e odgovor na upit za par indeksa \\((L,R)\\) biti \"DA\" u slede\u0107im slu\u010dajevima:</p> <ul> <li>ako je \\(last_L \\geq R-1\\) (jer mo\u017ee biti obrisan \\(A_R\\))</li> <li>ako je \\(last_{last_L+1} \\geq R\\) i \\(last_L = L\\) ili je \\(A_{last_L-1} \\leq A_{last_L+1}\\), jer se brisanjem elementa  \\(A_{last_L}\\) dobija sortiran podniz.</li> <li>ako je \\(last_{last_L+2} \\geq R\\) i \\(A_{last_L} \\leq A_{last_L+2}\\), jer se tada brisanjem elementa \\(A_{last_L+1}\\) dobija sortiran podniz. </li> </ul> <p>Elementi niza \\(last\\) mogu biti sra\u010dunati kori\u0161enjem slede\u0107ih \u010dinjenica:</p> <ul> <li>\\(last_N = N\\),</li> <li>\\(last_i = last_{i+1}\\) ako je \\(A_i \\leq A_{i+1}\\) i \\(last_i = i\\), ako je \\(A_i &gt; A_{i+1}\\), za \\(i=N-1, N-2, \\dots, 2, 1\\). Prema tome, slo\u017eenost izra\u010dunavanja elemenata niza \\(last\\) je \\(\\Theta(N)\\), a budu\u0107i da je slo\u017eenost odgovaranja na jedan upit \\(\\Theta(1)\\), slo\u017eenost kompletnog re\u0161enja je \\(\\Theta(N+Q)\\).</li> </ul> 04_poklon.cpp<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N = 300000;\n\nint niz[N+5];\nint poslednji_dobar[N+5];\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0);\n\n    int n;\n    cin &gt;&gt; n;\n    for(int i=1; i&lt;=n; i++) cin &gt;&gt; niz[i];\n    poslednji_dobar[n] = n;\n    for(int i=n-1; i&gt;=1; i--){\n        if(niz[i] &gt; niz[i+1]) poslednji_dobar[i] = i;\n        else poslednji_dobar[i] = poslednji_dobar[i+1];\n    }\n    int q;\n    cin &gt;&gt; q;\n    for(int i=1; i&lt;=q; i++){\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        int p = poslednji_dobar[l];\n        if(p &gt;= r - 1) cout &lt;&lt; \"DA\\n\";\n        else if(poslednji_dobar[p+1] &gt;= r &amp;&amp; (p == l || niz[p-1] &lt;= niz[p+1])) cout &lt;&lt; \"DA\\n\"; /// brisanje niz[p]\n        else if(poslednji_dobar[p+2] &gt;= r &amp;&amp; niz[p] &lt;= niz[p+2]) cout &lt;&lt; \"DA\\n\"; /// brisanje niz[p+1]\n        else cout &lt;&lt; \"NE\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/05_krompiri/","title":"A2 - Krompiri","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 750ms 64MB <p>\u010cuveni astro-botani\u010dar Mateja Dejmon se jo\u0161 od 2017. godine uspe\u0161no bavi uzgojem krompira na Marsu zahvaljuju\u0107i pomo\u0107i takmi\u010dara iz informatike.</p> <p>On je ove godine odlu\u010dio da napravi novu farmu krompira na Marsu i ponovo mu je potrebna va\u0161a pomo\u0107. Njemu je na raspolaganju plodno marsovsko zemlji\u0161te dimenzija \\(N \\times M\\) koje je on izdelio na \\(N \\cdot M\\) jedini\u010dnih polja. Na svakom polju je mogu\u0107e posaditi odre\u0111en broj krompira, me\u0111utim, zbog posebnog sastava marsovskog zemlji\u0161ta u redu \\(i\\) ukupno ne sme biti manje od \\(a_i\\) niti vi\u0161e od \\(b_i\\) krompira (za svako \\(i = 1,2,\\ldots,N\\)). Tako\u0111e, u koloni \\(j\\) ukupno ne sme biti manje od \\(c_j\\) niti vi\u0161e od \\(d_j\\) krompira (za svako \\(j = 1,2,\\ldots,M\\)).</p> <p>Pomozite Mateji da odredi raspored krompira koji \u0107e maksimizovati njegov prinos tj. pomozite mu da posadi \u0161to vi\u0161e krompira.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Igor Pavlovi\u0107 Igor Pavlovi\u0107 Igor Pavlovi\u0107 Nikola Pe\u0161i\u0107"},{"location":"takprog/2022_2023/okr/05_krompiri/#ulaz","title":"Ulaz","text":"<p>U prvom redu standardnog ulaza nalaze se, redom, dva cela broja \\(N\\) i \\(M\\) - dimenzije zemlji\u0161ta.</p> <p>U narednih \\(N\\) redova nalaze se po dva cela broja \\(a_i\\) i \\(b_i\\) - ograni\u010denja za \\(i\\)-ti red.</p> <p>U narednih \\(M\\) redova nalaze se po dva cela broja \\(c_j\\) i \\(d_j\\) - ograni\u010denja za \\(j\\)-tu kolonu.</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#izlaz","title":"Izlaz","text":"<p>U prvom redu standardnog izlaza ispisati maksimalan broj krompira koji Mateja mo\u017ee da posadi.</p> <p>U drugom redu ispisati broj \\(K\\) - broj polja na kojima treba posaditi krompire.</p> <p>U narednih \\(K\\) redova ispisati po tri cela broja \\(x\\), \\(y\\) i \\(n\\) (\\(1 \\leq x \\leq N\\), \\(1 \\leq y \\leq M\\), \\(n \\geq 0\\)), redom, koji ozna\u010davaju da na polju u preseku \\(x\\)-tog reda i \\(y\\)-te kolone treba posaditi \\(n\\) krompira.</p> <p>Raspored krompira mora biti takav da po\u0161tuje sva ograni\u010denja iz teksta zadatka. Ukoliko ima vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/okr/05_krompiri/#ulaz_1","title":"Ulaz","text":"<pre><code>2 2\n1 2\n1 1\n1 3\n0 0\n</code></pre>"},{"location":"takprog/2022_2023/okr/05_krompiri/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n2\n1 1 2\n2 1 1\n</code></pre>"},{"location":"takprog/2022_2023/okr/05_krompiri/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/okr/05_krompiri/#ulaz_2","title":"Ulaz","text":"<pre><code>2 3\n2 2\n2 2\n1 2\n1 2\n1 2\n</code></pre>"},{"location":"takprog/2022_2023/okr/05_krompiri/#izlaz_2","title":"Izlaz","text":"<pre><code>4\n4\n1 1 1\n1 3 1\n2 2 1\n2 3 1\n</code></pre>"},{"location":"takprog/2022_2023/okr/05_krompiri/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U tabeli ispod je prikazan jedan mogu\u0107i raspored krompira koji zadovoljava ograni\u010denja i maksimizuje prinos u prvom primeru (izrazi oblika \\(x-y\\) u tabeli ozna\u010davaju donju i gornju granicu za broj krompira u odgovaraju\u0107em redu/koloni).</p> 1-3 0-0 1-2 2 0 1-1 1 0 <p>U tabeli ispod je prikazan jedan mogu\u0107i raspored krompira koji zadovoljava ograni\u010denja i maksimizuje prinos u drugom primeru:</p> 1-2 1-2 1-2 2-2 1 0 1 2-2 0 1 1"},{"location":"takprog/2022_2023/okr/05_krompiri/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, M \\leq 50000\\).</li> <li>\\(0 \\leq a_i \\leq b_i \\leq 10^9\\).</li> <li>\\(0 \\leq c_i \\leq d_i \\leq 10^9\\).</li> <li>Garantuje se da postoji raspored krompira koji zadovoljava sve uslove.</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim \\(10\\) poena: \\(N=M, a_i \\leq c_i \\leq b_i \\leq d_i\\).</li> <li>U testovima vrednim \\(10\\) poena: \\(a_i = b_i, c_i = d_i\\).</li> <li>U testovima vrednim \\(15\\) poena: \\(a_i = b_i\\).</li> <li>U testovima vrednim \\(15\\) poena: \\(N = 1\\).</li> <li>U testovima vrednim \\(30\\) poena: \\(a_i = c_i = 0\\).</li> <li>U testovima vrednim \\(20\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/05_krompiri/#resenje-kada-nm-a_i-leq-c_i-leq-b_i-leq-d_i","title":"Re\u0161enje kada \\(N=M, a_i \\leq c_i \\leq b_i \\leq d_i\\)","text":"<p>U ovom podzadatku je dovoljno du\u017e dijagonale posaditi \\(b_i\\) krompira.</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#resenje-kada-a_i-b_i-c_i-d_i","title":"Re\u0161enje kada \\(a_i = b_i, c_i = d_i\\)","text":"<p>Za re\u0161avanje ovog podzadatka mo\u017eemo primeniti tehniku dva pokaziva\u010da. Pokaziva\u010d \\(i\\) iterira po redovima, a pokaziva\u010d \\(j\\) iterira po kolonama. Ako je \\(b_i=0\\) ili \\(d_i=0\\) tada uve\u0107amo \\(i\\) to jest \\(j\\) za 1. Ako je \\(b_i \\neq 0\\) i \\(d_j \\neq 0\\) posadi \\(min(b_i,d_j)\\) krompira na polje \\(i, j\\) i smanji \\(b_i\\) i \\(d_j\\) za \\(min(b_i,d_j)\\).</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#resenje-kada-a_i-b_i","title":"Re\u0161enje kada \\(a_i = b_i\\)","text":"<p>Ovaj podzadatak mo\u017eemo re\u0161iti analogno prethodnom. U ovom podzadatku je potrebno iterirati po kolonama 2 puta. Prvi put postavljamo broj krompira u svakoj koloni na donju granicu, a drugi put na gornju i a\u017euriramo broj krompira u svakoj koloni. Kada zavr\u0161imo sa iteracijom po redovima tada prekidamo iteraciju po kolonama tako\u0111e. Nakon \u0161to smo odredili broj krompira u svakoj koloni mo\u017eemo primeniti re\u0161enje iz prethodnog podzadatka.</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#resenje-kada-n-1","title":"Re\u0161enje kada \\(N = 1\\)","text":"<p>U slu\u010daju da va\u017ei \\(\\sum_{i=1}^{M} d_i \\leq b_1\\) dovoljno je samo u \\(i\\)-toj koloni posaditi \\(d_i\\) krompira.</p> <p>U suprotnom se re\u0161enje ovog podzadatka svodi na re\u0161enje prethodnog kada donju granicu postavimo da bude jednaka gornjoj (jer je neophodno posaditi \\(b_i\\) krompira u prvom redu kako bismo maksimizovali prinos).</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#resenje-kada-a_i-c_i-0","title":"Re\u0161enje kada \\(a_i = c_i = 0\\)","text":"<p>Ovaj podzadatak mo\u017eemo re\u0161iti gramzivom metodom i tehnikom 2 pokaziva\u010da. Pokaziva\u010d \\(i\\) iterira po redovima, a pokaziva\u010d \\(j\\) iterira po kolonama. Ako je \\(b_i=0\\) ili \\(d_i=0\\) tada uve\u0107amo \\(i\\) to jest \\(j\\) za 1. Ako je \\(b_i \\neq 0\\) i \\(d_j \\neq 0\\) posadi \\(min(b_i,d_j)\\) krompira na polje \\(i, j\\) i smanji \\(b_i\\) i \\(d_j\\) za \\(min(b_i,d_j)\\). Primetimo da je ovo re\u0161enje identi\u010dno podzadatku 2 samo \u0161to je u ovom slu\u010daju neophono zavr\u0161iti iteraciju po kolonama \u010dim se zavr\u0161i iteracija po vrstama i obrnuto. U podzadatku 2 se ove dve iteracije zar\u0161avaju istovremeno s obirom da re\u0161enje mora postojati.</p>"},{"location":"takprog/2022_2023/okr/05_krompiri/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo prvo da nije mogu\u0107e posaditi vi\u0161e od \\(min(\\sum_{i=1}^{N} b_i,\\sum_{j=1}^{M} d_i)\\) krompira ukupno. Dakle ukoliko konstrui\u0161emo re\u0161enje sa ta\u010dno \\(min(\\sum_{i=1}^{N} b_i,\\sum_{j=1}^{M} d_i)\\) krompira onda smo tako\u0111e dostigli maksimalan mogu\u0107i prinos.</p> <p>Bez umanjenja op\u0161tosti pretpostavimo da va\u017ei \\(\\sum_{i=1}^{N} b_i \\leq \\sum_{j=1}^{M} d_i\\). Da bismo maksimizovali prinos potrebno je u svakom redu posaditi \\(b_i\\) krompira. Po\u0161to nam je poznat broj krompira koji je potrebno posaditi u svakom redu sada se re\u0161enje zadatka svodi na re\u0161enje podzadatka 3. Primetimo tako\u0111e da ukuliko postoji neko re\u0161enje tada va\u017ei \\(\\sum_{j=1}^{M} c_i \\leq \\sum_{i=1}^{N} b_i\\), odakle sledi da mogu\u0107e konstruisati re\u0161enje sa ta\u010dno \\(min(\\sum_{i=1}^{N} b_i,\\sum_{j=1}^{M} d_i)\\) primenom algoritma iz podzadatka 3.</p> 05_krompiri.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxN 50005\n\nusing namespace std;\n\nint n,m,a[maxN],b[maxN],c[maxN],d[maxN],cnt[maxN],i,j;\nbool transposed = false;\nlong long s1=0,s2=0,sl=0;\n\nvector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt; ans;\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n\n    cin&gt;&gt;n&gt;&gt;m;\n    for(i=0;i&lt;n;i++){\n        cin&gt;&gt;a[i]&gt;&gt;b[i];\n        s1+=b[i];\n    }\n\n    for(i=0;i&lt;m;i++){\n        cin&gt;&gt;c[i]&gt;&gt;d[i];\n        s2+=d[i];\n    }\n\n    if(s2&lt;s1){\n        transposed=true;\n        swap(s1,s2);\n        swap(n,m);\n        for(i=0;i&lt;max(n,m);i++){\n            swap(a[i],c[i]);\n            swap(b[i],d[i]);\n        }\n    }\n\n    cout&lt;&lt;s1&lt;&lt;endl;\n\n    for(i=0;i&lt;m;i++) sl+=c[i];\n\n    long long dif = s1-sl;\n\n    for(i=0;i&lt;m;i++){\n        cnt[i]=min((long long)d[i],c[i]+dif);\n        dif-=cnt[i]-c[i];\n    }\n\n    i=j=0;\n\n    while(i&lt;n &amp;&amp; j&lt;m){\n        if(b[i]==0){\n            i++;\n            continue;\n        }\n        if(cnt[j]==0){\n            j++;\n            continue;\n        }\n        int tmp = min(b[i],cnt[j]);\n        ans.push_back({{i+1,j+1},tmp});\n        b[i]-=tmp;\n        cnt[j]-=tmp;\n    }\n\n    cout&lt;&lt;ans.size()&lt;&lt;endl;\n\n    for(i=0;i&lt;ans.size();i++){\n        if(transposed) {\n            swap(ans[i].first.first,ans[i].first.second);\n        }\n        cout&lt;&lt;ans[i].first.first&lt;&lt;\" \"&lt;&lt;ans[i].first.second&lt;&lt;\" \"&lt;&lt;ans[i].second&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2022_2023/okr/06_sdneirf/","title":"A3 - Sdneirf","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Prethodnih godina, filmovi duologije o velikom \u0161efu mafije ekskluzivne disjunkcije Okram \u0106ivas postali su neki od najpopularnijih i najvoljenijih na tr\u017ei\u0161tu. Duologija se sastojojala od, kao \u0161to ime ka\u017ee, dva filma, koji se zovu Okram i \u0106ivas. Me\u0111utim, usled lude popularnosti prethodna dva filma, pokrenula se proizvodnja za tre\u0107i i poslednji deo ovog serijala - \"Sdneirf\". U ovom filmu Okram \u0106ivas je odavno napustio mafiju i sad \u017eivi sre\u0107no sa svojom porodicom. Me\u0111utim, onda sti\u017ee poziv za jedan poslednji zadatak...</p> <p>U poslednjoj avanturi na\u0161eg heroja, sli\u010dno kao u prvoj (mora da se ga\u0111a na nostalgiju u ovakvim filmovima), on se zatekao u misterioznoj matrici, dimenzija \\(N\\times M\\). U svakom polju matrice je napisan po jedan ceo nenegativan broj, konkretno u polju u preseku reda \\(i\\) i kolone \\(j\\) se inicijalno nalazi vrednost \\(a_{i,j}\\). Posle zabune oko toga \u0161ta se de\u0161ava, Okram \u0106ivas je shvatio da ima samo jedan na\u010din na koji mo\u017ee da menja vrednosti u ovoj matrici. U svakom potezu, on mo\u017ee da izabere nenegativan ceo broj \\(X\\) i neki niz od \\(N+M-1\\) polja koji po\u010dinje od gornjeg levog polja i zavr\u0161ava se na donjem desnom, tako da svaka dva susedna polja u tom nizu dele stranicu, i onda za svako polje na tom putu promeni vrednost u njemu na slede\u0107i na\u010din: ako se pre ovog poteza u ovom polju nalazio broj \\(Y\\), nova vrednost u ovom polju \u0107e biti \\(Y\\text{ xor }X\\).</p> <p>Kako je Okram \u0106ivas poznat po svojoj majstoriji sa ekskluzivnom disjunkcijom, on je sebi zadao slede\u0107i zadatak: posle proizvoljnog broja poteza, koja je najmanja mogu\u0107a suma svih vrednosti u matrici? Ako uspe da minimizuje sumu, deluje da \u0107e uspeti da pobegne iz ove matrice i zauvek napusti svet kriminala.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Jovan Bengin Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/okr/06_sdneirf/#opis-ulaza","title":"Opis ulaza","text":"<p>Prva linija standardnog ulaza sadr\u017ei dva cela broja, broj redova \\(N\\) i broj kolona \\(M\\), redom. Narednih \\(N\\) linija sadr\u017ee po \\(M\\) celih brojeva: \\(j\\)-ti broj u \\((i+1)\\)-voj liniji predstavlja broj \\(a_{ij}\\), koji ozna\u010dava po\u010detnu vrednost polja u \\(i\\)-tom redu i \\(j\\)-toj koloni.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinoj liniji standardnog izlaza potrebno je ispisati jedan ceo broj: najmanju mogu\u0107u sumu brojeva u matrici posle nekog broja poteza.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/okr/06_sdneirf/#ulaz","title":"Ulaz","text":"<pre><code>1 2\n1 0\n</code></pre>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#izlaz","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/okr/06_sdneirf/#ulaz_1","title":"Ulaz","text":"<pre><code>2 3\n2 7 5\n5 7 2\n</code></pre>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>U prvom primeru, po\u010detna suma je jedan. Ovo je minimalna vrednost jer je suma pozitivna posle proizvoljno mnogo poteza.</p> <p>U drugom primeru, u prvom potezu Okram \u0106ivas mo\u017ee uzezi \\(X=7\\) i niz polja \\((1,1),\\) \\((1,2),\\) \\((2,2),\\) \\((2,3)\\), a onda napravi \\(3\\) poteza sa \\(X=5\\) i prvo nizom polja \\((1,1),\\) \\((2,1),\\) \\((2,2),\\) \\((2,3)\\), zatim nizom polja \\((1,1),\\) \\((1,2),\\) \\((1,3),\\) \\((2,3)\\) i na kraju nizom \\((1,1),\\) \\((1,2),\\) \\((2,2),\\) \\((2,3)\\).</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 1.500\\).</li> <li>\\(0\\leq A_{ij}\\leq 1.000.000.000\\).</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U test primerima vrednim \\(10\\) poena: \\(N,M\\leq2\\).</li> <li>U test primerima vrednim \\(10\\) poena: \\(N=1\\).</li> <li>U test primerima vrednim \\(20\\) poena: \\(N=2\\).</li> <li>U test primerima vrednim \\(30\\) poena: \\(0\\leq A_{ij}\\leq 1\\).</li> <li>U test primerima vrednim \\(30\\) poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#napomena","title":"Napomena","text":"<p>Operator ekskluzivne disjunkcije u Pascal-u je ozna\u010den sa  <code>xor</code>, dok u C++ ga zapisujemo pomo\u0107u simbola  <code>^</code>. Ova operacija \\(x\\ \\text{xor} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in {1, \\ldots, k }\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 0\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{xor} \\ y\\).</p> <p>Ako \u017eelite da upoznate sa prethodnim avanturama Okrama \u0106ivasa, posle takmi\u010denja mo\u017eete da pogledate pro\u0161logodi\u0161nji tre\u0107i zadatak za B kategoriju na okru\u017enom: Okram, kao i pro\u0161logodi\u0161nji drugi zadatak za A kategoriju na okru\u017enom: \u0106ivas</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#analiza","title":"Analiza","text":"<p>Primetimo prvo da nikada ne moramo napraviti potez sa nekim \\(X\\) koje nije stepen dvojke. Naime, umesto jednog poteza sa \\(X = 2^{i_1} + 2^{i_2} + 2^{i_3} + .... + 2^{i_k}\\), \\(i_1 &lt; i_2 &lt; ... &lt; i_k\\), mo\u017eemo da napravimo \\(k\\) poteza nad istim putem sa vrednostima \\(2^{i_1}, 2^{i_2}, ... , 2^{i_k}\\). Dakle, mo\u017eemo pretpostaviti da \u0107e \\(X\\) koje biramo uvek biti oblika \\(2^j\\). </p> <p>Po\u0161to sada nijedan potez nad nekim bitom ne uti\u010de na druge, mo\u017eemo za svaki bit nezavisno na\u0107i optimalno re\u0161enje i na kraju ih sva sumirati. Formalnije, defini\u0161imo matrice \\(B_0, B_1, ... , B_K\\), gde je \\(B_{x, i, j} = 1\\) ako \\(A_{i, j}\\) sadr\u017ei \\(x\\)-ti bit, u suprotnom je \\(B_{x, i, j} = 0\\). Ako je \\(C_i\\) optimalno re\u0161enje za matricu \\(B_i\\), onda je optimalno re\u0161enje za matricu \\(A\\) jednako \\(\\sum\\limits_{i=0}^{K} 2^i*C_i\\). Po\u0161to va\u017ei \\(A_{i,j} \\leq 10^9 &lt; 2^{30}\\), dovoljno je uzeti \\(K = 29\\) (jer bi matrice B_i za ve\u0107e vrednosti \\(i\\) sadr\u017eale samo nule, pa bi i \\(C_i\\) bilo \\(0\\)).</p> <p>Dalje \u0107emo razmatrati samo matrice \u010diji su svi \u010dlanovi \\(0\\) ili \\(1\\), a poteze vr\u0161imo isklju\u010divo sa \\(X = 1\\). Cilj nam je da dobijemo matricu sa minimalnim brojem jedinica.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#resenje-kada-je-n-m-leq-2","title":"Re\u0161enje kada je \\(N, M \\leq 2\\)","text":"<p>Ako je \\(N = 1\\) ili \\(M = 1\\), postoji ta\u010dno jedan put od \\((1, 1)\\) do \\((N, M)\\). Ako je \\(N = M = 2\\), postoje dva puta. Po\u0161to postoje najvi\u0161e dva razli\u010dita puta, time i najvi\u0161e \u010detiri razli\u010dite kombinacije poteza (po\u0161to se dva ista poteza skra\u0107uju), mo\u017eemo za svaku kombinaciju proveriti kako \u0107e matrica izgledati, i uzeti onu sa najmanjom rezultuju\u0107om sumom.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#resenje-kada-je-n-1","title":"Re\u0161enje kada je \\(N = 1\\)","text":"<p>Po\u0161to postoji samo jedan mogu\u0107 put, postoje samo dva mogu\u0107a niza poteza: jedan gde ne radimo ni\u0161ta (tada \u0107e matrica sadr\u017eati \\(a\\) jedinica), i drugi gde put prolazi kroz celu matricu (tada \u0107e matrica sadr\u017eati \\(M - a\\) jedinica), pa \u0107e re\u0161enje biti \\(min(a, M - a)\\).</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#resenje-kada-je-n-2","title":"Re\u0161enje kada je \\(N = 2\\)","text":"<p>Grupisa\u0107emo polja tako da sva polja sa istom \\(i + j\\) vrednosti budu u istoj grupi. Svaka grupa \u0107e onda zapravo biti dijagonala koja ide od dole-levo ka gore-desno, i sadr\u017ea\u0107e najvi\u0161e dva polja.</p> <p>Primetimo da svaki put od  \\((1, 1)\\) do \\((N, M)\\) sadr\u017ei po ta\u010dno jedan element iz svake grupe. To zna\u010di da ako je ukupan xor svih elemenata neke grupe jednak \\(0\\), posle jednog poteza bi\u0107e \\(1\\), i obrnuto. Neka na po\u010detku \\(a\\) dijagonala ima xor jednak nuli, a \\(b\\) dijagonala xor jednak jedinici. Onda \u0107e nakon jednog poteza biti \\(b\\) dijagonala sa xor \\(0\\), i \\(a\\) sa \\(1\\), nakon drugog poteza \u0107e ponovo biti \\(a\\) sa \\(0\\) i \\(b\\) sa \\(1\\) itd. Po\u0161to svaka dijagonala koja ima xor jednak jedinici mora da sadr\u017ei barem jednu jedinicu, vidimo da je re\u0161enje barem \\(min(a, b)\\).</p> <p>Ispostavlja se da je ovaj minimum uvek mogu\u0107e posti\u0107i. Bez umanjenja op\u0161tosti, neka je \\(a \\geq b\\) (\\(b &lt; a\\) se radi na isti na\u010din, samo \u0161to se na po\u010detku uradi bilo koji potez). Pokaza\u0107emo da je dijagonale sa xor-om \\(1\\) (kojih ima \\(b\\)) mogu\u0107e transformisati tako da imaju ta\u010dno jednu jedinicu, a one sa xor-om \\(0\\) tako da nemaju nijednu.</p> <p>Za dijagonale koje sadr\u017ee jedno polje je o\u010digledno: ako im je xor \\(0\\), onda je njihov jedini element \\(0\\), uostalom je \\(1\\). Dijagonale koje sadr\u017ee dva polja i imaju xor \\(1\\) tako\u0107e sadr\u017ee ta\u010dno jednu jedinicu. Ostalo nam je da poka\u017eemo da, ako imamo dijagonalu koja sadr\u017ei dve jedinice, mo\u017eemo obe pretvoriti u nule a da ne menjamo ostale elemente. Neka su elementi te dijagonale \\((2, i)\\) i \\((1, i + 1)\\). Napravi\u0107emo dva poteza: u prvom biramo put \\((1, 1), (1, 2), ... , (1, i), (1, i+1), (2, i+1), (2, i+2), ..., (2, M)\\), a u drugom put \\((1, 1), (1, 2), ... , (1, i), (2, i), (2, i+1), (2, i+2), ... , (2, M)\\). Primetimo da su jedina polja koja se nalaze u ta\u010dno jednom putu ba\u0161 \\((2, i)\\) i \\((1, i + 1)\\). To zna\u010di da su to jedina dva polja \u010dija \u0107e se vrednost obrnuti, pa tako od dve jedinice dobijamo dve nule.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#resenje-kada-su-sve-pocetne-vrednosti-0-ili-1","title":"Re\u0161enje kada su sve po\u010detne vrednosti \\(0\\) ili \\(1\\)","text":"<p>Po\u0161to smo po\u010detnu matricu \\(A\\) podelili na matrice sa vrednostima \\(0\\) i \\(1\\), ovaj podzadatak se re\u0161ava na isti na\u010din kao glavno re\u0161enje. Ipak, mogu\u0107e ga je uraditi i bez znanja da mo\u017eemo nezavisno nalaziti re\u0161enje za svaki bit.</p>"},{"location":"takprog/2022_2023/okr/06_sdneirf/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sli\u010dno kao u re\u0161enju za \\(N = 2\\), grupisa\u0107emo polja po dijagonali. Ovde se tako\u0111e ispostavlja da, ako imamo \\(a\\) dijagonala sa xor \\(0\\) i \\(b\\) sa xor \\(1\\), re\u0161enje je \\(min(a, b)\\). Ovo mo\u017eemo pokazati na sli\u010dan na\u010din kao za \\(N = 2\\), samo \u0161to sada moramo za svaku dijagonalu sa neparnim brojem jedinica dokazati da je mo\u017eemo transformisati da ima jednu jedinicu, a za one sa parnim brojem jedinica da nemaju nijednu.</p> <p>Na sli\u010dan na\u010din kao u slu\u010daju \\(N = 2\\), mo\u017eemo u dva poteza obrnuti vrednosti neka dva polja \\((i, j)\\) i \\((i -1, j + 1)\\). Ako dijagonalu predstavimo kao niz, ova operacija nam zapravo zna\u010di da obr\u0107emo vrednosti neka dva susedna polja. Upotrebom ove operacije treba da dobijemo minimalan broj jedinica.</p> <p>Ovo se mo\u017ee uraditi na slede\u0107i na\u010din: iteriramo kroz niz sleva nadesno, i ako nai\u0111emo na neki element koji je \\(1\\) (a nije poslednji), jednom operacijom obr\u0107emo njega i slede\u0107i element. Na kraju \u0107e svi elementi niza biti \\(0\\), sem eventualno poslednjeg. Po\u0161to na\u0161a operacija ne menja parnost broja jedinica, ako je na po\u010detku bio neparan broj jedinica, poslednji element \u0107e biti \\(1\\), uostalom \u0107e biti \\(0\\), pa smo dokazali da je mogu\u0107e dosti\u0107i \u017eeljeni minimum.</p> <p>Ukupna slo\u017eenost \u0107e biti \\(O(NMlog(max(A_{i,j}))\\), jer za svaki bit re\u0161enje nalazimo u \\(O(NM)\\).</p> 06_sdneirf.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 1507\nusing namespace std;\nint a[MAXN][MAXN],cnt[2*MAXN];\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    long long ans=0;\n    for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;a[i][j];\n    for(int x=0;x&lt;30;x++)\n    {\n        for(int i=0;i&lt;m+n-1;i++) cnt[i]=0;\n        for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(a[i][j]&amp;(1&lt;&lt;x)) cnt[i+j]^=1;\n        int br=0;\n        for(int i=0;i&lt;n+m-1;i++) if(cnt[i]==1) br++;\n        ans+=(1LL&lt;&lt;x)*min(br,n+m-1-br);\n    }\n    cout&lt;&lt;ans;\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/","title":"1 - Operacija nad glistom","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Jedan pre svega veliki ljubitelj \u017eivotinja po imenu Okram probudio se jednog dana i imao je \u0161ta da vidi: njegov ljubimac Edgar de Glist, jedna ki\u0161na glista, bio je raskomadan na \\(N\\) delova. Okram je bio potre\u0161en ovim prizorom, ali je, sa obzirom da se razume u ovu vrstu \u017eivotinje, znao za oni mogu da pre\u017eive i nakon \u0161to im se desi ovakva povreda, i \u0161to je najbitnije, znao je da najnovijim tehnologijama on mo\u017ee da vrati svog ljubimca u stanje u kom je bio pre nemilog doga\u0111aja. </p> <p>Okram je pripremio svoju glistu za operaciju tako \u0161to je delove njenog tela pore\u0111ao u niz u pravilnom redosledu i njihove du\u017eine zapisao u jedan niz istim redosledom (pri tome je pazio da je poslednji deo, to jest deo skroz desno, onaj sa usnom dupljom, vide\u0107emo posle da je orijentacija bitna). U ovoj nezgodnoj operaciji nad svojom glistom on mora da obrati pa\u017enju na nekoliko stvari:</p> <ul> <li>Dva dela gliste se mogu spojiti samo ako su oni susedni i ako za njihove du\u017eine \\(a\\) i \\(b\\) va\u017ei \\(a \\le b \\le a+1\\). Pri ovome je bitno obratiti pa\u017enju i na redosled, to jest \\(a\\) predstavlja levi a \\(b\\) desni broj (kao \u0161to smo rekli orijentacija je bitna).</li> <li>Da bi pro\u0161li uslov za spajanje mogao da bude ispunjen neki delovi \u0107e morati da se \"prepolove\" pre ponovnog spajanja sa drugim delovima, i to isklju\u010divo na slede\u0107i na\u010din: ako je \\(c\\) du\u017eina dela koji se polovi, levi deo \u0107e nakon podele biti du\u017eine \\(floor(c/2)\\) a desni du\u017eine \\(ceil(c/2)\\).</li> </ul> <p>Pomozite Okramu tako \u0161to \u0107ete mu re\u0107i koliko minimalno koraka (spajanja + polovljenja) je potrebno da bi se operacija odradila, to jest da bi ponovo spojio Edgara u jedan deo, kako bi znao da proceni vreme ovog hirur\u0161kog poduhvata.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Marko \u0160i\u0161ovi\u0107 Dragan Uro\u0161evi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N,  A[\\ldots])\\)</li> </ul> <p>Funkcija \\(Resi\\) se poziva samo jednom na po\u010detku ivr\u0161avanja programa, a njeni parametri su \\(N\\), broj delova gliste, i \\(A[\\ldots]\\), niz du\u017eine \\(N\\) koji sadr\u017ei du\u017eine delova gliste, i indeksiran je od \\(0\\). Povratna vrednost funkcije je minimalan broj koraka koji je potreban da se operacija izvr\u0161i.</p>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#ulaz","title":"Ulaz","text":"<pre><code>3\n1 2 1\n</code></pre>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Na po\u0161etku moramo podeliti srednji deo, nakon \u010dega imamo 4 dela du\u017eine 1. Sada mo\u017eemo spojiti prva dva, kao i poslednja dva dela, nakon \u010dega nam ostaju 2 dela du\u017eine 2 koje mo\u017eemo potom spojiti i time zavr\u0161iti postupak</p>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#ulaz_1","title":"Ulaz","text":"<pre><code>9\n1 1 1 1 1 1 1 1 1\n</code></pre>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#izlaz_1","title":"Izlaz","text":"<pre><code>8\n</code></pre>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Numeri\u0161imo delove od \\(1\\) do \\(9\\). Spojimo sada redom delove 1 i 2, 3 i 4, 5 i 6, kao i 8 i 9. Niz sada izgleda ovako: 2 2 2 1 2. Spojimo poslednja prva dva dela i poslednja dva dela i dobijamo niz: 4 2 3, kod kog mo\u017eemo spojiti poslednja dva dela odakle dobijamo niz: 4 5, koji sada mo\u017eemo spojiti i zavr\u0161iti postupak.</p>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N \\le 10^5\\)</li> <li>\\(S \\le 10^6\\), gde je \\(S\\) ukupna du\u017eina gliste, to jest suma brojeva u nizu</li> </ul>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(5\\) podzadataka:</p> <ul> <li>[10 poena] \\(S \\le 20\\)</li> <li>[10 poena] Du\u017eine svih delova, to jest svi elementi niza, su \\(1\\) ili \\(2\\).</li> <li>[20 poena] \\(S \\le 1000\\)</li> <li>[30 poena] \\(S \\le 10^5\\)</li> <li>[30 poena] Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>operacija_nad_glistom.cpp</code>  koji implementira pomenutu funkciju. Osim tra\u017eene funkcije, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>int Resi(int N, int* A);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojevi \\(N\\).</li> <li>U narednom redu \\(N\\) brojeva: \\(A_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje rezultate koje ona vrati.</p>"},{"location":"takprog/2022_2023/sio/01_operacija_nad_glistom/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo da su operacije razdvajanja i spajanja uzajamno inverzne (tj. iverzne jedna drugoj), tako da ako neka dva dela spojimo, nikad ih vi\u0161e ne\u0107emo razdvajati. U poslednjem potezu znamo da moramo da spojimo dva dela koji imaju jednake du\u017eine, ili dva dela od kojih je levi za jedan kra\u0107i od desnog (tj. du\u017eine delova su \\(\\left\\lfloor\\frac{S}{2}\\right\\rfloor\\) i \\(\\left\\lceil\\frac{S}{2}\\right\\rceil\\), gde je \\(S\\) ukupna du\u017eina gliste). Zbog toga treba da postoji indeks \\(k\\), tako da je suma du\u017eina prvih \\(k\\) delova jednaka \\(\\left\\lfloor\\frac{S}{2}\\right\\rfloor\\), a suma du\u017eina  preostalih delova iznosi \\(\\left\\lceil\\frac{S}{2}\\right\\rceil\\). Ako ne postoji takav indeks \\(k\\), onda se odre\u0111uje indeks \\(k\\) tako da je</p> \\[ \\sum_{i=1}^{k-1} a_i&lt; \\left\\lfloor\\frac{S}{2}\\right\\rfloor \\quad \\text{i} \\quad \\sum_{i=1}^{k} a_i &gt;  \\left\\lceil\\frac{S}{2}\\right\\rceil. \\] <p>Nakon toga se deo sa indeksom \\(k\\) deli sve dok se ne dobije niz u kome postoji indeks \\(l\\), takav da je</p> \\[ \\sum_{i=1}^{l} a_i = \\left\\lfloor\\frac{S}{2}\\right\\rfloor. \\] <p>To posti\u017eemo tako \u0161to svaki put delimo deo sa indeksom  \\(k'\\) za koji va\u017ei</p> \\[ \\sum_{i=1}^{k'-1} a_i &lt; \\left\\lfloor\\frac{S}{2}\\right\\rfloor \\quad \\text{i} \\quad \\sum_{i=1}^{k'} a_i &gt; \\left\\lceil\\frac{S}{2}\\right\\rceil. \\] <p>Kada dobijemo niz delova (koji ima \\(n'\\) delova) za koji postoji indeks \\(l\\) takav da je</p> <p>$$ \\sum_{i=1}^{l} a_i = \\left\\lfloor\\frac{S}{2}\\right\\rfloor. $$,</p> <p>onda raekrzivno pozivamo funkciju koja odre\u0111uje minimalni broj operacija potreban da se spoje prvih \\(l\\) delova u jedan deo i funciju koja odre\u0111uje minimalan broj operacija potreban da se spoji poslednjih \\(n'-l\\) delova  u jedan deo. Na kraju dva tako dobijena dela \u0107emo spojiti u jedan deo. Ukupan broj operacija je jednak zbiru broja operacija deljenja na po\u010detku funkcije, broju operacija za spajanje leve polovine, broja operacija za spajanje desne polovine i broja 1 za spajanje dva dobijena dela (polovine).</p> <p>Zna\u010di, za re\u0161avanje zadatka smo iskoristili tehniku podeli pa vladaj (\\(divide\\ and\\ conquer\\)). Primetimo da je slo\u017eenost jednog rekurzivnog poziva (odnosno pripreme za rekrzivne pozive tokom izvr\u0161avanja tog rekurzivnog poziva) \\({\\mathcal O}(S)\\), a da se rekurzivno poziva funkcija za nizove u kojima je suma du\u017eina delova \\(\\frac{S}{2}\\), pa je po master teoremi slo\u017eenost kompletnog funkcije \\({\\mathcal O}(S\\log S)\\).</p> 01_operacija_nad_glistom.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n;\n\nstruct node{\n    int val = -1;\n    node* next = nullptr;\n    node(int val):val(val){};\n    node(int val, node* next):val(val),next(next){};\n};\n\nnode *head, *tail;\n\nint solve(node* l_ptr, int total_sum){\n    /*for(node* i = head; i != 0; i = i-&gt;next){\n        if(l_ptr == i){\n            printf(\"*\");\n        }\n        printf(\"%d \", i-&gt;val);\n    }\n    printf(\"-- %d\\n\", total_sum);*/\n    if(l_ptr-&gt;val == total_sum){\n        return 0;\n    }\n    int ans = 0;\n    node* ptr = l_ptr;\n    int cur_sum = l_ptr-&gt;val;\n    while(cur_sum != total_sum/2){\n        while(cur_sum &lt; total_sum/2){\n            ptr = ptr-&gt;next;\n            cur_sum += ptr-&gt;val;\n        }\n        while(cur_sum &gt; total_sum/2){\n            int a = ptr-&gt;val;\n            int la = a/2, ra = (a + 1)/2;\n            cur_sum -= ra;\n            ptr-&gt;val = la;\n            ptr-&gt;next = new node(ra, ptr-&gt;next);\n            ans++;\n        }\n    }\n    ptr = ptr-&gt;next;\n    return ans + solve(l_ptr, total_sum/2) + solve(ptr, (total_sum + 1)/2) + 1;\n}\n\nint Resi(int N, int* A){\n    n = N;\n    int total_sum = 0;\n    for(int i = 0; i &lt; n; i++){\n        int in = A[i];\n        total_sum += in;\n        if(i == 0){\n            head = new node(in);\n            tail = head;\n        }\n        else{\n            tail-&gt;next = new node(in);\n            tail = tail-&gt;next;\n        }\n    }\n    return solve(head, total_sum);\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/","title":"2 - Kompresovani niz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 500ms 256MB <p>\u010clanovi komisije su odlu\u010dili da takmi\u010darima olak\u0161aju \u010ditanje tekstova, te je tekst ovog zadatka napisan formalno:</p> <p>Dat je niz \\(A\\) sa \\(N\\) elemenata i broj \\(K\\). Na nizu se primenjuju operacije slede\u0107eg tipa, sve dok je to mogu\u0107e:</p> <ul> <li>Izabere se podniz uzastopnih elemenata izme\u0111u pozicija \\(L\\) i \\(R\\) (uklju\u010duju\u0107i i te dve pozicije), du\u017eine ta\u010dno \\(K\\) (dakle \\(K  = R-L+1\\)) i ceo podniz se zameni jednim elementom, koji ima vrednost \\(A_L \\ \\text{or} \\  A_{L+1} \\ \\text{or} \\ ... \\ \\text{or} \\ A_{R-1} \\ \\text{or} \\  A_{R}\\). Operacija \\(x \\ \\text{or} \\  y\\) ozna\u010dava operaciju bitovske disjunkcije. Detaljnije informacije mo\u017eete pro\u010ditati u napomeni.</li> </ul> <p>Formalno, ozna\u010dimo sa \\(B\\) niz dobijen posle primene jedne operacije na nizu \\(A\\) sa \\(N\\) elemenata. Niz \\(B\\) ima \\(N-(K-1)\\) elemenata i to sa slede\u0107im vrednostima:</p> <ul> <li>\\(B_i = A_i\\) za \\(1 \\leq i &lt; L\\).</li> <li>\\(B_L = A_L \\ \\text{or} \\  A_{L+1} \\ \\text{or} \\ ... \\ \\text{or} \\ A_{R-1} \\ \\text{or} \\  A_{R}\\).</li> <li>\\(B_i = A_{i+(K-1)}\\) za \\(L &lt; i \\leq N-(K-1)\\).</li> </ul> <p>Nakon \u0161to u nizu ostane manje od \\(K\\) elemenata, posmatramo sumu elemenata koji su preostali. Cilj je da minimizujete sumu elemenata koji preostanu na kraju. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Vladimir Milenkovi\u0107"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N,  A[\\ldots], K)\\)</li> </ul> <p>Funkcija \\(Resi\\) se poziva samo jednom na po\u010detku ivr\u0161avanja programa, a njeni parametri su \\(N\\), \\(A[\\ldots]\\) i \\(K\\). Povratna vrednost funkcije re\u0161i je minimalna suma elemenata, nakon primene najve\u0107eg mogu\u0107eg broja operacija. Niz A je indeksiran od 1.</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#primer","title":"Primer","text":"<p>Neka je \\(N=4\\),  \\(A=[2,6,12,5]\\), \\(K=3\\). Nakon primene operacije na poslednja tri elementa originalnog niza \\(A\\), dobija se niz \\([2,6 \\ \\text{or} \\  12 \\ \\text{or} \\  5] = [2,15]\\) sa sumom \\(17\\). Lako se utvr\u0111uje da je ovo najmanja mogu\u0107a suma, te je potrebno vratiti vrednost \\(17\\).</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq K \\leq N \\leq 400.000\\).</li> <li>\\(0 \\leq A_i \\leq 1.000.000.000\\).</li> </ul>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[7 poena]: \\(N \\le 10\\).</li> <li>[9 poena]: \\(K \\le 3\\) i \\(N \\le 100.000\\).</li> <li>[15 poena]: Sve vrednosti u nizu \\(A\\) su \\(1\\) ili \\(2\\) i \\(N \\le 100.000\\).</li> <li>[22 poena]: \\(N \\le 3.000\\).</li> <li>[29 poena]: \\(N \\le 100.000\\).</li> <li>[18 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>kompresovani_niz.cpp</code>  koji implementira pomenute funkcije. Osim tra\u017eenih funkcija, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija moraju biti slede\u0107eg oblika:</p> <p><code>long long Resi(int N, int* A, int K);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojevi \\(N\\) i \\(K\\).</li> <li>U narednom redu \\(N\\) brojeva: \\(A_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje rezultate koje ona vrati.</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#napomena","title":"Napomena","text":"<p>Operator disjunkcije je u  C++ zapisan pomo\u0107u simbola <code>|</code>. Ova operacija \\(x\\ \\text{or} \\ y\\) se za nenegativne cele brojeve \\(x,y\\) defini\u0161e na slede\u0107i na\u010din. Prvo se brojevi zapi\u0161u u binarnom zapisu. Ukoliko jedan broj ima manje cifara od drugog, dopisuju mu se vode\u0107e nule sve dok ne budu imali isti broj binarnih cifara. Tako se dobijaju dva niza binarnih cifara, ozna\u010dimo ih sa \\(a_1, \\ldots, a_k\\) i \\(b_1, \\ldots b_k\\). Zatim se za svaku poziciju \\(i \\in \\{1, \\ldots, k \\}\\) ra\u010duna \\(c_i\\) pomo\u0107u slede\u0107ih pravila:</p> <ul> <li>Za \\(a_{i} = 0, b_{i} = 0\\) va\u017ei \\(c_{i} = 0\\)</li> <li>Za \\(a_{i} = 0, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 0\\) va\u017ei \\(c_{i} = 1\\)</li> <li>Za \\(a_{i} = 1, b_{i} = 1\\) va\u017ei \\(c_{i} = 1\\)</li> </ul> <p>Niz binarnih cifara \\(c_1, \\ldots, c_k\\) (koji mo\u017eda ima vode\u0107e nule) je binarni zapis rezultata, odnosno broja \\(x \\ \\text{or} \\  y\\).</p> <p>Bitovska disjunkcija izme\u0111u \\(n\\) elemenata \\(x_{1},x_{2},...,x_{n}\\) defini\u0161e se kao \\(x_{1} \\ \\text{or} \\ x_{2}  \\ \\text{or} \\  ...  \\ \\text{or} \\  x_{n} = (...(((x_{1}  \\ \\text{or} \\  x_{2})  \\ \\text{or} \\  x_{3}) \\ \\text{or} \\ x_{4})...)  \\ \\text{or} \\  x_{n}\\).</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#resenje-kada-n-leq-10","title":"Re\u0161enje kada \\(N \\leq 10\\)","text":"<p>U ovom podzadatku mo\u017eemo testirati svaki mogu\u0107i niz primene operacija. Za dato \\(K\\) imamo \\(N-K+1 = (N - (K-1))\\) opcija za primenu prve operacije. Posle prvog koraka, broj elemenata se smanji za \\(K-1\\), pa u drugom koraku imamo \\(N-2\\cdot(K-1)\\) opcija. Ukupno, postoji \\((N-(K-1)) \\cdot (N-2\\cdot(K-1)) \\cdot ... \\cdot ( (K-1) + (N\\mod(K-1)))\\) razli\u010ditih sekvenci operacija koje rezultuju nizom du\u017eine manje od \\(K\\). Prethodni proizvod je ograni\u010den sa \\((N-1)!\\), pa je slo\u017eenost ovog re\u0161enja \\(O(N!)\\).</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#resenje-kada-k-leq-3-i-n-leq-100000","title":"Re\u0161enje kada \\(K \\leq 3\\) i  \\(N \\leq 100.000\\)","text":"<p>Za naredne podzadatke moramo malo detaljnije analizirati kako primene operacija uti\u010du na niz. Za ovaj podzadatak, dovoljno je primetiti da su elementi krajnjeg niza zapravo kompresovani blokovi uzastopnih elemenata u po\u010detnom nizu. Ti blokovi uzastopnih elemenata imaju du\u017einu \\(1 \\mod (K-1)\\), \u0161to je lako pokazati. Naime, u po\u010detnom nizu blokovi imaju du\u017einu \\(1\\). Svakom daljom kompresijom se \\(K\\) takvih blokova spaja u jedan blok, koji po modulu \\(K-1\\) ima du\u017einu \\(K \\cdot 1 = K = 1 \\mod (K-1)\\). Kona\u010dno, za ovaj podzadatak mo\u017eemo da analiziramo dva slu\u010daja:</p> <ul> <li>\\(K=2\\) - tada krajnji niz ima du\u017einu \\(1\\), a vrednost tog elementa je \\(\\textbf{or}\\) vrednosti svih elemenata u po\u010detnom nizu</li> <li>\\(K=3\\) - tada krajnji niz ima du\u017einu \\(1\\) ukoliko je \\(N\\) neparno i \\(2\\), ukoliko je \\(N\\) parno. Ukoliko je \\(N\\) neparno, tada je vrednost jedinog elementa \\(\\textbf{or}\\) vrednosti svih elemenata u po\u010detnom nizu. Kona\u010dno, ukoliko je \\(N\\) parno, mo\u017eemo da iteriramo po zavr\u0161etku prvog bloka, koji se zavr\u0161ava na nekom neparnom indeksu u po\u010detnom nizu i da posmatramo prefiksni i sufiksni \\(\\textbf{or}\\) elemenata po\u010detnog niza. Re\u0161enje zadatka je minimum njihove sume.</li> </ul>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#resenje-kada-n-le-3000","title":"Re\u0161enje kada \\(N \\le 3.000\\)","text":"<p>Ovaj i naredne podzadatke re\u0161avamo dinami\u010dkim programiranjem. Vrednost \\(dp[i]\\) \u0107e predstavljati minimalnu vrednost sume ukoliko se ograni\u010dimo isklju\u010divo na prvih \\(i\\) elemenata niza. Prvo moramo primetiti da je uslov da se operacije primenjuju sve dok niz ima dovoljno elemenata su\u0161tinski neva\u017ean. Naime, primenom operacije se suma elemenata niza ne mo\u017ee pove\u0107ati, te je svakako uvek bolje primeniti \u0161to vi\u0161e operacija. Za svaku poziciju \\(i\\), iteriramo po zavr\u0161noj poziciji prethodnog bloka. Rekurentna formula za na\u0161e dinami\u010dko programiranje je \\(\\min_j (dp[j] + A[j+1] \\textbf{ or } A[j+2] \\textbf{ or } ... \\textbf{ or } A[i])\\), gde je \\(i - j = 1 \\mod (K-1)\\) (jer prema opservaciji iz prethodnog podzadatak va\u017ei da je du\u017eina svakog bloka \\(1 \\mod (K-1)\\)). Ukoliko odr\u017eavamo vrednost \\(A[j+1] \\textbf{ or } A[j+2] \\textbf{ or } ... \\textbf{ or } A[i]\\), dok iteriramo po \\(j\\), dobijamo re\u0161enje slo\u017eenosti \\(O(N^2)\\).</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#resenje-kada-su-sve-vrednosti-u-nizu-a-su-1-ili-2-i-n-le-100000","title":"Re\u0161enje kada su sve vrednosti u nizu \\(A\\) su \\(1\\) ili \\(2\\) i \\(N \\le 100.000\\)","text":"<p>I u ovom podzadatku ponovo posmatramo blokove. Svaki blok ima vrednost \\(1\\), \\(2\\) ili \\(3\\). Me\u0111utim, blok koji se zavr\u0161ava na nekoj poziciji \\(i\\) mo\u017ee da ima samo dve vrednosti, a to su \\(A[i]\\) i \\(3\\) (npr. ukoliko \\(i\\)-ti element ima vrednost \\(1\\), blok koji se zavr\u0161ava na poziciji \\(i\\) nikako ne mo\u017ee da ima vrednost \\(2\\) i obrnuto). Za svaku krajnju poziciju, fiksiramo jednu od te dve mogu\u0107e vrednosti poslednjeg bloka i posmatramo sve mogu\u0107e startne pozicije trenutnog bloka. Za njih mo\u017eemo da odr\u017eavamo minimum koriste\u0107i neku strukturu podataka, na primer <code>set</code>.</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#resenje-kada-n-le-100000","title":"Re\u0161enje kada \\(N \\le 100.000\\)","text":"<p>Re\u0161enje ovog podzadatka predstavlja nadogradnju na re\u0161enje podzadatka u kojem su sve vrednosti u nizu \\(A\\) jednake \\(1\\) ili \\(2\\). Mo\u017eemo da primetimo da postoji najvi\u0161e \\(\\log_2 \\max_i A[i] \\leq 30\\) mogu\u0107ih razli\u010ditih vrednosti bloka koji se zavr\u0161ava na poziciji \\(i\\) za svako \\(i\\). Sada mo\u017eemo da fiksiramo jednu od tih vrednosti i prona\u0111emo najraniju poziciju (ozna\u010dimo tu poziciju sa \\(j\\)) na kojoj je trenutni blok mogao da po\u010dne da bi imao tu vrednost. Zatim, koriste\u0107i neku strukturu, npr. <code>set</code> prona\u0111emo minimum vrednosti \\(dp\\)-ova prethodnog bloka od pozicije \\(j\\) pa do \\(i\\). Ovo mo\u017eemo da realizujemo koriste\u0107i <code>set</code> na slede\u0107i na\u010din. Mo\u017eemo da \u010duvamo \\(K-1\\) <code>set</code>-ova, jedan za svaku krajnju pozicija moduo \\(K-1\\). U svakom od njih mo\u017eemo da \u010duvamo vrednosti \\(dp\\)-ova sortirano po indeksu. Kona\u010dno kada ubacujemo \\(dp[i]\\) u <code>set</code> koji odgovara modulu \\(i \\mod (K-1)\\), treba da izbacimo sve one koje koji se pojavljuju pre njega, a imaju ve\u0107u vrednost od \\(dp[i]\\). Kada tra\u017eimo minimum od pozicije \\(j\\) do pozicije \\(i\\), mo\u017eemo da pozovemo ugra\u0111enu funkciju <code>lower_bound</code>, da bi prona\u0161li prvi indeks ve\u0107i od \\(j\\) koji postoji u odgovaraju\u0107em <code>set</code>-u. Slo\u017eenost ovog re\u0161enja je \\(O(N \\log N \\log \\max_i A[i])\\).</p>"},{"location":"takprog/2022_2023/sio/02_kompresovani_niz/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za glavno re\u0161enje i poslednji podzadatak, dovoljno je optimizovati slo\u017eenost na \\(O(N \\log \\max_i A[i])\\). Ovo se mo\u017ee posti\u0107i na primer tako \u0161to zamenimo <code>set</code> sa spars tabelom. </p> 02_kompresovani_niz.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 400005\n#define maxl 31\nusing namespace std;\nint l;\nlong long dp[maxn];\nlong long prev_bit[maxl];\nlong long sprs[maxn][21];\nint val[maxn];\nint bit[2][maxl];\nint pos[2][maxl];\npair&lt;int,int&gt; v[2][maxl];\ninline long long query(int p,int q) {\n    int k=val[q-p];\n    return min(sprs[q][k],sprs[p+((1&lt;&lt;k)-1)*l][k]);\n}\nlong long Resi(int N, int* A, int K)\n{\n    l=K-1;\n    int c=0;\n    for(int j=1;j*l&lt;maxn;j++) {\n        if(2*(1&lt;&lt;c)&lt;=j) c++;\n        val[j*l]=c;\n    }\n    for(int j=0;j&lt;maxl;j++) bit[0][j]=bit[1][j]=j;\n    int g=0;\n    for(int i=1;i&lt;=N;i++) {\n        int c=0;\n        for(int j=0;j&lt;maxl;j++) {\n            if(A[i]&amp;(1&lt;&lt;bit[g][j])) {\n                pos[g^1][c]=i;\n                bit[g^1][c]=bit[g][j];\n                c++;\n            }\n        }\n        for(int j=0;j&lt;maxl;j++) {\n            if(!(A[i]&amp;(1&lt;&lt;bit[g][j]))) {\n                pos[g^1][c]=pos[g][j];\n                bit[g^1][c]=bit[g][j];\n                c++;\n            }\n        }\n        g^=1;\n        dp[i]=A[i]+dp[i-1];\n        int o=0;\n        c=(i-1);\n        int fst=c-l*(c/l);\n        for(int j=0;j&lt;maxl;j++) {\n            if(pos[g][j]==0) break;\n            if(pos[g][j]==i) {\n                o|=(1&lt;&lt;bit[g][j]);\n                continue;\n            }\n            if(j!=0 &amp;&amp; pos[g][j]==pos[g][j-1]) {\n                o|=(1&lt;&lt;bit[g][j]);\n                continue;\n            }\n            int rm=c%l;\n            int start=c-l*((c-(pos[g][j]))/l);\n            dp[i]=min(dp[i],query(start,c)+o);\n            o|=(1&lt;&lt;bit[g][j]);\n            if(query(fst,start)+o&gt;dp[i]) break;\n        }\n        int rm=c%l;\n        dp[i]=min(dp[i],query(fst,c)+o);\n        sprs[i][0]=dp[i];\n        for(int j=1;i-((1&lt;&lt;j)-1)*l&gt;=0;j++) {\n            sprs[i][j]=min(sprs[i][j-1],sprs[i-((1&lt;&lt;(j-1)))*l][j-1]);\n        }\n    }\n    return dp[N];\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/","title":"3 - Najslabija karika","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3500ms 512MB <p>Svet nije mesto za slabi\u0107e, ve\u0107 samo najja\u010di opstaju. Potkrepio bih ovakav argument nekim primerima, ali, na\u017ealost, to u ovom trenutku nije mogu\u0107e (razmislite za\u0161to?). Mora\u0107ete naprosto da mi verujete na re\u010d, samo najja\u010di opstaju.</p> <p>No dobro, i u ovom zadatku samo najja\u010di opstaju. Naime, na datom nizu razli\u010ditih pozitivnih celih brojeva \\(A\\) smemo da vr\u0161imo slede\u0107u operaciju: ako je neki broj u nizu manji od svih svojih suseda, onda ga mo\u017eemo izbaciti (slabi\u0107). Na primer u nizu \\(2,3,1,4,5\\) mo\u017eemo izbaciti broj \\(2\\) ili broj \\(1\\). Ozna\u010dimo sa \\(D(A)\\) broj razli\u010ditih nizova (mogu\u0107e \u010dak i praznih) koje je mogu\u0107e dobiti primenom nekog broja ovakvih operacija krenuv\u0161i od niza \\(A\\).</p> <p>Vama je data permutacija \\(A\\) brojeva od \\(1\\) do \\(N\\). Neka sa \\(A[L\\ldots R]\\) ozna\u010dimo podniz ove permutacije koji sadr\u017ei elemente \\(A[L],A[L+1],\\ldots,A[R]\\). Zadatak za najja\u010de me\u0111u takmi\u010darima je da odgovore na \\(Q\\) upita koji tra\u017ee da sra\u010dunate \\(D(A[L\\ldots R])\\). Naravno, kako ovaj broj mo\u017ee biti prevelik, potrebno ga je sra\u010dunati po modulu \\(10^9+7\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkcije</p> <ul> <li>\\(Init(N,  A[\\ldots])\\)</li> <li>\\(Query(L, R)\\)</li> </ul> <p>Funkcija \\(Init\\) se poziva samo jednom na po\u010detku ivr\u0161avanja programa njegovi argumenti su \\(N\\) i \\(A[\\ldots]\\), gde je \\(A[\\ldots]\\) permutacija brojeva od \\(1\\) do \\(N\\).   Niz je indeksiran od 1.</p> <p>Zatim se funkcija \\(Query\\) poziva \\(Q\\) puta. Ona treba da vrati \\(D(A[L\\ldots R])\\).</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#primer","title":"Primer","text":"<p>Neka je \\(N=5\\),  \\(A=\\{2,3,1,4,5\\}\\). Ako bismo hteli da sra\u010dunamo   \\(D(A[1\\ldots3])\\), odnosno \\(D(\\{2,3,1\\})\\), odgovor bi bio \\(5\\), jer su nizovi koje bismo dobili \\(\\{\\}\\), \\(\\{3\\}\\), \\(\\{2,3\\}\\), \\(\\{3,1\\}\\), \\(\\{2,3,1\\}\\). Ako bi tra\u017eili \\(D(A[1\\ldots5])\\), odnosno \\(D(\\{2,3,1,4,5\\})\\) , odgovor bi bio \\(7\\) sa nizovima \\(\\{\\},\\) \\(\\{5\\}\\), \\(\\{4,5\\}\\), \\(\\{3,4,5\\}\\), \\(\\{2,3,4,5\\}\\), \\(\\{3,1,4,5\\}\\), \\(\\{2,3,1,4,5\\}\\).</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,Q \\leq 500.000\\)</li> </ul>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadatka:</p> <ul> <li>[6 poena]: \\(N\\le10\\), \\(Q\\le 100\\)</li> <li>[9 poena]: \\(N,Q\\le500\\)</li> <li>[13 poena]: \\(N,Q\\le5000\\)</li> <li>[14 poena]: Broj \\(N\\) se u nizu \\(A\\) nalazi izme\u0111u \\(L\\) i \\(R\\) u svakom upitu</li> <li>[20 poena]: Sa jednakom verovatno\u0107om je izabrana jedna od mogu\u0107ih permutacija</li> <li>[38 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>samo_najjaci_opstaju.cpp</code>  koji implementira pomenute funkcije. Osim tra\u017eenih funkcija, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161e funkcije moraju biti slede\u0107eg oblika:</p> <p><code>void Init(int N, int* A);</code> <code>int Query(int L, int R);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojevi \\(N\\) i \\(Q\\).</li> <li>U narednom redu \\(N\\) brojeva: \\(A[i]\\).</li> <li>U narednih \\(Q\\) redova po \\(2\\) broja: \\(L\\) i \\(R\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje rezultat koji va\u0161a funkcija vrati.</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#resenje-kada-n-leq-10-qleq100","title":"Re\u0161enje kada \\(N \\leq 10\\), \\(Q\\leq100\\)","text":"<p>Primetimo da svaki niz koji dobijemo na kraju je podsekvenca po\u010detnog, pa za dati niz postoji najvi\u0161e \\(2^N\\) mogu\u0107ih podsekvenci i za svaku mo\u017eemo gramzivim algoritmom da proverimo da li se zaista mo\u017ee dobiti opisanim operacijama. \\(O(Q2^NN)\\) </p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#resenje-kada-nq-leq-500","title":"Re\u0161enje kada \\(N,Q \\leq 500\\)","text":"<p>Za svaki podzadatak nadalje \u0107emo morati da se udubimo u koncept Dekartovog stabla niza. Naime, to je binarno stablo koje se konstrui\u0161e rekurzivno (u kvadratnom vremenu) na slede\u0107i na\u010din: neka je \\(i\\) indeks maksimuma u na\u0161em nizu, onda je \u010dvor \\(i\\) koren na\u0161eg stabla. Zatim, podelimo niz na dva niza \\(1\\),\\(2\\),\\(\\cdots\\),\\(i-1\\) i \\(i+1,i+2,\\cdots,N\\) i na\u0111emo Dekartovo stablo od ova dva podniza, \u010dijim ka\u010danjem na koren \\(i\\) kao levo i desno dete, redom, \u0107emo dobiti Dekartovo stablo celog niza. Sada mo\u017ee se primetiti da je mogu\u0107e ukloniti neki \u010dlan niza akko smo ve\u0107 uklonili celo njegovo podstablo u Dekartovom stablu. Stoga je zadatak zapravo ekvivalentan sa tra\u017eenjem broja na\u010dina kako mo\u017eemo da izaberemo nekoliko disjunktnih podstabala Dekartovog stabla datog niza. Ovo se re\u0161ava prostim dinami\u010dkim programiranjem na stablu. Ako su \\(l\\) i \\(r\\) deca \u010dvora \\(u\\), onda mo\u017eemo da sra\u010dunamo \\(dp[u]=dp[l]\\cdot dp[r]+1\\). \\(O(QN^2)\\)</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#resenje-kada-nq-leq-500_1","title":"Re\u0161enje kada \\(N,Q \\leq 500\\)","text":"<p>Ovaj podzadatak se radi sli\u010dno kao i prethodni, samo je potrebno da se br\u017ee izgradi Dekartovo stablo. Ovo mo\u017ee da se uradi, na primer, tako \u0161to se za svaki element niza na\u0111e prvi element levo i desno ve\u0107i od njega (preko takozvane \"stek fore\"), i onda je njegov roditelj u Dekartovom stablu upravo manji od ta dva broja. \\(O(NQ)\\)</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#resenje-kada-svaki-upit-sadrzi-maksimum","title":"Re\u0161enje kada svaki upit sadr\u017ei maksimum","text":"<p>Nadalje je jasno da je klju\u010dni problem kako brzo nalaziti Dekartovo stablo za podniz ili bar dovoljno informacija o tom Dekartovom podstablu. Ako interval sadr\u017ei \\(M\\) \u010diji je indeks \\(i\\) onda je jasno da je dovoljno re\u0161iti zadatak samo za \\([L,i]\\) i \\([i,R]\\) odvojeno, nakon \u010dega lako nalazimo re\u0161enje ukupno. Sada \u0107emo ra\u010dunati odgovor za svaki interval oblika \\([i,R]\\) nekom vrstom dinami\u010dkog programiranja, gde \u0107emo se pozivati na vrednosti koje smo sra\u010dunali dinami\u010dkog programiranja za ceo niz (ako bismo prvo re\u0161ili zadatak za ceo niz kao u prethodnom podzadatku). Naime neka je \\(last[R]\\) najve\u0107i indeks broja ve\u0107eg od onog na poziciji \\(R\\). Ako je \\(last[R]=i\\), potrebno nam je samo re\u0161enje za interval \\([i+1,R-1]\\). Ukoliko nije, onda je re\u0161enje jednako re\u0161enju za \\(last[R]\\), ali treba da mu dodamo jo\u0161 proizvod re\u0161enja za \\([last[R]+1,R-1]\\),\\(\\cdots\\), \\([last^k[R]+1, last^{k-1}[R]-1]\\) (u kasnijim podzadacima \u0107emo videti ta\u010dan razlog ovome). Me\u0111utim, sva ova re\u0161enja potproblema koja nam trebaju su zapravo ve\u0107 izra\u010dunati u Dekartovom stablu, tako da ve\u0107 za te intervale znamo da re\u0161imo problem i kombinovanjem svega toga mo\u017eemo re\u0161iti ovaj podzadatak. </p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#resenje-kada-je-permutacija-nasumicna","title":"Re\u0161enje kada je permutacija nasumi\u010dna","text":"<p>Inspirisani prethodnim podzadatkom, jasno je da se nekako sve vrti oko maksimuma na intervalu \\(L,R\\), tako da bi bilo lepo kada bismo na\u0161li vezu maksimuma na intervalu i Dekartovog stabla. Nije te\u0161ko uveriti se da je najmanji zajedni\u010dki predak od \\(L\\) i \\(R\\) zaista maksimum na intervalu \\([L,R]\\). Me\u0111utim, sada dolazi pitanje, kako ta\u010dno izgleda to Dekartovo stablo podniza, i da li mo\u017eemo da ga izrazimo preko Dekartovog stabla po\u010detnog niza. Ispostavlja se da mo\u017eemo, i to na slede\u0107i na\u010din: krenimo od \u010dvora \\(L\\) i njegovog desnog podstabla. Sada idemo putem od \\(L\\) do \\(LCA(L,R)\\): ako do\u0111emo u neki \u010dvor iz levog deteta, onda taj \u010dvor izbacujemo, a \u010dvor iz kog smo do\u0161li prespojimo sa njegovim dedom. Ovo isto radimo sa \\(R\\), samo zamenimo re\u010di \"levo\" i \"desno\". Uverite se sami da ovakva konstrukcija radi!! Kako je permutacija random generisana, zapravo mo\u017eemo da tvrdimo da je Dekartovo stablo dubine reda veli\u010dine \\(O(\\log N)\\), pa ovakvu simulaciju mo\u017eemo da vr\u0161imo u \\(O(Q\\log N)\\), kao i onda prera\u010dunavanje vrednosti dinami\u010dkog programiranja za tih \\(O(\\log N)\\) novih vrednosti po upitu.</p>"},{"location":"takprog/2022_2023/sio/03_samo_najjaci_opstaju/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sada treba nekako izbe\u0107i ru\u010dnu simulaciju pravljenja novog Dekartovog stabla, kada ne znamo da je ono plitko. Ovo \u0107emo raditi, naravno, putem *sparse tabela. Naime za svaki \u010dvor \u0107emo primetiti da nam je operacija koja se primeni na trenutnu vrednost \\(dp\\) biti oblika linearna oblika \\(dp\\) \\(-&gt;dp\\cdot x+c\\). \u0160ta mislimo pod ovime? Pa ako imamo vrednost \\(dp[l]\\), onda nalazimo vrednost za \\(dp[u]=dp[l]\\cdot dp[r]+1\\), zna\u010di transformaciju od \\(dp[l]\\) u \\(dp[u]\\) imamo po gornjoj formuli za \\(k=dp[r]\\), \\(c=1\\). Me\u0111utim, ono \u0161to je va\u017eno primetiti je da je kompozicija dve operacije ovog tipa opet operacija tog tipa (kompozivcija dve linearne funkcije je opet linearna). Tako da mi u sparse tabeli mo\u017eemo na\u0107i kako izgleda formula za \\(dp[2^k\\text{-ti predak od }u]\\) preko \\(dp[u]\\). Ono \u0161to jo\u0161 va\u017ei je da je \\(x\\cdot1+0\\), neutral za operaciju kompozicije funkcije. Onda nalazimo re\u0161enje na slede\u0107i na\u010din: imamo dve tabele, jedna koja kad idemo na gore od nekog \u010dvora kad u\u0111emo sleva mno\u017ei rezultat sa vrednosti \\(dp\\) od desnog deteta i dodaje \\(1\\), a ako ulazi sdesna onda ne radi ni\u0161ta i druga koja radi obrnuto. Nije te\u0161ko videti da se na ovaj na\u010din ako krenemo od \\(L\\) do \\(LCA(L,R)\\) upravo ra\u010duna re\u0161enje problema za taj podinterval, a takve operacije su sve linearne, pa svaku od njih mo\u017eemo pretvoriti u spars tabelu, koja nam dozvoljava brzo ra\u010dunanje re\u0161enja za taj podinterval. Zatim radimo to za desnu stranu i spajamo re\u0161enja kao u podzadatku \\(4\\). Slo\u017eenost \\(O(Q\\log N)\\). </p> 03_samo_najjaci_opstaju.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 500007\n#define MAXL 20\n#define MOD 1000000007\nusing namespace std;\nint a[MAXN],lg[MAXN],rg[MAXN],l[MAXN],r[MAXN],in[MAXN],out[MAXN],p[MAXL][MAXN],t;\nlong long dp[MAXN],mul[2][MAXL][MAXN],pls[2][MAXL][MAXN];\nvoid dfs(int s)\n{\n    in[s]=t++;\n    if(l[s]) dfs(l[s]);\n    if(r[s]) dfs(r[s]);\n    if(l[s] || r[s]) dp[s]=(dp[l[s]]*dp[r[s]]+1)%MOD;\n    else dp[s]=2;\n    out[s]=t++;\n}\nbool insub(int u,int v) {return in[u]&gt;=in[v] &amp;&amp; out[u]&lt;=out[v];}\nint LCA(int u,int v)\n{\n    if(insub(v,u)) return u;\n    if(insub(u,v)) return v;\n    for(int j=MAXL-1;j&gt;=0;j--) if(!insub(v,p[j][u])) u=p[j][u];\n    return p[0][u];\n}\nvoid Init(int N, int* A)\n{\n    a[0]=N+2;\n    a[N+1]=N+1;\n    stack&lt;int&gt; st; st.push(0);\n    for(int i=1;i&lt;=N;i++) a[i]=A[i];\n    for(int i=1;i&lt;=N;i++)\n    {\n        while(a[st.top()]&lt;a[i]) st.pop();\n        lg[i]=st.top();\n        st.push(i);\n    }\n    while(!st.empty()) st.pop();\n    st.push(N+1);\n    for(int i=N;i&gt;=1;i--)\n    {\n        while(a[st.top()]&lt;a[i]) st.pop();\n        rg[i]=st.top();\n        st.push(i);\n    }\n    for(int i=1;i&lt;=N;i++) l[i]=r[i]=0;\n    for(int i=1;i&lt;=N;i++)\n    {\n        if(a[lg[i]]&lt;a[rg[i]])\n        {\n            p[0][i]=lg[i];\n            r[lg[i]]=i;\n        }\n        else\n        {\n            p[0][i]=rg[i];\n            l[rg[i]]=i;\n        }\n    }\n    dp[0]=1;\n    dfs(N+1);\n    p[0][N+1]=N+1;\n    for(int i=1;i&lt;=N;i++)\n    {\n        if(A[i]==N) continue;\n        if(a[lg[i]]&lt;a[rg[i]])\n        {\n            mul[0][0][i]=1;\n            pls[0][0][i]=0;\n            mul[1][0][i]=dp[l[p[0][i]]];\n            pls[1][0][i]=1;\n        }\n        else\n        {\n            mul[0][0][i]=dp[r[p[0][i]]];\n            pls[0][0][i]=1;\n            mul[1][0][i]=1;\n            pls[1][0][i]=0;\n        }\n    }\n    for(int j=1;j&lt;MAXL;j++) for(int i=1;i&lt;=N+1;i++)\n    {\n        p[j][i]=p[j-1][p[j-1][i]];\n        for(int k=0;k&lt;2;k++)\n        {\n            mul[k][j][i]=(mul[k][j-1][i]*mul[k][j-1][p[j-1][i]])%MOD;\n            pls[k][j][i]=(mul[k][j-1][p[j-1][i]]*pls[k][j-1][i]+pls[k][j-1][p[j-1][i]])%MOD;\n        }\n    }\n}\nint Query(int L,int R)\n{\n    int w=LCA(L,R);\n    long long pl=0,ml=dp[r[L]]+1,pd=0,md=dp[l[R]]+1;\n    if(L==w) ml=1;\n    else\n    {\n        for(int j=MAXL-1;j&gt;=0;j--) if(!insub(w,p[j][L]))\n        {\n            ml=(ml*mul[0][j][L])%MOD;\n            pl=(pl*mul[0][j][L]+pls[0][j][L])%MOD;\n            L=p[j][L];\n        }\n    }\n    if(R==w) md=1;\n    else\n    {\n        for(int j=MAXL-1;j&gt;=0;j--) if(!insub(w,p[j][R]))\n        {\n            md=(md*mul[1][j][R])%MOD;\n            pd=(pd*mul[1][j][R]+pls[1][j][R])%MOD;\n            R=p[j][R];\n        }\n    }\n    return ((ml+pl)*(md+pd)+1)%MOD;\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/04_opet_xor/","title":"4 - Opet XOR","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 4000ms 512MB <p>\u010culi smo da ovogodi\u0161njim takmi\u010denjima nije bilo dovoljno zadataka u kojima se pominje XOR. SIO je pravo mesto da se ovaj previd ispravi.</p> <p>Ka\u017eemo da je niz \\(X_1, X_2, \\dots, X_k\\) ksortasti\u010dan ako je mogu\u0107e preurediti ga tako da XOR-ovi svih prefiksa preure\u0111enog niza budu strogo rastu\u0107i. Formalnije, niz je ksortasti\u010dan ako postoji permutacija \\(\\pi_1, \\pi_2, \\dots, \\pi_k\\) brojeva od \\(1\\) do \\(k\\) takva da za vrednosti \\(Y_1, Y_2, \\dots, Y_k\\) definisane sa </p> \\[Y_i = X_{\\pi_1} \\oplus X_{\\pi_2} \\oplus \\dots \\oplus X_{\\pi_i}\\] <p>va\u017ei \\(Y_1 &lt; Y_2 &lt; \\dots &lt; Y_k\\) (gde je \\(\\oplus\\) XOR).</p> <p>Dat je niz \\(A_1, A_2, \\dots, A_n\\) du\u017eine \\(n\\). Va\u0161 program treba da odgovori na dve vrste upita:</p> <ul> <li>\\(1\\) \\(i\\) \\(x\\): postavi vrednost \\(A_i\\) na \\(x\\).</li> <li>\\(2\\) \\(i\\) \\(k\\): da li je podniz du\u017eine \\(k\\) koji po\u010dinje sa \\(A_i\\) ksortasti\u010dan?</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Dimitrije Erdeljan Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2022_2023/sio/04_opet_xor/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, A[\\dots], Q, T[\\dots], I[\\dots], X[\\dots], O[\\dots])\\)</li> </ul> <p>Funkcija \\(Resi\\) se poziva samo jednom na po\u010detku ivr\u0161avanja programa, a njeni parametri su:</p> <ul> <li>\\(N\\): du\u017eina niza \\(A\\).</li> <li>\\(A[\\dots]\\): po\u010detne vrednosti niza nad kojim se vr\u0161e upiti, du\u017eine \\(N\\), indeksiran od 1.</li> <li>\\(Q\\): broj upita.</li> <li>\\(T[\\dots]\\), \\(I[\\dots]\\), \\(X[\\dots]\\): nizovi du\u017eine \\(Q\\), indeksirani od 1, koji opisuju upite, \u010diji odgovori se upisuju u \\(O[\\dots]\\). \\(i\\)-ti upit mo\u017ee biti:<ul> <li>Ako je \\(T[i] = 1\\): postavi \\(A_{I[i]}\\) na \\(X[i]\\).</li> <li>Ako je \\(T[i] = 2\\): program treba da u \\(O[i]\\) upi\u0161e <code>true</code> ako je niz \\(A_{I[i]}, A_{I[i]+1}, \\dots, A_{I[i]+X[i]-1}\\) (du\u017eine \\(X[i]\\)) ksortasti\u010dan, i <code>false</code> u suprotnom.</li> </ul> </li> </ul>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#primer","title":"Primer","text":"<p>Neka je \\(N=5\\), \\(A=[1, 1, 3, 3, 3]\\), \\(Q=3\\), \\(T = [2,1,2]\\), \\(I = [1, 3, 1]\\), \\(X = [3, 2, 3]\\). Na prvi upit tipa \\(2\\), odgovor je <code>true</code>, jer se niz \\([1, 1, 3]\\) mo\u017ee preurediti kao \\([1, 3, 1]\\) tako da XOR-ovi prefiksa budu \\([1, 2, 3]\\). Na drugi upit tipa \\(2\\), odgovor je <code>false</code>, jer nijedna permutacija niza \\([1, 3, 2]\\) nema ovu osobinu.</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 3 \\cdot 10^5\\).</li> <li>\\(0 \\leq A[i] &lt; 2^{30}\\).<ul> <li>Ovo \u0107e va\u017eiti i nakon svakog upita tipa \\(1\\).</li> </ul> </li> <li>Svi indeksi i podnizovi u upitima su u granicama niza \\(A\\).</li> </ul>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#podzadaci","title":"Podzadaci","text":"<p>Test primeri su podeljeni u \\(6\\) podzadataka:</p> <ul> <li>[8 poena]: \\(Q \\leq 10\\), \\(X[i] \\leq 10\\) za upite tipa \\(2\\).</li> <li>[15 poena]: \\(N, Q \\leq 200\\).</li> <li>[17 poena]: \\(N, Q \\leq 5000\\).</li> <li>[18 poena]: \\(T[i] = 2\\) (nema upita tipa \\(1\\)).</li> <li>[13 poena]: \\(A[i] &lt; 64\\) (u svakom trenutku).</li> <li>[29 poena]: Nema dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl <code>opet_xor.cpp</code> koji implementira pomenutu funkcije. Osim tra\u017eenih funkcija, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>void Resi(int N, int *A, int Q, int *T, int *I, int *X, bool *O);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl <code>code.cpp</code> koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program <code>grader.cpp</code> koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojevi \\(N\\) i \\(Q\\).</li> <li>U narednom redu \\(N\\) brojeva: \\(A_i\\).</li> <li>U narednih \\(Q\\) redova: \\(T[i], I[i], X[i]\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje odgovore na upite tipa \\(2\\) koje ona vrati.</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#resenje-kada-je-q-leq-10-xi-leq-10-za-upite-tipa-2","title":"Re\u0161enje kada je \\(Q \\leq 10\\), \\(X[i] \\leq 10\\) za upite tipa \\(2\\)","text":"<p>U ovom podzadatku mo\u017eemo testirati sve mogu\u0107e permutacije i proveriti da li su XOR-ovi svih prefiksa rastu\u0107i. Slo\u017eenost ovog re\u0161enja \\(O(Q\\cdot N!)\\).</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#resenje-kada-je-n-q-leq-200","title":"Re\u0161enje kada je \\(N, Q \\leq 200\\)","text":"<p>Za ovaj podzadatak neophodno je da razmotrimo detaljnije kada je niz ksortasti\u010dan. Za po\u010detak, mo\u017eemo da primetimo dodavanje elementa sa vredno\u0161\u0107u \\(0\\) na proizvoljnu poziciju ne uti\u010de na monotonost prefiksnih XOR-eva, pa te elemente mo\u017eemo da zanemarimo. Dodatno \u0107emo, zarad jasnije notacije, u obja\u0161njenju ovog podzadatka pretpostaviti da je dat samo jedan upit na koji treba odgovoriti. Razmatra\u0107emo slede\u0107e gramzivo re\u0161enje: iterativno gradimo permutaciju tako da naredni izabrani element prouzrokuje najmanji mogu\u0107i prefiksni XOR, i da taj naredni prefiksni XOR jo\u0161 uvek bude ve\u0107i od trenutnog. Neka je trenutni prefiksni XOR jednak \\(x\\). Ozna\u010dimo sa \\(B_i\\) poziciju vode\u0107eg bita broja \\(A_i\\). Neka je ba\u0161 \\(A_i\\) naredni odabrani elment. Da bi naredni XOR bio ve\u0107i, u binarnom zapisu broja \\(x\\) mora da stoji \\(0\\) na poziciji \\(B_i\\). Od svih narednih elementa koji zadovoljavaju ovaj uslov, dovoljno je da odaberemo onaj koji \u0107e \u0161to slabiju \\(0\\) broja \\(x\\) promeniti u \\(1\\). Jedna od strategija koja rezultuje u ovakvom na\u010dinu biranja elemenata je upravo odabir elementa koji \u0107e \u0161to manje da pove\u0107a prefiksni XOR. Na intuitivnom nivou, mo\u017eemo shvatiti da ovim izborom \u0161to manje ve\u0107ih pozicija na kojima su \\(0\\) menjamo u \\(1\\). Ova strategija \u0107e uvek proizvesti niz rastu\u0107ih prefiksnih XOR-eva kad god je niz ksortasti\u010dan. Pretpostavimo da postoji re\u0161enje u kojem na poziciji \\(j\\) u permutaciji nije odabran element kojim se najslabija \\(0\\) transformi\u0161e u \\(1\\) i ozna\u010dimo tu poziciju na kojoj je najslabija \\(0\\) sa \\(p\\). Posmatrajmo u tom re\u0161enju prvu poziciju \\(k &gt; j\\) u permutaciji nakon trenutne na kojoj se nalazi element \\(A_l\\), takav da je \\(B_l = p\\). Tada mo\u017eemo da modifikujemo permutaciju tako \u0161to na poziciju \\(j\\) postavimo \\(A_l\\), a sve ostale elemente pomerimo za jedno mesto desno. Nakon toga, potrebno je jo\u0161 da razre\u0161imo probleme koji su mogli nastati sa elementima \\(A_m\\) koji su u permutaciji bili izme\u0111u \\(j\\) i \\(k\\) i takvim da \\(B_m &lt; p\\). Nakon ovog tehni\u010dkog detalja kojeg ostavljamo \u010ditaocu, dobija se permutacija koja ima neopadaju\u0107i niz prefiksnih XOR-eva, a element \\(A_l\\) na poziciji \\(j\\). Slo\u017eenost ovog re\u0161enja je \\(O(Q\\cdot N^2)\\).</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#resenje-kada-n-q-leq-5000","title":"Re\u0161enje kada \\(N, Q \\leq 5000\\)","text":"<p>U prethodnom podzadatku smo primetili da je dovoljno odabrati element koji \u0161to slabiju \\(0\\) trenutnog prefiksnog XOR-a transformi\u0161e u \\(1\\). Dovoljno je da elemente \u010duvamo prema njihovom najja\u010dem bitu i da iteracijom kroz sve pozicije na kojima su \\(0\\) (po\u010dev\u0161i od najslabije) u binarnom zapisu trenutnog prefiksnog XOR-a odaberemo proizvoljan element koji ima \\(1\\) kao najja\u010di bit na toj poziciji. Slo\u017eenost ovog re\u0161enja je \\(O(Q\\cdot N \\cdot \\log_2 \\max_i A_i)\\).</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#resenje-kada-ai-64","title":"Re\u0161enje kada \\(A[i] &lt; 64\\).","text":"<p>Primetimo da su u ovom slu\u010daju i prefiksni XOR-evi do \\(64\\). Ukoliko niz iz upita ima vi\u0161e od \\(64\\) pozitivne vrednost, odgovor je <code>false</code>. U suprotnom mo\u017eemo da primenimo re\u0161enje iz prethodnog opisanog podzadatka. Slo\u017eenost ovog re\u0161enja je \\(O(Q\\cdot \\max_i A_i \\cdot \\log_2 \\max_i A_i)\\).</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#resenje-kada-ti-2","title":"Re\u0161enje kada \\(T[i] = 2\\)","text":"<p>Za ovaj podzadatak je neophodno da dalje optimizujemo proveru uslova iz gramzivog re\u0161enja. Primetili smo da je bilo dovoljno birati proizvoljan broj koji ima najve\u0107i bit postavljen na poziciji \u0161to slabije \\(0\\) iz trenutnog prefiksnog XOR-a. Sada je potrebno da vidimo kada \u0107emo uspeti da odaberemo sve takve brojeve. Odabirom tog broja se \\(0\\) na toj poziciji promenila u \\(1\\) u narednim prefiksnim XOR-evima. Da bi opet odabrali broj koji ima \\(1\\) na toj poziciji, potrebno je da se ponovo u prefiksnom XOR-u na\u0111e \\(0\\). Dakle, za svako (osim poslednjeg) postavljanje tog bita na \\(1\\) u aktuelnom prefiksnom XOR-u, potrebno je da ga kasnije resetujemo, postavljanjem na \\(0\\). Ozna\u010dimo sa \\(p_i\\) broj elemenata u kojima je bit na poziciji \\(i\\) najja\u010di, a sa \\(q_i\\) broj elemenata u kojima je taj bit postavljen, ali ne kao najja\u010di. Potreban i dovoljan uslov je da \\(q_i \\geq p_i + 1\\). Vrednosti \\(p_i\\) i \\(q_i\\) u nekom podnizu mo\u017eemo prona\u0107i kori\u0161\u0107enjem prefiksnih suma. Slo\u017eenost ovog re\u0161enja je \\(O(Q \\cdot \\log_2 \\max_i A_i)\\).</p>"},{"location":"takprog/2022_2023/sio/04_opet_xor/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za glavno re\u0161enje bi bilo neophodno i da vr\u0161imo a\u017euriranje tih prefiksnih suma. Ovo zahteva da koristimo fenvikovo stablo (tj. <code>bit</code>). U fenvikovom stablu za svako \\(i\\) pamtimo i a\u017euriramo koliko elemenata u odgovaraju\u0107em intervalu ima \\(1\\) kao najja\u010di bit na poziciji \\(i\\), a koliko njih ima \\(1\\), ali ne kao najja\u010di bit. Slo\u017eenost ovog re\u0161enja je \\(O(Q \\cdot \\log_2 \\max_i A_i \\cdot \\log_2 N)\\).</p> 04_opet_xor.cpp<pre><code>#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nconst int N = 1 &lt;&lt; 19, B = 30;\n\nstruct segtree {\n    int a[2*N];\n\n    void init() {\n        memset(a, 0, sizeof(a));\n    }\n\n    void set(int pos, int val) {\n        pos += N;\n        if(a[pos] == val) return;\n        a[pos] = val;\n        for(pos /= 2; pos; pos /= 2) {\n            a[pos] = a[2*pos] + a[2*pos + 1];\n        }\n    }\n\n    int query(int left, int right) {\n        left += N; right += N;\n        if(left &gt; right) return 0;\n        if(left == right) return a[left];\n        int res = a[left] + a[right];\n        while(left / 2 != right / 2) {\n            if(left % 2 == 0) res += a[left + 1];\n            if(right % 2 == 1) res += a[right - 1];\n            left /= 2; right /= 2;\n        }\n        return res;\n    }\n} ;\n\nsegtree bitcount[B];\n\n\nvoid set_value(int pos, int val) {\n    for(int i = 0; i &lt; B; i++) {\n        if(val &amp; (1 &lt;&lt; i)) {\n            val ^= 1 &lt;&lt; i;\n            // 1: highest bit, -1: not the highest\n            bitcount[i].set(pos, val ? -1 : 1);\n        } else {\n            bitcount[i].set(pos, 0);\n        }\n    }\n}\n\n\nbool query(int left, int n) {\n    int right = left + n - 1;\n    for(int i = 0; i &lt; B; i++) {\n        // For each bit i, let a[i] = number of values where it is the\n        // highest bit, and b[i] = the number of values where it is\n        // set but not the highest. Pass only if a[i] &lt;= b[i] + 1. We\n        // keep track of Q = a[i] - b[i], so we need Q &lt;= 1.\n\n        // printf(\" %d -&gt; %d\\n\", i, bitcount[i].query(left, right));\n        // printf(\"    \");\n        // for(int j = 1; j &lt;= 7; j++) printf(\"%3d\", bitcount[i].a[j+N]);\n        // printf(\"\\n\");\n\n        if(bitcount[i].query(left, right) &gt; 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nvoid Resi(int N, int *A, int Q, int *T, int *I, int *X, bool *O) {\n    for(int i = 0; i &lt; B; i++) bitcount[i].init();\n\n    for(int i = 1; i &lt;= N; i++) set_value(i, A[i]);\n    for(int i = 1; i &lt;= Q; i++) {\n        if(T[i] == 1) {\n            int pos = I[i], val = X[i];\n            A[pos] = val;\n            set_value(pos, A[pos]);\n        } else {\n            O[i] = query(I[i], X[i]);\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/05_vooda/","title":"5 - Majnkraft vOOda","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje - - <p>PA\u017dNjA! PA\u017dNjA! PA\u017dNjA! U neo\u010dekivanom trenutku izme\u0111u po\u010detka SIO i sad je izbio ogroman po\u017ear u prostorijama Ra\u010dunarskog fakulteta (u Majnkraftu). Komisija nije htela da prekida takmi\u010denje i da ometa takmi\u010dare u radu, pa smo odlu\u010dili da vas obavestimo putem ovog zadatka. Ako \u017eelite da nam pomognemo da spasimo RAF, i da usput osvojite koji poneki poen na SIO, nastavite da \u010ditate!</p> <p>Naime, u \\(8\\) prostorija trenutno gori vatra. Svaku prostoriju mo\u017eemo zamisliti kao \\(M\\times N\\) matricu, gde su neka polja prohodna, a ostala polja su zidovi. Vatra trenutno gori na svim prohodnim poljima. Komisija je blago ilegalnim metodama (u Majnkraftu) nabavila neizmerne zalihe vode. Vi mo\u017eete da iskoristite jedan litar vode da biste poplavili jedno prohodno polje. Me\u0111utim, kako se sve ovo de\u0161ava u Majnkraftu (da, u Majnkraftu, definitivno u Majnkraftu), ako je prohodno polje susedno dva poplavljena polja, onda i ono postaje poplavljeno. Dva polja su susedna ako dele stranicu.</p> <p>Da biste ugasili svu vatru, treba da ikoristite nekoliko litara komisijske vode tako da sva prohodna polja budu poplavljena. Kako komisija ipak ne bi \u017eelela da koristi previ\u0161e svoje (i)legalno nabavljene vode, da joj ne bi policija (u Majnkraftu) bila za vratom, molimo vas da pri re\u0161avanju zadatka koristite \u0161to manje litara vode. Imate do kraja takmi\u010denja da re\u0161ite ovaj zadatak, da ne bismo svi izgoreli (u stvarnosti (u Majnkraftu)).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Igor Pavlovi\u0107 i Pavle Martinovi\u0107 Igor Pavlovi\u0107 i Pavle Martinovi\u0107 Igor Pavlovi\u0107 i Pavle Martinovi\u0107"},{"location":"takprog/2022_2023/sio/05_vooda/#napomena","title":"Napomena","text":"<p>Ovo je zadatak sa poznatim ulazom (output-only  zadatak). Vama su dati ulazni fajlovi (<code>1.in</code>,  <code>2.in</code>,  <code>3.in</code>,  <code>4.in</code>,  <code>5.in</code>,  <code>6.in</code>,  <code>7.in</code>,  <code>8.in</code>), dok vi treba da po\u0161aljete samo odgovaraju\u0107e izlazne fajlove za njih (<code>1.out</code>,  <code>2.out</code>,  <code>3.out</code>,  <code>4.out</code>,  <code>5.out</code>,  <code>6.out</code>,  <code>7.out</code>,  <code>8.out</code>). Tako\u0111e vam je data slika kako izgleda svaki ulazni fajl (<code>1.png</code>,  <code>2.png</code>,  <code>3.png</code>,  <code>4.png</code>,  <code>5.png</code>,  <code>6.png</code>,  <code>7.png</code>,  <code>8.png</code>).</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze dva cela broja \\(N\\) i \\(M\\) - dimenzije matrice. Onda u svakom od narednih \\(N\\) redova je data niska du\u017eine \\(M\\) gde stoji karakter <code>.</code> ako je polje prohodno, a u suprotnom <code>#</code>.</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#opis-izlaza","title":"Opis izlaza","text":"<p>Uprvoj liniji treba ispisati \\(L\\) broj litara koji planirate da iskoristite za ga\u0161enje po\u017eara. Neka polju \\((x,y)\\) pripi\u0161emo broj \\(M\\cdot(x-1)+y\\). Formira se pomo\u0107ni niz \\(A\\), gde je \\(A[0]=0\\), a \\(A[1],A[2],\\cdots,A[L]\\) brojevi pripisani brojevima koje \u017eelite da poplavite. U drugom redu izlza se nalazi \\(L\\) brojeva, od kojih svaki predstavlja razliku izme\u0111u susednih brojeva u nizu \\(A\\) (\\(A[1]-A[0]\\), \\(A[2]-A[1]\\), \\(\\cdots\\), \\(A[L]-A[L-1]\\)).</p> <p>Me\u0111utim u zip arhivi koja vam je obezbe\u0111ena uz ovaj zadatak vam je tako\u0111e obezbe\u0111en <code>compressor.cpp</code> koji iz slede\u0107eg formata (koji je verovatno lakzi takmi\u010darima za ispis, ali je neprakti\u010dan zbog veli\u010dine odre\u0111enih re\u0161enja) u gorenavedeni tra\u017eeni.</p> <p>Uprvoj liniji treba ispisati \\(L\\) broj litara koji planirate da iskoristite za ga\u0161enje po\u017eara. Dalje, u svakoj  od narednih \\(L\\) linija je potrebno ispisati dva cela broja, koja predstavljaju redni broj reda i kolone (indeksirani od \\(1\\)) koji poplavljujemo sa slede\u0107im litrom vode. </p>"},{"location":"takprog/2022_2023/sio/05_vooda/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2022_2023/sio/05_vooda/#ulaz","title":"Ulaz","text":"<pre><code>3 3\n#.#\n.##\n...\n</code></pre>"},{"location":"takprog/2022_2023/sio/05_vooda/#izlaz","title":"Izlaz","text":"<pre><code>4\n2 2 4 1\n</code></pre>"},{"location":"takprog/2022_2023/sio/05_vooda/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Polja koja su poplavljena u navedenom izlazu su \\((1,2)\\), \\((2,1)\\), \\((3,2)\\) i \\((3,3)\\) (njima su pripisani brojevi \\(2,4,8,9\\), pa su napisane razlike \\(2-0=2\\), \\(4-2=2\\), \\(8-4=4\\) i \\(9-8=1\\)). Nakon poplavljivanja polja koja su opisana u zadatku, jedino polje koje nismo poplavili ru\u010dno je \\((3,1)\\). Me\u0111utim, ono \u0107e postati poplavljeno jer je susedna sa dva  poplavljena polja (\\((2,1)\\) i \\((3,2)\\)).</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N,M \\leq 3000\\)</li> </ul>"},{"location":"takprog/2022_2023/sio/05_vooda/#bodovanje","title":"Bodovanje","text":"<p>U arhivi prilo\u017eenoj uz ovaj zadatak mo\u017eete na\u0107i za datoteku koji opisuje bodovanje za svaki primer. U prvoj liniji pi\u0161e broj \\(P\\) koliko ukupno nosi taj zadatak, dok u naredoj liniji se nalazi \\(P\\) brojeva, gde \\(i\\)-ti predstavlja granicu koliko najvi\u0161e litara vode da iskoristite ako \u017eelite \\(i\\) poena.</p> Primer N,M Poena 1 10 6 2 600 6 3 20 12 4 700 12 5 100 16 6 300 16 7 1000 16 8 3000 16"},{"location":"takprog/2022_2023/sio/05_vooda/#koreni-u-korovima","title":"Koreni u korovima","text":"<p>\u010cak iako je inspiracija za zadatak zaista do\u0161la iz na\u010dina kako se propagiraju tzv. source block-ovi u igrici Majnkraft, pojedini u\u010denici mogli su prepoznati vezu izme\u0111u ovog zadatka i takmi\u010darskog zadatka iz folklora: Data je tabla \\(10\\times10\\) i \\(9\\) polja su obrasla korovom. Ako je polje susedno dva polja obrasla korovom onda i ono postane obraslo korovom. Da li je mogu\u0107e da cela tabla bude obrasla korovom? U ovom zadatku je odgovor NE, a razlog za\u0161to je odgovor NE mo\u017ee nam poslu\u017eiti kao dobra vodilja za re\u0161avanje ovakvog zadatka.</p> <p>Naime obim figure na kom je obrasla korov nikad ne raste, mo\u017ee samo da se smanji. Ako se pojavi polje koje je susedno \\(3\\) ili \u010dak \\(4\\) korova, onda nam se obim smanjuje. Kako je na po\u010detku obim najvi\u0161e \\(36\\), a na kraju treba biti \\(40\\), odgovor na pitanje u zadatku je negativan.</p> <p>Glavna heuristika koju mo\u017eemo odmah poneti odavde je da nikad (ili barem da se trudimo da izbegnemo) ne poplavimo polje  koje je susedno ve\u0107 nekom poplavljenom polju.</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#analiza-primera","title":"Analiza primera","text":"<p>Prvi primer je mali i mo\u017ee se uraditi manje vi\u0161e ru\u010dno. Ocena obima iz prvog dela nam daje da je \\(27\\) optimalan odgovor.</p> <p>Drugi primer je ve\u0107i ali mu je svaka pozevazana komponenta pravougaonik. Za pravougaonike se problem mo\u017ee re\u0161iti ta\u010dno, i da se doka\u017ee ta\u010dnost ocenom gore.</p> <p>Tre\u0107i primer je mali, ali je verovatno te\u0161ko re\u0161iti ru\u010dno osim ako se ulo\u017ei jako puno vremena, ve\u0107 je realnije da ga takmi\u010dar programom napravi nekako i onda ru\u010dno doradi ako treba. I ovde je na\u0111ena ocena optimalna.</p> <p>\u010cetvrti primer je kao komplikovana verzija drugog gde imamo pravougaonike, ali oni mogu i da se seku. Komisijsko re\u0161enje ovde nalazi odgovor \\(16316\\), dok nam obim daje granicu od \\(16315\\), tako da smo ovaj primer re\u0161ili ili optimalno ili skoro optimalno.</p> <p>Primeri \\(5-8\\) su malo divljiji, i ocena koja je data u prvoj sekciji nije toliko blizu konstrukcija koja je na\u0161la komisija. Primeri \\(5\\) i \\(7\\) su crtani rukom, dok su \\(6\\) i \\(8\\) random \u0161um, sa razli\u010ditim gustinama. Primer \\(8\\) je ogroman, tako da bilo \u0161ta malo sporije mo\u017ee jako dugo da se izvr\u0161ava. Sa njim moramo biti posebno pa\u017eljivi</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#autorsko-resenje-1-86-poena-resava-4-primer","title":"Autorsko re\u0161enje 1 (86 poena, re\u0161ava 4. primer)","text":"<p>Svaki put kad postavimo novu vodu lako mo\u017eemo da simuliramo kako se voda dalje kre\u0107e pomo\u0107u nekog algoritma nalik flood-fill algoritma. Prvo postavimo vodu u polja koja imaju maks jednog prohodnog suseda. Dalje svakom polje dodelimo neku te\u017einu sa kojom ga treba izabrati. Ako je ve\u0107 susedan nekom poplavljenom polju, \u0161teti\u0107emo obimu, tako da mu na te\u017einu dodajemo \\(-10000\\). Za svako susedno polje koje \u0107e postati poplavljeno ako dodamo vode na to polje dodamo \\(1000\\). Bolje je stavljati u \u0107o\u0161kove nego na otvoreno empirijki, pa dodamo na te\u017einu \\(100\\cdot(4-\\deg)\\). Najzad (i ovo se ispostavlja kao klju\u010dno za nala\u017eenja re\u0161enja u priemru \\(4\\)) dodamo malu random te\u017einu, do \\(10\\) na primer. U svakom trenutku biramo polje sa najve\u0107om te\u017einu i njega poplavimo i ispropagiramo sve. Za svako plavljenje moramo da a\u017euriramo te\u017eine \\(12\\) polja koji su na distanci najvi\u0161e \\(2\\) od poplavljenog polja, pa ceo algoritam radi jako brzo. Na primer, osmi primer re\u0161ava u roku od jednog minuta.</p>"},{"location":"takprog/2022_2023/sio/05_vooda/#autorsko-resenje-2-98-poena-resava-sve-osim-4-og-primera","title":"Autorsko re\u0161enje 2 (98 poena, re\u0161ava sve osim 4-og primera)","text":"<p>Anlogno prethodnom re\u0161enju mo\u017eemo prvo postaviti vodu u ona polja koja imaju ta\u010dno jednog slobodnog suseda a zatim simulirati dodavanje novih blokova primenom nekog algoritma za obilazak grafa. Klju\u010dna razlika ovog re\u0161enja u odnosu na prethodno je \u0161to za naredno poplavljeno polje biramo ono polje koje \u0107e poplaviti najve\u0107i broj polja ukoliko na njega postavimo blok sa vodom. Za pronala\u017eenje takvog polja neophodno je simulirati poplavu za svakog kandidata koji mo\u017ee poplaviti vi\u0161e od jednog polja, to jest ima bar jednog suseda koji je susedan sa ta\u010dno jednim poplavljenim poljem. Primetimo da je slo\u017eenost jedne iteracije ograni\u010dena odozgo sa brojem kandidata u toj iteraciji puta broj poplavljenih polja nakon te iteracije. Na osnovu toga mo\u017eemo zaklju\u010diti da slo\u017eenost ovog re\u0161enja nije ve\u0107a od \\(O(N^2M^2)\\). Me\u0111utim u prilo\u017eenim primerima je broj kandidata u svakoj iteraciji zna\u010dajno manji od \\(NM\\) pa je i slo\u017eenost ovog re\u0161enja zna\u010dajno manja i mo\u017ee se primeniti na primerima od 1 do 7. Za re\u0161enje primera 8 u vremenskom periodu prikladnom za du\u017einu trajanja takmi\u010denja neophodno je izdeliti celu tablu na manje table dimenzija 300x300 i re\u0161iti ih zasebno a zatim spojiti u jedno re\u0161enje. Da bismo osvojili poslednjih par poena na ovom zadatku potrebno je primetiti da re\u0161enje zavisi od polja koje izaberemo izme\u0111u onih polja sa jednakim rezultatom simulacije. Kako bismo dodatno pobolj\u0161ali skor mogu\u0107e je primeniti isti algoritam na razlicite izometrijske transformacije ulaza i izabrati najbolje re\u0161enje.</p> StupidNasumi\u010dni kandidatiLowerboundGreedyDijagonalno 05_vooda-stupid.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define MAXN 5007\nusing namespace std;\npriority_queue&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; pq;\nqueue&lt;pair&lt;int,int&gt; &gt; q;\nvector&lt;pair&lt;int,int&gt; &gt; v,c;\nbool arr[MAXN][MAXN],fl[MAXN][MAXN];\nstring s[MAXN];\nint broj[MAXN][MAXN],dx[4]={-1,0,1,0}, dy[4]={0,-1,0,1};\nmt19937 rng(time(0));\nvoid dodajflood(int x,int y)\n{\n    broj[x][y]++;\n    if(broj[x][y]==2)\n    {\n        q.push({x,y});\n        fl[x][y]=true;\n    }\n}\nvoid poplavi(int x,int y)\n{\n    fl[x][y]=true;\n    for(int i=0;i&lt;4;i++) if(arr[x+dx[i]][y+dy[i]] &amp;&amp; !fl[x+dx[i]][y+dy[i]]) dodajflood(x+dx[i],y+dy[i]);\n}\nint main()\n{\n    int t,rand;\n    cin&gt;&gt;t&gt;&gt;rand;\n    string st;\n    if(t&lt;10) st='0'+to_string(t);\n    else st=to_string(t);\n    ifstream in(\"testcases\\\\\"+st+\".in\");\n    ofstream out(\"sols-stupid\\\\\"+st+\".out\");\n    int n,m,br=0;\n    in&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++)\n    {\n        in&gt;&gt;s[i];\n        for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n    }\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(arr[i][j]) c.push_back({i,j});\n    if(rand) shuffle(c.begin(),c.end(),rng);\n    for(int i=0;i&lt;c.size();i++) if(!fl[c[i].first][c[i].second])\n    {\n        br++;\n        v.push_back(c[i]);\n        q.push(c[i]);\n        while(!q.empty())\n        {\n            poplavi(q.front().first,q.front().second);\n            q.pop();\n        }\n    }\n    cout&lt;&lt;br&lt;&lt;endl;\n    out&lt;&lt;v.size()&lt;&lt;endl;\n    for(int i=0;i&lt;v.size();i++) out&lt;&lt;v[i].first&lt;&lt;\" \"&lt;&lt;v[i].second&lt;&lt;endl;\n    //for(int i=1;i&lt;=n;i++) cout&lt;&lt;s[i]&lt;&lt;endl;\n}\n</code></pre> 05_vooda-rnd-kandidati.cpp<pre><code>#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n#include &lt;cassert&gt;\n#include &lt;fstream&gt;\n#include &lt;random&gt;\n#include &lt;time.h&gt;\n#include &lt;chrono&gt;\n\n#define maxN 5000\n#define maxM 5000\n\nusing namespace std;\nusing namespace std::chrono;\n\nint n, m, cnt[maxN][maxN], deg[maxN][maxM];\nstring s[maxN],input[maxN];\n\nvector&lt;pair&lt;int, int&gt;&gt; ans, all;\nset&lt;pair&lt;int, int&gt;&gt; candidates;\n\nbool checkAndUpdate(int x, int y) {\n    if (cnt[x][y] == 2) return false;\n    cnt[x][y]++;\n    if (cnt[x][y] == 2) return true;\n    candidates.insert({ x,y });\n\n    return false;\n}\n\nvoid add(int x, int y) {\n    cnt[x][y] = 2;\n    if (x &gt; 0 &amp;&amp; s[x - 1][y] == '.') {\n        if (checkAndUpdate(x - 1, y)) add(x - 1, y);\n    }\n    if (x &lt; n - 1 &amp;&amp; s[x + 1][y] == '.') {\n        if (checkAndUpdate(x + 1, y)) add(x + 1, y);\n    }\n    if (y &gt; 0 &amp;&amp; s[x][y - 1] == '.') {\n        if (checkAndUpdate(x, y - 1)) add(x, y - 1);\n    }\n    if (y &lt; m - 1 &amp;&amp; s[x][y + 1] == '.') {\n        if (checkAndUpdate(x, y + 1)) add(x, y + 1);\n    }\n}\n\nint iter[maxN][maxN], cur_iter = 0;\n\nmt19937 rnd(time(NULL));\n\nint simulate(int x, int y) {\n    return rnd();\n}\n\nvoid solve(){\n    all.clear();\n    ans.clear();\n    candidates.clear();\n    cur_iter=0;\n\n    for(int i=0;i&lt;n;i++){\n        for(int j=0;j&lt;m;j++){\n            deg[i][j]=cnt[i][j]=iter[i][j]=0;\n        }\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (s[i][j] == '#') continue;\n            all.push_back({ i,j });\n            if (i &gt; 0 &amp;&amp; s[i - 1][j] == '.') deg[i][j]++;\n            if (i &lt; n - 1 &amp;&amp; s[i + 1][j] == '.') deg[i][j]++;\n            if (j &gt; 0 &amp;&amp; s[i][j - 1] == '.') deg[i][j]++;\n            if (j &lt; m - 1 &amp;&amp; s[i][j + 1] == '.') deg[i][j]++;\n        }\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (deg[i][j] == 1) {\n                ans.push_back({ i,j });\n                add(i, j);\n            }\n        }\n    }\n\n    while (all.size()) {\n        if (candidates.empty()) {\n            pair&lt;int, int&gt; last = all.back();\n            all.pop_back();\n            int x = last.first, y = last.second;\n            if (cnt[x][y] != 0) continue;\n            ans.push_back({ x,y });\n            add(x, y);\n            continue;\n        }\n\n        int curMax = 0, bestX, bestY;\n        cur_iter++;\n\n        for (auto it = candidates.begin(); it != candidates.end();) {\n            int x = (*it).first, y = (*it).second;\n            if (cnt[x][y] != 1) {\n                candidates.erase(it++);\n                continue;\n            }\n\n            if (x &gt; 0 &amp;&amp; s[x - 1][y] == '.' &amp;&amp; cnt[x - 1][y] != 2 &amp;&amp; iter[x - 1][y] != cur_iter) {\n                int tmp = simulate(x - 1, y);\n                iter[x - 1][y] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x - 1; bestY = y;\n                }\n            }\n            if (x &lt; n - 1 &amp;&amp; s[x + 1][y] == '.' &amp;&amp; cnt[x + 1][y] != 2 &amp;&amp; iter[x + 1][y] != cur_iter) {\n                int tmp = simulate(x + 1, y);\n                iter[x + 1][y] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x + 1; bestY = y;\n                }\n            }\n            if (y &gt; 0 &amp;&amp; s[x][y - 1] == '.' &amp;&amp; cnt[x][y - 1] != 2 &amp;&amp; iter[x][y - 1] != cur_iter) {\n                int tmp = simulate(x, y - 1);\n                iter[x][y - 1] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x; bestY = y - 1;\n                }\n            }\n            if (y &lt; m - 1 &amp;&amp; s[x][y + 1] == '.' &amp;&amp; cnt[x][y + 1] != 2 &amp;&amp; iter[x][y + 1] != cur_iter) {\n                int tmp = simulate(x, y + 1);\n                iter[x][y + 1] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x; bestY = y + 1;\n                }\n            }\n\n            it++;\n        }\n\n        if (curMax != 0) {\n            ans.push_back({ bestX,bestY });\n            add(bestX, bestY);\n        }\n    }\n}\n\npair&lt;int,int&gt;  pos[maxN][maxN];\nvector&lt;pair&lt;int,int&gt;&gt; bestAns;\n\nvoid flip() {\n    for(int i=0;i&lt;n;i++){\n        reverse(s[i].begin(),s[i].end());\n        reverse(pos[i],pos[i]+m);\n    }\n}\n\nvoid transpose(){\n    for(int i=0;i&lt;n;i++){\n        for(int j=i+1;j&lt;m;j++){\n            swap(s[i][j],s[j][i]);\n            swap(pos[i][j],pos[j][i]);\n        }\n    }\n}\n\nvoid rotate90(){\n    transpose();\n    flip();\n}\n\nvoid updateAns(){\n    if(!bestAns.empty() &amp;&amp; bestAns.size()&lt;ans.size()) return;\n    bestAns = ans;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int t,threshold;\n    cin&gt;&gt;t;\n    string st;\n    if(t&lt;10) st='0'+to_string(t);\n    else st=to_string(t);\n    ifstream in(\"testcases\\\\\"+st+\".in\");\n    ofstream out(\"sols-rnd-kandidati\\\\\"+st+\".out\");\n\n    in &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; n; i++) {\n        in &gt;&gt; input[i];\n    }\n\n    if(t&lt;=7){\n        for (int i = 0; i &lt; n; i++) {\n            s[i]=input[i];\n        }\n\n        auto start = high_resolution_clock::now();\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast&lt;seconds&gt;(stop - start);\n\n        while(duration.count()&lt;300){\n            solve();\n            updateAns();\n            stop = high_resolution_clock::now();\n            duration = duration_cast&lt;seconds&gt;(stop - start);\n        }\n    }\n\n    if(t==8){\n        int l=10,k=300;\n        n=m=k;\n\n        for(int i=0;i&lt;l;i++){\n            for(int j=0;j&lt;l;j++){\n                for(int ii=i*k;ii&lt;i*k+k;ii++){\n                    s[ii%k]=\"\";\n                    for(int jj=j*k;jj&lt;j*k+k;jj++) {\n                        s[ii%k]+=input[ii][jj];\n                        pos[ii%k][jj%k]={ii,jj};\n                    }\n                }\n\n                solve();\n                for(int ii=0;ii&lt;ans.size();ii++){\n                    bestAns.push_back(pos[ans[ii].first][ans[ii].second]);\n                }\n                cout&lt;&lt;i*l+j&lt;&lt;endl;\n            }\n        }\n    }\n\n    cout&lt;&lt;bestAns.size()&lt;&lt;endl;\n\n    out &lt;&lt; bestAns.size() &lt;&lt; endl;\n    sort(bestAns.begin(), bestAns.end());\n\n    for (int i = 0; i &lt; bestAns.size(); i++) {\n        input[bestAns[i].first][bestAns[i].second] = 'V';\n        out &lt;&lt; bestAns[i].first + 1 &lt;&lt; \" \" &lt;&lt; bestAns[i].second + 1 &lt;&lt; endl;\n    }\n    /*\n    for (int i = 0; i &lt; n; i++) {\n        fout &lt;&lt; s[i] &lt;&lt; endl;\n    }*/\n    return 0;\n}\n</code></pre> 05_vooda-lowerbound.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define MAXN 5007\nusing namespace std;\npriority_queue&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; pq;\nqueue&lt;pair&lt;int,int&gt; &gt; q;\nvector&lt;pair&lt;int,int&gt; &gt; v;\nbool arr[MAXN][MAXN],vi[MAXN][MAXN];\nstring s[MAXN];\nint cnt;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nmt19937 rng(time(0));\nvoid dfs(int x,int y)\n{\n    vi[x][y]=true;\n    for(int i=0;i&lt;4;i++)\n    {\n        if(!arr[x+dx[i]][y+dy[i]])  cnt++;\n        else if(!vi[x+dx[i]][y+dy[i]]) dfs(x+dx[i],y+dy[i]);\n    }\n}\nint main()\n{\n    int t;\n    cin&gt;&gt;t;\n    string st;\n    if(t&lt;10) st='0'+to_string(t);\n    else st=to_string(t);\n    ifstream in(\"testcases\\\\\"+st+\".in\");\n    //ofstream out(\"sols\\\\\"+st+\".out\");\n    int n,m;\n    int lw=0;\n    in&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++)\n    {\n        in&gt;&gt;s[i];\n        for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n    }\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(!vi[i][j] &amp;&amp; arr[i][j])\n    {\n        cnt=0;\n        dfs(i,j);\n        lw+=(cnt+3)/4;\n    }\n    cout&lt;&lt;lw;\n}\n</code></pre> 05_vooda-greedy.cpp<pre><code>#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n#include &lt;cassert&gt;\n#include &lt;fstream&gt;\n\n#define maxN 5000\n#define maxM 5000\n\nusing namespace std;\n\nint n, m, cnt[maxN][maxN], deg[maxN][maxM];\nstring s[maxN],input[maxN];\n\nvector&lt;pair&lt;int, int&gt;&gt; ans, all;\nset&lt;pair&lt;int, int&gt;&gt; candidates;\n\nbool checkAndUpdate(int x, int y) {\n    if (cnt[x][y] == 2) return false;\n    cnt[x][y]++;\n    if (cnt[x][y] == 2) return true;\n    candidates.insert({ x,y });\n\n    return false;\n}\n\nvoid add(int x, int y) {\n    cnt[x][y] = 2;\n    if (x &gt; 0 &amp;&amp; s[x - 1][y] == '.') {\n        if (checkAndUpdate(x - 1, y)) add(x - 1, y);\n    }\n    if (x &lt; n - 1 &amp;&amp; s[x + 1][y] == '.') {\n        if (checkAndUpdate(x + 1, y)) add(x + 1, y);\n    }\n    if (y &gt; 0 &amp;&amp; s[x][y - 1] == '.') {\n        if (checkAndUpdate(x, y - 1)) add(x, y - 1);\n    }\n    if (y &lt; m - 1 &amp;&amp; s[x][y + 1] == '.') {\n        if (checkAndUpdate(x, y + 1)) add(x, y + 1);\n    }\n}\n\nvector&lt;pair&lt;int, int&gt;&gt; simulation;\nint cntSim[maxN][maxN];\n\nvoid addSimulation(int x, int y, int&amp; count) {\n    cntSim[x][y] = 2 - cnt[x][y];\n    count++;\n    if (x &gt; 0 &amp;&amp; s[x - 1][y] == '.') {\n        cntSim[x - 1][y]++;\n        simulation.push_back({ x - 1,y });\n        if ((cntSim[x - 1][y] + cnt[x - 1][y]) == 2) addSimulation(x - 1, y, count);\n    }\n    if (x &lt; n - 1 &amp;&amp; s[x + 1][y] == '.') {\n        cntSim[x + 1][y]++;\n        simulation.push_back({ x + 1,y });\n        if ((cntSim[x + 1][y] + cnt[x + 1][y]) == 2) addSimulation(x + 1, y, count);\n    }\n    if (y &gt; 0 &amp;&amp; s[x][y - 1] == '.') {\n        cntSim[x][y - 1]++;\n        simulation.push_back({ x,y - 1 });\n        if ((cntSim[x][y - 1] + cnt[x][y - 1]) == 2) addSimulation(x, y - 1, count);\n    }\n    if (y &lt; m - 1 &amp;&amp; s[x][y + 1] == '.') {\n        cntSim[x][y + 1]++;\n        simulation.push_back({ x,y + 1 });\n        if ((cntSim[x][y + 1] + cnt[x][y + 1]) == 2) addSimulation(x, y + 1, count);\n    }\n}\n\nint iter[maxN][maxN], cur_iter = 0;\n\nint simulate(int x, int y) {\n    int result = 0;\n    simulation.push_back({ x ,y });\n    addSimulation(x, y, result);\n    for (int i = 0; i &lt; simulation.size(); i++) {\n        cntSim[simulation[i].first][simulation[i].second] = 0;\n    }\n    simulation.clear();\n    return result;\n}\n\nvoid solve(){\n    all.clear();\n    ans.clear();\n    simulation.clear();\n    candidates.clear();\n    cur_iter=0;\n\n    for(int i=0;i&lt;n;i++){\n        for(int j=0;j&lt;m;j++){\n            deg[i][j]=cnt[i][j]=iter[i][j]=cntSim[i][j]=0;\n        }\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (s[i][j] == '#') continue;\n            all.push_back({ i,j });\n            if (i &gt; 0 &amp;&amp; s[i - 1][j] == '.') deg[i][j]++;\n            if (i &lt; n - 1 &amp;&amp; s[i + 1][j] == '.') deg[i][j]++;\n            if (j &gt; 0 &amp;&amp; s[i][j - 1] == '.') deg[i][j]++;\n            if (j &lt; m - 1 &amp;&amp; s[i][j + 1] == '.') deg[i][j]++;\n        }\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (deg[i][j] == 1) {\n                ans.push_back({ i,j });\n                add(i, j);\n            }\n        }\n    }\n\n    while (all.size()) {\n        if (candidates.empty()) {\n            pair&lt;int, int&gt; last = all.back();\n            all.pop_back();\n            int x = last.first, y = last.second;\n            if (cnt[x][y] != 0) continue;\n            ans.push_back({ x,y });\n            add(x, y);\n            continue;\n        }\n\n        int curMax = 0, bestX, bestY;\n        cur_iter++;\n\n        for (auto it = candidates.begin(); it != candidates.end();) {\n            int x = (*it).first, y = (*it).second;\n            if (cnt[x][y] != 1) {\n                candidates.erase(it++);\n                continue;\n            }\n\n            if (x &gt; 0 &amp;&amp; s[x - 1][y] == '.' &amp;&amp; cnt[x - 1][y] != 2 &amp;&amp; iter[x - 1][y] != cur_iter) {\n                int tmp = simulate(x - 1, y);\n                iter[x - 1][y] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x - 1; bestY = y;\n                }\n            }\n            if (x &lt; n - 1 &amp;&amp; s[x + 1][y] == '.' &amp;&amp; cnt[x + 1][y] != 2 &amp;&amp; iter[x + 1][y] != cur_iter) {\n                int tmp = simulate(x + 1, y);\n                iter[x + 1][y] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x + 1; bestY = y;\n                }\n            }\n            if (y &gt; 0 &amp;&amp; s[x][y - 1] == '.' &amp;&amp; cnt[x][y - 1] != 2 &amp;&amp; iter[x][y - 1] != cur_iter) {\n                int tmp = simulate(x, y - 1);\n                iter[x][y - 1] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x; bestY = y - 1;\n                }\n            }\n            if (y &lt; m - 1 &amp;&amp; s[x][y + 1] == '.' &amp;&amp; cnt[x][y + 1] != 2 &amp;&amp; iter[x][y + 1] != cur_iter) {\n                int tmp = simulate(x, y + 1);\n                iter[x][y + 1] = cur_iter;\n                if (tmp &gt; curMax) {\n                    curMax = tmp; bestX = x; bestY = y + 1;\n                }\n            }\n\n            it++;\n        }\n\n        if (curMax != 0) {\n            ans.push_back({ bestX,bestY });\n            add(bestX, bestY);\n        }\n    }\n}\n\npair&lt;int,int&gt;  pos[maxN][maxN];\nvector&lt;pair&lt;int,int&gt;&gt; bestAns;\n\nvoid flip() {\n    for(int i=0;i&lt;n;i++){\n        reverse(s[i].begin(),s[i].end());\n        reverse(pos[i],pos[i]+m);\n    }\n}\n\nvoid transpose(){\n    for(int i=0;i&lt;n;i++){\n        for(int j=i+1;j&lt;m;j++){\n            swap(s[i][j],s[j][i]);\n            swap(pos[i][j],pos[j][i]);\n        }\n    }\n}\n\nvoid rotate90(){\n    transpose();\n    flip();\n}\n\nvoid updateAns(){\n    if(!bestAns.empty() &amp;&amp; bestAns.size()&lt;ans.size()) return;\n    bestAns.clear();\n    for(int i=0;i&lt;ans.size();i++){\n        bestAns.push_back(pos[ans[i].first][ans[i].second]);\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    int t,threshold;\n    cin&gt;&gt;t;\n    string st;\n    if(t&lt;10) st='0'+to_string(t);\n    else st=to_string(t);\n    ifstream in(\"testcases\\\\\"+st+\".in\");\n    ofstream out(\"sols-gridi\\\\\"+st+\".out\");\n\n    in &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; n; i++) {\n        in &gt;&gt; input[i];\n    }\n\n    if(t&lt;=6){\n        // Pokreni algoritam nad svim izometrijskim transformacijama ulaza i uzmi najbolji\n        for (int i = 0; i &lt; n; i++) {\n            s[i]=input[i];\n            for(int j=0;j&lt;m;j++){\n                pos[i][j] = {i,j};\n            }\n        }\n\n        for(int i=0;i&lt;4;i++){\n            solve();\n            cout&lt;&lt;ans.size()&lt;&lt;endl;\n            updateAns();\n            rotate90();\n        }\n\n        flip();\n\n        for(int i=0;i&lt;4;i++){\n            solve();\n            cout&lt;&lt;ans.size()&lt;&lt;endl;\n            updateAns();\n            rotate90();\n        }\n    }\n\n    if(t==7){\n        for (int i = 0; i &lt; n; i++) {\n            s[i]=input[i];\n            for(int j=0;j&lt;m;j++){\n                pos[i][j] = {i,j};\n            }\n        }\n\n        solve();\n        updateAns();\n    }\n\n    if(t==8){\n        int l=10,k=300;\n        n=m=k;\n\n        for(int i=0;i&lt;l;i++){\n            for(int j=0;j&lt;l;j++){\n                for(int ii=i*k;ii&lt;i*k+k;ii++){\n                    s[ii%k]=\"\";\n                    for(int jj=j*k;jj&lt;j*k+k;jj++) {\n                        s[ii%k]+=input[ii][jj];\n                        pos[ii%k][jj%k]={ii,jj};\n                    }\n                }\n\n                solve();\n                for(int ii=0;ii&lt;ans.size();ii++){\n                    bestAns.push_back(pos[ans[ii].first][ans[ii].second]);\n                }\n                cout&lt;&lt;i*l+j&lt;&lt;endl;\n            }\n        }\n    }\n\n    cout&lt;&lt;bestAns.size()&lt;&lt;endl;\n\n    out &lt;&lt; bestAns.size() &lt;&lt; endl;\n    sort(bestAns.begin(), bestAns.end());\n\n    for (int i = 0; i &lt; bestAns.size(); i++) {\n        input[bestAns[i].first][bestAns[i].second] = 'V';\n        out &lt;&lt; bestAns[i].first + 1 &lt;&lt; \" \" &lt;&lt; bestAns[i].second + 1 &lt;&lt; endl;\n    }\n    /*\n    for (int i = 0; i &lt; n; i++) {\n        fout &lt;&lt; s[i] &lt;&lt; endl;\n    }*/\n    return 0;\n}\n</code></pre> 05_vooda-dijagonalno.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define MAXN 5007\nusing namespace std;\npriority_queue&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; pq;\nqueue&lt;pair&lt;int,int&gt; &gt; q;\nvector&lt;pair&lt;int,int&gt; &gt; v;\nbool arr[MAXN][MAXN],fl[MAXN][MAXN];\nstring s[MAXN];\nint broj[MAXN][MAXN],rando[MAXN][MAXN];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nmt19937 rng(time(0));\nint brojsuseda(int x,int y)\n{\n    int cnt=0;\n    for(int i=0;i&lt;4;i++) if(arr[x+dx[i]][y+dy[i]])  cnt++;\n    return cnt;\n}\nint skor(int x,int y)\n{\n    int a=brojsuseda(x,y);\n    int pre=0;\n    for(int i=0;i&lt;4;i++) if(arr[x+dx[i]][y+dy[i]] &amp;&amp; !fl[x+dx[i]][y+dy[i]] &amp;&amp; broj[x+dx[i]][y+dy[i]])  pre++;\n    if(a&lt;2) return 1000000000;\n    return -100000*broj[x][y]+1000*pre+100*(4-a)+rando[x][y]%100;\n}\nvoid u_pq(int x,int y)\n{\n    rando[x][y]=rng()%100;\n    pq.push({skor(x,y),{x,y}});\n}\nvoid dodajflood(int x,int y)\n{\n    broj[x][y]++;\n    if(broj[x][y]==2)\n    {\n        q.push({x,y});\n        fl[x][y]=true;\n    }\n    else\n    {\n        u_pq(x,y);\n        for(int i=0;i&lt;4;i++) if(arr[x+dx[i]][y+dy[i]] &amp;&amp; !fl[x+dx[i]][y+dy[i]]) u_pq(x+dx[i],y+dy[i]);\n    }\n\n}\nvoid poplavi(int x,int y)\n{\n    fl[x][y]=true;\n    for(int i=0;i&lt;4;i++) if(arr[x+dx[i]][y+dy[i]] &amp;&amp; !fl[x+dx[i]][y+dy[i]]) dodajflood(x+dx[i],y+dy[i]);\n}\nint main()\n{\n    int t,threshold;\n    cin&gt;&gt;t&gt;&gt;threshold;\n    if(threshold==0) threshold=1000000000;\n    string st;\n    if(t&lt;10) st='0'+to_string(t);\n    else st=to_string(t);\n    ifstream in(\"testcases\\\\\"+st+\".in\");\n    ofstream out(\"sols-dijagonalno\\\\\"+st+\".out\");\n    int n,m;\n    int lw=0;\n    in&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++)\n    {\n        in&gt;&gt;s[i];\n        for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n    }\n    while(true)\n    {\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) arr[i][j]=(s[i][j-1]=='.');\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) fl[i][j]=false;\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) broj[i][j]=0;\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) rando[i][j]=0;\n        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(arr[i][j]) u_pq(i,j);\n        int br=0;\n        while(!pq.empty())\n        {\n            pair&lt;int,int&gt; p=pq.top().second;\n            int rez=pq.top().first;\n            pq.pop();\n            if(fl[p.first][p.second] || rez!=skor(p.first,p.second)) continue;\n            q.push(p);\n            //cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl;\n            v.push_back(p);\n            br++;\n            while(!q.empty())\n            {\n                pair&lt;int,int&gt; pr=q.front();\n                q.pop();\n                poplavi(pr.first,pr.second);\n            }\n        }\n        cout&lt;&lt;br&lt;&lt;endl;\n        if(br&lt;threshold) break;\n        v.clear();\n    }\n    out&lt;&lt;v.size()&lt;&lt;endl;\n    for(int i=0;i&lt;v.size();i++) out&lt;&lt;v[i].first&lt;&lt;\" \"&lt;&lt;v[i].second&lt;&lt;endl;\n    //for(int i=1;i&lt;=n;i++) cout&lt;&lt;s[i]&lt;&lt;endl;\n}\n</code></pre>"},{"location":"takprog/2022_2023/sio/05_vooda/#dodatno-citanje","title":"Dodatno \u010ditanje","text":"<p>Za interesantno i pou\u010dno netakmi\u010darsko re\u0161enje ovog zadatka, pogledajte materijale profesora Ervina Varge sa Fakulteta Tehni\u010dkih Nauka u Novom Sadu, koji je na\u0161ao najbolje re\u0161enja koriste\u0107i programski interfejs OpenMP za paralelno programiranje. </p>"},{"location":"takprog/2022_2023/sio/06_parovi/","title":"6 - Parovi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Dat je povezan neusmeren te\u017einski graf od \\(N\\) \u010dvorova i \\(M\\) grana, i prirodan broj \\(K\\). Grane su numerisane od \\(1\\) do \\(M\\), gde \\(i\\)-ta grana ima te\u017einu \\(\\lceil \\frac{i}{K} \\rceil\\).</p> <p>Ozna\u010dimo sa \\(f(x, y)\\), gde je \\(1 \\leq x &lt; y \\leq N\\), odgovor na slede\u0107i upit:</p> <ul> <li>Me\u0111u svim minimalnim razapinju\u0107im stablima datog grafa, na\u0107i ono sa najve\u0107om vrednosti zbira stepena \u010dvorova \\(x\\) i \\(y\\), i vratiti tu vrednost.</li> </ul> <p>Izra\u010dunajte \\(\\sum\\limits_{x=1}^N \\sum\\limits_{y=x+1}^N f(x, y)\\), tj. sumu vrednosti \\(f(x, y)\\) za sve \\(1 \\leq x &lt; y \\leq N\\). </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Jovan Bengin Jovan Bengin Mom\u010dilo To\u0161i\u0107 Jovan Bengin"},{"location":"takprog/2022_2023/sio/06_parovi/#opisi-funkcija","title":"Opisi funkcija","text":"<p>Potrebno je da implementirate funkciju</p> <ul> <li>\\(Resi(N, M, K, U[\\dots], V[\\dots])\\)</li> </ul> <p>Funkcija \\(Resi\\) se poziva samo jednom na po\u010detku ivr\u0161avanja programa, a njeni parametri su:</p> <ul> <li>\\(N\\): broj \u010dvorova u grafu.</li> <li>\\(M\\): broj grana u grafu.</li> <li>\\(K\\): parametar koji ozna\u010dava da \\(i\\)-ta grana ima te\u017einu \\(\\lceil \\frac{i}{K} \\rceil\\).</li> <li>\\(U[\\dots]\\), \\(V[\\dots]\\): nizovi du\u017eine \\(M\\), indeksirani od 1, koji opisuju grane: \\(i\\)-ta grana spaja \u010dvorove \\(U_i\\) i \\(V_i\\).</li> </ul> <p>Funkcija \\(Resi\\) treba da vrati jedan ceo broj - vrednost \\(\\sum\\limits_{x=1}^N \\sum\\limits_{y=x+1}^N f(x, y)\\).</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#primer","title":"Primer","text":"<p>Neka je \\(N=4\\), \\(M=4\\), \\(K=2\\), \\(U = [1, 3, 4, 2]\\), \\(V = [2, 4, 1, 3]\\). U ovom grafu su grane \\(1-2\\) i \\(3-4\\) te\u017eine \\(1\\), a grane \\(4-1\\) i \\(2-3\\) te\u017eine \\(2\\). Ovaj graf ima dva mogu\u0107a minimalna razapinju\u0107a stabla - jedno sa granama \\(1-2\\), \\(3-4\\) i \\(1 - 4\\), drugo sa granama \\(1 - 2\\), \\(3 - 4\\), \\(2 - 3\\). </p> <p>U prvom stablu \u010dvorovi  \\(1\\) i \\(4\\) imaju stepen \\(2\\), a \\(2\\) i  \\(3\\) stepen \\(1\\). U drugom stablu \u010dvorovi  \\(1\\) i \\(4\\) imaju stepen \\(1\\), a \\(2\\) i  \\(3\\) stepen \\(2\\). Ako za svaki par uzmemo bolje od data dva stabla, dobijamo vrednosti \\(f(1, 2) = 3\\), \\(f(1, 3)  = 3\\), \\(f(1, 4) = 4\\), \\(f(2, 3) = 4\\), \\(f(2, 4) = 3\\), \\(f(3, 4) = 3\\), pa je broj koji funkcija \\(Resi\\) treba da vrati jednak \\(3+3+4+4+3+3=20\\).</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 100.000\\)</li> <li>\\(1 \\leq M \\leq 200.000\\)</li> <li>\\(1 \\leq K \\leq 100\\)</li> <li>\\(1 \\leq u_i, v_i \\leq N\\) i \\(u_i \\neq v_i\\) za \\(1 \\leq i \\leq M\\)</li> <li>Dati graf je povezan.</li> </ul>"},{"location":"takprog/2022_2023/sio/06_parovi/#podzadaci","title":"Podzadaci","text":"<ul> <li>[5 poena]: \\(M \\leq 18\\)</li> <li>[11 poena]: \\(N \\leq 50, M = K\\)</li> <li>[12 poena]: \\(N \\leq 100, M \\leq 200\\)</li> <li>[14 poena]: \\(K \\leq 6\\)</li> <li>[16 poena]: \\(N \\leq 1.000, M \\leq 2.000\\)</li> <li>[42 poena]: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2022_2023/sio/06_parovi/#detalji-implementacije","title":"Detalji implementacije","text":"<p>Potrebno je da po\u0161aljete ta\u010dno jedan fajl  <code>parovi.cpp</code>  koji implementira pomenutu funkciju. Osim tra\u017eenih funkcija, va\u0161 fajl mo\u017ee sadr\u017eati i dodatne globalne promenljive, pomo\u0107ne funkcije i dodatne biblioteke.</p> <p>Va\u0161a funkcija mora biti slede\u0107eg oblika:</p> <p><code>long long Resi(int N, int M, int K, int* U, int* V);</code></p> <p>Va\u0161im programima je dozvoljeno da menjaju sadr\u017eaj nizova ali ne smeju da pristupaju van granica datih nizova.</p> <p>Uz zadatak, obezbe\u0111en vam je \"template\" fajl  <code>code.cpp</code>  koje mo\u017eete koristiti i menjati po potrebi. Tako\u0111e vam je obezbe\u0111en program  <code>grader.cpp</code>  koji slu\u017ei da lak\u0161e testirate kodove. Ovaj program u\u010ditava sa standardnog ulaza slede\u0107e podatke:</p> <ul> <li>U prvom redu brojevi \\(N\\), \\(M\\) i \\(K\\).</li> <li>U narednih \\(M\\) redova brojevi \\(A_i\\) i \\(B_i\\).</li> </ul> <p>Zatim ovaj program zove va\u0161u funkciju i ispisuje rezultate koje ona vrati.</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#napomena","title":"Napomena","text":"<p>Razapinju\u0107e stablo povezanog te\u017einskog neusmerenog grafa je te\u017einsko stablo (povezan acikli\u010dan neusmeren graf) koje sadr\u017ei sve \u010dvorove i \u010dije se sve grane sadr\u017ee i u po\u010detnom grafu.</p> <p>Minimalno razapinju\u0107e stablo je bilo koje razapinju\u0107e stablo sa minimalnom sumom te\u017eina grana.</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#resenje-kad-m-leq-18","title":"Re\u0161enje kad \\(M \\leq 18\\)","text":"<p>U ovom slu\u010daju mo\u017eemo isprobati svako razapinjuju\u0107e stablo (biranjem svakog podskupa grana), na\u0107i sva minimalna i za svaki par \u010dvorova (kojih isto ima malo jer je graf povezan) na\u0107i i dodati re\u0161enje.  Tada je slo\u017eenost \\(O(N^2 2^M)\\)</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#resenje-kad-m-k-n-leq-50","title":"Re\u0161enje kad \\(M = K, N \\leq 50\\)","text":"<p>Uo\u010dimo da \u0107e te\u017eina svake grane biti 1. Dakle, MST je svako razapinjuju\u0107e stablo, a kako je i broj \u010dvorova manji, mo\u017eemo da izra\u010dunamo re\u0161enje za svaki par na tzv. pohlepan na\u010din. Ovde je potrebno uraditi analizu slu\u010dajeva, prebrojimo sve \u010dvorove sa direktnim vezama do ona dva koje posmatramo, oduzimaju\u0107i one koji su zajedni\u010dki (s tim da se s jednim mogu oba povezati ukoliko ne postoji grana izme\u0111u njih). Slo\u017eenost \u0107e biti \\(O(N^2(N+M))\\).</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#resenje-kad-je-n-leq-100-m-leq-200","title":"Re\u0161enje kad je \\(N \\leq 100, M \\leq 200\\)","text":"<p>Mo\u017eemo ponovo re\u0161avati za svaka dva \u010dvora, s tim \u0161to pu\u0161tamo simulaciju nala\u017eenja MST sa optimalnim biranjem grana tako da se maksimizuju one koje uklju\u010duju neki od dva odabrana \u010dvora. Slo\u017eenost je u ovom slu\u010daju \\(O(N^2 M\\log{M})\\).</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#resenje-kad-k-leq-6","title":"Re\u0161enje kad \\(K \\leq 6\\)","text":"<p>Za ovo re\u0161enje potrebno je pre\u0107i na druga\u010diji na\u010din prebrojavanja (koji se koristi i u celon re\u0161enju) - grupi\u0161emo grane sa jednakim te\u017einama (ka\u017eemo da je \u010dvor u grupi ako postoji grana u grupi koja ga sadr\u017ei) i brojimo koliko puta grane iz date grupe \"figuri\u0161u\" u kona\u010dnom zbiru (dakle bar jedan od selektovanih \u010dvorova je neki iz grupe). Po\u0161to Kruskalov algoritam dodaje grane u sortiranom redosledu, mo\u017eemo ra\u010dunati da kada posmatramo grupu te\u017eine \\(W\\) su \u010dvorovi ve\u0107 povezani u komponente koje formiraju grane te\u017eina ispod \\(W\\). Da bi se formirao MST svakako se u njega dodaje neki podskup novih grana, a kako je broj \\(K\\) mali, mo\u017eemo ru\u010dno probati svaki podskup i videti koliko grane doprinose zbiru (za svaka dva \u010dvora koja se pojavljuju u grupi kao krajevi veza). Kako ima \\(\\frac{M}{K}\\) grupa, a \\(O(K)\\) i \u010dvorova i grana u grupi, slo\u017eenost je \\(O(2^K MK)\\).</p>"},{"location":"takprog/2022_2023/sio/06_parovi/#resenje-za-pun-broj-poena","title":"Re\u0161enje za pun broj poena","text":"<p>Mogu\u0107e je izvr\u0161iti prebrojavanje pojavljivanja grana u maks stepeninma \u010dvorova iz grupe i br\u017ee, tako da ne postoji dodatni faktor osim kvadratnog po \\(K\\). Posmatrajmo veze \u010dvorova iz grupe sa ve\u0107 formiranim komponentama. Fiksiramo 2 \u010dvora u grupi i za njih dodajemo broj komponenti s kojima su povezani, oduzimaju\u0107i broj s kojim su oba povezana, sa obra\u0107anjem pa\u017enje na specijalne slu\u010dajeve (neki od dva \u010dvora povezan je sa komponentom od ovog drugog, u istoj su komponenti, ili postoji direktna veza izme\u0111u dva selektovana \u010dvora). Ovde se radi ne\u0161to donekle sli\u010dno kao u drugom podzadatku, s tim \u0161to je (uslovno re\u010deno) tada jedina grupa bio skup svih \u010dvorova, sada treba dodati i doprinos grana u  trenutnoj grupi na zbir stepena kad selektovan par uklju\u010duje jedan \u010dvor koji se ne pojavljuje u grupi, mada ovo se ra\u010duna samo kao broj komponenti s kojim je povezan onaj \u010dvor koji jeste u grupi (naravno onoliko puta koliko ima \u010dvorova van grupe). Nakon ovog procesa, a\u017euriramo komponente i prelazimo na narednu grupu. Ukupna slo\u017eenost je (istim rezonom kao i pre) \\(O(MK)\\).</p> 06_parovi.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define pb push_back\n#define si(x) int(x.size())\n#define all(x) x.begin(), x.end()\n#define fi first\n#define se second\n\nconst int N = 200000;\n\nstruct DSU{\n    int n;\n    int par[N+5], sz[N+5];\n    void init(int _n){\n        n = _n;\n        for(int i=1; i&lt;=n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n    int root(int x){\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    void unite(int u, int v){\n        u = root(u), v = root(v);\n        if(u == v) return;\n        if(sz[u] &lt; sz[v]) swap(u, v);\n        sz[u] += sz[v];\n        par[v] = par[u];\n    }\n} dsu;\n\nint n, m;\n\nvector &lt;int&gt; gc[N+5];\nvector &lt;int&gt; gn[N+5];\npair &lt;int, int&gt; e[N+5];\n\nint shares[N+5];\nbool has_edge[N+5];\nint ima_c[N+5], ima_n[N+5];\nbool bitan[N+5];\n\nll solve(int l, int r){\n    vector &lt;int&gt; nodes, comps;\n    for(int i=l; i&lt;=r; i++){\n        int u = e[i].fi, v = e[i].se;\n        int u1 = dsu.root(u), v1 = dsu.root(v);\n        if(u1 == v1) continue;\n        nodes.pb(u);\n        nodes.pb(v);\n        comps.pb(u1);\n        comps.pb(v1);\n        gc[u].pb(v1);\n        gc[v].pb(u1);\n        gn[u1].pb(v);\n        gn[v1].pb(u);\n    }\n    sort(all(nodes));\n    sort(all(comps));\n    nodes.erase(unique(all(nodes)), nodes.end());\n    comps.erase(unique(all(comps)), comps.end());\n    for(auto u : nodes){\n        bitan[u] = 1;\n        sort(all(gc[u]));\n        gc[u].erase(unique(all(gc[u])), gc[u].end());\n    }\n    for(auto cm : comps){\n        sort(all(gn[cm]));\n        gn[cm].erase(unique(all(gn[cm])), gn[cm].end());\n    }\n    ll res = 0;\n    for(int i=0; i&lt;si(nodes); i++){\n        int u = nodes[i];\n        for(auto cm : gc[u]){\n            ima_c[cm] = 1;\n            for(auto c : gn[cm]) shares[c]++;\n        }\n        for(auto c : gn[dsu.root(u)]){\n            ima_n[c] = 1;\n        }\n        res += 1LL*(n - si(nodes))*si(gc[u]);\n        for(int j=l; j&lt;=r; j++){\n            if(e[j].fi == u &amp;&amp; bitan[e[j].se]) has_edge[e[j].se] = 1;\n            if(e[j].se == u &amp;&amp; bitan[e[j].fi]) has_edge[e[j].fi] = 1;\n        }\n        for(int j=i+1; j&lt;si(nodes); j++){\n            int v = nodes[j];\n            res += si(gc[u]) + si(gc[v]) - shares[v];\n            if(has_edge[v] || dsu.root(u) == dsu.root(v)){\n                continue;\n            }\n            res -= ima_n[v] + ima_c[dsu.root(v)];\n            if(ima_n[v] || ima_c[dsu.root(v)] || shares[v]) res++;\n        }\n        for(auto c : nodes){\n            shares[c] = 0;\n            has_edge[c] = 0;\n            ima_n[c] = 0;\n        }\n        for(auto c : comps){\n            ima_c[c] = 0;\n        }\n    }\n    for(auto c : nodes){\n        bitan[c] = 0;\n        gc[c].clear();\n    }\n    for(auto c : comps) gn[c].clear();\n    for(int i=l; i&lt;=r; i++){\n        dsu.unite(e[i].fi, e[i].se);\n    }\n    return res;\n}\n\nlong long Resi(int _n, int _m, int _k, int *U, int *V){\n    int k;\n    n = _n, m = _m, k = _k;\n    for(int i=1; i&lt;=m; i++){\n        e[i].fi = U[i], e[i].se = V[i];\n    }\n    dsu.init(n);\n    ll res = 0;\n    for(int i=1; i&lt;=m; i+=k){\n        res += solve(i, min(m, i + k - 1));\n    }\n    return res;\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/01_neopodniz/","title":"B1 - Neopodniz","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Za nisku \\(A\\) ka\u017eemo da je podniz niske \\(B\\) ukoliko se \\(A\\) mo\u017ee dobiti brisanjem nekoliko karaktera iz \\(B\\), zadr\u017eavaju\u0107i redosled. Na primer, <code>a</code>, <code>ab</code> i <code>aa</code> su podnizovi niske <code>aba</code>, dok <code>bb</code> i <code>aab</code> to nisu.</p> <p>Za nisku \\(A\\) ka\u017eemo da je nepodniz niske \\(B\\) ukoliko ona nije njen podniz.</p> <p>Data je niska \\(S\\) du\u017eine \\(N\\) i prirodan broj \\(K\\). Poznato je da se \\(S\\) sastoji od prvih \\(K\\) malih slova Engleske abecede. Odrediti, za svako \\(i\\) (\\(1 \\leq i \\leq N\\)), du\u017einu najmanjeg nepodniza niske \\(S_1 S_2 \\ldots S_i\\). Pritom, razmatramo nepodnize koji se sastoje samo od prvih \\(K\\) slova Engleske abecede.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Mladen Puzi\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2023_2024/drz/01_neopodniz/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, nalaze se dva prirodna broja \\(N\\) i \\(K\\).</p> <p>U drugom redu standardnog ulaza, nalazi se jedna niska \\(S\\) du\u017eine \\(N\\). Garantuje se da se ona sastoji od prvih \\(K\\) malih slova Engleske abecede.</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati \\(N\\) celih brojeva u jednom redu. \\(i\\)-ti od njih predstavlja du\u017einu najmanjeg nepodniza niske \\(S_1 S_2 \\ldots S_i\\).</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/drz/01_neopodniz/#ulaz","title":"Ulaz","text":"<pre><code>7 3\nabcbaca\n</code></pre>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#izlaz","title":"Izlaz","text":"<pre><code>1 1 2 2 2 3 3\n</code></pre>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Najmanji po du\u017eini nepodnizovi niske <code>a</code> su <code>b</code> i <code>c</code>. Oba imaju du\u017einu \\(1\\) i odgovaraju prvom broju na izlazu.</p> <p>Najmanji po du\u017eini nepodniz niske <code>ab</code> je <code>c</code>. On ima du\u017einu \\(1\\), \u0161to odgovara drugom broju na izlazu.</p> <p>Jedan od najmanjih nepodnizova niske <code>abc</code> je <code>ba</code>. On ima du\u017einu \\(2\\), \u0161to odgovara tre\u0107em broju na izlazu.</p> <p>Jedan on najmanjih nepodnizova niske <code>abcbaca</code> je <code>ccb</code> . On ima du\u017einu \\(3\\) i odgovara poslednjem broju na izlazu.</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/drz/01_neopodniz/#ulaz_1","title":"Ulaz","text":"<pre><code>26 26\nabcdefghijklmnopqrstuvwxyz\n</code></pre>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#izlaz_1","title":"Izlaz","text":"<pre><code>1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2\n</code></pre>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 2\\cdot 10^5\\)</li> <li>\\(2 \\leq K \\leq 26\\)</li> <li>\\(S\\) se sastoji od prvih \\(K\\) malih slova Engleske abecede.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 18 poena: \\(N\\leq 5\\), \\(K=2\\);</li> <li>U testovima vrednim 36 poena: \\(N \\leq 1000\\);</li> <li>U testovima vrednim 10 poena: Niska \\(S\\) je ure\u0111ena leksikografski.</li> <li>U testovima vrednim 36 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#resenje-kada-n-leq-5-k-2","title":"Re\u0161enje kada \\(N \\leq 5, K = 2\\)","text":"<p>Za svaki prefiks, mo\u017eemo probati prvo sve mogu\u0107e niske du\u017eine \\(1\\), pa sve mogu\u0107e niske du\u017eine \\(2\\), itd. dok ne na\u0111emo re\u0161enje. </p> <p>Proveru za konkretnu nisku \\(T\\) mo\u017eemo uraditi tako \u0161to prolazimo sleva nadesno kroz prefiks niske \\(S\\) i uparujemo redom karaktere \u010dim nai\u0111emo na njih. Ukoliko smo prona\u0161li sve karaktere (istim redom kao u \\(T\\)), onda jeste podniz te niske, u suprotnom nije.</p> <p>Vremenska slo\u017eenost je \\(O(K^N \\cdot N^2)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#resenje-kada-je-niska-ureena-leksikografski","title":"Re\u0161enje kada je niska ure\u0111ena leksikografski","text":"<p>Primetimo da ukoliko prefiks niske \\(S\\) ne sadr\u017ei svih \\(K\\) razli\u010ditih karaktera, odgovor \u0107e biti \\(1\\) (niska koja se sastoji samo od karaktera koji se tu ne nalazi). </p> <p>Po\u0161to je niska ure\u0111ena leksikografski, postoja\u0107e neko \\(x\\) tako da je prvih \\(x\\) odgovora \\(1\\) (jer jo\u0161 nisu dodati svi karakteri), a ostalih \\(N-x\\) odgovora bi\u0107e 2 - npr. niska <code>ba</code>, koja se svakako ne pojavljuje u nisci, po\u0161to nije ure\u0111ena leksikografski.</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#resenje-kada-n-leq-1000","title":"Re\u0161enje kada \\(N \\leq 1000\\)","text":"<p>Sli\u010dno obzervaciji iz prethodnog podzadatka, optimalno je da prvi karakter na\u0161eg re\u0161enja za neki prefiks, bude karakter koji se prvi put pojavljuje \u0161to kasnije - do tog karaktera svi rezultati bi\u0107e \\(1\\).</p> <p>Primetimo da isto razmi\u0161ljanje mo\u017eemo da primenimo ponovo. Tra\u017eimo karakter koji se pojavljuje \u0161to kasnije, ne ra\u010dunaju\u0107i do sada vi\u0111ene karaktere. Svi rezultati do te pozicije \u0107e sad biti \\(2\\). </p> <p>Ovo razmi\u0161ljanje nastavljamo da primenjujemo dok ne odredimo sve rezultate.</p> <p>Vremenska slo\u017eenost je \\(O(N^2)\\), a memorijska \\(O(N)\\).</p>"},{"location":"takprog/2023_2024/drz/01_neopodniz/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Re\u0161enje za prethodni podzadatak se mo\u017ee ubrzati tako \u0161to \u0107emo \u010duvati matricu dimenzija \\(K \\times N\\), gde za svaku poziciju i svaki karakter \u010duvamo kada \u0107e se slede\u0107i put pojaviti. Ovo mo\u017eemo jednostavno izra\u010dunati, krenuv\u0161i unazad kroz nisku \\(S\\) i pamte\u0107i kad smo poslednji put videli svaki od karaktera.</p> <p>Kada popunimo ovu matricu, lako je ubrzati prethodno re\u0161enje, br\u017eim odabirom slede\u0107eg karaktera.</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(NK)\\).</p> 01_neopodniz.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nbool ima[26];\nint cnt=0;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n,k; cin&gt;&gt;n&gt;&gt;k;\n    string s; cin&gt;&gt;s;\n    int duz=1;\n    for (int i=0;i&lt;n;i++)\n    {\n        int c=s[i]-'a';\n        if (!ima[c]) ima[c]=true,cnt++;\n        if (cnt==k)\n        {\n            cnt=0;\n            for (int j=0;j&lt;k;j++) ima[j]=false;\n            duz++;\n        }\n        cout&lt;&lt;duz&lt;&lt;\" \";\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/","title":"B2 - Domski sleta\u010d","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Domski Sleta\u010d se nalazi u gornjem levom uglu matrice dimenzija \\(N \\times M\\). \u017delja mu je da do\u0111e do polja u donjem desnom uglu, jer se tamo nalazi njegov fri\u017eider sa mlekom. Op\u0161te je poznato da se Domski Sleta\u010d mo\u017ee pomerati iz trenutnog polja u polje direktno ispod ili u polje direktno desno (ukoliko takva polja postoje, odnosno nije mogu\u0107e da \"iza\u0111e\" iz matrice.).</p> <p>Bane Kasapin i Vojni Momak \u017eele da napakoste Domskom Sleta\u010du, pa su u nekim poljima matrice postavili izvestan broj njegovih neistomi\u0161ljenika. Neistomi\u0161ljenici tako\u0111e moraju da se kre\u0107u kao i Domski Sleta\u010d (mogu se pomerati iz trenutnog polja u polje direktno ispod ili u polje direktno desno). Kako je Domski Sleta\u010d neustra\u0161iv, on na putu do svog mleka \u017eeli i da raspravi nesuglasice sa svim svojim neistomi\u0161ljenicima.</p> <p>Kada Domski Sleta\u010d izabere svoju putanju do mleka, svi neistomi\u0161ljenici \u0107e se pomeriti do sebi najbli\u017eeg polja na tom putu. Tek kada se svi neistomi\u0161ljenici presele na \u017eeljena polja, onda Domski Sleta\u010d kre\u0107e na svoj put. Po\u0161to \u017eeli da mu neistomi\u0161ljenici budu \u0161to odmorniji, potrebno je da Domski Sleta\u010d izabere put takav da je ukupan put koji \u0107e svi neistomi\u0161ljenici pre\u0107i minimalan.</p> <p>Va\u0161 zadatak je da prona\u0111ete i ispi\u0161ete koliko \u0107e neistomi\u0161ljenici pre\u0107i do opisane putanje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko Milenkovi\u0107 Marko Milenkovi\u0107 Dragan Uro\u0161evi\u0107"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza, nalaze se dva prirodna broja \\(N\\) i \\(M\\) koji predstavljaju dimenzije matrice.</p> <p>U narednih \\(N\\) linija standardnog ulaza, nalazi se po \\(M\\) nenegativnih celih brojeva. U \\(i\\)-tom od \\(N\\) redova, \\(j\\)-ti broj ozna\u010den sa \\(a_{ij}\\) predstavlja broj neistomi\u0161ljenika na polju u \\(i\\)-toj vrsti i \\(j\\)-toj koloni. </p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvoj i jedinoj liniji izlaza ispisati najmanju ukupnu distancu koju \u0107e neistomi\u0161ljenici pre\u0107i.</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/drz/02_domski_sletac/#ulaz","title":"Ulaz","text":"<pre><code>4 4 \n4 3 2 1\n4 3 2 1\n4 3 2 1\n4 3 2 1\n</code></pre>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#izlaz","title":"Izlaz","text":"<pre><code>29\n</code></pre>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Optimalna putanja Domskom Sleta\u010du je \\((1,1)\\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (3, 2) \\rightarrow (4, 2) \\rightarrow (4, 3) \\rightarrow (4, 4)\\). Svih \\(4+4+3+3+3+2+1=20\\) neistomi\u0161ljenika na poljima kroz koje Domski Sleta\u010d prolazi, ne\u0107e morati da se pomere, pa je ukupna distanca koji oni pre\u0111u \\(0\\). Neistomi\u0161ljenici na poljima \\((3, 1)\\) i \\((4, 1)\\) \u0107e pre\u0107i za jedno polje u desnu stranu, \u0161to zna\u010di da \u0107e zbirno pre\u0107i \\(4+4 = 8\\). Neistomi\u0161ljenik u polju \\((1,2)\\) \u0107e se spustiti za jedno pole ispod i pre\u0107i \\(3\\). Zatim, neistomi\u0161ljenici na poljima \\((3, 3)\\) i \\((3, 4)\\) \u0107e pre\u0107i po jedno polje ispod, odnosno zbirno \u0107e pre\u0107i \\(2 + 1 = 3\\). Sli\u010dno, neistomi\u0161ljenici na poljima \\((2, 3)\\) i \\((2, 4)\\) \u0107e pre\u0107i po \\(2\\) polja na dole i ukupno pre\u0107i \\(2\\cdot 2 + 2\\cdot1 = 6\\). Na kraju, neistomi\u0161ljenici na poljima \\((1, 3)\\) i \\((1, 4 )\\) spusti\u0107e se za tri polja ispod i prelaze zbirno \\(3\\cdot 1 + 3\\cdot 2 = 9\\). Ukupno, svi neistomi\u0161ljenici \u0107e pre\u0107i \\(0+8+3+3+6+9 = 29\\).</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/drz/02_domski_sletac/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3 \n1 0 0\n0 7 0\n0 0 1\n</code></pre>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n</code></pre>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#objasnjenje-primera_1","title":"Obja\u0161njenje primera","text":"<p>U ovom primeru, optimalna putanja Domskom Sleta\u010du nije jedinstvena. Jedna mogu\u0107nost je \\((1,1)\\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (3, 3)\\). Na ovaj na\u010din, Domski Sleta\u010d prolazi kroz sve neistomi\u0161ljenike. Svih \\(1+7+1=9\\) neistomi\u0161ljenika na poljima kroz koje Domski Sleta\u010d prolazi, ne\u0107e morati da se pomere, pa je ukupna distanca koji oni pre\u0111u \\(0\\).</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\cdot M \\leq 10^6\\)</li> <li>\\(0 \\leq a_{ij} \\leq 10^6\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 20 poena: \\(1 \\leq NM \\leq 20\\);</li> <li>U test primerima vrednim 10 poena: \\(N = 2\\);</li> <li>U test primerima vrednim 35 poena: \\(N\\cdot M \\leq 10^4\\);</li> <li>U test primerima vrednim 35 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#nm-leq-20","title":"\\(NM \\leq 20\\)","text":"<p>U ovom podzadatku je dovoljno izgenerisati sve mogu\u0107e puteve (npr. bektreking algoritmom) i proveriti za svako polje koliko su neistomi\u0161ljenici udaljeni od tog puta. Na kraju samo ispisujemo minimum svih zbirnih udaljenosti.</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#n2","title":"\\(N=2\\)","text":"<p>U ovom podzadatku je klju\u010dno primetiti da time \u0161to posmatrana matrica ima dva reda, Domski Sleta\u010d \u0107e se samo jednom spustiti u drugi (ni\u017ei) red. Neka to bude iz polja \\((1, X)\\) u polje \\((2, X)\\). Kako neistomi\u0161ljenici mogu tako\u0111e da se kre\u0107u samo dole i desno, svi neistomi\u0161ljenici iz prvog reda desno od polja \\((1,X)\\), \u0107e morati da se spuste jedno polje nani\u017ee. Sa druge strane, neistomi\u0161ljenici iz drugog reda levo od polja \\((2,X)\\), \u0107e morati da idu na desnu stranu do polja \\((2, X)\\). Kona\u010dna suma za fiksirano \\(X\\) bi\u0107e \\(\\sum_{j=X+1}^M a_{1j} + \\sum_{j=1}^{X-1} \\left( a_{2j}\\cdot (X-j) \\right)\\). Mno\u017eenje sa \\((X-j)\\) zapravo odre\u0111uje koliko putanju \u0107e pre\u0107i neistomi\u0161ljenici iz drugog reda. Iterira\u0107emo po \\(X\\), a tra\u017eene sume mo\u017eemo da izra\u010dunamo pre toga kako ne bismo dobili kvadratnu slo\u017eenost. Kona\u010dno, vremenska slo\u017eenost ovog pristupa je \\(\\mathcal{O}(M)\\).</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#nm-leq-104","title":"\\(NM \\leq 10^4\\)","text":"<p>Primetimo da se u pro\u0161lom podzadatku svaki neistomi\u0161ljenik kretao samo dole ili samo desno. Ako uop\u0161timo zaklju\u010dak dobijamo da ako fiksiramo putanju Domskog Sleta\u010da i ukoliko se neistomi\u0161ljenik nalazi ispod nje, najbli\u017ee polje putanje \u0107e upravo biti ono koje je prvo gledaju\u0107i samo nadesno. Sli\u010dno, neistomi\u0161ljenicima koji su iznad putanje je optimalno da se spuste samo dole do prvog polja putanje. Imaju\u0107i u obzir da i Domski Sleta\u010d i neistomi\u0161ljenici kre\u0107u samo dole i desno, mo\u017ee se lako pokazati da su im to najbli\u017ea polja.</p> <p>Uz ovaj zaklju\u010dak mo\u017eemo da formiramo stanje dinami\u010dkog programiranja: \\(dp[i][j]\\) nam predstavlja odgovor na postavku zadatka ali za podmatricu do \\(i\\)-tog reda i \\(j\\)-te kolone (kolika je minimalna distanca koju svi neistomi\u0161ljenici iz ove podmatrice moraju da pre\u0111u da bi stigli do putanje Domskog Sleta\u010da koji se kre\u0107e od polja \\((1,1)\\) do polja \\((i,j)\\)). Jasno, u po\u010detku je \\(dp[1][x] = dp[y][1] = 0\\) za svako \\(x=1,2,\\ldots,M\\) i \\(y=1,2,\\ldots,N\\). U polje \\((i,j)\\) mo\u017eemo do\u0107i s gornje strane, odnosno iz polja \\((i-1,j)\\), ili s leve strane odnosno iz polja \\((i,j-1)\\). U prvom slu\u010daju minimalna distanca bi\u0107e \\(dp[i-1][j] + \\sum_{k=1}^{j-1} \\left( a_{ik}\\cdot (j-k) \\right)\\), jer neistomi\u0161ljenici iz \\(i\\)-tog reda s leve strane od trenutnog polja ba\u0161 dolaze u polje \\((i,j)\\). Sli\u010dnim rezonovanjem, u drugom slu\u010daju minimalna distance bi\u0107e. Na kraju, prelaz dinami\u010dkog programiranja bi\u0107e \\(dp[i][j-1]+\\sum_{k=1}^{i-1}\\left( a_{kj}\\cdot (i-k)\\right)\\). Za \\(dp[i][j]\\) uzimamo manju od ove dve vrednosti. Kona\u010dno re\u0161enje je \\(dp[N][M]\\). Ukupna vremenska slo\u017eenost ovog algoritma je \\(\\mathcal{O}(NM(N+M))\\).  </p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Jedino \u0161to nas spre\u010dava da dostignemo \u017eeljenu slo\u017eenost \\(\\mathcal{O}(NM)\\) u prethodnom re\u0161enju jeste sporo ra\u010dunanje prelaza za \\(dp[i][j]\\). Primetimo da isto kao i u drugom podzadatku mo\u017eemo da pre ra\u010dunanja prelaza i stanja dodatne sume. Odnosno, izra\u010duna\u0107emo \\(r[i][j]\\) najmanja distanca da svi neistomi\u0161ljenici iz reda \\(i\\) a u kolonama \\(1,2,\\ldots,j-1\\) do\u0111u do polja \\((i,j)\\). Sli\u010dno, \\(c[i][j]\\) najmanja distanca da svi neistomi\u0161ljenici iz kolone \\(j\\) a u redovima \\(1,2,\\ldots,i-1\\) do\u0111u do polja \\((i,j)\\). Prelaze ra\u010dunamo po formuli \\(r[i][j] = r[i][j-1] + \\sum_{k=1}^{j-1}a_{ij}\\) (posmatramo ovo na slede\u0107i na\u010din: kao da su do susednog polja levo svi neistomi\u0161ljenici do\u0161li i onda svi zajedno pre\u0161li za jedno polje udesno se pomerili) i \\(c[i][j] = c[i-1][j]  + \\sum_{k=1}^{i-1}a_{ij}\\). Primetimo da ove dodatne sume nisu ni\u0161ta nego prefiksne sume po redovima i kolonama, koje mo\u017eemo tako\u0111e unapred da izra\u010dunamo i obele\u017eimo sa \\(pref\\_r[i][j]\\) i \\(pref\\_c[i][j]\\). Sada nam prelazi izledaju ovako: \\(r[i][j] = r[i][j-1] + pref\\_r[i][j-1]\\) i \\(c[i][j] = c[i-1][j]  + pref\\_c[i-1][j]\\). Kona\u010dno, po\u010detni prelaz iz prethodnog podzadatka dobija slede\u0107u formu \\(dp[i][j] = \\min(dp[i-1][j] + r[i][j], dp[i][j-1] + c[i][j])\\). Vremenska slo\u017eenost ovog re\u0161enja je \\(\\mathcal{O}(NM)\\).</p>"},{"location":"takprog/2023_2024/drz/02_domski_sletac/#napomena","title":"Napomena","text":"<p>U skoro svim podzadacima je potrebno da se koristi \\(64\\)-bitni tip podataka za ra\u010dunanje, jer krajnji odgovor mo\u017ee da bude znatno ve\u0107i od \\(2\\cdot 10^9\\).</p> 02_domski_sletac.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair&lt;int, int&gt; pi;\ntypedef pair&lt;ll, ll&gt; pl;\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;ll&gt; vl;\ntypedef vector&lt;double&gt; vd;\ntypedef vector&lt;bool&gt; vb;\ntypedef vector&lt;char&gt; vc;\ntypedef vector&lt;string&gt; vs;\ntypedef vector&lt;pi&gt; vp;\ntypedef vector&lt;pl&gt; vpl;\n\n\nifstream in;\nofstream out;\n\nconst int mod = 1e9+7;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false); \n    cin.tie(nullptr); \n    cout.tie(nullptr); \n    cerr.tie(nullptr);  \n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt;&gt; a(n, vi(m, 0)), dp = a, rows = a, cols = a;\n\n    for (auto&amp; i : a)\n        for(auto&amp; j : i)\n            cin &gt;&gt; j;\n\n    for (int i = 0; i &lt; n; ++i){\n        rows[i][0] = a[i][0];\n        for (int j = 1; j &lt; m; ++j)\n            rows[i][j] = rows[i][j-1] + a[i][j];\n    }\n\n    for (int j = 0; j &lt; m; ++j){\n        cols[0][j] = a[0][j];\n        for (int i = 1; i &lt; n; ++i)\n            cols[i][j] = cols[i-1][j] + a[i][j];\n    }\n\n    auto pref_cols = vector&lt;vector&lt;int&gt;&gt;(n, vi(m, 0));\n    auto pref_rows = pref_cols;\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 1; j &lt; m; ++j)\n            pref_rows[i][j] = pref_rows[i][j-1] + rows[i][j-1];\n\n    for (int j = 0; j &lt; m; ++j)\n        for (int i = 1; i &lt; n; ++i)\n            pref_cols[i][j] = pref_cols[i-1][j] + cols[i-1][j];\n\n    for (int i = 1; i &lt; n; ++i){\n        for (int j = 1; j &lt; m; ++j){\n            int levo = dp[i][j-1] + pref_cols[i][j];\n            int gore = dp[i-1][j] + pref_rows[i][j];\n\n            dp[i][j] = min(levo, gore);\n        }\n    }\n\n    cout &lt;&lt; dp[n-1][m-1] &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/","title":"B3 - Staru\u0107i prsten","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Igrate najnoviji nastavak popularne igrice \"Staru\u0107i prsten\". Poznato je da u ovoj igrici postoji \\(Q\\) \u0161efova, od kojih \\(i\\)-ti ima \\(H_i\\) zdravstvenih poena. Da bi zavr\u0161ili igricu, morate da pobedite svakog od njih.</p> <p>Borba sa svakim \u0161efom traje najvi\u0161e \\(N\\) poteza. Sa svakim \u0161efom se borba odigrava kroz istih \\(N\\) poteza. Tokom \\(k\\)-tog od njih, na raspolaganju su Vam dve opcije:</p> <ul> <li>Primeniti direktan napad na \u0161efa i time mu smanjiti broj zdravstvenih poena za \\(D_k\\).</li> <li>Primeniti napad sa otrovom. Primenom ovog napada se \u0161efu nakon svakog narednog poteza (uklju\u010duju\u0107i i trenutni) broj zdravstvenih poena smanjuje za \\(P_k\\). Primetite da se napadi sa otrovom akumuliraju, tj. nakon kraja svakog poteza, \u0161efu se broj zdravstvenih poena smanjuje za ukupnu sumu primenjenih napada sa otrovom zaklju\u010dno sa tim potezom.</li> </ul> <p>Ukoliko nakon zavr\u0161etka nekog poteza \u0161ef ima najvi\u0161e \\(0\\) zdravstvenih poena, on je pobe\u0111en i borba sa njim se zavr\u0161ava.</p> <p>Po\u0161to ste veteran ove igrice, trenutno Vas jedino zanima da je \u0161to br\u017ee zavr\u0161ite. Za svakog \u0161efa ispisati koliko je najmanje poteza potrebno da bi ga pobedili. \"Staru\u0107i prsten\" je poznat kao igrica sa te\u0161kim \u0161efovima, te neke od njih nije fizi\u010dki ni mogu\u0107e pobediti. Ukoliko nije mogu\u0107e pobediti \u0161efa nakon najvi\u0161e \\(N\\) poteza, ispisati \\(-1\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se celi brojevi \\(N\\) i \\(Q\\), koji redom predstavljaju broj poteza i broj \u0161efova. U svakoj od narednih \\(N\\) linija, nalaze se po dva cela broja. U \\(k\\)-toj liniji, nalaze se brojevi \\(D_k\\) i \\(P_k\\). U narednih \\(Q\\) linija, nalazi se po jedan ceo broj, \\(H_i\\), broj zdravstvenih poena \\(i\\)-tog \u0161efa.</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svakog od \\(Q\\) \u0161efova ispisati po jedan ceo broj - broj poteza potrebnih da se dati \u0161ef pobedi. Ukoliko \u0161efa nije mogu\u0107e pobediti nakon najvi\u0161e \\(N\\) poteza, ispisati \\(-1\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 200.000\\)</li> <li>\\(0 \\leq D_k, P_k \\leq 100.000.000\\)</li> <li>\\(1 \\leq H_i \\leq 1.000.000.000\\)</li> </ul>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#podzadaci","title":"Podzadaci","text":"<ul> <li>(11 poena): \\(P_k = 0\\)</li> <li>(13 poena): \\(D_k = 0\\)</li> <li>(29 poena): \\(Q \\leq 10\\)</li> <li>(14 poena): \\(2 \\cdot P_k &gt; D_k\\)</li> <li>(33 poena): Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#primer","title":"Primer","text":""},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#ulaz","title":"Ulaz","text":"<pre><code>4 5\n1 2\n2 1\n1 0\n1 0\n2\n3\n14\n13\n6\n</code></pre>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#izlaz","title":"Izlaz","text":"<pre><code>1\n2\n-1\n4\n2\n</code></pre>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#objasnjenje","title":"Obja\u0161njenje","text":"<ul> <li>Prvi \u0161ef ima \\(2\\) zdravstvena poena. Na njega primenimo napad sa otrovom u prvom potezu. Nakon prvog poteza, taj mu napad smanjuje broj zdravstvenih poena na \\(0\\), \u010dime je \u0161ef pobe\u0111en nakon jednog poteza.</li> <li>Drugi \u0161ef ima \\(3\\) zdravstvena poena. Na njega u prvom potezu primenimo napad sa otrovom. Nakon prvog poteza, taj mu napad smanjuje broj zdravstvenih poena za \\(2\\), \u010dime mu preostaje \\(1\\) zdravstveni poen. U drugom potezu na \u0161efa mo\u017eemo ponovo da primenimo napad sa otrovom. Nakon kraja poteza akumulirani napadi sa otrovom mu smanjuju broj zdravstvenih poena za \\(2+1=3\\), \u010dime mu preostaju \\(1 - 3 = -2\\) zdravstvena poena. Time je \u0161ef pobe\u0111en nakon dva poteza.</li> <li>Tre\u0107i \u0161ef ima \\(14\\) zdravstvenih poena i nije ga mogu\u0107e pobediti sa \\(4\\) data poteza.</li> <li>\u010cetvrti \u0161ef ima \\(13\\) zdravstvenih poena. Na njega u prvom potezu primenjujemo napad sa otrovom. Nakon prvog poteza, taj mu napad smanjuje broj zdravstvenih poena za \\(2\\), \u010dime mu preostaje \\(11\\) zdravstvenih poena. U drugom potezu na \u0161efa mo\u017eemo ponovo da primenimo napad sa otrovom. Nakon kraja poteza akumulirani napadi sa otrovom mu smanjuju broj zdravstvenih poena za \\(2+1=3\\), \u010dime mu preostaje \\(11 - 3 = 8\\) zdravstvenih poena. U tre\u0107em potezu na \u0161efa primenjujemo direktni napad \u010dime mu smanjujemo broj zdravstvenih poena za \\(1\\), tj. nakon napada mu preostaje \\(8 - 1 = 7\\) zdravstvenih poena. Nakon kraja poteza akumulirani napadi sa otrovom mu smanjuju broj zdravstvenih poena za \\(2+1=3\\), \u010dime mu preostaje \\(7 - 3 = 4\\) zdravstvena poena. U \u010detvrtom potezu na \u0161efa primenjujemo direktni napad \u010dime mu smanjujemo broj zdravstvenih poena za \\(1\\), tj. nakon napada mu preostaje \\(4 - 1 = 3\\) zdravstvena poena. Nakon kraja poteza akumulirani napadi sa otrovom mu smanjuju broj zdravstvenih poena za \\(2+1=3\\), \u010dime mu preostaje \\(3 - 3 = 0\\) zdravstvenih poena. Time je \u0161ef pobe\u0111en nakon \u010detiri poteza. </li> <li>Peti \u0161ef ima \\(6\\) zdravstvenih poena. Na njega u prvom potezu primenimo napad sa otrovom. Nakon prvog poteza, taj mu napad smanjuje broj zdravstvenih poena za \\(2\\), \u010dime mu preostaju \\(4\\) zdravstvena poena. U drugom potezu na \u0161efa primenjujemo direktni napad \u010dime mu smanjujemo broj zdravstvenih poena za \\(2\\), tj. nakon napada mu preostaju \\(4 - 2 = 2\\) zdravstvena poena. Nakon kraja poteza akumulirani napadi sa otrovom mu smanjuju broj zdravstvenih poena za \\(2\\), \u010dime mu preostaje \\(2 - 2 = 0\\) zdravstvenih poena. Time je \u0161ef pobe\u0111en nakon dva poteza.</li> </ul>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#resenje-kada-p_i0","title":"Re\u0161enje kada \\(P_i=0\\)","text":"<p>Primetimo da \u0107emo u ovom slu\u010daju uvek raditi direktan napad, tako da posle \\(k\\) poteza \u0107emo naneti ukupno \\(S_k=D_1+D_2+\\cdots+D_k\\) poena \u0161tete. Ovaj niz je sortiran, te binarnom pretragom za svaki upit mo\u017eemo da na\u0111emo najmanji element \\(S\\) koji je ve\u0107i od tra\u017eenog \\(H_i\\). Slo\u017eenost je \\(O(N+Q\\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#resenje-kada-d_i0","title":"Re\u0161enje kada \\(D_i=0\\)","text":"<p>U ovom slu\u010daju \u010demo uvek raditi napad otrovom, tako da posle \\(k\\) poteza \u0107emo naneti ukupno \\(S_k=k\\cdot P_1+(k-1)\\cdot P_2+\\cdots+1\\cdot P_k\\) poena \u0161tete. Ako sra\u010dunamo ovaj niz, mo\u017eemo zavr\u0161iti binarnom pretragom, kao i u prvom podzadatku. Ovo se, me\u0111utim, lako mo\u017ee uraditi tako \u0161to se uzme parcijalna suma parcijalnih suma niza \\(P_i\\). Slo\u017eenost je \\(O(N+Q\\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#resenje-kada-d_i0_1","title":"Re\u0161enje kada \\(D_i=0\\)","text":"<p>U ovom slu\u010daju \u010demo uvek raditi napad otrovom, tako da posle \\(k\\) poteza \u0107emo naneti ukupno \\(S_k=k\\cdot P_1+(k-1)\\cdot P_2+\\cdots+1\\cdot P_k\\) poena \u0161tete. Ako sra\u010dunamo ovaj niz, mo\u017eemo zavr\u0161iti binarnom pretragom, kao i u prvom podzadatku. Ovo se, me\u0111utim, lako mo\u017ee uraditi tako \u0161to se uzme parcijalna suma parcijalnih suma niza \\(P_i\\). Slo\u017eenost je \\(O(N+Q\\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#resenje-kada-je-qleq-10","title":"Re\u0161enje kada je \\(Q\\leq 10\\)","text":"<p>U daljim podzadacima, sli\u010dno prva dva, \u0107emo ozna\u010diti sa \\(S_k\\) koliko najvi\u0161e \u0161tete mo\u017eemo naneti u prvih \\(k\\) poteza. U ovom podzadatku \u0107emo pokazti kako se proizvoljno \\(S_k\\) mo\u017ee sra\u010dunati u \\(O(N)\\). Zaista, primetimo da ako znamo da \u0107emo raditi ta\u010dno \\(k\\) poteza, onda u nekom \\(i\\)-tom potezu imamo izbor da ili radimo \\(D_i\\) \u0161tete direktnim napadom, ili \\(P_i\\) otrova koje \u0107e trajati \\(k-i+1\\) poteza, odnosno naneti ukupno \\((k-i+1)P_i\\) \u0161tete. Po\u0161to je \\(k\\) fiksirano, potrebno je samo izabrati ve\u0107u od ove dve vrednosti. Sada radimo binarnu pretragu po \\(S\\), ali ra\u010dunaju\u0107i konkretne vrednosti za \\(S_i\\) samo kad nam trebaju (jer je niz svakako sortiran). Ovo nam daje slo\u017eenost \\(O(QN\\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#resenje-kada-nema-upita-prvog-tipa","title":"Re\u0161enje kada nema upita prvog tipa","text":"<p>U ovom slu\u010daju mo\u017eemo lako sra\u010dunati niz \\(S_i\\). Zaista, zbog uslova va\u017ei da jedini potez kad je mo\u017eda optimalno primeniti direktan napad poslednji pred ubijanje, te su nam jedine opcije za \\(S_k\\) ili ono \u0161to je bilo u drugom podzataku, ili \\(k\\cdot P_1+(k-1)\\cdot P_2+\\cdots+2\\cdot P_{k-1}+D_k\\). Uzimaju\u0107i maksimum od te dve vrednosti, nalazimo niz \\(S_k\\), i mo\u017eemo opet da zavr\u0161imo binarnom pretragom kao u prva dva podzadatka. Slo\u017eenost \\(O(N+Q\\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/03_staruci_prsten/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>U ovom re\u0161enju \u0107emo sra\u010dunati sve vrednosti \\(S_k\\) u \\(O(N)\\), oslanjaju\u0107i se na opservacije iz tre\u0107eg podzadatka. Glavno je videti da za svako \\(i\\), kako pomeramo \\(k\\) \u0107e nam prvo biti optimalno raditi direktan napad, pa onda od  \\(k\\ge i+\\lfloor\\frac{D_i}{P_i}\\rfloor\\) \u0107e biti optimalno raditi napad otrovom. Sada pomeramo \\(k\\) i zapamtimo \"doga\u0111aje\" oblika od kada je optimalno raditi napad otrovom. Kada nai\u0111emo na novi doga\u0111aj prera\u010dunamo vrednost nanete \u0161tete do sad ako bismo uradili napad otrovom umesto direktnog napada u tom potezu, i dodamo taj otrov na neki broja\u010d totalnog otrova. Zatim u svakom potezu dodamo totali otrov i na\u0111emo novu vrednost niza \\(S\\). Ovime smo sra\u010dunali niz \\(S\\) i mo\u017eemo opet binarnom pretragom dovr\u0161iti zadatak u \\(O(N+Q\\log N)\\)</p> 03_staruci_prsten.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 200005\nusing namespace std;\nint n, q;\nint p[maxn];\nint d[maxn];\nlong long gt[maxn];\nlong long ad[maxn];\nlong long off[maxn];\nvoid solve()\n{\n    long long cur = 0;\n    long long sum = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        sum += d[i];\n        if (p[i])\n        {\n            int steps = d[i] / p[i] + 1;\n            int j = i + steps - 1;\n            if (j &lt;= n)\n            {\n                ad[j] += p[i];\n                off[j] += (1ll * p[i] * (j - i) - d[i]);\n            }\n        }\n        cur += ad[i];\n        sum += off[i];\n        sum += cur;\n        gt[i] = sum;\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; d[i] &gt;&gt; p[i];\n    }\n    solve();\n    while (q--)\n    {\n        int x;\n        cin &gt;&gt; x;\n        if (x &gt; gt[n])\n            cout &lt;&lt; -1 &lt;&lt; endl;\n        else\n        {\n            int l = 1;\n            int r = n;\n            while (l &lt; r)\n            {\n                int m = (l + r) / 2;\n                if (gt[m] &gt;= x)\n                    r = m;\n                else\n                    l = m + 1;\n            }\n            cout &lt;&lt; l &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/04_i_ili/","title":"A1 - I/Ili","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Dobili ste jedan niz od \\(N\\) brojeva na poklon! Poznato Vam je da se na ovom nizu mo\u017ee raditi slede\u0107a operacija: izaberi 2 broja \\(1 \\leq i \\leq N\\) i \\(1 \\leq j \\leq N\\), i elemente niza \\(A_i\\) i \\(A_j\\) zameni sa \\(A_i\\text{ and }A_j\\) i \\(A_i\\text{ or }A_j\\), gde su \\(and\\) i \\(or\\) operacije logi\u010dko \"i\", odnosno logi\u010dko \"ili\" (ove operacije vr\u0161e logi\u010dko \"i\"/\"ili\" na svakom od bitova u binarnom zapisu dveju brojeva).</p> <p>Uz niz dolazi i ma\u0161ina koja zadaje \\(Q\\) komandi. Svaka komanda je oblika</p> <ul> <li>\\(T_i\\) \\(K_i\\)</li> <li>\\(T_i\\) \\(K_i\\) \\(X_i\\)</li> </ul> <p>Ukoliko je \\(T_i = 0\\) (komanda tipa \\(0\\)), to zna\u010di da treba odgovoriti na pitanje Koji je \\(K_i\\)-ti broj u leksikografski najve\u0107em nizu koji je mogu\u0107e dobiti primenom proizvoljno mnogo operacija opisanih gore, na niz koji imate.</p> <p>Ukoliko je \\(T_i = 1\\) (komanda tipa \\(1\\)), to zna\u010di da je potrebno promeniti niz koji imate tako da element na poziciji \\(K_i\\) postaje \\(X_i\\).</p> <p>Komande tipa \\(0\\) ne menjaju niz. odnosno ne formira se leksikografski najve\u0107i niz, ve\u0107 se Va\u0161 niz isklju\u010divo menja komandama tipa \\(1\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Mom\u010dilo To\u0161i\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/drz/04_i_ili/#opis-ulaza","title":"Opis ulaza","text":"<ul> <li>U prvoj liniji ulaza nalazi se broj \\(N\\), broj elemenata u nizu.</li> <li>U slede\u0107oj liniji nalazi se \\(N\\) celih brojeva \\(A_i\\), razdvojenih razmakom, koji predstavljaju vrednosti niza.</li> <li>U tre\u0107oj liniji nalazi se \\(Q\\), broj komandi.</li> <li>U svakoj od narednih \\(Q\\) linija data je komanda u obliku opisanom gore, brojevi su razdvojeni razmakom.</li> </ul>"},{"location":"takprog/2023_2024/drz/04_i_ili/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaku komandu tipa \\(0\\) \\(K_i\\), potrebno je ispisati u novom redu \\(K_i\\)-ti \u010dlan leksikografski najve\u0107eg niza koji se mo\u017ee dobiti primenom opisanih operacija nad nizom.</p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/drz/04_i_ili/#ulaz","title":"Ulaz","text":"<pre><code>4\n0 1 2 3\n3\n0 1\n0 2\n0 3\n</code></pre>"},{"location":"takprog/2023_2024/drz/04_i_ili/#izlaz","title":"Izlaz","text":"<pre><code>3\n3\n0\n</code></pre>"},{"location":"takprog/2023_2024/drz/04_i_ili/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Tra\u017eeni niz je \\(3\\), \\(3\\), \\(0\\), \\(0\\), te je prvi element 3, drugi 3, a tre\u0107i 0.</p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/drz/04_i_ili/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n2 4 8 2 0\n3\n0 2\n1 4 0\n0 2\n</code></pre>"},{"location":"takprog/2023_2024/drz/04_i_ili/#izlaz_1","title":"Izlaz","text":"<pre><code>2\n0\n</code></pre>"},{"location":"takprog/2023_2024/drz/04_i_ili/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(N, Q \\leq 10^5\\)</li> <li>\\(T_i \\in \\{ 0, 1 \\}\\)</li> <li>\\(1 \\leq K_i \\leq N\\)</li> <li>\\(0 \\leq X_i, A_i \\leq 10^9\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 7 poena: \\(N, Q, A_i \\leq 5\\);</li> <li>U testovima vrednim 21 poen: \\(N, Q \\leq 100\\);</li> <li>U testovima vrednim 22 poena: \\(N, Q \\leq 5000\\)</li> <li>U testovima vrednim 13 poena: \\(A_i, X_i \\in \\{ 0, 1 \\}\\)</li> <li>U testovima vrednim 37 poena: Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2023_2024/drz/04_i_ili/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Rekurzivno isprobavanje svih mogu\u0107ih primena operacija osvaja poene u ovom podzadatku. Bitno je optimizovati tu rekurziju i ne posetiti nijedan niz vi\u0161e od dvaput u istoj komandi. To se mo\u017ee ostvariti upotrebom skupa u kome \u010duvamo sve pose\u0107ene nizove.</p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Primetimo da primena operacije \\(A_i = A_i\\text{ or }A_{i+1}\\), \\(A_{i+1} = A_i\\text{ and }A_{i+1}\\) ima tendenciju da \"bitove pomera ulevo\". Ponovljenom primenom ovog postupka, sli\u010dno kao u algoritmu \"bubble sort\", mo\u017eemo efektivno sortirati trenutni niz i na\u0107i \\(K\\)-ti po redu element. Doslovna gruba implementacija dovodi do re\u0161enja drugog podzadatka. Vremenska lo\u017eenost je \\(O(QN^2)\\).</p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Fiksirajmo neko \\(0 \\leq i &lt; 30\\). Primetimo da se nakon primene operacije ukupan broj elemenata niza koji sadr\u017ee \"bit\" \\(2^i\\) ne menja. Uo\u010dimo postupak iz prethodnog podzadatka. Rezultat je taj da se svi \"bitovi\" nalaze \"zbijeno levo\". Ta\u010dnije, izme\u0111u svake dve jedinice se tako\u0111e nalaze sve jedinice na odre\u0111enoj mesnoj vrednosti u binarnom zapisu.</p> <p>Sada je dovoljno izbrojati svaki \"bit\", i u zavisnosti od \\(K\\) odrediti da li se on nalazi u \\(K\\)-tom elementu krajnjeg niza \\(A\\) ili ne. Direktna simulacija komandi dovodi do vremenske slo\u017eenosti \\(O(NQ\\log M)\\), gde je \\(M\\) najve\u0107a vrednost niza \\(A\\) .</p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#cetvrti-podzadatak","title":"\u010cetvrti podzadatak","text":"<p>Sli\u010dno kao u prethodnim podzadacima, brojimo koliko se puta \"bit\" pojavljuje u nizu. U ovom slu\u010daju je to jednostavnije jer su elementi niza \\(0\\) i \\(1\\). Dakle, brojimo samo broj jedinica. Za komandu tipa \\(1\\), pode\u0161avamo broja\u010d na novu odgovaraju\u0107u vrednost na osnovu promenjenog elementa niza. Za komandu tipa \\(0\\), dajemo odgovor u zavisnosti od a\u017euriranog broja jedinica. Vremenska slo\u017eenost je \\(O(N)\\). </p>"},{"location":"takprog/2023_2024/drz/04_i_ili/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Spajamo ideje iz tre\u0107eg i \u010detvrtog podzadatka. Za svaki \"bit\" (od \\(0\\) do \\(29\\)), brojimo koliko se puta pojavljuje u nizu. Za komandu tipa \\(1\\), pode\u0161avamo broja\u010de na odgovaraju\u0107e nove vrednosti. Za komandu tipa \\(0\\), dajemo odgovor sli\u010dno kao u tre\u0107em podzadatku. Kod svake komande prolazimo po najvi\u0161e \\(30\\) bitova. Ovo daje re\u0161enje vremenske slo\u017eenosti \\(O((N+Q)\\log M)\\), gde je \\(M\\) najve\u0107a vrednost niza \\(A\\).</p> 04_i_ili.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nlong long typedef ll;\n\nint cnt[30];\n\nvoid brisi(int x)\n{\n    for (int i=0;i&lt;30;i++) if (x&amp;(1&lt;&lt;i)) cnt[i]--;\n}\n\nvoid dodaj(int x)\n{\n    for (int i=0;i&lt;30;i++) if (x&amp;(1&lt;&lt;i)) cnt[i]++;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n; cin&gt;&gt;n;\n    vector&lt;int&gt; a(n);\n    for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i],dodaj(a[i]);\n\n    int q; cin&gt;&gt;q;\n    while (q--)\n    {\n        int t; cin&gt;&gt;t;\n        if (t==0)\n        {\n            int k; cin&gt;&gt;k;\n            int ans=0;\n            for (int i=0;i&lt;30;i++)\n            {\n                if (cnt[i]&gt;=k) ans|=(1&lt;&lt;i);\n                else if (i==48 &amp;&amp; k==n-1) ans|=(1&lt;&lt;i);\n            }\n            cout&lt;&lt;ans&lt;&lt;\"\\n\";\n        }\n        else\n        {\n            int k,x; cin&gt;&gt;k&gt;&gt;x;\n            brisi(a[k-1]);\n            a[k-1]=x;\n            dodaj(a[k-1]);\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/05_kiki/","title":"A2 - Kiki","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1500ms 256MB <p>Limeni je pokidao dr\u017eavno takmi\u010denje iz programiranja i kao nagradu je dobio neobojeno stablo (povezan acikli\u010dan graf)! U pakovanju su tako\u0111e bile i dve beskona\u010dno velike kantice sa bojama - plava i crvena. Stablo koje je dobio na poklon je malo specifi\u010dno po tome \u0161to nisu svi \u010dvorovi iste veli\u010dine, pa je i razli\u010dita koli\u010dina boje koja je potrebna da se oboje razli\u010diti \u010dvorovi. Naime, da bi se \\(i\\)-ti \u010dvor obojio, potrebno je \\(a_i\\) koli\u010dine boje iz jedna od kantica.</p> <p>Osim \u0161to je vrhunski programer, Limeni je i \u0161apta\u010d ptica, pa je istrenirao svog papagaja Kikija da igra jednu igru bojenja nad ovim stablom. Pravila igre su slede\u0107a:</p> <ul> <li>Limeni i Kiki igraju naizmeni\u010dno, a Limeni igra prvi;</li> <li>Igra\u010d koji je na potezu bira jedan od neobojenih \u010dvorova i boji ga proizvoljnom bojom (plavom ili crvenom), ali tako da nijedan od njegovih suseda nije obojen istom tom bojom;</li> <li>Igra se zavr\u0161ava kada vi\u0161e ne postoji \u010dvor koji mo\u017ee biti obojen.</li> </ul> <p>Na kraju igre je pobednik Limeni ukoliko je svaki \u010dvor stabla obojen, a u suprotnom Kiki.</p> <p>Kako je Kiki jako dobro istreniran i igra optimalno u svakom trenutku, dogovorili su se da Limeni mo\u017ee da u svom prvom potezu oboji proizvoljan broj \u010dvorova proizvoljnim bojama (dakle, mogu\u0107e je da nekoliko \u010dvorova oboji crvenom bojom, a nekoliko drugih \u010dvorova plavom). Kako bi igra bila \u0161to zanimljivija, interesuje ih koliko najmanje boje u svom prvom potezu Limeni mora da potro\u0161i tako da zagarantuje pobedu.</p> <p>Ukoliko postoji vi\u0161e re\u0161enja, ispisati bilo koje.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko Milenkovi\u0107 Marko Milenkovi\u0107 Dimitrije Erdeljan"},{"location":"takprog/2023_2024/drz/05_kiki/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza, nalazi se jedan prirodan broj \\(N\\), koji predstavlja broj \u010dvorova u stablu.</p> <p>U drugoj liniji standardnog ulaza, nalazi se \\(N\\) prirodnih brojeva \\(a_1, a_2, \\ldots, a_n\\), koji predstavljaju kolika koli\u010dina boje je potrebno da se \u010dvorovi \\(1, 2, \\ldots, N\\) redom oboje.</p> <p>U narednih \\(N-1\\) linija standardnog ulaza, nalaze se po \\(2\\) prirodna broja. U \\(i\\)-tom od \\(N-1\\) redova, data dva prirodna broja \\(u_i\\) i \\(v_i\\) ozna\u010davaju da postoji grana izme\u0111u \u010dvorova sa indeksima \\(u_i\\) i \\(v_i\\). </p>"},{"location":"takprog/2023_2024/drz/05_kiki/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvoj liniji standardnog izlaza ispisati najmanju koli\u010dinu boje \\(X\\) koju Limeni mora da potro\u0161i u prvom potezu kako bi osigurao pobedu protiv Kikija.</p> <p>U drugoj liniji standardnog izlaza ispisati broj \\(R\\) - koliko \u010dvorova Limeni treba da oboji crvenom bojom u prvom potezu. U tre\u0107oj liniji standardnog izlaza ispisati \\(R\\) prirodnih brojeva, koji predstavljaju skup \u010dvorova koje Limeni treba da oboji crvenom bojom u prvom potezu.</p> <p>U \u010detvrtoj liniji standardnog izlaza ispisati broj \\(B\\) - koliko \u010dvorova Limeni treba da oboji plavom bojom u prvom potezu. U petoj liniji standardnog izlaza ispisati \\(B\\) prirodnih brojeva, koji predstavljaju skup \u010dvorova koje Limeni treba da oboji plavom bojom u prvom potezu.</p> <p>Ukoliko postoji vi\u0161e re\u0161enja, ispisati bilo koje.</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/drz/05_kiki/#ulaz","title":"Ulaz","text":"<pre><code>5\n2 2 2 2 2\n1 2\n2 3\n3 4\n4 5\n</code></pre>"},{"location":"takprog/2023_2024/drz/05_kiki/#izlaz","title":"Izlaz","text":"<pre><code>4\n2\n2 4\n0\n</code></pre>"},{"location":"takprog/2023_2024/drz/05_kiki/#objasnjenje-primera","title":"Obja\u0161njenje primera","text":"<p>Jedno od mogu\u0107ih re\u0161enja jeste da Limeni oboji \u010dvorove \\(2\\) i \\(4\\) crvenom bojom, \u0161to zahteva \\(4\\) koli\u010dine boje. Na ovaj na\u010din, u slede\u0107im potezima i Kiki i Limeni su primorani da boje \u010dvorove \\(1\\), \\(3\\) i \\(5\\) plavom bojom, kako ne bi postojala dva susedna \u010dvora iste boje. </p>"},{"location":"takprog/2023_2024/drz/05_kiki/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/drz/05_kiki/#ulaz_1","title":"Ulaz","text":"<pre><code>6\n1 2 3 4 5 6\n1 3\n3 5\n3 4\n5 2\n6 5\n</code></pre>"},{"location":"takprog/2023_2024/drz/05_kiki/#izlaz_1","title":"Izlaz","text":"<pre><code>8\n1\n3\n1\n5\n</code></pre>"},{"location":"takprog/2023_2024/drz/05_kiki/#objasnjenje-primera_1","title":"Obja\u0161njenje primera","text":"<p>U ovom primeru, optimalno je da Limeni oboji \u010dvorove \\(3\\) i \\(5\\) redom crvenom i plavom i time potro\u0161i \\(8\\) koli\u010dine boje. Do kraja igre \u010dvorovi \\(1\\) i \\(4\\) moraju biti obojeni plavom, a \u010dvorovi \\(2\\) i \\(6\\) crvenom bojom.</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(4 \\leq N  \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq a_i \\leq 10^9\\), za \\(i = 1, 2, \\ldots, N\\)</li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U test primerima vrednim 10 poena: \\(4 \\leq N \\leq 20\\);</li> <li>U test primerima vrednim 5 poena: \u010cvor \\(1\\) je povezan sa \u010dvorovima \\(2, 3, \\ldots, N\\);</li> <li>U test primerima vrednim 10 poena: \u010cvor \\(i\\) je povezan sa \u010dvorom \\(i+1\\), za \\(i=1,2,\\ldots,N-1\\);</li> <li>U test primerima vrednim 20 poena: \\(4 \\leq N \\leq 1000\\)</li> <li>U test primerima vrednim 20 poena: Sve te\u017eine su jednake me\u0111usobno, odnosno \\(a_1 = a_2 = \\ldots = a_N\\)</li> <li>U test primerima vrednim 35 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/drz/05_kiki/#pocetna-zapazanja","title":"Po\u010detna zapa\u017eanja","text":"<p>Pre svega, jasno je da moramo da koristimo \\(64\\)-bitni tip podataka, jer re\u0161enje mo\u017ee biti drasti\u010dno ve\u0107e od \\(2\\cdot10^9\\).</p> <p>Zatim, kakvo stanje Limenom definitivno ne donosi pobedu? Primetimo da ukoliko je neki \u010dvor obojen ili ima obojenog suseda, onda ne\u0107e biti problemati\u010dan - u smislu da je isforsirano koja boja \u0107e morati da se pojavi na tom \u010dvoru. I zapravo, vrlo lako mo\u017eemo da poka\u017eemo da ukoliko svi \u010dvorovi ispunjavaju svojstvo da su ili obojeni (bilo kojom bojom) ili je neki od njihovih suseda obojeni (ponovo bilo kojom bojom), onda je to definitivno pobedni\u010dka pozicija za Limenog. Naravno, lako se i pokazuje da ukoliko ovo ne va\u017ei, postoji na\u010din da Kiki pobedi (oboji jedan od \u010dvorova koji ne zadovoljavaju svojstvo obrnuto od o\u010dekivane boje).</p> <p>\u0160ta nam je o\u010dekivana boja? Jasno je da ukoliko imamo neko re\u0161enje gde neke \u010dvorove bojimo plavom, a neke druge crvenom bojom, tako\u0111e je i suprotno bojenje re\u0161enje. Ako se pretvaramo da bojimo samo jednom bojom, onda mo\u017eemo na kraju samo da vidimo kako da ih raspodelimo sa bojama, jedino je va\u017eno da ne postoje dva \u010dvora iste boje na neparnom rastojanju. Npr, ne odgovara ako imamo sekvencu \u010dvorova crveno-neobojeno-neobojeno-crveno, jer unutra\u0161nji \u010dvorovi moraju biti plavi a susedni su. Kada na kraju obojimo 'jednom bojom' stablo, mo\u017eemo samo da pustimo pretragu u \u0161irinu/dubinu od proizvoljnog \u010dvora i u odnosu na parnost dubine odlu\u010dujemo koja boja \u0107e biti dodeljena tom \u010dvoru ukoliko je predvi\u0111eno da bude obojen (npr parne dubine crvenom, neparne plavom). </p> <p>Usputno, skup \u010dvorova koji tra\u017eimo se naziva dominantan skup grafa/stabla. Me\u0111u svim takvim mi biramo minimalan.</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#n-leq-20","title":"\\(N \\leq 20\\)","text":"<p>U ovom podzadatku je dovoljno da isprobamo svih \\(2^N\\) mogu\u0107ih bojenja stabla i vidimo koje je zadovoljavaju\u0107e i ima najmanju zbirnu te\u017einu. Vremenska slo\u017eenost ovog re\u0161enja je \\(\\mathcal{O}(N\\cdot 2^N)\\).</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#cvor-1-je-povezan-sa-cvorovima-2-3-ldots-n","title":"\u010cvor \\(1\\) je povezan sa \u010dvorovima \\(2, 3, \\ldots, N\\)","text":"<p>Ovakav tip grafova se naziva zvezda. Jedna varijanta je da obojimo samo \u010dvor \\(1\\). Druga je da obojimo sve ostale \u010dvorove. U oba ta slu\u010daja dobijamo dominantan skup i potrebno je samo da izaberemo onaj \u010dija je suma te\u017eina manja. U oba slu\u010daja bojimo \u010dvorove jednom bojom po izboru. Vremenska slo\u017eenost ovog re\u0161enja je \\(\\mathcal{O}(N)\\).</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#cvor-i-je-povezan-sa-cvorom-i1-za-i12ldotsn-1","title":"\u010cvor \\(i\\) je povezan sa \u010dvorom \\(i+1\\), za \\(i=1,2,\\ldots,N-1\\)","text":"<p>Ovakav tip grafova se naziva put. Sada zadatak prakti\u010dno postaje: dat je niz i potrebno je da izaberemo elemente tako da je svaki element ili izabran ili neki njegov sused izabran, a tako da je suma tih elemenata minimalna. Ovo mo\u017eemo re\u0161iti na nekoliko na\u010dina, od kojih je najintuitivniji dinami\u010dko programiranje.</p> <p>Jedno od mogu\u0107ih stanja jeste \\(dp[i][0/1][0/1]\\) - odnosno kolika je minimalna suma elemenata tako da je do \\(i\\)-tog validno izabrano, dok nam druga i tre\u0107a koordinata ozna\u010davaju da li su prethodna dva elementa obojena. U slu\u010daju kada prethodna dva nisu obojena, primorani smo da obojimo trenutni, u svim ostalim slu\u010dajevima mo\u017eemo da biramo. Na kraju nas interesuje stanje poslednjeg elementa. Vremenska slo\u017eenost ovog re\u0161enja je \\(\\mathcal{O}(N)\\).</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#sve-tezine-su-jednake-meusobno","title":"Sve te\u017eine su jednake me\u0111usobno","text":"<p>U ovom podzadatku mogu\u0107e je koristiti greedy pristup. Primetimo da nam nikad nije optimalno da bojimo listove stabla, jer ukoliko njihove roditelje obojimo, ve\u0107i broj \u010dvorova relaksiramo i dodajemo u dominantni skup. Uz ovaj i sli\u010dne argumente mo\u017ee se pokazati (dokaz ostavljamo \u010ditaocu) da slede\u0107a strategija funkcioni\u0161e:</p> <ul> <li>Izaberimo \u010dvor \\(X\\) sa najve\u0107im brojem suseda koji su listovi i obojimo taj \u010dvor</li> <li>Bri\u0161emo iz stabla \u010dvor \\(X\\) i sve njegove susede stepena manjeg ili jednakog \\(2\\)</li> <li>Ponavljamo postupak rekurzivno dok ne budu obrisani svi \u010dvorovi</li> </ul> <p>Podsetnik da bojimo u odgovaraju\u0107u boju na osnovu po\u010detnih zaklju\u010daka. Vremenska slo\u017eenost ovog pristupa je \\(\\mathcal{O}(N)\\) ili \\(\\mathcal{O}(N\\log_2 N)\\), u zavisnosti od implementacije.</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Za ceo zadatak je potrebno primeniti ponovo dinami\u010dko programiranje. Za \u010dvor ka\u017eemo da ima isforsiranu boju (odnosno da je isforsiran \u010dvor) ukoliko je obojen on ili neki njegov sused. </p> <p>Za po\u010detak \u0107emo korenovati stablo u proizvoljnom \u010dvoru \\(r\\). Stanje \u0107e nam biti \\(dp[i][0/1]\\) - minimalna suma obojenih \u010dvorova u podstablu \u010dvora \\(i\\) tako da je to optimalno bojenje, a pritom \u010dvor \\(i\\) jeste forsiran (ukoliko je druga koordinata \\(1\\)), odnosno nije nu\u017eno forsiran (ukoliko je druga koordinata \\(0\\)). </p> <p>Preciznije koristimo tehniku bottom-up dinami\u010dkog programiranja. Kre\u0107emo od listova stabla i ra\u010dunamo na gore stanja. U red dodajemo \u010dvorove \u010dija su sva deca ve\u0107 obi\u0111ena. Za listove postavljamo \\(dp[l][0] = 0\\) i \\(dp[l][1] = 1\\). </p> <p>Kada ra\u010dunamo \\(dp[i][1]\\) imamo dva izbora. Prvi jeste da obojimo \u010dvor \\(i\\) i onda deca ne moraju da imaju od ranije isforsiranu boju. Drugi jeste da jedno od dece bude obojeno, zatim deca tog deteta ne moraju da imaju isforsiranu boju, a sva ostala deca \u010dvora \\(i\\) tako\u0111e moraju da imaju isforsiranu boju. Po svoj deci tra\u017eimo minimmum. Matemati\u010dki zapisano: \\(dp[i][1] = min(a[i] + \\sum_{x \\in deca[i]}dp[x][0], min_{x \\in deca[i]}(a[x] + \\sum_{y \\in deca[x]}dp[y][0] + \\sum_{z \\in deca[i], z \\neq x} dp[z][1]))\\).  </p> <p>Kada ra\u010dunamo \\(dp[i][0]\\) bitno nam je da sva deca \u010dvora \\(i\\) imaju isforsiranu boju, jer im \u010dvor \\(i\\) to ne\u0107e omogu\u0107iti. Tako da je prelaz \\(dp[i][0] = min(\\sum_{x \\in deca[i]}dp[x][1], dp[i][1])\\).</p> <p>Na kraju, re\u0161enje je \\(dp[r][1]\\). Vremenska slo\u017eenost ovog re\u0161enja je \\(\\mathcal{O}(N)\\) ili \\(\\mathcal{O}(N \\log(N))\\), u zavisnosti od implementacije.</p>"},{"location":"takprog/2023_2024/drz/05_kiki/#napomena","title":"Napomena","text":"<p>Podzadatak \\(N \\leq 1000\\) je izostavljen jer predstavlja samo sporiju implementaciju op\u0161teg re\u0161enja.</p> 05_kiki.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair&lt;int, int&gt; pi;\ntypedef pair&lt;ll, ll&gt; pl;\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;ll&gt; vl;\ntypedef vector&lt;double&gt; vd;\ntypedef vector&lt;bool&gt; vb;\ntypedef vector&lt;char&gt; vc;\ntypedef vector&lt;string&gt; vs;\ntypedef vector&lt;pi&gt; vp;\ntypedef vector&lt;pl&gt; vpl;\n\n\nconst int maxn = 2e5 + 10;\nvi e[maxn], a(maxn);\nvi p(maxn), sub(maxn);\nvector&lt;vi&gt; dp(maxn, vi(2, 0));\n\nvoid dfs(int x, int y = 0){\n\n    p[x] = y;\n\n    for (auto&amp; i : e[x]){\n        if (i == y) continue;\n\n        dfs(i, x);\n    }   \n}\n\nvi red, blue;\n\nvoid povrati(int x, int v, int par = 1){\n    if (v == 0 &amp;&amp; dp[x][0] &lt; dp[x][1]){\n        for (auto&amp; i : e[x]){\n            if (i == p[x]) continue;\n\n            povrati(i, 1, 1-par);\n        }\n\n        return;\n    }\n\n    int s = 0;\n    int suma = a[x];\n    for (auto&amp; i : e[x]){\n        if (i == p[x]) continue;\n        suma += dp[i][0];\n        s += dp[i][1];\n    }\n\n    if (suma == dp[x][1]){\n        if (par)\n            red.push_back(x);\n        else\n            blue.push_back(x);\n\n        for (auto&amp; i : e[x]){\n            if (i == p[x]) continue;\n\n            povrati(i, 0, 1-par);\n        }\n\n        return;\n    }   \n\n    int ind;\n    for (auto&amp; i : e[x]){\n        if (i == p[x]) continue;\n\n        suma = sub[i] + a[i] + s - dp[i][1];\n\n        if (suma == dp[x][1]){\n            ind = i;\n            break;\n        }\n    }\n\n    for (auto&amp; i : e[x]){\n        if (i == p[x] || i == ind) continue;\n\n        povrati(i, 1, 1-par);\n    }\n\n    if (par)\n        blue.push_back(ind);\n    else\n        red.push_back(ind);\n\n    for (auto&amp; i : e[ind]){\n        if (i == x) continue;\n\n        povrati(i, 0, par);\n    }\n}\n\nsigned main()\n{\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i){\n        cin &gt;&gt; a[i];\n\n        e[i].clear();\n    }\n\n    for (int i = 1; i &lt; n; ++i){\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(1);\n\n    vi d(n+1, 0);\n    queue&lt;int&gt; q;\n\n    for (int i = 2; i &lt;= n; ++i){\n        if ((int)e[i].size() == 1){\n            q.push(i);\n            dp[i][0] = 0;\n            dp[i][1] = a[i];\n        }\n    }\n\n    while(!q.empty()){\n        int c = q.front();\n        q.pop();\n\n        ++d[p[c]];\n\n        if ((int)e[c].size() == 1 &amp;&amp; c != 1){\n\n            if (d[p[c]] == (int)e[p[c]].size() &amp;&amp; p[c] == 1){\n                q.push(1);\n            }\n\n            if (d[p[c]] + 1 == (int)e[p[c]].size() &amp;&amp; p[c] != 1){\n                q.push(p[c]);\n            }\n\n            continue;\n        }\n\n        dp[c][1] = a[c];\n        int s = 0;\n        for (auto&amp; i : e[c]){\n            if (i == p[c]) continue;\n            dp[c][1] += dp[i][0];\n            s += dp[i][1];\n        }\n\n        for (auto&amp; i : e[c]){\n            if (i == p[c]) continue;\n\n            dp[c][1] = min(dp[c][1], sub[i] + a[i] + s - dp[i][1]);\n\n        }\n\n        dp[c][0] = s;\n\n        dp[c][0] = min(dp[c][0], dp[c][1]);\n\n        for (auto&amp; i : e[c])\n            if (i != p[c])\n                sub[c] += dp[i][0];\n\n\n        if (d[p[c]] == (int)e[p[c]].size() &amp;&amp; p[c] == 1){\n            q.push(1);\n        }\n\n        if (d[p[c]] + 1 == (int)e[p[c]].size() &amp;&amp; p[c] != 1){\n            q.push(p[c]);\n        }           \n    }\n\n    povrati(1, 1);\n\n\n    cout &lt;&lt; dp[1][1] &lt;&lt; '\\n';\n\n    cout &lt;&lt; red.size() &lt;&lt; '\\n';\n    for (int x : red)\n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n\n    cout &lt;&lt; blue.size() &lt;&lt; '\\n';\n    for (int x : blue)\n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/","title":"A3 - Palindromska \u0161etnja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 256MB <p>Bob voli \u0161etnje. Ali ne bilo kakve! Bob isklju\u010divo voli palindromske \u0161etnje.</p> <p>Graf u kojem Bob \u017eivi ima \\(N\\) \u010dvorova. Na po\u010detku nikoja dva \u010dvora nisu povezana. Potrebno je izvr\u0161iti \\(Q\\) upita dva tipa:</p> <ul> <li>\\(1\\) \\(u\\) \\(v\\) \\(c\\) - Izme\u0111u \u010dvorova \\(u\\) i \\(v\\) dodaje se grana sa karakterom \\(c\\) napisanim na njoj.</li> <li>\\(2\\) \\(u\\) \\(v\\) - Potrebno je odogovoriti da li postoji \u0161etnja izme\u0111u \u010dvorova \\(u\\) i \\(v\\) tako da karakteri sa grana koje pripadaju \u0161etnji formiraju palindrom. Palindrom je niz karaktera koji se \u010dita isto sa obe strane, npr. \"oko\", \"kajak\", \"ratar\" itd. \u0160etnja izme\u0111u \\(u\\) i \\(v\\) je naizmeni\u010dni niz \u010dvorova i grana, koji po\u010dinje sa \u010dvorom \\(u\\), a zavr\u0161ava se sa \u010dvorom \\(v\\). U toj \u0161etnji se ista grana mo\u017ee ponoviti vi\u0161e puta. Ukoliko takva \u0161etnja postoji, ispisati <code>1</code>, a u suportnom ispisati <code>0</code>.</li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 nPavle Martinovi\u0107"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza nalaze se celi brojevi \\(N\\) i \\(Q\\), koji redom predstavljaju broj \u010dvorova i broj upita. U narednih \\(Q\\) linija, nalaze se upiti u formatu opisanom u tekstu.</p>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki upit drugog tipa ispisati <code>1</code> ukoliko \u0161etnja postoji i <code>0</code> ukoliko \u0161etnja ne postoji.</p>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N \\leq 1.000\\)</li> <li>\\(1 \\leq Q \\leq 300.000\\)</li> <li>\\(1 \\leq u \\neq v \\leq N\\)</li> <li>\\(c \\in \\{a,b,c,...,x,y,z\\}\\)</li> <li>Garantuje se da \u0107e svaka dva \u010dvora direktno biti povezana najvi\u0161e jednom granom.</li> </ul>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#podzadaci","title":"Podzadaci","text":"<ul> <li>(9 poena): U svakom upitu \\(c\\) = <code>a</code></li> <li>(10 poena): U svakom upitu prvog tipa \\(v = u + 1\\)</li> <li>(32 poena): \\(N \\leq 100\\)</li> <li>(49 poena): Bez dodatnih ograni\u010denja</li> </ul>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#primer","title":"Primer","text":""},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#ulaz","title":"Ulaz","text":"<pre><code>5 6\n1 1 2 a\n1 2 3 b\n2 1 3\n2 2 3\n1 3 4 a\n2 1 4\n</code></pre>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n1\n</code></pre>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#objasnjenje","title":"Obja\u0161njenje","text":"<ul> <li>U prvom upitu tipa \\(2\\) ne postoji \u0161etnja izme\u0111u \u010dvora \\(1\\) i \u010dvora \\(3\\) takva da karakteri sa \u0161etnje formiraju palindrom. </li> <li>U drugom upitu tipa \\(2\\) postoji \u0161etnja izme\u0111u \u010dvora \\(2\\) i \u010dvora \\(3\\) takva da karakteri sa \u0161etnje formiraju palindrom. Ta \u0161etnja je: \\(2 - 3\\), a formirani palindrom je <code>b</code>.</li> <li>U tre\u0107em upitu tipa \\(2\\) postoji \u0161etnja izme\u0111u \u010dvora \\(3\\) i \u010dvora \\(4\\) takva da karakteri sa \u0161etnje formiraju palindrom. Ta \u0161etnja je \\(1 - 2 - 3 - 4\\), a formirani palindrom je <code>aba</code>.</li> </ul>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#resenje-kada-je-u-svakom-upitu-c-a","title":"Re\u0161enje kada je u svakom upitu \\(c\\) = <code>a</code>","text":"<p>U ovom podzadatku je svaka \u0161etnja palindrom. Dovoljno je proveriti da li su dva \u010dvora u istoj komponenti povezanosti.  Ovo mo\u017eemo da postignemo tako \u0161to koristimo \u010duvamo kojoj komponenti pripada koji \u010dvor. Svaki upit u kojem se granom povezuju dva \u010dvora iz iste komponente ignori\u0161emo. Kada se spajaju dva \u010dvora iz razli\u010ditih komponenti, dodajemo novu granu izme\u0111u njih i pu\u0161tamo <code>bfs</code> u kojem sve \u010dvorove do kojih je mogu\u0107e sti\u0107i do jednog iz ta dva stavljamo u istu komponentu. Ovo re\u0161enje radi u slo\u017eenosti \\(O(N^2 + Q)\\). Za bolju slo\u017eenost je potrebno koristiti adekvatnu strukturu, npr. <code>dsu (disjoint set union)</code>.</p>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#resenje-kada-n-leq-100","title":"Re\u0161enje kada \\(N \\leq 100\\)","text":"<p>Da bi re\u0161ili ovaj podzadatak, moramo da primetimo par stvari. Posmatrajmo slede\u0107u relaciju nad neure\u0111enim parovima \u010dvorova:</p> <ul> <li>\\((a,b)\\) je u relaciji sa \\((x,y)\\) \\(\\leftrightarrow\\) mogu\u0107e je sti\u0107i palindromskom \u0161etnjom od \\(a\\) do \\(b\\) akko je mogu\u0107e sti\u0107i palindromskom \u0161etnjom od \\(x\\) do \\(y\\) .</li> </ul> <p>Primetimo da je ovo relacija ekvivalencije. \u0160tavi\u0161e, primetimo da je u svakoj klasi ekivalencije u kojoj su palindromske \u0161etnje bar jedan neure\u0111en par oblika \\((a,a)\\) ili oblika \\((a,b)\\), gde postoji grana izme\u0111u \\(a\\) i \\(b\\). Dodavanjem grane izme\u0111u \u010dvorova \\(u\\) i \\(v\\) sa karakterom \\(c\\) stapa neke klase ekvivalencije u jednu. Posmatrajmo sve grane \\((x,y)\\) na kojima je napisan karakter \\(c\\). Tada se stapaju ta\u010dno slede\u0107e klase ekvivalencije:</p> <ul> <li> <p>\\((x,u)\\) i \\((y,v)\\) u jednu klasu ekvivalencije (jer ako je postoji palindromska \u0161etnja izme\u0111u \\(x\\) i \\(u\\), tada postoji i palindromska \u0161etnja izme\u0111u \\(y\\) i \\(v\\), npr produ\u017eavanjem prethodne granama \\((x,y)\\) i \\((u,v)\\)).</p> </li> <li> <p>\\((x,v)\\) i \\((y,u)\\) u jednu klasu ekvivalencije.</p> </li> </ul> <p>Prema tome za svaku dodatu granu, mo\u017eemo iterirati po svim prethodnim dodatim granama istog tipa i spajati odgovaraju\u0107e klase ekvivalencije. Ovo re\u0161enje radi u vremenskoj slo\u017eenosti \\(O(N^4 + N^2 \\log N + Q \\log N)\\).</p>"},{"location":"takprog/2023_2024/drz/06_palindromska_setnja/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Za ovaj podzadatak, neophodno je optimizovati prethodno re\u0161enje. Mo\u017eemo primetiti da nije neophodno iterirati kroz sve prethodne grane, ve\u0107 mo\u017eemo da presko\u010dimo grane koje bi formirale ciklus koji ne menja bipartitnost komponente povezanosti na istom karakteru. Formalno, pretpostavimo da dodajemo granu izme\u0111u \\(u\\) i \\(v\\) sa karakterom \\(c\\). Tada, razlikujemo slede\u0107e slu\u010dajeve:</p> <ul> <li>\\(u\\) i \\(v\\) do sada nisu bili povezani u podgrafu koji je formiran granama sa karakterom \\(c\\). Tada procesiramo ovu granu.</li> <li>\\(u\\) i \\(v\\) jesu u istoj komponenti povezanosti i ta komponenta je bipartitna, ali dodavanjem nove grane, ta komponenta prestaje biti bipartitna. Tada procesiramo ovu granu.</li> <li>U suprotnom ignori\u0161emo dodavanje grane. Pa\u017eljivijom analizom klasa koje se stapaju u jednu iz re\u0161enja prethodnog podzadatka se mo\u017ee videti da grana u ovom slu\u010daju ne bi stopila nikoje dve klase ekvivalencije, niti bi uticala na neke naredne upite.</li> </ul> <p>Prema tome, za svaki karakter, grana koje treba da procesiramo ima \\(O(N)\\) (za\u0161to?). Ovo re\u0161enje radi u slo\u017eenosti \\(O(N^2 \\cdot |\\Sigma| \\cdot \\log N)\\).</p> 06_palindromska_setnja.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 1005\n#define maxt 700000\n#define maxc 27\nusing namespace std;\nint n,q;\nint mp[maxn][maxn];\nint par[maxt];\nbool pc[maxt];\nint h[maxt];\ninline int get_par(int x) {\n    if(par[x]==x) return x;\n    par[x]=get_par(par[x]);\n    return par[x];\n}\ninline void merge(int x,int y) {\n    x=get_par(x);\n    y=get_par(y);\n    if(x==y) return;\n    if(h[x]&lt;h[y]) {\n        par[x]=y;\n        pc[y]|=pc[x];\n    }\n    else {\n        if(h[y]&lt;h[x]) {\n            par[y]=x;\n            pc[x]|=pc[y];\n        }\n        else {\n            par[y]=x;\n            pc[x]|=pc[y];\n            h[x]++;\n        }\n    }\n}\nint cnt=0;\nbool col[maxc][maxn];\nint incomp[maxc][maxn];\nvector&lt;int&gt; comps[maxc][maxn];\nbool nbp[maxc][maxn];\nvector&lt;pair&lt;int,int&gt; &gt; relevant[maxc];\ninline bool path(int u,int v) {\n    return pc[get_par(mp[u][v])];\n}\nint tot[maxc];\ninline void add_edge(int u,int v,int c) {\n    pc[get_par(mp[u][v])]=true;\n    bool ok=false;\n    int cu=incomp[c][u];\n    int cv=incomp[c][v];\n    if(cu!=cv) {\n        ok=true;\n        int x;\n        if(col[c][u]!=col[c][v]) x=0;\n        else x=1;\n        if(comps[c][cv].size()&lt;comps[c][cu].size()) swap(cu,cv);\n        for(auto w:comps[c][cu]) {\n            incomp[c][w]=cv;\n            comps[c][cv].push_back(w);\n            tot[c]++;\n            col[c][w]^=x;\n        }\n        nbp[c][cv]|=nbp[c][cu];\n    }\n    else {\n        if(col[c][u]==col[c][v]) {\n            if(!nbp[c][cu]) ok=true;\n            nbp[c][cu]=true;\n        }\n    }\n    if(ok) {\n        for(auto pr:relevant[c]) {\n            int x=pr.first;\n            int y=pr.second;\n            merge(mp[x][u],mp[y][v]);\n            merge(mp[x][v],mp[y][u]);\n        }\n        relevant[c].push_back({u,v});\n    }\n}\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin&gt;&gt;n&gt;&gt;q;\n    for(int u=1;u&lt;=n;u++) {\n        for(int v=u;v&lt;=n;v++) {\n            par[cnt]=cnt;\n            if(u==v) pc[cnt]=true;\n            mp[u][v]=cnt++;\n            mp[v][u]=mp[u][v];\n        }\n        for(int j=0;j&lt;26;j++) {\n            incomp[j][u]=u;\n            comps[j][u].push_back(u);\n        }\n    }\n    for(int i=0;i&lt;q;i++) {\n        int t;\n        cin&gt;&gt;t;\n        if(t==1) {\n            int u,v;\n            char c;\n            cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;\n            add_edge(u,v,c-'a');\n        }\n        else {\n            int u,v;\n            cin&gt;&gt;u&gt;&gt;v;\n            if(path(u,v)) cout&lt;&lt;1&lt;&lt;endl;\n            else cout&lt;&lt;0&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/","title":"1 - Tri tajna broja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Komisija je kri\u0161om odabrala tri tajna nenegativna cela broja \\(X\\), \\(Y\\) i \\(Z\\), tako da \\(0 \\leq X \\leq Y \\leq Z\\). </p> <p>Da bi spre\u010dila takmi\u010dare da se dokopaju ovih tajnih brojeva, Komisija \u0107e uz njih takmi\u010darima saop\u0161titi i vrednosti \\(X+Y\\), \\(X+Z\\), \\(Y+Z\\) i \\(X+Y+Z\\). Dakle, Komisija \u0107e takmi\u010darima dati sedam vrednosti \\(X\\), \\(Y\\), \\(Z\\), \\(X+Y\\), \\(X+Z\\), \\(Y+Z\\) i \\(X+Y+Z\\) u nekom redosledu. </p> <p>Prona\u0111ite \\(X\\), \\(Y\\) i \\(Z\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107 Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom i jedinom redu standardnog ulaza, nalazi se sedam celih brojeva \\(X\\), \\(Y\\), \\(Z\\), \\(X+Y\\), \\(X+Z\\), \\(Y+Z\\) i \\(X+Y+Z\\) u nekom proizvoljnom redosledu (tj. prvi broj iz standardnog ulaza ne mora da bude jedank \\(X\\)).</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza, ispisati \\(X\\), \\(Y\\) i \\(Z\\). Primetite da va\u017ei \\(0 \\leq X \\leq Y \\leq Z\\).</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#ulaz","title":"Ulaz","text":"<pre><code>12 8 5 17 9 3 14\n</code></pre>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#izlaz","title":"Izlaz","text":"<pre><code>3 5 9\n</code></pre>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Na ulazu su redom dati brojevi \\(X + Z = 12\\), \\(X + Y = 8\\), \\(Y = 5\\), \\(X + Y + Z = 17\\), \\(Z = 9\\), \\(X = 3\\), \\(Y + Z = 14\\)</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(0 \\leq X \\leq Y \\leq Z \\leq 10^8\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 25 poena: \\(0 = X = Y &lt; Z\\).</li> <li>U testovima vrednim 25 poena: \\(0 \\leq X \\leq Y \\leq Z &lt; 100\\).</li> <li>U testovima vrednim 25 poena: Brojevi iz ulaza su dati u neopadaju\u0107em redosledu.</li> <li>U testovima vrednim 25 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#napomena","title":"Napomena","text":"<p>Garantuje se da zadatak ima re\u0161enje i da je to re\u0161enje jedinstveno.</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#resenje-kada-0-x-y-z","title":"Re\u0161enje kada \\(0 = X = Y &lt; Z\\)","text":"<p>Sedam datih brojeva su \\(X\\), \\(Y\\), \\(Z\\), \\(X+Y\\), \\(X+Z\\), \\(Y+Z\\) i\\(X+Y+Z\\). Kako je \\(X = 0\\) i \\(Y=0\\), to su ovih sedam vrednosti zapravo  \\(0\\), \\(0\\), \\(Z\\), \\(0\\), \\(Z\\), \\(Z\\) i \\(Z\\). Za re\u0161avanje ovog podzadatka, dovoljno je prona\u0107i neku vrednost koja nije nula (ta vrednost mora biti jednaka \\(Z\\)) i ispisati dve \\(0\\) (tj. \\(X\\) i \\(Y\\)) i tu vrednost (tj. \\(Z\\)).</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#resenje-kada-0-leq-x-leq-y-leq-z-100","title":"Re\u0161enje kada \\(0 \\leq X \\leq Y \\leq Z &lt; 100\\)","text":"<p>U ovom slu\u010daju mo\u017eemo iterirati po svim mogu\u0107im vrednostima za \\(X\\), \\(Y\\) i \\(Z\\). Ukupno postoji do \\(10^6\\) mogu\u0107nosti za \\(X\\), \\(Y\\) i \\(Z\\). Potom je dovoljno da proverimo da li skup vrednosti \\(X\\), \\(Y\\), \\(Z\\), \\(X+Y\\), \\(X+Z\\), \\(Y+Z\\) i\\(X+Y+Z\\) za izabrano \\(X\\), \\(Y\\) i \\(Z\\) odgovara vrednostima sa ulaza. Ovo mo\u017eemo posti\u0107i na primer sortiranjem oba skupa i pore\u0111enjem svake vrednosti.</p>"},{"location":"takprog/2023_2024/kv1/01_tri_tajna_broja/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za glavno re\u0161enje, dovoljno je da primetimo da je najmanja vrednost sa ulaza upravo jednaka \\(X\\). Zaista, va\u017ei da je \\(X \\leq Y, Z, X+Y, X+Z, Y+Z, X+Y+Z\\). Sli\u010dno tome, druga najmanja vrednost je jednaka \\(Y\\), jer \\(Y \\leq Z, X+Y, X+Z, Y+Z, X+Y+Z\\). Kona\u010dno, najve\u0107a vrednost sa ulaza mora biti jednaka jednaka \\(X+Y+Z\\), jer \\(X+Y+Z \\geq X,Y,Z, X+Y, X+Z, Y+Z, X+Y+Z\\). Dakle dovoljno je prona\u0107i dve najmanje vrednosti (one redom odgovaraju \\(X\\) i \\(Y\\)), i oduzeti ih od najve\u0107e vrednosti (\u0161to odgovara \\((X+Y+Z) - X - Y = Z\\)).</p> <p>U pretposlednjem podzadatku, niz je dat sortiran i dve najmanje vrednosti odgovaraju prva dva elementa niza, dok najve\u0107a vrednost odgovara poslednjem elementu niza. Za poslednji zadatak, mo\u017eemo da sortiramo niz ili da prolaskom kroz njega odredimo ove vrednosti.</p> 01_tri_tajna_broja.cpp<pre><code>#include&lt;bits/stdc++.h&gt;\n#define ll long long\n#define inf 1e18\nusing namespace std;\nint nums[7];\nint main() {\n    for(int i=0;i&lt;7;i++) {\n        scanf(\"%d\",&amp;nums[i]);\n    }\n    sort(nums,nums+7);\n    cout&lt;&lt;nums[0]&lt;&lt;\" \"&lt;&lt;nums[1]&lt;&lt;\" \"&lt;&lt;nums[6]-nums[0]-nums[1]&lt;&lt;endl;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/","title":"2 - Moramo da recikliramo","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 64MB <p>Moramo da recikliramo!</p> <p>Poznato je da su \u010dlanovi komisije ekolo\u0161ki osve\u0161\u0107eni. Stoga, svaki od \\(N\\) \u010dlanova komisije ima svoj kontejner za recikla\u017eu papira, koji je krajnje odredi\u0161te za sve takmi\u010darske \u017ealbe. Ti kontejneri su pore\u0111ani u niz. \\(i\\)-ti od njih ima kapacitet \\(C_i\\), a u njemu se ve\u0107 nalazi \\(A_i\\) \u017ealbi. </p> <p>Rok za \u017ealbe traje \\(Q\\) dana. \\(j\\)-tog od tih \\(Q\\) dana pristigne \\(x_j\\) \u017ealbi, (i te \u017ealbe odbija) na te \u017ealbe odgovara \u010dlan \\(k_j\\). Kada \\(k_j\\) (odbije sve \u017ealbe) odgovori na sve \u017ealbe, on ih odnosi do svog kontejnera i ubacuje u njega (tj. pove\u0107ava \\(A_{k_j}\\) za \\(x_j\\)). Me\u0111utim, ukoliko se dodavanjem \\(x_j\\) \u017ealbi kontejner \\(k_j\\) napuni, vi\u0161ak \u017ealbi se prebacuje u naredni kontejner (doga\u0111aj komisiji poznat kao prelivanje) i tako sve do kraja niza. Formalno, ukoliko je \\(A_{k_j} + x_j &gt; C_{k_j}\\), \\(A_{k_j}\\) postaje \\(C_{k_j}\\) a \\(A_{k_j} + x_j - C_{k_j}\\) \u017ealbi koje su vi\u0161ak se dodaje u kontajner \\(k_j + 1\\). Ukoliko se i poslednji kontejner napuni, \u017ealbe koje su vi\u0161ak jednostavno padnu na trotoar pored njega (ekolo\u0161ka osve\u0161\u0107enost komisije ima svoje granice).</p> <p>Nakon kraja roka za \u017ealbe, komisija dodeljuje nagrade svojim \u010dlanovima na osnovu toga koliko je pun njihov kontejner. Kako je komisija prezauzeta (odbijanjem \u017ealbi) odgovaranjem na \u017ealbe, pomozite joj i ispi\u0161ite koliko \u017ealbi ima u svakom kontejneru nakon svih \\(Q\\) promena.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksa Milisavljevi\u0107 Igor Pavlovi\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je ceo broj \\(N\\). U drugom redu, dato je \\(N\\) celih brojeva, \\(i\\)-ti od njih predstalja \\(A_i\\). U tre\u0107em redu, dato je \\(N\\) celih brojeva, a \\(i\\)-ti od njih predstavlja \\(C_i\\). </p> <p>U narednom redu, dat je jedan ceo broj \\(Q\\). U \\(j\\)-tom od narednih \\(Q\\) redova, data su po dva cela broja \\(k_j\\) i \\(x_j\\), koji ozna\u010davaju promenu \\(A_{k_j} = A_{k_j} + x_j\\).</p>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#opis-izlaza","title":"Opis izlaza","text":"<p>U jedinom redu standardnog izlaza ispisati vrednosti niza nakon svih operacija.</p>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#ulaz","title":"Ulaz","text":"<pre><code>4\n1 3 2 3\n5 4 5 4\n2\n3 2\n2 4\n</code></pre>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#izlaz","title":"Izlaz","text":"<pre><code>1 4 5 4\n</code></pre>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Komisija ima \\(4\\) \u010dlana. </p> <p>Kontejner prvog \u010dlana ima \\(1\\) \u017ealbu i kapacitet \\(5\\). Kontejner drugog \u010dlana ima \\(3\\) \u017ealbe i kapacitet \\(4\\). Kontejner tre\u0107eg \u010dlana ima \\(2\\) \u017ealbe i kapacitet \\(5\\). Kontejner \u010detvrtog \u010dlana ima \\(3\\) \u017ealbe i kapacitet \\(4\\).</p> <p>Rok za \u017ealbe traje \\(2\\) dana.</p> <p>Prvog dana sti\u017eu \\(2\\) \u017ealbe i za njih je zadu\u017een tre\u0107i \u010dlan komisije. Kako njegov kontejner ima \\(2\\) \u017ealbe, a kapacitet \\(5\\), nakon obe \u017ealbe staju u kontejner i nakon ovog dana u njemu se nalazi \\(4\\) \u017ealbe.</p> <p>Drugog dana sti\u017eu \\(4\\) \u017ealbe i za njih je zadu\u017een drugi \u010dlan komisije. Kako njegov kontejner ima \\(3\\) \u017ealbe a kapacitet \\(4\\), u njega stane jedna \u017ealba a preostale \\(3\\) se prebacuju u tre\u0107i kontejner. Me\u0111utim, nakon prvog dana, ovaj kontejner ima \\(4\\) \u017ealbe, a kapacitet \\(5\\), pa i u njega staje samo jedna \u017ealba. Preostale \\(2\\) se prebacuju u \u010detvrti kontejner. U njemu se nalaze \\(3\\) \u017ealbe i ima kapacitet \\(4\\), pa i u njega staje samo jedna \u017ealba. Kako je ovo poslednji kontejner u nizu, poslednja \u017ealba ne\u0107e biti uba\u010dena ni u jedan kontejner.</p>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq N, Q \\leq 200.000\\)</li> <li>\\(0 \\leq A_i \\leq C_i \\leq 10^9\\) za \\(1 \\leq i \\leq N\\)</li> <li>U svih \\(Q\\) upita va\u017ei \\(1 \\leq k_j \\leq N\\) i \\(0 \\leq x_j \\leq 10^9\\) (takmi\u010dari su nemilosrdni u svom slanju \u017ealbi).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 30 poena: \\(Q = 1\\).</li> <li>U testovima vrednim 30 poena: \\(N, Q \\leq 5.000\\).</li> <li>U testovima vrednim 15 poena: Za sve \\(1 \\leq i \\leq N\\) va\u017ei \\(C_i \\leq 10\\).</li> <li>U testovima vrednim 25 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#prva-dva-podzadatka","title":"Prva dva podzadatka","text":"<p>Izvr\u0161avamo direktnu simulaciju svih upita. Neka su \\(k\\) i \\(x\\) trenutni parametri upita. Ukoliko je \\(A_k + x \\leq C_k\\), tada jednostavno dodajemo \\(x\\) na \\(A_k\\) i zavr\u0161avamo upit. U suprotnom, \\(x\\) smanjujemo za \\(C_k-A_k\\), a na vrednost \\(A_k\\) upisujemo \\(C_k\\). Potom pove\u0107avamo \\(k\\) za \\(1\\) i nastavljamo izvr\u0161avanje upita sa novim vrednostima. Ukoliko iza\u0111emo iz niza, svakako prekidamo izvr\u0161avanje upita.</p> <p>Vremenska slo\u017eenost je \\(O(QN)\\), jer se mo\u017ee desiti da prilikom izvr\u0161avanja upita pro\u0111emo kroz celu du\u017einu niza.</p>"},{"location":"takprog/2023_2024/kv1/02_moramo_da_recikliramo/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primetimo da redosled izvr\u0161avanja upita nije bitan. To zna\u010di da mo\u017eemo prvo u\u010ditati sve upite, a potom ih odjednom sve izvr\u0161iti. Ta\u010dnije, za svaki upit sa parametrima \\(k\\) i \\(x\\) najpre dodamo \\(x\\) na \\(A_k\\) bez vo\u0111enja ra\u010duna o \\(C_k\\). </p> <p>Kada to uradimo za svaki upit, dovoljno je pro\u0107i jednom po celom nizu sleva nadesno i a\u017eurirati vrednosti \\(A_k\\). Za trenutni indeks \\(k\\), ako je \\(A_k&gt; C_k\\),Wdodajemo \\(A_k-C_k\\) na \\(A_{k+1}\\), a zatim na vrednost \\(A_k\\) upisujemo \\(C_k\\). U suprotnom, ne radimo ni\u0161ta. Napomenimo da ako je $k= $ (krajwniza), nije potrebno a\u017eurirati[\\(A_{+1}\\).</p> <p>Slo\u017eenost prolaska po svim upitima je \\(O(Q)\\), dok je slo\u017eenost jednog prolaska po celom nizu \\(O(hN)\\) Ukupna slo\u017eenost je \\(O(N+Qi.\\)</p> 02_moramo_da_recikliramo.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 2000050\nusing namespace std;\nint n;\nint q;\nlong long a[maxn];\nlong long c[maxn];\nint main() {\n    scanf(\"%d\",&amp;n);\n    for(int i=1;i&lt;=n;i++) {\n        scanf(\"%lld\",&amp;a[i]);\n    }\n    for(int i=1;i&lt;=n;i++) {\n        scanf(\"%lld\",&amp;c[i]);\n    }\n    scanf(\"%d\",&amp;q);\n    while(q--) {\n        int i;\n        long long x;\n        scanf(\"%d %lld\",&amp;i,&amp;x);\n        a[i]+=x;\n    }\n    for(int i=1;i&lt;=n;i++) {\n        if(a[i]&gt;c[i]) {\n            a[i+1]+=(a[i]-c[i]);\n            a[i]=c[i];\n        }\n        printf(\"%lld \",a[i]);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv1/03_presedanja/","title":"3 - Presedanja","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>U gradu \\(17\\) postoji sistem gradskog prevoza. Na po\u010detku je postojalo \\(N\\) stanica, numerisanih od \\(1\\) do \\(N\\), i \\(M\\) parova stanica izme\u0111u kojih postoji direktna i dvosmerna autobuska linija. Me\u0111utim, zbog u\u010destalog stajanja, tro\u0161kovi goriva su eksplodirali.</p> <p>Volis Brin, ugledni gradona\u010delnik grada \\(17\\), smislio je novi plan. Uveo je nove parove stanica izme\u0111u kojih prolaze autobusi. Ta\u010dnije, sada izme\u0111u dve stanice postoji dvosmerna autobuska linija ako i samo ako je u starom planu postojala me\u0111ustanica izme\u0111u njih. Formalnije, stanice \\(A\\) i \\(B\\) su povezane linijama ako i samo ako postoji stanica \\(C\\) takva da su u starom planu \\(A\\) i \\(C\\), kao i \\(B\\) i \\(C\\), bile povezane.</p> <p>Aliks, junakinja na\u0161eg zadatka, trenutno se nalazi kod stanice \\(S\\). Potrebno joj je da \u0161to pre stigne do tajne laboratorije koja se nalazi kod stanice \\(T\\). Ta\u010dnije, Aliks mo\u017ee da putuje autobusima opisanim parovima u novom planu (jer je on aktuelan). Ona \u017eeli da iskoristi najmanji broj presedanja. Napomenimo da u gradu \\(17\\) autobusi idu toliko \u010desto da su presedanja izme\u0111u konkretnih linija zanemarljiva.</p> <p>Na\u017ealost, Aliks je ostala bez signala i nema uvid u novi plan gradskog prevoza. Na svu sre\u0107u, se\u0107a se starog plana do detalja. Zato je upitala Vas, kao programera, za pomo\u0107. Potrebno je da joj ka\u017eete najmanji broj autobusa koje mora iskoristiti da bi stigla do svog cilja.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2023_2024/kv1/03_presedanja/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, nalaze se \u010detiri cela broja \\(N\\), \\(M\\), \\(S\\) i \\(T\\). Oni ozna\u010davaju broj stanica, broj parova u starom planu, po\u010detnu stanicu na kojoj se nalazi Aliks i njenu destinaciju.</p> <p>U \\(i\\)-tom od narednih \\(M\\) redova, nalaze se po dva cela broja \\(U_i\\) i \\(V_i\\). Oni ozna\u010davaju da su u starom planu stanice \\(U_i\\) i \\(V_i\\) bile povezane autobuskom linijom.</p>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza, ispisati ceo broj koji predstavlja minimalan broj autobusa koje mora iskoristiti da bi Aliks stigla do svog cilja. Poznato je da \u0107e ulaz biti takav da ona to uvek mo\u017ee u\u010diniti u kona\u010dnom broju presedanja i koriste\u0107i samo autobuse.</p>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv1/03_presedanja/#ulaz","title":"Ulaz","text":"<pre><code>8 9 5 8\n1 2\n1 3\n1 4\n3 5\n3 6\n4 6\n2 5\n6 7\n7 8\n</code></pre>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv1/03_presedanja/#ulaz_1","title":"Ulaz","text":"<pre><code>5 5 1 4\n1 2\n2 3\n3 4\n4 5\n5 1\n</code></pre>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N,M \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq U_i, V_i, S,T \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 10 poena: \\(N=M-1\\) i \\(U_i = i, V_i = i+1\\).</li> <li>U testovima vrednim 25 poena: \\(N=M-1\\) i garantuje se da je u starom planu bilo mogu\u0107e sti\u0107i od svake stanice do svake druge stanice.</li> <li>U testovima vrednim 25 poena: Garantuje se da je u starom planu Aliks mogla od svoje po\u010detne stanice sti\u0107i do vi\u0161e drugih stanica kre\u0107u\u0107i se autobusima nego \u0161to mo\u017ee sada (naravno, ostaje uslov da Aliks mo\u017ee sti\u0107i do svog cilja).</li> <li>U testovima vrednim 20 poena: \\(N,M \\leq 500\\).</li> <li>U testovima vrednim 20 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>Sve stanice mo\u017eemo smestiti na brojevnu pravu. Kori\u0161\u0107enjem jedne autobuske linije u novom planu gradskog prevoza mo\u017eemo se kretati za \\(2\\) stanice ulevo ili za \\(2\\) stanice udesno. Samim tim, re\u0161enje zadatka je \\(\\frac{|S-T|}{2}\\).</p>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#drugi-podzadatak","title":"Drugi podzadatak","text":"<p>Originalan plan gradskog prevoza mo\u017eemo da modelujemo kao stablo. Stablo je povezan graf takav da izme\u0111u svaka dva \u010dvora postoji jedinstven nesamopresecaju\u0107i put. Stanice su u stvari \u010dvorovi, dok su autobuske linije grane. U novom planu, izme\u0111u dva \u010dvora postoji grana ako i samo ako je njihova udaljenost \\(2\\). Primetimo da graf novog plana ne mora biti stablo. </p> <p>Potrebno je odrediti du\u017einu puta u originalnom planu izme\u0111u \u010dvorova \\(S\\) i \\(T\\), a zatim je podeliti sa \\(2\\). Nju odre\u0111ujemo primenom algoritma za pretragu grafa poput DFS, odnosno pretragom u dubinu. Ako je ta du\u017eina \\(D\\), odgovor na zadatak je \\(\\frac{D}{2}\\).</p> <p>Ukupna slo\u017eenost je \\(O(N)\\).</p>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#treci-podzadatak","title":"Tre\u0107i podzadatak","text":"<p>Nastavljamo sa jezikom teorije grafova. Ranije smo primetili da u novom grafu izme\u0111u dva \u010dvora postoji grana ako i samo ako je u starom grafu njihova udaljenost bila \\(2\\). Da bi svaki \u010dvor koji je u starom planu bio dosti\u017ean iz \\(S\\) bio i dalje dosti\u017ean, potrebno je da u njegovom grafu postoji ciklus neparne du\u017eine. Kako to nije slu\u010daj po uslovu podzadatka, mo\u017eemo zaklju\u010diti da taj graf nema neparan ciklus. Takav graf jo\u0161 nazivamo i bipartitivnim. To zna\u010di da svaki \u010dvor mo\u017eemo obojiti u dve boje na na\u010din da nikoja dva \u010dvorova iste boje nisu povezani. Tra\u017eenje najkra\u0107eg puta od \\(S\\) do \\(T\\) je pravolinijski. Mo\u017eemo primeniti \\(BFS\\) algoritam direktno, tj. pretragu u \u0161irinu. Ako algoritam u originalnom grafu odredi du\u017einu \\(D\\), odgovor na zadatak je \\(\\frac{D}{2}\\).</p> <p>Ukupna slo\u017eenost je \\(O(N+M)\\).</p>"},{"location":"takprog/2023_2024/kv1/03_presedanja/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Podrebno je nastaviti u generalnom grafu koji mo\u017ee imati neparne cikluse. Tra\u017eimo najkra\u0107i put parne du\u017eine izme\u0111u \u010dvorova \\(S\\) i \\(T\\). Potrebno je da na neki na\u010din ne ra\u010dunamo puteve neparne du\u017eine ka re\u0161enju, ali da ih u isto vreme ne zanemarimo pri nala\u017eenju istog. Jedan na\u010din da to u\u010dinimo je da za svaki \u010dvor napravimo i njegov \"neparni\" parnjak. Dakle, svaki \u010dvor ima \"parnu\" i \"neparnu\" verziju, tj. duplirali smo ga. Grane postoje samo izme\u0111u \u010dvorova razli\u010dite parnosti. Sada prime\u0107ujemo da prilikom prela\u017eenja iz jednog \u010dvora u drugi menjamo trenutnu parnost \u010dvora. Ovim je jasno da je u ovakvom grafu dovoljno na\u0107i put od \"parnog\" \\(S\\) do \"parnog\" \\(T\\), jer od parnosti poslednjeg \u010dvora u kome smo zavr\u0161ili zavisi i parnost puta.</p> <p>Ukupna slo\u017eenost je \\(O(N+M)\\).</p> 03_presedanja.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; g(400005);\nbool vis[400005];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n,m,s,t; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;\n    while (m--)\n    {\n        int u,v; cin&gt;&gt;u&gt;&gt;v;\n        g[u].push_back(v+n);\n        g[v].push_back(u+n);\n        g[u+n].push_back(v);\n        g[v+n].push_back(u);\n    }\n\n    queue&lt;pair&lt;int,int&gt;&gt; bfs;\n    bfs.push({s,0});\n    while (!bfs.empty())\n    {\n        int p=bfs.front().first;\n        int d=bfs.front().second;\n        bfs.pop();\n        if (vis[p]) continue;\n        vis[p]=true;\n\n        if (p==t)\n        {\n            cout&lt;&lt;d/2&lt;&lt;\"\\n\";\n            break;\n        }\n\n        for (auto it : g[p]) bfs.push({it,d+1});\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/","title":"4 - Ve\u0107a trka","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 3000ms 64MB <p>Mo\u017eda ste \u010duli za tzv. \"veliku trku\" koja se de\u0161ava u jednoj zemlji iz kom\u0161iluka. Ako pitate njih \u0161ta je najve\u0107i godi\u0161nji spektakl kod njih, re\u0107i \u0107e vam  \"U RePuBlIcI iZoMeTrIjI nAjVe\u0106i GoDi\u0160njI sPeKtAkL jE vElIkA tRkA kOjA sE oDr\u017daVa U sRcU dR\u017eAvE - cEnTrAlGrAdU\"  (fuj). Ako pitate nas, to su sve budala\u0161tine, a prave trke se de\u0161avaju samo kod nas u Republici Liniji. Me\u0111utim, slu\u017ee\u0107i se ve\u0161tim marketin\u0161kim trikom, oni su svoju \"trku\" promovisali na jednom od najve\u0107ih doga\u0111aja na svetu - okru\u017enom takmi\u010denju iz informatike \\(2021\\) - i sad imaju milione turista svake godine. E pa, sada je na na\u0161 red! A da ne pominjemo da su kvalifikacije jo\u0161 ve\u0107e takmi\u010denje...</p> <p>Ilustrova\u0107emo superiornost na\u0161ih trka primerom. Danas se odr\u017eava jedna trka sa \\(N\\) u\u010desnika. Trka\u010di su postavljeni na brojevnoj pravoj (mi se ne zamla\u0107ujemo \"slatkim\" rutama, najbitnija je brzina). Svaki trka\u010d ima razli\u010ditu po\u010detnu poziciju \\(x_i\\) i neku brzinu \\(v_i\\). Kada trka krene, svako potr\u010di svojom brzinom u pozitivnom smeru (\"ka desno\") i nastavi to da radi zauvek. Preciznije, nakon \\(t\\) pozicija \\(i\\)-tog trka\u010da je \\(x_i+t\\cdot v_i\\)</p> <p>Najbitnije je ko je br\u017ei od koga, tako da nas interesuju trenuci kada jedan trka\u010d pretekne drugog. Da biste mogli istinski da se u\u017eivite u na\u0161u trku, zahtevamo od vas da na\u0111ete trenutak \\(K\\)-tog preticanja. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze dva broja \\(N\\) i \\(K\\) iz teksta zadatka. U narednih \\(N\\) linija se nalaze po dva cela broja \\(x_i\\) i \\(v_i\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#opis-izlaza","title":"Opis izlaza","text":"<p>Potrbeno je ispisati jedan broj - vreme \\(K\\)-tog preticanja. Va\u0161e re\u0161enje se smatrati ta\u010dnim ukoliko se razlikuje od komisijskog za manje od \\(10^{-4}\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv1/04_veca_trka/#ulaz","title":"Ulaz","text":"<pre><code>4 3\n1 5\n2 2\n3 3\n5 2\n</code></pre>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#izlaz","title":"Izlaz","text":"<pre><code>1.333333333\n</code></pre>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Prvo preticanje \u0107e se dogoditi kada prvi trka\u010d da pretekne drugog nakon tre\u0107ine sekunde (u tom trenutku se oba trka\u010da nalaze na lokaciji \\(2\\frac{2}{3}\\)). Drugo preticanje \u0107e se dogoditi kada prvi trka\u010d pretekne tre\u0107eg nakon ukupno jedne sekunde. Kona\u010dno, tre\u0107e preticanje \u0107e se dogoditi \u010detiri tre\u0107ine sekunde od po\u010detka trke, kada prvi trka\u010d prestigne poslednjeg. U ovom primeru jo\u0161 i tre\u0107i igr\u010d pretekne \u010detvrog ukupno dve sekunde nakon po\u010detka, i onda vi\u0161e nikad niko nikoga ne pretekne.</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv1/04_veca_trka/#ulaz_1","title":"Ulaz","text":"<pre><code>4 5\n1 4\n2 3\n3 2\n4 1\n</code></pre>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#izlaz_1","title":"Izlaz","text":"<pre><code>1.000000000\n</code></pre>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Nakon jedne sekunde \u0107e se sva \\(4\\) trka\u010da nalaziti u poziciji \\(5\\). U tom trenutku se de\u0161ava 6 preticanja istovremeno, pa se peto preticanje desi posle jedne sekunde.</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N \\leq 150.000\\)</li> <li>\\(1\\leq K \\leq \\frac{N(N-1)}{2}\\)</li> <li>Za svaki test primer se garantuje da \u0107e se dogoditi barem \\(K\\) preticanja</li> <li>\\(1\\leq x_1&lt;x_2&lt;\\cdots&lt;x_N \\leq 10^9\\)</li> <li>\\(1\\leq v_i \\leq 10^8\\)</li> </ul> <p>Test primeri su podeljeni u \\(5\\) disjunktnih grupa</p> <ul> <li>U test primerima vrednim 10 poena: \\(N=2\\).</li> <li>U test primerima vrednim 20 poena: \\(N\\leq2000\\).</li> <li>U test primerima vrednim 15 poena: \\(K=1\\).</li> <li>U test primerima vrednim 25 poena: \\(K\\leq300.000\\).</li> <li>U test primerima vrednim 30 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#resenje-kada-n2","title":"Re\u0161enje kada \\(N=2\\)","text":"<p>U ovom podzadatku, mo\u017ee se desiti najvi\u0161e jedno preticanje. Kako je \\(1 \\leq K\\), garantuje se da \u0107e se desiti ta\u010dno jedno preticanje. To preticanje \u0107e se desiti upravo u momentu \\(\\frac{x_2-x_1}{v_1-v_2}\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#resenje-kada-n-leq-2000","title":"Re\u0161enje kada \\(N \\leq 2.000\\)","text":"<p>U ovom podzadatku, mo\u017eemo da posmatramo skup svih preticanja koja \u0107e se desiti. Za svako \\(i&lt;j\\) za koje \\(v_i &gt; v_j\\), va\u017ei da \u0107e \\(i\\) prete\u0107i \\(j\\) u momentu \\(\\frac{x_j-x_i}{v_i-v_j}\\). Potom mo\u017eemo da sortiramo sve ove vrednosti i uzmemo \\(K\\)-tu najmanju vrednost. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N^2 \\log N)\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#resenje-kada-k-1","title":"Re\u0161enje kada \\(K = 1\\)","text":"<p>Primetimo da se prvo preticanje mora desiti izme\u0111u dva susedna trka\u010da. Dakle, dovoljno je da za svako \\(1 \\leq i &lt; N\\) za koje \\(v_i &gt; v_{i+1}\\) izra\u010dunamo kada \u0107e trka\u010d \\(i\\) prete\u0107i trka\u010da \\(i+1\\). To \u0107e se desiti u momentu \\(\\frac{x_{i+1}-x_i}{v_i - v_{i+1}}\\). Treba da ispi\u0161emo najraniji takav momenat. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(N)\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#resenje-kada-k-leq-300000","title":"Re\u0161enje kada \\(K \\leq 300.000\\)","text":"<p>Ovaj podzadatak zahteva generalizaciju prethodnog podzadatka. Znamo da se prvo preticanje mora desiti izme\u0111u dva susedna trka\u010da. Da bi re\u0161ili ovaj podzadatak, potrebno je da simuliramo prvih \\(K\\) preticanja. Ovo mo\u017eemo posti\u0107i tako \u0161to u nekoj strukturi (recimo <code>set</code> ili <code>priority_queue</code>) \u010duvamo momente kada \u0107e neki trka\u010d presti\u0107i onog koji je trenutno neposredno ispred njega (pored momenta u kojem \u0107e se ovo desiti, potrebno je da \u010duvamo i poziciju trka\u010da na kojeg se to preticanje odnosi). Prona\u0107emo najraniji takav momenat u strukturi i zamenimo redosled ta dva trka\u010da. Zatim ubacimo preticanja koja \u0107e se desiti izme\u0111u trka\u010da koji su postali susedni nakon ove razmene. Vremenska slo\u017eenost ovog re\u0161enja je \\(O(K \\log N)\\).</p>"},{"location":"takprog/2023_2024/kv1/04_veca_trka/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Primeni\u0107emo binarnu pretragu po re\u0161enju. Sada se zadatak svodi na slede\u0107e pitanje: \"Za dato \\(t\\), koliko preticanja se desilo do trenutka \\(t\\)?\". Prvo \u0107emo prona\u0107i poziciju svakog trka\u010da posle \\(t\\) sekundi. Pretpostavimo, za po\u010detak, da su te pozicije jedinstvene, tj. da se dva razli\u010dita trka\u010da ne\u0107e na\u0107i na istoj poziciji posle \\(t\\) sekundi. Ozna\u010dimo poziciju trka\u010da \\(i\\) sa \\(y_i\\). Primetimo da je trka\u010d \\(i\\) pretekao sve one trka\u010de \\(j&gt;i\\) za koje va\u017ei \\(y_j &lt; y_i\\). Sortirajmo sada trka\u010de prema njihovim novim pozicijama. Ozna\u010dimo sa \\(a_i\\) trka\u010da \u010diji indeks odgovara \\(i\\)-toj najmanjoj poziciji u nizu \\(y\\). Dakle, trka\u010d \\(a_i\\) je pretekao sve trka\u010de \\(a_j\\) za koje va\u017ei \\(j&lt;i\\) i \\(a_j&gt;a_i\\). Tj. broj preticanja je jednak broju parova \\(j&lt;i\\) takvih da \\(a_j &gt; a_i\\). Ovo je poznato kao problem prebrojavanja inverzija u nizu. Ovaj problem najlak\u0161e mo\u017eemo re\u0161iti koriste\u0107i se Fenvikovim stablom (tj <code>bit</code>-om) ili segmentnim stablom. Prolazimo kroz niz s desna na levo i za dato \\(i\\) na re\u0161enje dodamo broj elemenata u Fenvikovom stablu koji je manji od \\(a_i\\) i potom dodamo \\(a_i\\) u Fenvikovo stablo. Alternativno, ovaj problem se mo\u017ee re\u0161iti i simulacijom <code>merge sort</code> procedure. </p> <p>Trebalo bi analizirati i \u0161ta se de\u0161ava u slu\u010daju da su neke pozicije nakon \\(t\\) sekundi jednake. To bi zna\u010dilo da se neka preticanja de\u0161avaju ta\u010dno nakon \\(t\\) sekundi. U ovom slu\u010daju \u0107emo, pri pore\u0111enju, redosled trka\u010da sa istim pozicijama odrediti na osnovu njihovih originalnih indeksa. U op\u0161tem slu\u010daju, time \u0107emo dobiti broj preticanja koji se desio pre strogo momenta \\(t\\).  Pretpostavimo da se u momentu \\(p\\) desilo \\(K\\)-to preticanje. Dakle, algoritam \u0107e za momenat \\(p\\) vratiti vrednost koja je manja od \\(K\\). To zna\u010di da \u0107emo u binarnoj pretrazi u narednom koraku posmatrati vrednosti koje su ve\u0107e od \\(p\\). Me\u0111utim, za svako \\(t&gt;p\\), algoritam \u0107e vratiti vrednost koja je ve\u0107a ili jednaka od \\(K\\). Nakon nekoliko iteracija binarne pretrage, algoritam \u0107e stati i ispisati vrednost \\(p + \\varepsilon\\), \u0161to je dovoljno dobro, jer re\u0161enje treba odrediti sa gre\u0161kom do \\(10^{-4}\\). </p> <p>Kona\u010dno, prokomentari\u0161imo i samu implementaciju binarne pretrage nad brojevima koji nisu celi. U ovom slu\u010daju, binarnu pretragu mo\u017eemo implementirati tako \u0161to poredimo razliku desne i leve granice, \\(r-l\\), sa nekom malom vredno\u0161\u0107u, npr. \\(10^{-5}\\), \u0161to je u ovom slu\u010daju dovoljno dobro. U op\u0161tem slu\u010daju, ovo mo\u017ee da izazove probleme sa precizno\u0161\u0107u i bolje je unapred fiksirati broj iteracija binarne pretrage. Na primer \\(50\\) iteracija garantuje da \u0107e nakon zavr\u0161etka binarne pretrage va\u017eiti \\(r-l \\leq \\frac{r_0-l_0}{2^{50}}\\), gde su \\(l_0\\) i \\(r_0\\) po\u010detne vrednosti leve i desne granice. </p> 04_veca_trka.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 150007\nusing namespace std;\nint bit[MAXN],N;\ndouble a[MAXN];\nlong long x[MAXN],v[MAXN],K;\nvoid upd(int x)\n{\n    while(x&lt;=N)\n    {\n        bit[x]++;\n        x+=(x&amp;-x);\n    }\n}\nlong long sum(int x)\n{\n    long long sum=0;\n    while(x)\n    {\n        sum+=bit[x];\n        x-=(x&amp;-x);\n    }\n    return sum;\n}\nbool provera(double s)\n{\n    vector&lt;pair&lt;double,int&gt;&gt; vec;\n    for(int i=1;i&lt;=N;i++) vec.push_back({x[i]+s*v[i],i});\n    sort(vec.begin(),vec.end());\n    fill(bit,bit+N+1,0);\n    long long invcnt=0;\n    for(int i=0;i&lt;N;i++)\n    {\n        invcnt+=i-sum(vec[i].second);\n        upd(vec[i].second);\n    }\n    return invcnt&gt;=K;\n}\nint main()\n{\n    scanf(\"%d%lld\",&amp;N,&amp;K);\n    for(int i=1;i&lt;=N;i++) scanf(\"%lld%lld\",&amp;x[i],&amp;v[i]);\n    double l=0,r=1000000000;\n    while(r-l&gt;5e-10)\n    {\n        double s=0.5*(l+r);\n        if(provera(s)) r=s;\n        else l=s;\n    }\n    printf(\"%.9f\",0.5*(l+r));\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/","title":"5 - Fejk reklama","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Svetski poznata kompanija \"Najbolji ltd.\" razvija novu igru za mobilne telefone. Ova igra se di\u010di svim najnovijim grafi\u010dkim inovacijama, uklju\u010duju\u0107i ray tracing, DLSS, itd. Pored nadmo\u0107ne grafike, igrica poseduje i revolucionaran gejmplej.</p> <p>U igri ima \\(T\\) nivoa. </p> <p>Igra\u010d zapo\u010dinje nivo sa vojskom veli\u010dine \\(S\\) i nailazi na \\(N\\) prepreka, sa ciljem maksimizovanja veli\u010dine svoje vojske nakon svih prepreka. Neka je veli\u010dina vojske koju igra\u010d poseduje pre \\(i\\)-te prepreke jednaka \\(x\\). U \\(i\\)-toj od prepreci igra\u010d mo\u017ee da bira izme\u0111u dve opcije, \"*\\(m_i\\)\" ili \"+\\(a_i\\)\". Ukoliko odabere prvu opciju, veli\u010dina njegove vojske nakon \\(i\\)-te prepreke postaje \\(x*m_i\\), a ukoliko odabere drugu opciju veli\u010dina njegove vojske postaje \\(x+a_i\\).</p> <p>Dodatno, nakon \\(i\\)-te prepreke, veli\u010dina vojske koju igra\u010d poseduje mora biti barem \\(l_i\\) i ne sme biti ve\u0107a od \\(r_i\\) (u suprotnom most posle \\(i\\)-te prepreke pukne pod prevelikim optere\u0107enjem).</p> <p>Primetite da vojska mo\u017ee da ima negativno vojnika. Tako\u0111e, neki nivoi mogu da budu toliko te\u0161ki da ih uop\u0161te nije ni mogu\u0107e pre\u0107i. </p> <p>Na slici ispod je prikazan jedan nivo ove igrice:</p> <p>Sre\u0107om po tebe, dragi takmi\u010daru, odabran si da bude\u0161 tester ove igrice u poznoj fazi njene proizvodnje. </p> <p>Tebe naravno, najvi\u0161e interesuje kolika je teoretski maksimalna mogu\u0107a veli\u010dina vojske koju mo\u017ee\u0161 posti\u0107i u svakom niovu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Aleksa Milisavljevi\u0107 Aleksandar Vi\u0161nji\u0107 Dimitrije Erdeljan i Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je ceo broj \\(T\\) - koji predstavlja broj nivoa u igrici. U narednim redovima slede opisi \\(T\\) nivoa, pet redova po nivou.</p> <p>U prvom redu opisa svakog nivoa su celi brojevi \\(N\\) i \\(S\\) - broj prepreka i po\u010detna veli\u010dina vojske. U drugom redu opisa svakog nivoa nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(m_i\\).  U tre\u0107em redu opisa svakog nivoa nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(a_i\\). U \u010detvrtom redu opisa svakog nivoa nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(l_i\\). U petom redu opisa svakog nivoa nalazi se \\(N\\) celih brojeva, \\(i\\)-ti od njih je \\(r_i\\).</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(T\\) redova. U \\(i\\)-tom od njih ispisati maksimalnu mogu\u0107u veli\u010dinu vojske nakon svih prepreka iz \\(i\\)-tog nivoa (primetite da ovaj broj mo\u017ee da bude i negativan), ili <code>nemoguce</code>, ukoliko nije mogu\u0107e pre\u0107i \\(i\\)-ti nivo. </p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#ulaz","title":"Ulaz","text":"<pre><code>1\n2 4\n2 3\n-1 4\n-2 2\n5 10\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#izlaz","title":"Izlaz","text":"<pre><code>9\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Nivo sa slike. Igra\u010d po\u010dinje igricu sa vojskom veli\u010dine \\(4\\). Ukoliko bi odabrao opciju \\(*2\\) na prvoj prepreci, ne bi mogao da pro\u0111e preko nje jer bi imao \\(4*2=8&gt;5\\) vojnika. Zato bira opciju \\(-1\\) i do druge prepreke dolazi sa \\(3\\) vojnika. Na njoj ima dve opcije \\(*3\\) i \\(+4\\). Prvom opcijom zavr\u0161ava nivo sa \\(9\\) vojnika, dok izborom druge opcije zavr\u0161ava igricu sa \\(7\\) vojnika. Zato je maksimum koji igra\u010d mo\u017ee da postigne upravo \\(9\\).</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n1 5\n2\n-2\n4\n6\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#izlaz_1","title":"Izlaz","text":"<pre><code>nemoguce\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>U ovom niovu igra\u010d ima dve opcije \\(*2\\) i \\(-2\\). Prvom opcijom bi imao vojsku od \\(5*2=10\\) vojnika, dok bi drugom opcijom imao vojsku od \\(5-2=3\\) vojnika. Me\u0111utim ni jedan ni drugi broj nisu u intervalu \\([4,6]\\), te ovaj nivo nije mogu\u0107e pre\u0107i.</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#ulaz_2","title":"Ulaz","text":"<pre><code>2\n3 5\n2 2 2\n10 9 8\n-100 -100 0\n100 100 39\n3 -5\n100 100 100\n1 1 1\n-1000000000 -1000000000 -1000000000\n1000000000 1000000000 1000000000\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#izlaz_2","title":"Izlaz","text":"<pre><code>38\n-2\n</code></pre>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(T &lt;= 10\\)</li> <li>\\(N &lt;= 40\\)</li> <li>\\(|S| &lt;= 10^9\\)</li> <li>\\(|m_i|, |a_i| &lt;= 10^9\\)</li> <li>\\(|l_i|,|r_i| &lt;= 10^9\\) i \\(l_i &lt;= r_i\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 10 poena: \\(N &lt;= 20\\).</li> <li>U testovima vrednim 30 poena: \\(N &lt;= 30\\), \\(m_i = 1\\), za svako \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 40 poena: \\(N &lt;= 30\\).</li> <li>U testovima vrednim 20 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#resenje-za-nleq-20","title":"Re\u0161enje za \\(N\\leq 20\\)","text":"<p>Kod svake prepreke imamo \\(2\\) izbora, te rekurzivno re\u0161enje daje slo\u017eenost \\(2^N\\),</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#resenje-kada-m_i1-za-svako-1leq-ileq-n-i-n-leq-30","title":"Re\u0161enje kada \\(m_i=1\\) za svako \\(1\\leq i\\leq N\\) i \\(N \\leq 30\\)","text":"<p>Koristimo meet in the middle tehniku. Za prvih \\(\\lfloor \\frac{N}{2} \\rfloor\\) prepreka izra\u010dunamo sve mogu\u0107e veli\u010dine vojske (rekurzivno kao u prethodnom podzadatku). Zatim, za narednih \\(\\lceil \\frac{N}{2} \\rceil\\) po\u010dnemo od neke neodre\u0111ene veli\u010dine vojske \\(x\\) i simuliramo prepreke za nju. Podatke \u010duvamo u slede\u0107em formatu:</p> <ul> <li>Ako je po\u010detno \\(x\\) u intervalu \\([y,z]\\), onda je \\(x+s\\) mogu\u0107a trenutna veli\u010dina vojske.</li> </ul> <p>Naravno, ovih stavki mo\u017ee imati proizvoljno mnogo, te ih \u010duvamo u nekoj kolekciji. Ta kolekcija mo\u017ee biti prazna. Na po\u010detku ta kolekcija sadr\u017ei samo jednu stavku - onu za po\u010detno \\(x\\) i ograni\u010denje \\([-10^9,10^9]\\)</p> <p>Kada prolazimo kroz prepreke, zbog uslova \\(m_i=1\\), imamo dva izbora:</p> <ul> <li>Ne radimo ni\u0161ta, i dodajemo novo ograni\u010denje za interval za po\u010detno \\(x\\) na svaku stavku;</li> <li>Za svaku po\u010detnu stavku, napravimo kopiju i simuliramo dodavanje \\(a_i\\) na \\(x\\).  Pamtimo inkrement, a potom dodajemo novo ograni\u010denje za po\u010detno \\(x\\) u obliku intervala. </li> </ul> <p>Pri svakom koraku veli\u010dina kolekcije ne poraste za vi\u0161e od duplo. Krajnja veli\u010dina nije ve\u0107a od \\(2^N\\). </p> <p>Kada nakon izv\u0161avanja prve polovine saznamo svako mogu\u0107e \\(x\\), a nakon izvr\u0161avanja druge polovine dobijemo sve mogu\u0107e stavke, mo\u017eemo ih spojiti i izra\u010dunati najve\u0107u mogu\u0107u veli\u010dinu vojske nakon svih pro\u0111enih prepreka.</p> <p>Memorijska slo\u017eenost je \\(O(2^{N/2})\\), dok je vremenska \\(O(2^{N/2} \\cdot N)\\) zbog sortiranja i binarne pretrage.</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#resenje-kada-n-leq-30","title":"Re\u0161enje kada \\(N \\leq 30\\)","text":"<p>Sli\u010dno kao u prethodnom podzadatku, koristimo tehniku meet in the middle. Problem nastaje pri a\u017euriranju \"*\\(m_i\\)\". U prvom delu mo\u017eemo rekurzivno prona\u0107i svako mogu\u0107e \\(x\\). Ali, u drugom delu vi\u0161e nemamo jednostavne stavke. One sada postaju komplikovanije funkcije od \\(x\\). Ipak, ispostavlja se da su te funkcije linearne. Na po\u010detku imamo funkciju \\(f(x)=x\\). Ona je o\u010dito linearna. Pretpostavimo da pre neke prepreke imamo kolekciju linearnih funkcija. Posmatrajmo jednu od njih, neka je to \\(f(x)=p x + q\\). Za modifikovanje nje imamo dve opcije:</p> <ul> <li>\\(f(x)=p m_i x + q m_i\\)</li> <li>\\(f(x) = px + q + a_i\\)</li> </ul> <p>Prime\u0107ujemo da pri oba izbora, na\u0161a funkcija zaista ostaje linearna. Me\u0111utim, dodavanje novih ograni\u010denja za segment na originalno \\(x\\) je ne\u0161to komplikovanije, ali izvodivo. Mo\u017eemo celu stavku zamisliti kao funkciju sa ograni\u010denim domenom (koji \u0107e biti neki segment).</p> <p>Na kraju, iz prve polovine imamo svako mogu\u0107e \\(x\\), a iz druge polovine imamo svaku mogu\u0107u linearnu funkciju sa odgovaraju\u0107im domenom. Spajanje mo\u017eemo izvr\u0161iti tako \u0161to fiksiramo funkciju sa njenim domenom \\([l,r]\\). Primetimo da linearna funkcija dosti\u017ee maksimum u krajevima, tj. da tra\u017eimo \\(x\\) da bude \u0161to bli\u017ee \"ve\u0107em kraju\". Ovim skra\u0107ujemo mogu\u0107nost na najvi\u0161e jedno mogu\u0107e \\(x\\). Sada jednostavno pro\u0111emo po svakoj funkciji i evaluiramo je u njenom optimalnom \\(x\\).</p> <p>Bitno je napomenuti da se mo\u017ee desiti da koeficijenti neke funkcije iza\u0111u iz opsega tipa long long. Takva je, na primer, funkcija \\(f(x)=10^{100}x -10^{100}\\). Ona staje u ograni\u010denje \\([-10^9,10^9]\\) za ta\u010dku \\(x=1\\). Me\u0111utim, primetimo da takve funkcije \u010diji su koeficijenti ve\u0107i od \\(10^{18}\\) (po apsolutnoj vrednosti) staju u ograni\u010denje \\([l_i,r_i]\\) samo u jednoj ta\u010dki. Po\u0161to je domen te funkcije u stvari jedna ta\u010dka, dovoljno je \"kompresovati\" je. Neka je \\((x_e,y_e=f(x_e))\\) ta ta\u010dka (u op\u0161tem slu\u010daju \"prevelike\" funkcije). Nju mo\u017eemo opisati i na slede\u0107i na\u010din: \\(f(x) = 0x + y_e\\). Ona o\u010dito ima koeficijente u opsegu \\([-10^9,10^9]\\), te staje u long long.</p> <p>Memorijska slo\u017eenost je \\(O(2^{N/2})\\), dok je vremenska \\(O(2^{N/2} \\cdot N)\\) zbog sortiranja i binarne pretrage.</p>"},{"location":"takprog/2023_2024/kv1/05_fejk_reklama/#resenje-kada-n-leq-40","title":"Re\u0161enje kada \\(N \\leq 40\\)","text":"<p>Koristimo ideje iz prethodnog podzadatka. Potrebno je smanjiti vremensku slo\u017eenost na \\(O(2^{N/2})\\). Primetimo dve \u010dinjenice:</p> <ul> <li>Algoritam binarne pretrage mo\u017ee se zameniti sa tehnikom dva pokaziva\u010da</li> <li>Sortiranje parametara je mogu\u0107e vr\u0161iti u \\(O(2^{N/2})\\) vremenskoj slo\u017eenosti.</li> </ul> <p>Jasno je da ako doka\u017eemo i izvedemo drugu \u010dinjenicu, ukupna slo\u017eenost bi\u0107e \\(O(2^{N/2})\\).</p> <p>Zamislimo da imamo trenutni niz \\(x_1,x_2,\\ldots ,x_k\\) (u prvom delu meet in the middle algoritma ) i da njega a\u017euriramo novim operacijama \"*\\(m\\)\" i \"+\\(a\\)\".  Poznato je da ako je po\u010detni niz sortiran, tada su i nizovi </p> \\[ m\\cdot x_1,m\\cdot x_2, \\ldots, m\\cdot x_k; \\] \\[ a+x_1, a+x_2, \\ldots ,a+x_k. \\] <p>(potencijalno u obrnutom redosledu). Sada mo\u017eemo primeniti algoritam nalik merge sort . Vremenska slo\u017eenost ovog algoritma sortiranja zaista jeste \\(O(2^{N/2})\\).</p> <p>Funkcije sli\u010dno sortiramo kada ih pripremamo za tehniku dva pokaziva\u010da. Me\u0111utim, potrebno ih je filtrirati u dve grupe. Jednu grupu sortiramo po levom kraju domena (one funkcije sa negativnim koeficijentom uz \\(x\\)), a drugu grupu po desnom kraju domena (one funkcije sa nenegativnim koeficijentom uz \\(x\\)).</p> 05_fejk_reklama.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define maxn 44\n#define maxl 2100000\n#define maxk 530000\nusing namespace std;\nlong long t;\nlong long n,s;\nlong long m;\nlong long mult[maxn];\nlong long add[maxn];\nlong long l[maxn];\nlong long r[maxn];\nlong long npot[2][maxl];\nlong long add_pot[maxl];\nlong long mult_pot[maxl];\nlong long add_potn;\nlong long mult_potn;\nlong long npotn[maxn];\ninline void construct_pot(long long i,long long g) {\n    if(i&gt;m) return;\n    add_potn=mult_potn=0;\n    for(long long j=0;j&lt;npotn[g];j++) {\n        long long v=npot[g][j];\n        long long add_v = 1ll * v + add[i];\n        if(l[i]&lt;=add_v &amp;&amp; add_v&lt;=r[i]) add_pot[add_potn++]=add_v;\n        long long mult_v = 1ll * v * mult[i];\n        if(l[i]&lt;=mult_v &amp;&amp; mult_v&lt;=r[i]) mult_pot[mult_potn++]=mult_v;\n    }\n    if(mult[i]&lt;0) {\n        reverse(mult_pot,mult_pot+mult_potn);\n    }\n    long long p=0;\n    long long q=0;\n    npotn[g^1]=0;\n    while(p&lt;add_potn &amp;&amp; q&lt;mult_potn) {\n        if(add_pot[p]&lt;mult_pot[q]) {\n            npot[g^1][npotn[g^1]++]=add_pot[p];\n            p++;\n        }\n        else {\n            if(add_pot[p]&gt;mult_pot[q]) {\n                npot[g^1][npotn[g^1]++]=mult_pot[q];\n                q++;\n            }\n            else {\n                npot[g^1][npotn[g^1]++]=add_pot[p];\n                p++;\n                q++;\n            }\n        }\n    }\n    while(p&lt;add_potn) {\n        npot[g^1][npotn[g^1]++]=add_pot[p];\n        p++;\n    }\n    while(q&lt;mult_potn) {\n        npot[g^1][npotn[g^1]++]=mult_pot[q];\n        q++;\n    }\n    construct_pot(i+1,g^1);\n}\nstruct func {\n    long long k,n;\n    long long l,r;\n};\ninline bool l_cmp(func a,func b) {\n    return a.l&gt;b.l;\n}\ninline bool r_cmp(func a,func b) {\n    return a.r&lt;b.r;\n}\ninline bool (*(cmp[2]))(func x, func y) = {l_cmp,r_cmp};\nfunc fnc[2][2][maxk];\nlong long fncn[2][2];\nfunc add_fnc[maxk];\nfunc mult_fnc[maxk];\nlong long add_fncn;\nlong long mult_fncn;\ninline void construct_linear(long long i,long long g) {\n    if(i&lt;=m) {\n        for(long long id=0;id&lt;2;id++) {\n            for(long long j=0;j&lt;fncn[id][g];j++) {\n                if(fnc[id][g][j].l==fnc[id][g][j].r) {\n                    fnc[id][g][j].n=fnc[id][g][j].k*fnc[id][g][j].l+fnc[id][g][j].n;\n                    fnc[id][g][j].k=0;\n                }\n            }\n        }\n        return;\n    }\n    for(long long id=0;id&lt;2;id++) fncn[id][g^1]=0;\n    for(long long id=0;id&lt;2;id++) {\n        add_fncn=mult_fncn=0;\n\n        for(long long j=0;j&lt;fncn[id][g];j++) {\n            func f=fnc[id][g][j];\n            if(f.l==f.r) {\n                f.n=f.k*f.l+f.n;\n                f.k=0;\n            }\n            long long nl = f.l-add[i];\n            long long nr = f.r-add[i];\n            long long ml = max(l[i-1],nl);\n            long long mr = min(r[i-1],nr);\n            if(ml&lt;=mr) {\n                func add_f = {f.k,f.k*add[i]+f.n,ml,mr};\n                add_fnc[add_fncn++]=add_f;\n            }\n        }\n        if(mult[i]&gt;=0) {\n            for(long long j=0;j&lt;fncn[id][g];j++) {\n                func f=fnc[id][g][j];\n                if(f.l==f.r) {\n                    f.n=f.k*f.l+f.n;\n                    f.k=0;\n                }\n                long long nl,nr;\n                if(mult[i]&gt;0) {\n                    nl = f.l/mult[i];\n                    while(nl*mult[i]&lt;f.l) nl++;\n                    while((nl-1)*mult[i]&gt;=f.l) nl--;\n                    nr = f.r/mult[i];\n                    while(nr*mult[i]&gt;f.r) nr--;\n                    while((nr+1)*mult[i]&lt;=f.r) nr++;\n                }\n                else {\n                    if(f.l&lt;=0 &amp;&amp; 0&lt;=f.r) {\n                        nl = -1e9;\n                        nr = 1e9;\n                    }\n                    else {\n                        nl = 1e9;\n                        nr = -1e9;\n                    }\n                }\n                long long ml = max(l[i-1],nl);\n                long long mr = min(r[i-1],nr);\n                if(ml&lt;=mr) {\n                    func mult_f = {f.k*mult[i],f.n,ml,mr};\n                    mult_fnc[mult_fncn++]=mult_f;\n                }\n            }\n        }\n        else {\n            mult[i]*=-1;\n            for(long long j=0;j&lt;fncn[1-id][g];j++) {\n                func f=fnc[1-id][g][j];\n                if(f.l==f.r) {\n                    f.n=f.k*f.l+f.n;\n                    f.k=0;\n                }\n                long long nl = f.l/mult[i];\n                while(nl*mult[i]&lt;f.l) nl++;\n                while((nl-1)*mult[i]&gt;=f.l) nl--;\n                long long nr = f.r/mult[i];\n                while(nr*mult[i]&gt;f.r) nr--;\n                while((nr+1)*mult[i]&lt;=f.r) nr++;\n                nl*=-1;\n                nr*=-1;\n                swap(nl,nr);\n                long long ml = max(l[i-1],nl);\n                long long mr = min(r[i-1],nr);\n                if(ml&lt;=mr) {\n                    func mult_f = {-f.k*mult[i],f.n,ml,mr};\n                    mult_fnc[mult_fncn++]=mult_f;\n                }\n            }\n            mult[i]*=-1;\n        }\n        long long p=0;\n        long long q=0;\n        while(p&lt;add_fncn &amp;&amp; q&lt;mult_fncn) {\n            if(cmp[id](add_fnc[p],mult_fnc[q])) {\n                fnc[id][g^1][fncn[id][g^1]++]=add_fnc[p];\n                p++;\n            }\n            else {\n                fnc[id][g^1][fncn[id][g^1]++]=mult_fnc[q];\n                q++;\n            }\n        }\n        while(p&lt;add_fncn) {\n            fnc[id][g^1][fncn[id][g^1]++]=add_fnc[p];\n            p++;\n        }\n        while(q&lt;mult_fncn) {\n            fnc[id][g^1][fncn[id][g^1]++]=mult_fnc[q];\n            q++;\n        }\n    }\n    construct_linear(i-1,g^1);\n}\nint main() {\n    scanf(\"%lld\",&amp;t);\n    assert(1&lt;=t &amp;&amp; t&lt;=10);\n    while(t--) {\n        scanf(\"%lld %lld\",&amp;n,&amp;s);\n        assert(1&lt;=n &amp;&amp; n&lt;=40);\n        assert(abs(s)&lt;=1000000000);\n        for(long long i=0;i&lt;2;i++) {\n            npotn[i]=0;\n            fncn[0][i]=fncn[1][i]=0;\n        }\n        for(long long i=0;i&lt;n;i++) {\n            scanf(\"%lld\",&amp;mult[i]);\n            assert(abs(mult[i])&lt;=1000000000);\n        }\n        for(long long i=0;i&lt;n;i++) {\n            scanf(\"%lld\",&amp;add[i]);\n            assert(abs(add[i])&lt;=1000000000);\n        }\n        for(long long i=0;i&lt;n;i++) {\n            scanf(\"%lld\",&amp;l[i]);\n            assert(abs(l[i])&lt;=1000000000);\n        }\n        for(long long i=0;i&lt;n;i++) {\n            scanf(\"%lld\",&amp;r[i]);\n            assert(abs(r[i])&lt;=1000000000);\n        }\n        m=n/2;\n        npot[0][0]=s;\n        npotn[0]=1;\n        construct_pot(0,0);\n        fnc[0][(n-1)&amp;1][fncn[0][(n-1)&amp;1]++]={1,0,l[n-1],r[n-1]};\n        fnc[1][(n-1)&amp;1][fncn[1][(n-1)&amp;1]++]={1,0,l[n-1],r[n-1]};\n        construct_linear(n-1,(n-1)&amp;1);\n        bool hans=false;\n        long long mans=0;\n        long long p=0;\n        if(npotn[(m+1)&amp;1]&gt;0) {\n            p=0;\n            for(long long i=0;i&lt;fncn[1][m&amp;1];i++) {\n                func f=fnc[1][m&amp;1][i];\n                while(p+1&lt;npotn[(m+1)&amp;1] &amp;&amp; npot[(m+1)&amp;1][p+1]&lt;=f.r) p++;\n                long long x = npot[(m+1)&amp;1][p];\n                if(f.l&lt;=x &amp;&amp; x&lt;=f.r) {\n                    if(!hans || f.k*x+f.n&gt;mans) {\n                        hans=true;\n                        mans=f.k*x+f.n;\n                    }\n                }\n            }\n            reverse(npot[(m+1)&amp;1],npot[(m+1)&amp;1]+npotn[(m+1)&amp;1]);\n            p=0;\n            for(long long i=0;i&lt;fncn[0][m&amp;1];i++) {\n                func f=fnc[0][m&amp;1][i];\n                while(p+1&lt;npotn[(m+1)&amp;1] &amp;&amp; npot[(m+1)&amp;1][p+1]&gt;=f.l) p++;\n                long long x = npot[(m+1)&amp;1][p];\n                if(f.l&lt;=x &amp;&amp; x&lt;=f.r) {\n                    if(!hans || f.k*x+f.n&gt;mans) {\n                        hans=true;\n                        mans=f.k*x+f.n;\n                    }\n                }\n            }\n        }\n        if(!hans) printf(\"nemoguce\\n\");\n        else printf(\"%lld\\n\",mans);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/","title":"1 - Nadkvadrat","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 100ms 32MB <p>Dobro je poznato (jo\u0161 od 1888. godine i Ni\u010deovog dela Sumrak idola) da ono \u0161to nas ne ubije - to nas oja\u010da. Tako je i sa ta\u010dkama, kvadratima, takmi\u010darima, pa i samom komisijom... Ako ve\u0107 ne mo\u017ee da kao ranije organizuje tri kruga kvalifikacija, komisija mo\u017ee zadati tri tajna broja (videti pro\u0161li krug) i tri javne ta\u010dke u ravni (gledate ih upravo). Ako ve\u0107 ta\u010dno tri godine, jo\u0161 od doba poslednje pandemije (i drugog kruga kvalifikacija \u0161kolske 2020/2021. godine), niko i dalje ne pita kako je kvadrat?, a on pre\u017eivi, posta\u0107e nadkvadrat (nem. \u00dcberquadrat) i obuhvati\u0107e sve tri javno zadate ta\u010dke!</p> <p>Naime komisija je zadala ta\u010dno tri ta\u010dke u Dekartovom pravouglom koordinatnom sistemu u ravni definisane celobrojnim koordinatama \\((x_1, y_1)\\), \\((x_2, y_2)\\) i \\((x_3, y_3)\\). Va\u0161 zadatak je da prona\u0111ete povr\u0161inu najmanjeg kvadrata sa stranicama paralelnim koordinatnim osama koji ih sadr\u017ei, odnosno obuhvata sve tri zadate ta\u010dke!</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Vladimir Milovanovi\u0107 Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#opis-ulaza","title":"Opis ulaza","text":"<p>U prva i jedina tri reda standardnog ulaza nalaze se celobrojne koordinate ta\u010daka i to: u prvom redu \\((x_1, y_1)\\), u drugom redu \\((x_2, y_2)\\) i u tre\u0107em redu \\((x_3, y_3)\\). U svakom redu koordinate \\(x\\) i \\(y\\) su razdvojene razmakom.</p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza, ispisati povr\u0161inu najmanjeg kvadrata sa stranicama paralelnim koordinatnim osama, odnosno pravama \\(x=0\\) i \\(y=0\\), koji obuhvata tri zadate ta\u010dke.</p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#ulaz","title":"Ulaz","text":"<pre><code>1 2\n3 3\n2 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Tri ta\u010dke koje su zadate mogu se obuhvatiti kvadratom \u010dije \u0107e donje levo teme biti u koordinati \\((1, 1)\\), a gornje desno teme u koordinati \\((3, 3)\\) te je njegova povr\u0161ina \\(2^2=4\\).</p> <p></p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#ulaz_1","title":"Ulaz","text":"<pre><code>1 1\n-2 -1\n3 -2\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#izlaz_1","title":"Izlaz","text":"<pre><code>25\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Tri ta\u010dke koje su zadate mogu se obuhvatiti kvadratom \u010dije \u0107e donje levo teme biti u koordinati \\((-2, -3)\\), a gornje desno teme u koordinati \\((3, 2)\\) te je njegova povr\u0161ina \\(5^2=25\\).</p> <p></p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#ulaz_2","title":"Ulaz","text":"<pre><code>1 2\n3 4\n5 6\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#izlaz_2","title":"Izlaz","text":"<pre><code>16\n</code></pre>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#objasnjenje_2","title":"Obja\u0161njenje","text":"<p>Tri ta\u010dke koje su zadate mogu se obuhvatiti kvadratom \u010dije \u0107e donje levo teme biti ba\u0161 u koordinati \\((1, 2)\\), \u0161to je zapravo prvozadata ta\u010dka, a gornje desno teme u koordinati \\((5, 6)\\), \u0161to je tre\u0107ezadata ta\u010dka, te je njegova povr\u0161ina \\(4^2=16\\).</p> <p></p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#ogranicenja","title":"Ograni\u010denja","text":"<p>\\(-10^9 \\leq x_1, x_2, x_3, y_1, y_2, y_3 \\leq 10^9\\)</p> <p>Test primeri su podeljeni u \u010detiri disjunktna skupa:</p> <ul> <li>U testovima vrednim 30 poena: koordinate su nenegativne \\(0 \\leq x_1, x_2, x_3, y_1, y_2, y_3 \\leq 10^4\\)</li> <li>U testovima vrednim 30 poena: \\(-10^4 \\leq x_1, x_2, x_3, y_1, y_2, y_3 \\leq 10^4\\)</li> <li>U testovima vrednim 30 poena: tri ta\u010dke su jo\u0161 i kolinearne</li> <li>U testovima vrednim 10 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#napomena","title":"Napomena","text":"<p>Smatrati da kvadrat obuhvata, odnosno sadr\u017ei ta\u010dku \u010dak i ako se ona nalazi na njegovoj stranici ili u temenu.</p>"},{"location":"takprog/2023_2024/kv2/01_nadkvadrat/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za re\u0161enje zadatka dovoljno je prona\u0107i masimum i minimum po svakoj koordinati od tri zadate ta\u010dke, a zatim kvadrirati ve\u0107u od razlika dveju koordinata. Drugim re\u010dima, ako su tri ta\u010dke u Dekartovom koordinatnom sistemu zadate koordinatama \\((x_1, y_1)\\), \\((x_2, y_2)\\) i \\((x_3, y_3)\\), tada je najpre neophodno prona\u0107i \\(x_\\max = \\max(x_1, x_2, x_3)\\) i \\(x_\\min = \\min(x_1, x_2, x_3)\\), te \\(y_\\max = \\max(y_1, y_2, y_3)\\) i \\(y_\\min = \\min(y_1, y_2, y_3)\\). Da se u zadatku tra\u017eila povr\u0161ina minimalnog obuhvataju\u0107eg pravougaonika, onda bi du\u017eine stranica tog pravougaonika bile \\(\\Delta x = x_\\max - x_\\min\\) i \\(\\Delta y = y_\\max - y_\\min\\). Me\u0111utim, s obzirom da se tra\u017ei povr\u0161ina minimalnog obuhvataju\u0107eg kvadrata, to je stranica kvadrata zapravo \\(\\max(\\Delta x, \\Delta y)\\), a povr\u0161ina tog kvadrata \\((\\max(\\Delta x, \\Delta y))^2\\) do \u010dega se dolazi u konstantnoj vremenskoj i prostornoj slo\u017eenosti \\(\\mathcal{O}(1)\\). Za sve poene (poslednji podzadatak) bilo je neophodno primetiti implementacijski detalj da kvadriranjem neke velike vrednosti mo\u017ee do\u0107i do prekora\u010denja, pa je u programskom jeziku C rezultat neophodno smestiti u neki dovoljno veliki ceo broj (konkretno <code>long long</code> u ovom slu\u010daju).</p> <p>Da je umesto tri, u op\u0161tijem slu\u010daju bilo zadato \\(N\\) ta\u010daka u prostoru, mogao bi se primeniti identi\u010dan algoritam, a njegova slo\u017eenost bila bi \\(\\mathcal{O}(N)\\), to jest linearna po broju zadatih ta\u010daka \u010dije se obuhvatanje kvadratom tra\u017ei.</p> 01_nadkvadrat.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;int&gt; x(3);\n    vector&lt;int&gt; y(3);\n\n    for (int i=0;i&lt;3;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    int len=max(x[2]-x[0],y[2]-y[0]);\n    cout&lt;&lt;(long long)len*len;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/","title":"2 - Manja je matrica od matrice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p><pre><code>Manja je matrica od matrice,\nNajmanja \"Mala Matrica\" matrica;\nU njoj je reda dva, a kolone tri\nU njoj su nule i stotke\nNa svakom krugu kvalifikacija;\n...\n</code></pre> Vama su data \\(4\\) pozitivna cela broja \\(N,M,K,L\\), kao i niz \\(A\\) od  \\(N\\cdot M\\) nenegativnih celih brojeva. Ra\u010dunamo lepotu \\(N\\times M\\) matrice tako \u0161to za svaku njegovu podmatricu dimenzije \\(K\\times L\\) zapi\u0161emo na papiru sumu elemenata te podmatrice, a zatim saberemo sve brojeve koje smo zapisali na na\u0161em papiru. Va\u0161 zadatak je da odredite najve\u0107u mogu\u0107u lepotu \\(N\\times M\\) matrice ako u nju upi\u0161emo elemente niza \\(A\\).</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Pavle Martinovi\u0107 Mladen Puzi\u0107 Aleksandar Vi\u0161nji\u0107 <p>U analizi re\u0161enje smatra\u0107e se da prvi red od gore ima indeks \\(1\\), poslednji red indeks \\(N\\), prva kolona sleva ima indeks \\(1\\), a poslednja \\(M\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji standardnog ulaza se nalaze \u010detiri broja \\(N,M,K,L\\), koji opisuju dimenzije matrice i dimezije posmatranih podmatrica. U drugoj liniji standardnog ulaza se nalazi \\(N\\cdot M\\) brojeva koji predstavljaju elemente \\(A\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#opis-izlaza","title":"Opis izlaza","text":"<p>Potrbeno je ispisati jedan broj - najve\u0107u mogu\u0107u lepotu matrice. </p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1\\leq N,M \\leq 1.000\\)</li> <li>\\(1\\leq K \\leq N\\)</li> <li>\\(1\\leq L \\leq M\\)</li> <li>\\(0\\leq A_i \\leq 10^6\\)</li> </ul> <p>Test primeri su podeljeni u \\(5\\) disjunktnih grupa</p> <ul> <li>U test primerima vrednim 20 poena: \\(K=L=1\\).</li> <li>U test primerima vrednim 20 poena: \\(N=M=3\\), \\(K=L=2\\).</li> <li>U test primerima vrednim 20 poena: \\(0\\leq A_i\\leq 1\\)</li> <li>U test primerima vrednim 20 poena: \\(K,L\\leq 5\\).</li> <li>U test primerima vrednim 20 poena: Nema dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#ulaz","title":"Ulaz","text":"<pre><code>2 3 2 2\n1 5 6 0 5 2\n</code></pre>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#izlaz","title":"Izlaz","text":"<pre><code>30\n</code></pre>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Optimalno je rasporediti brojeve na slede\u0107i na\u010din <pre><code>0 6 2\n1 5 5\n</code></pre> Ova \\(3\\times2\\) matrica ima dve \\(2\\times2\\) podmatrice, levu i desnu. U levoj je suma \\(12\\), a u desnoj \\(18\\) pa je ukupna suma \\(30\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#ulaz_1","title":"Ulaz","text":"<pre><code>3 3 2 2\n1 0 0 0 0 0 0 0 0 \n</code></pre>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#izlaz_1","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Ova matrica ima \u010detiri \\(2\\times2\\) podmatrice, i ako se jedinica postavi u cetnralno polje, suma u svakoj od tih podmatrica \u0107e biti \\(1\\), pa je tada ukupna suma \\(4\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#napomena","title":"Napomena","text":"<p>Primetite da re\u0161enje na zadatak mo\u017ee biti zna\u010dajno ve\u0107e od \\(2\\cdot 10^9\\), tako da ne treba raditi sa 32-bitnim tipovima podataka kao <code>int</code> ve\u0107 64-bitnim kao <code>long long</code>. </p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#resenje-kada-k-l-1","title":"Re\u0161enje kada \\(K = L = 1\\)","text":"<p>Lepota matrice je suma svih podmatrica dimenzija \\(1 \\times 1\\), \u0161to je u stvari zbir svih elemenata matrice. Dakle, kako god rasporedili elemente, lepota matrice bi\u0107e ista i to zbir svih elemenata niza \\(A\\).</p> <p>Vremenska i memorijska slo\u017eenost je \\(O(NM)\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#resenje-kada-n-m-3-k-l-2","title":"Re\u0161enje kada \\(N = M = 3, K = L = 2\\)","text":"<p>Po\u0161to matrica ima samo \\(9\\) polja, postoji \\(9! = 362.880\\) mogu\u0107nosti za raspore\u0111ivanje niza \\(A\\) u matricu. Nazovimo matricu \\(m\\) - lepota matrice nakon fiksiranog niza jeste (mo\u017ee se videti ako se ispi\u0161u zajedno sume svih podmatrica dimenzije \\(2\\times 2\\)):</p> \\[ m_{1, 1} + 2\\cdot m_{1, 2} + m_{1, 3} + 2\\cdot m_{2, 1} + 4\\cdot m_{2, 2} + 2\\cdot m_{2, 3} + m_{3, 1} + 2\\cdot m_{3, 2} + m_{3, 3} \\] <p>Od svih mogu\u0107ih opcija, biramo onu koja maksimizira gorenavedenu formulu.</p> <p>Vremenska slo\u017eenost je \\(O((NM)!)\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#resenje-kada-k-l-leq-5","title":"Re\u0161enje kada \\(K, L \\leq 5\\)","text":"<p>Po\u0161to su dimenzije posmatranih podmatrica male, mi mo\u017eemo grubom silom izra\u010dunati za svako polje u koliko podmatrica dimenzije \\(K \\times L\\) se nalazi, slede\u0107im algoritmom:</p> <ul> <li>Inicijalizujemo matricu \\(cnt_{i, j} = 0\\), za svako \\(1 \\leq i \\leq N\\) i \\(1 \\leq j \\leq M\\);</li> <li>Za svako mogu\u0107e gornje levo polje \\((x, y)\\) (ovo su sva polja za koja va\u017ei \\(1 \\leq x \\leq N-K+1\\) i \\(1 \\leq y \\leq M-L+1\\)):<ul> <li>Za svako polje \\((i, j)\\) za koje va\u017ei \\(x \\leq i &lt; x+K\\) i \\(y \\leq j &lt; y+L\\) uve\u0107ati \\(cnt_{i, j}\\) za jedan.</li> </ul> </li> </ul> <p>Nakon toga, sve vrednosti iz matrice \\(cnt\\) prebacimo u niz koji sortiramo. Najve\u0107u vrednost niza \\(A\\) potrebno je staviti na polje koje se pojavljuje u najvi\u0161e posmatranih podmatrica, drugu najve\u0107u vrednost u polje koje se pojavljuje u drugom najve\u0107em broju podmatrica, itd.</p> <p>Vremenska slo\u017eenost je \\(O(NMKL + NM\\log(NM))\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#resenje-kada-0-leq-a_i-leq-1","title":"Re\u0161enje kada \\(0 \\leq A_i \\leq 1\\)","text":"<p>Po\u0161to imamo samo dve mogu\u0107e vrednosti, \u017eelimo jedinice staviti u polja koja se nalaze u najve\u0107em broju podmatrica dimenzije \\(K\\times L\\), dok nule stavljamo u polja koja se re\u0111e pojavljuju. Dakle, \u017eelimo da za svako polje efikasno prona\u0111emo u koliko posmatranih podmatrica se nalazi (ovo ne zavisi od raspodele elemenata u matrici).</p> <p>Kada bismo imali beskona\u010dnu tablu, polje \\((i, j)\\) bi sadr\u017eao svaki pravougaonik dimenzije \\(K\\times L\\) \u010diji je gornje levo polje \\((x, y)\\), gde va\u017ei \\(i-K+1 \\leq x \\leq i\\) i \\(j-L+1 \\leq y \\leq j\\). Ukoliko ura\u010dunamo da ivice matrice mogu da smanje na\u0161 broj opcija, dobijamo da mora da va\u017ei: </p> \\[ \\max(i-K+1, 1) \\leq x \\leq \\min(N-K+1, i) \\] \\[ \\max(j-L+1, 1) \\leq y \\leq \\min(M-L+1, j) \\] <p>Iz ovoga se mo\u017ee zaklju\u010diti da se broj podmatrica koje sadr\u017ee polje \\((i, j)\\), dakle, \\(cnt_{i, j}\\), mo\u017ee izra\u010dunati formulom:</p> \\[ cnt_{i, j} = (\\min(N-K+1, i) - \\max(i-K+1, 1) + 1) \\cdot (\\min(M-L+1, j) - \\max(j-L+1, 1) + 1) \\] <p>Dalje, izbrojimo broj jedinica u nizu \\(A\\) i re\u0161enje je zbir toliko najve\u0107ih elemenata iz matrice \\(cnt\\).</p> <p>Vremenska slo\u017eenost je \\(O(NM\\log(NM))\\), a memorijska \\(O(NM)\\).</p>"},{"location":"takprog/2023_2024/kv2/02_manja_je_matrica_od_matrice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Poput re\u0161enja kada \\(0 \\leq A_i \\leq 1\\) za svako polje pronalazimo u koliko posmatranih podmatrica se nalazi, a poput re\u0161enja kada \\(K, L \\leq 5\\) uparujemo najve\u0107i element niza \\(A\\) sa onom pozicijom koja se pojavljuje u najvi\u0161e posmatranih podmatrica.</p> <p>Vremenska slo\u017eenost je \\(O(NM\\log(NM))\\), a memorijska \\(O(NM)\\).</p> 02_manja_je_matrica_od_matrice.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN 1007\nusing namespace std;\nlong long a[MAXN*MAXN],b[MAXN*MAXN];\nint main()\n{\n    int n,m,k,l;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;l;\n    for(int i=0;i&lt;m*n;i++) cin&gt;&gt;a[i];\n    sort(a,a+m*n);\n    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)\n    {\n        long long kx=min(n,i+k-1)-max(k,i)+1,ky=min(m,j+l-1)-max(l,j)+1;\n        b[(i-1)*m+j-1]=kx*ky;\n    }\n    sort(b,b+m*n);\n    long long ans=0;\n    for(int i=0;i&lt;n*m;i++) ans+=a[i]*b[i];\n    cout&lt;&lt;ans;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv2/03_skolice/","title":"3 - \u0160kolice","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Perica je de\u010dak koji slabo u\u010di. Nakon duga\u010dkog izmotavanja na \u010dasu informatike, zazvonilo je za odmor. Iza\u0161ao je napolje da se igra \u0161kolica. Tu igru mo\u017eemo zamisliti kao niz koji se sastoji od \\(M\\) pozitivnih celih brojeva \\(B_1,B_2,\\ldots B_M\\). Perica se trenutno nalazi na poziciji \\(0\\) i \u017eeli da stigne do pozicije \\(M+1\\). Kako bi to u\u010dinio, on u jednom potezu mo\u017ee da sko\u010di za jednu ili dve pozicije udesno. Kada stane na neku poziciju \\(i\\) izme\u0111u \\(1\\) i \\(M\\), njegov skor se pove\u0107a za \\(B_i\\). Cilj igre je tako\u0111e minimizovati skor.</p> <p>Na po\u010detku je dat niz koji se sastoji od \\(N\\) pozitivnih celih brojeva \\(A_1,A_2,\\ldots A_N\\). Me\u0111utim, perica ima \\(Q\\) drugova. Svaki od njih je video novi Tik Tok prenk, i \u017eeli Perici da zagusti igru. Ta\u010dnije, \\(i\\)-ti drug je smislio dva broja \\(L_i\\) i \\(R_i\\) (\\(L_i &lt; R_i\\)) i obrisao elemente niza \\(A_{L_i},A_{L_i+1},\\ldots,A_{R_i}\\). Ostatak niza je spojio. Preciznije, nakon \u0161to \\(i\\)-ti drug izvr\u0161i smicalicu, Peri\u010din niz za igru je \\(B = A_1,A_2,\\ldots,A_{L_i-1},A_{R_i+1},\\ldots,A_{N-1},A_{N}\\).</p> <p>Napomenimo da su njegovi drugovi ipak po\u0161teni. Oni svoje smicalice ne me\u0161aju. Svaki od drugova \u0107e odmah nakon \u0161to Perica zavr\u0161i sa njegovom verzijom igre vratiti obrisane brojeve. Ta\u010dnije, smicalice drugova su nezavisne. Tako\u0111e, mo\u017ee se desiti \\(L_i=1\\) ili \\(R_i=N\\) za neko \\(i\\). U tim slu\u010dajevima, nizovi za igru izgledaju kao \\(A_{R_i+1},\\ldots,A_{N-1},A_N\\) i \\(A_1,A_2,\\ldots,A_{L_i-1}\\), redom. Mo\u017ee se desiti \\(L_i=1\\) i \\(R_i=N\\) istovremeno, pri \u010demu je niz za igru prazan i skor uvek jednak \\(0\\).</p> <p>Perici je ovo sve postalo jako komplikovano i dosadno. Po\u0161to nije pratio na \u010dasovima, upitao je Vas kao programera da mu pomognete u njegovoj nevolji tako \u0161to \u0107ete mu za svaku smicalicu re\u0107i minimalan skor.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Igor Pavlovi\u0107"},{"location":"takprog/2023_2024/kv2/03_skolice/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je ceo broj \\(N\\) - veli\u010dina niza \\(A\\).</p> <p>U drugom redu standardnog ulaza dato je \\(N\\) celih brojeva \\(A_1,A_2,\\ldots,A_N\\) - elementi niza.</p> <p>U tre\u0107em redu standardnog ulaza dat je ceo broj \\(Q\\) - broj Peri\u010dinih drugova koji izvr\u0161avaju smicalice.</p> <p>U \\(i\\)-tom od narednih \\(Q\\) redova data su dva cela broja \\(L_i\\) i \\(R_i\\). Oni opisuju uzastopne elemente niza koji \\(i\\)-ti drug bri\u0161e (a potom ih nakon zavr\u0161etka njegove verzije igre vra\u0107a).</p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(Q\\) redova. U \\(i\\)-tom od njih ispisati minimalan skor u verziji igre \\(i\\)-tog Peri\u010dinog druga. </p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#primer","title":"Primer","text":""},{"location":"takprog/2023_2024/kv2/03_skolice/#ulaz","title":"Ulaz","text":"<pre><code>7\n1 4 3 6 4 3 5\n3\n4 5\n3 6\n1 7\n</code></pre>"},{"location":"takprog/2023_2024/kv2/03_skolice/#izlaz","title":"Izlaz","text":"<pre><code>7\n4\n0\n</code></pre>"},{"location":"takprog/2023_2024/kv2/03_skolice/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvoj smicalici, niz za igru je \\([1, 4, 3, 3, 5]\\). Optimalno je sko\u010diti na prvo, tre\u0107e i \u010detvrto polje (niza za igru).</p> <p>U drugoj smicalici, niz za igru je \\([1, 4, 5]\\).</p> <p>U tre\u0107oj smicalici, niz za igru je prazan te je odgovor \\(0\\).</p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 200\\,000\\)</li> <li>\\(1 \\leq Q \\leq 200\\,000\\)</li> <li>\\(1 \\leq A_i \\leq 10^9\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U testovima vrednim 10 poena: \\(A_i=1\\) za svako \\(1 \\leq i \\leq N\\).</li> <li>U testovima vrednim 10 poena: \\(N \\leq 10, Q \\leq 100\\).</li> <li>U testovima vrednim 40 poena: \\(N,Q \\leq 4\\,000\\).</li> <li>U testovima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv2/03_skolice/#resenje-kada-a_i-1","title":"Re\u0161enje kada \\(A_i = 1\\)","text":"<p>Stajanje na bilo koji stepenik ima istu \"cenu\". Potrebno je stati na ukupno \u0161to je manje mogu\u0107e stepenika. Re\u0161enje zavisi samo od du\u017eine niza za igru. Za svaki upit je zasebno ra\u010dunamo i neka ona iznosi \\(M_i\\) kod \\(i\\)-tog druga. Re\u0161enje kod istog je \\(\\lfloor \\frac{M_i}{2} \\rfloor\\).</p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#resenje-kada-nleq-10-qleq-100","title":"Re\u0161enje kada \\(N\\leq 10, Q\\leq 100\\)","text":"<p>Svaki niz za igru nema veli\u010dinu ve\u0107u od \\(10\\). Ukupan broj na\u010dina skakanja nije velik, te ih mo\u017eemo simulirati rekurzijom. Biramo onaj na\u010din koji daje najmanji rezultat.</p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#resenje-kada-nq-leq-4-000","title":"Re\u0161enje kada \\(N,Q \\leq 4\\, 000\\)","text":"<p>Saznajmo prvo kako re\u0161avamo zadatak za jedan odre\u0111en niz za igru. Neka je taj niz \\(B_1,B_2,\\ldots B_M\\). Ovo predstavlja klasi\u010dan zadatak iz dinami\u010dkog programiranja. Neka je \\({dp}_i\\) minimalna cena stajanja na polje \\(i\\) (po\u010dev od \\(0\\), zajedno uz sve skokove do tog polja). Po\u010detne vrednosti su \\({dp}_0 = 0\\) i \\({dp}_1 = B_1\\). Za \\(i&gt;1\\) rekurentna veza je </p> \\[ {dp}_i = \\min({dp}_{i-1},{dp}_{i-2})  + B_i \\] <p>Odgovor na tra\u017eeno pitanje je \\({dp}_{M+1}\\). Neophodno je zasebno razmatrati slu\u010daje \\(M=0\\) (niz za igru je prazan) i \\(M=1\\). U njima je odgovor uvek \\(0\\).</p> <p>Slo\u017eenost algoritma po smicalici je \\(O(N)\\). Dakle, ukupno \\(O(Q\\cdot N)\\).</p>"},{"location":"takprog/2023_2024/kv2/03_skolice/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Neophodno je br\u017ee nalaziti odgovore za svaku smicalicu. Dozvoljeno nam je da pre njihovih tra\u017eenja izra\u010dunamo neke vrednosti u nizu \\(A_1,A_2,\\ldots , A_N\\). Od koristi \u0107e biti sli\u010dno dinami\u010dko programiranje kao u prethodnom podzadatku. U ovom \u010duvamo i prefiks i sufiks. Ta\u010dnije, neka \\({pref}_i\\) predstavlja najmanju cenu potrebnu za stajanje na polje \\(i\\) po\u010dev od polja \\(0\\). A neka \\({suf}_i\\) predstavlja najmanju cenu potrebnu za stajanje na polje \\(i\\) po\u010dev od polja \\(N+1\\). Ova dva niza se ra\u010dunaju na analogan na\u010din sa dinami\u010dkim programiranjem iz prethodnog podzadatka.</p> <p>Pre\u0107imo sad na smicalice. Dajemo postupak za re\u0161avanje slu\u010daja \\(1 &lt; L \\leq R &lt; N\\). Ivi\u010dne slu\u010daje ostavljamo \u010ditaocu za ve\u017ebu. Primetimo da, koriste\u0107i indekse iz niza \\(A\\), Perica mora stati na barem jedno od polja \\(L-1\\) i \\(R+1\\) (jer je u nizu za igru njihovo rastojanje zapravo \\(1\\)) . Formalno, postoje \\(3\\) slu\u010daja:</p> <ol> <li>Perica je pro\u0161ao samo kroz polje \\(L-1\\);</li> <li>Perica je pro\u0161ao samo kroz polje \\(R+1\\);</li> <li>Perica je pro\u0161ao kroz oba polja.</li> </ol> <p>Kad spojimo sve slu\u010daje, odgovor na smicalicu postaje </p> \\[ \\min({pref}_{L-1}+{suf}_{R+2}, \\ \\ {pref}_{L-2}+{suf}_{R+1},\\ \\ {pref}_{L-1}+{suf}_{R+1}) \\] <p>Prefiksne i sufiksne nizove ra\u010dunamo u slo\u017eenosti \\(O(N)\\). Za svaku smicalicu nalazimo re\u0161enje u \\(O(1)\\). Ukupna slo\u017eenost je \\(O(N+Q)\\).</p> 03_skolice.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nlong long int typedef li;\n\nint a[200005];\nli pre[200005];\nli suf[200005];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n; cin&gt;&gt;n;\n    for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];\n    pre[1]=a[1];\n    for (int i=2;i&lt;=n;i++) pre[i]=min(pre[i-1],pre[i-2])+a[i];\n    suf[n]=a[n];\n    for (int i=n-1;i&gt;=1;i--) suf[i]=min(suf[i+1],suf[i+2])+a[i];\n\n    int q; cin&gt;&gt;q;\n    while (q--)\n    {\n        int l,r; cin&gt;&gt;l&gt;&gt;r;\n        if (l==1) cout&lt;&lt;min(suf[r+1],suf[r+2])&lt;&lt;\"\\n\";\n        else if (r==n) cout&lt;&lt;min(pre[l-1],pre[l-2])&lt;&lt;\"\\n\";\n        else cout&lt;&lt;min(min(pre[l-2]+suf[r+1],pre[l-1]+suf[r+2]),pre[l-1]+suf[r+1])&lt;&lt;\"\\n\";\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/","title":"4 - Obaranje ruku","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2400ms 768MB <p>Zmijko Reptil organizuje turnir u obaranju ruku. Kako je on zmija i nema ruke, on ne\u0107e u\u010destvovati. U\u010destvova\u0107e njegovih \\(N\\) najboljih drugova koji su svi ljudi, gde je \\(N\\) stepen dvojke. Ta\u010dnije, mogu\u0107e je napraviti perfektan turnir bez potrebe da neko izostane iz nekog kruga. Zmijko je ve\u0107 svakom od njih dodelio jedinstven broj od \\(1\\) do \\(N\\). Poznato je da \\(i\\)-ti drug ima snagu \\(P_i\\), kao i da su sve snage razli\u010diti brojevi iz skupa \\(\\{ 1,2,\\ldots, N\\}\\).</p> <p>Odvija se vi\u0161e krugova kako bi se izabrao pobednik. Neka u trenutnom krugu turnira u\u010destvuje \\(K\\) drugova. Ruke obaraju parovi drugova \\((1,2),(3,4),\\ldots (K-1,K)\\). U naredni krug prolazi onaj sa ve\u0107om snagom u paru. Dakle, ukupno \\(\\frac{K}{2}\\) drugova u\u010destvuje u narednom krugu i dodeljuju im se novi brojevi na naredno naveden na\u010din. Neka su \\(B_1 &lt; B_2 &lt; \\ldots &lt; B_{K/2}\\) brojevi pobednika trenutnog kruga. Njihovi novi brojevi su, redom, \\(1,2,\\ldots \\frac{K}{2}\\). Napomenimo da oni prilikom renumeracije zadr\u017eavaju stare snage. U prvom krugu u\u010destvuje \\(N\\) drugova, u drugom \\(\\frac{N}{2}\\), u tre\u0107em \\(\\frac{N}{4}\\), \\(\\ldots\\) , u poslednjem \\(1\\). Primetimo da, po\u0161to je \\(N\\) stepen dvojke, u svakom krugu u\u010destvuje ceo broj drugova, tj. uvek je mogu\u0107e pravilno izvr\u0161iti deljenje.</p> <p>Zmijko je poznati prevarant i on \u017eeli da jedan njegov poseban drug osvoji \u0161to bolji rezultat. Pobednik je o\u010dito poznat - to je drug sa snagom \\(N\\). Me\u0111utim, Zmijku je dovoljno da poslednji krug njegovog miljenika bude \u0161to vi\u0161i. On ni sam ne zna \u0161ta \u017eeli i dvoumi se izme\u0111u \\(Q\\) opcija.</p> <p>U svakoj opciji poznati su mu miljenik \\(M_i\\) i broj \\(J_i\\). Zmijko ima pravo da zameni mesto bilo koja dva druga (koji nisu \\(M_i\\) jer je to previ\u0161e sumnjivo) i time promeni budu\u0107i ishod turnira. Dozvoljeno mu je da to izvr\u0161i najvi\u0161e \\(J_i\\) puta pre po\u010detka turnira. Nakon \u0161to turnir po\u010dne nema pravo da vr\u0161i zamene. Pri takvim uslovima, zanima ga najve\u0107i broj kruga do kog miljenik \\(M_i\\) mo\u017ee sti\u0107i.</p> <p>Po\u0161to su ovo ipak teoretske opcije, one se ne\u0107e zapravo izvr\u0161avati. Samim tim smatramo da se one nezavisno jedna od druge odvijaju.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksandar Vi\u0161nji\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je ceo broj \\(N\\) - broj Zmijkovih drugova koji u\u010destvuju u turniru obaranja ruku. Garantuje se da je \\(N\\) stepen dvojke.</p> <p>U drugom redu standardnog ulaza, dato je \\(N\\) celih brojeva \\(P_1,P_2,\\ldots,P_N\\) - snage drugova.</p> <p>U tre\u0107em redu standardnog ulaza, dat je ceo broj \\(Q\\) - broj opcija koje Zmijko razmatra.</p> <p>U \\(i\\)-tom od narednih \\(Q\\) redova, data su dva cela broja \\(M_i\\) i \\(J_i\\).</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#opis-izlaza","title":"Opis izlaza","text":"<p>Ispisati \\(Q\\) redova. U \\(i\\)-tom od njih ispisati najvi\u0161i krug do koji miljenik mo\u017ee sti\u0107i.</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(4 \\leq N \\leq 2^{20}\\), \\(N\\) je stepen dvojke</li> <li>\\(1 \\leq Q \\leq 5\\cdot 10^5\\)</li> <li>\\(1 \\leq P_i \\leq N\\), navedeni brojevi su me\u0111usobno razli\u010diti.</li> <li>\\(1 \\leq M_i \\leq N\\)</li> <li>\\(0 \\leq J_i \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 8 poena: \\(N = 4\\)</li> <li>U testovima vrednim 16 poena: Va\u017ei \\(P_i = i\\) za svakog druga.</li> <li>U testovima vrednim 16 poena: Va\u017ei \\(M_i = M_j\\) za svaka dva cela broja \\(1 \\leq i,j \\leq Q\\). Ta\u010dnije, miljenik je isti u svakoj opciji.</li> <li>U testovima vrednim 44 poena: \\(N \\leq 2^{17}\\), \\(Q \\leq 10^5\\)</li> <li>U testovima vrednim 16 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#ulaz","title":"Ulaz","text":"<pre><code>8\n1 8 2 7 4 6 3 5\n4\n1 8\n3 1\n5 2\n5 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#izlaz","title":"Izlaz","text":"<pre><code>1\n2\n3\n2\n</code></pre>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U prvoj opciji, drug broj \\(1\\) ima snagu \\(1\\). On ne mo\u017ee pobediti nikoga drugog jer ima najmanju snagu, te igru zavr\u0161ava u prvom krugu.</p> <p>U drugoj opciji, drug broj \\(3\\) ima snagu \\(2\\). Spre\u010davamo obaranje ruku sa drugom \\(4\\) koji ima snagu \\(7\\) tako \u0161to njega menjamo sa drugom \\(1\\) snage \\(1\\). Prilikom obaranja ruku, miljenik pobe\u0111uje i time se plasira u drugi krug. Dokazuje se da je to i najvi\u0161i krug do kog mo\u017ee sti\u0107i.</p> <p>U tre\u0107oj opciji, menjamo drugove \\(6\\) i \\(8\\) sa, redom, drugovima \\(1\\) i \\(3\\). Time drug \\(5\\), miljenik, sti\u017ee do tre\u0107eg kruga.</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 2 3 4\n4\n1 1\n2 1\n3 1\n4 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n2\n2\n3\n</code></pre>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>U \u010detvrtoj opciji, drug \\(4\\) ima snagu \\(4\\) i on zasigurno pobe\u0111uje turnir. U prvom krugu u\u010destvuje \\(4\\) druga, u drgom \\(2\\), a za tre\u0107i krug mo\u017eemo re\u0107i da u\u010destvuje samo \\(1\\) (iako se taj krug ne nastavlja). Zato ka\u017eemo da je \\(3\\) odgovor za \u010detvrtu opciju.</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#resenje-kada-n4","title":"Re\u0161enje kada \\(N=4\\)","text":"<p>Ovaj zadatak je mogu\u0107e uraditi grubom silom, ali i ru\u010dno s obzirom da postoje samo \u010detiri me\u0111usobno ne-ekvivalentna \u017ereba, a to su \\((1,2,3,4)\\), \\((1,3,2,4)\\) i \\((1,4,2,3)\\), gde svakom treba najvi\u0161e jedna razmena da bi stigao do finala, osim najslabijem koji svakako ispada u prvoj rudni.</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#resenje-kada-p_ii","title":"Re\u0161enje kada \\(P_i=i\\)","text":"<p>U ovom zadatku, kao i u svakom nadalje, je klju\u010dno opisati uslov za jednu osobu da li mo\u017ee da stigne do neke runde. Podturnir defini\u0161emo kao skup svih ljudi koji igraju da bi jedan od njih pro\u0161ao u \\(k\\)-to kolo. Da li osoba \\(x\\) mo\u017ee sti\u0107i do \\(k\\)-runde zavisi da li ima \\(2^{k-1}-1\\) igra\u010da koje mo\u017ee da pobedi, (jer da bi stigao do \\(k\\)-te runde, mora biti najja\u010di u njegovom podturniru), i da li ima dovoljno razmena na raspolaganju da izbacimo sve ja\u010de ljude iz tog podturnira. Ukoliko imamo dovoljno razmena na raspolaganju, onda samo sve te ja\u010de ljude unutar podturnira zamenimo sa slabijim ljudima van podturnira, kojih ima dovoljno zbog prvog uslova. Tako da sada znamo da odgovorimo na pitanje da li u\u010desnik mo\u017ee da stigne do runde \\(k\\) ako znamo broj razmena i broj ja\u010dih od njega u tom podturniru. Znamo da postoji ukupno \\(N-1\\) podturnira, i svaki u\u010destvuje u \\(\\log_2N\\) podturnira. Kada dobijemo novo pitanje, mo\u017eemo za svaki podturnir u kome taj \u010dovek u\u010destuje da odredimo da li mo\u017ee da bude pobednik tu (broj razmena nam je dat, a broj ja\u010dih u podturniru mo\u017eemo lako odrediti zbog specifi\u010dnosti permutacije) i odgovorimo na sva pitanja u \\(O(Q\\log N)\\).</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#resenje-kada-je-uvek-isti-miljenik","title":"Re\u0161enje kada je uvek isti miljenik","text":"<p>Za svaki podturnir koji sadr\u017ei miljenika je mogu\u0107e pro\u0107i kroz sve ljude i sra\u010dunati koliko ih ima ja\u010dih od njega u \\(O(N)\\), a zatim odgovaramo na pitanja isto ko u prethodnom podzadatku.</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#resenje-kada-nleq-17-qleq-100000","title":"Re\u0161enje kada \\(N\\leq 17\\), \\(Q\\leq 100.000\\)","text":"<p>U svakom podturniru mo\u017eemo dr\u017eati sortiran niz svih u\u010desnika tog turnira, a zatim kada ho\u0107emo da vidimo da li miljenik mo\u017ee sti\u0107i do nekog kola, binarnom pretragom po tom nizu sa\u010duvanom za taj podturnir, mo\u017eemo brzo na\u0107i ta\u010dno koliko njih je ja\u010dih u tom podturniru, i onda videti jel mogu\u0107e sti\u0107i do tog kola isto kao u drugom podzadatku. Slo\u017eenost \\(O(N\\log^2N+Q\\log^2N)\\).</p>"},{"location":"takprog/2023_2024/kv2/04_obaranje_ruku/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Radimo upite u tzv. <code>offline</code> na\u010dinu. Sortiramo upite po tome kolika je ja\u010dina \u010doveka koji je miljenik, a zatim po tome koliko razmena imamo na raspolaganju. Kada re\u0161imo sve upite za nekog miljenika, pro\u0111emo kroz sve podturnire u kojima on u\u010destvuje i dodamo \\(1\\) na neki broja\u010d. Kada sad re\u0161avamo upite za nekog slede\u0107eg miljenika, u broja\u010du za svaki podturnir \u0107e stajati broj u\u010desnika tog podturnira koji su slabiji od trenutno posmatranog (iz \u010dega, naravno, odmah mo\u017eemo da na\u0111emo i broj ja\u010dih od posmatranog). Dalje, po\u0161to je broj razmena potreban da stigne do \\(k\\)-tog kola rastu\u0107a funckija, tako da sada, preko informacija u broja\u010dima mo\u017eemo na\u0107i u \\(O(1)\\) koliko najmanje razmena treba da bi stigao do tog kola. Po\u0161to je niz upita sortiran, metodom <code>2 pointers</code>, mo\u017eemo odgovoriti na svaki upit za trenutnog miljenika. Slo\u017eenost \\(O(N\\log N+Q\\log Q)\\).</p> 04_obaranje_ruku.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAXN (1&lt;&lt;20)+7\nusing namespace std;\npair&lt;int,int&gt; p[MAXN];\nvector&lt;pair&lt;int,int&gt; &gt; queries[MAXN];\nint br[2*MAXN],ans[MAXN];\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n,q;\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].first;\n    for(int i=0;i&lt;n;i++) p[i].second=i;\n    sort(p,p+n,greater&lt;pair&lt;int,int&gt;&gt;());\n    cin&gt;&gt;q;\n    for(int i=0;i&lt;q;i++)\n    {\n        int t1,t2;\n        cin&gt;&gt;t1&gt;&gt;t2;\n        queries[t1-1].push_back({t2,i});\n    }\n    for(int i=0;i&lt;n;i++)\n    {\n        int poz=n+p[i].second,t=0;\n        sort(queries[p[i].second].begin(),queries[p[i].second].end());\n        int k=1;\n        while(poz!=1)\n        {\n            poz/=2;\n            int treba=(n-i&lt;(1&lt;&lt;k))?MAXN:br[poz];\n            while(t&lt;queries[p[i].second].size() &amp;&amp; queries[p[i].second][t].first&lt;treba) {ans[queries[p[i].second][t].second]=k; t++;}\n            br[poz]++;\n            k++;\n        }\n    }\n    int log=0;\n    while((1&lt;&lt;log)!=n) log++;\n    for(int i=0;i&lt;queries[p[0].second].size();i++)  ans[queries[p[0].second][i].second]=log+1;\n    for(int i=0;i&lt;q;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;\n}\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/","title":"5 - Pe\u0107inski ze\u010devi","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 6000ms 512MB <p>Kao \u0161to je op\u0161te poznato u godini \\(3023\\), ze\u010devi nemaju brkove, oslepeli su, imaju tri puta ve\u0107e u\u0161i i \u017eive u pe\u0107inama. U jednoj pe\u0107ini nalati se \\(N\\) soba, a u svakoj se nalazi po jedan zec. Poznato je da su neke sobe povezane prolazima. Postoji \\(N-1\\) parova takvih soba. \\(i\\)-ti par opisuje da je soba \\(U_i\\) direktno iznad sobe \\(V_i\\). Mogu\u0107e je od sobe \\(V_i\\) tim prolazom sti\u0107i do sobe \\(U_i\\). Soba \\(1\\) je posebna. Iznad nje se ne nalazi nijedna soba, ve\u0107 izlaz iz pe\u0107ine. Iznad svake ostale sobe se nalazi druga soba. Poznato je da je iz svake sobe mogu\u0107e sti\u0107i do sobe \\(1\\) kre\u0107u\u0107i se prolazima.</p> <p>Promena magnetnih polova zemlje izazvala je neprevi\u0111ena seizmi\u010dka de\u0161avanja. Pe\u0107ina je pod zemljotresom, i potrebno je evakuisati sve ze\u010deve. Oni su numerisani brojevima od \\(1\\) do \\(N\\). \\(i\\)-ti zec se nalazi u sobi \\(i\\) i ima snagu \\(i\\). Kako bi ze\u010devi iza\u0161li iz pe\u0107ine, oni mogu da ska\u010du nagore. Ta\u010dnije, mogu sko\u010diti u bilo koju sobu koja je direktno iznad trenutne, na onu koja je iznad nje, na onu iznad nje itd. Uslov je da \\(i\\)-ti zec snage \\(i\\) mo\u017ee sko\u010diti najvi\u0161e \\(i\\) soba nagore (odjednom). Ze\u010devi mogu skakati vi\u0161e puta, ali neophodno je u \u0161to manje skokova iza\u0107i iz pe\u0107ine. Tako\u0111e, ako \\(i\\)-ta soba \"nagore\" ne postoji, to zna\u010di da zec odjednom mo\u017ee da sko\u010di dovoljno jako da iza\u0111e iz pe\u0107ine, te \u0107e to u\u010diniti. Ako ovaj posao nije ve\u0107 bio dovoljno komplikovan, zemljotres je poremetio pristupa\u010dnosti soba. Ta\u010dnije, kroz svaku sobu je mogu\u0107e pro\u0107i, ali nije nu\u017eno mogu\u0107e dosko\u010diti na svaku sobu. Samo u nekim sobama se nalazi platforma za skakanje (i samo na nju je mogu\u0107e dosko\u010diti).</p> <p>Da ne bi pravili gu\u017evu, ze\u010devi su se dogovorili da izlaze redom, od zeca \\(1\\) do \\(N\\). Pre nego \u0161to zec \\(i\\) krene u svoj pohod, zbog nestabilnosti pe\u0107ine, mo\u017ee se desiti jedna od narednih \\(N+1\\) stvari:</p> <ul> <li>Promeni se stanje sobe \\(1\\);</li> <li>Promeni se stanje sobe \\(2\\);</li> <li>Promeni se stanje sobe \\(3\\);</li> <li>\\(\\ldots\\)</li> <li>Promeni se stanje sobe \\(N\\);</li> <li>Ni\u0161ta se ne menja.</li> </ul> <p>Pod promenom stanja podrazumevamo da, ako je ranije postojala platforma u sobi, vi\u0161e ne postoji, a ako ranije nije postojala, sada postoji.</p> <p>Za svakog zeca potrebno je prona\u0107i najmanji broj skokova potreban da on iza\u0111e iz pe\u0107ine. Mo\u017ee se desiti da to nije mogu\u0107e i da \u0107e, na\u017ealost, on ostati zaglavljen u pe\u0107ini. Ukoliko se to desi, naknadno \u0107e do\u0107i ekipa evakuacionih glista i izbaviti sve zarobljene ze\u010deve. Potrebno je objaviti posebnu poruku za sve takve.</p> <p>Napomena: mo\u017ee se desiti da soba iz koje zec kre\u0107e nema platformu za skakanje. On i dalje mo\u017ee skakati na sobe iznad. Uslov je samo da nije mogu\u0107e dosko\u010diti na sobu bez platforme.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Jovan Bengin i Aleksandar Vi\u0161nji\u0107 Nikola Pe\u0161i\u0107 i Jovan Bengin"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, dat je ceo broj \\(N\\) - broj soba i broj ze\u010deva</p> <p>U \\(i\\)-tom od narednih \\(N-1\\) redova, data su dva cela broja \\(U_i\\) i \\(V_i\\) - on obele\u017eava da postoji prolaz izme\u0111u te dve sobe, kao i da je soba \\(U_i\\) iznad sobe \\(V_i\\).</p> <p>U pretpostlednjem redu standardnog ulaza, dato je \\(N\\) celih brojeva \\(B_1, B_2, \\ldots, B_N\\). Ako je \\(B_i=1\\), tada u sobi \\(i\\) postoji platforma za skakanje (na po\u010detku). Ako je \\(B_i=0\\), onda ne postoji u toj sobi.</p> <p>U poslednjem redu standardnog ulaza, dato je \\(N\\) celih brojeva \\(X_1,X_2,\\ldots, X_N\\). * Ako je \\(X_N = 0\\), pre skoka zeca \\(i\\) ni\u0161ta se ne menja. * Ina\u010de, pre skoka zeca \\(i\\) menja se stanje sobe \\(X_i\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#opis-izlaza","title":"Opis izlaza","text":"<p>U jednoj liniji ispisati \\(N\\) brojeva. \\(i\\)-ti broj predstavlja najmanji broj skokova potreban da \\(i\\)-ti zec iza\u0111e iz pe\u0107ine. Ukoliko to ne mo\u017ee u\u010diniti, za \\(i\\)-ti broj postaviti vrednost \\(-1\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 500\\,000\\)</li> <li>\\(1 \\leq U_i,V_i \\leq N\\), \\(U_i \\neq V_i\\), va\u017ee dodatni uslovi povezanosti soba opisani u postavci zadatka.</li> <li>\\(B_i \\in \\{ 0,1 \\}\\)</li> <li>\\(0 \\leq X_i \\leq N\\)</li> </ul> <p>Test primeri su podeljeni u pet disjunktnih grupa:</p> <ul> <li>U testovima vrednim 8 poena: Svaka soba ima najvi\u0161e jednu ispod nje, \\(X_i = 0\\) za svako \\(i\\).</li> <li>U testovima vrednim 24 poena: Svaka soba ima najvi\u0161e jednu ispod nje.</li> <li>U testovima vrednim 20 poena: \\(X_i = 0\\) za svako \\(i\\).</li> <li>U testovima vrednim 32 poena: \\(N \\leq 100\\,000\\)</li> <li>U testovima vrednim 16 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#ulaz","title":"Ulaz","text":"<pre><code>3\n1 3\n3 2\n1 1 1\n0 0 0\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#izlaz","title":"Izlaz","text":"<pre><code>1 2 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#objasnjenje","title":"Obja\u0161njenje","text":"<p>U svakoj sobi nalazi se platforma za skakanje i va\u017ei \\(X_1 = X_2 = X_3 = 0\\). Tj. nema promena. Zec \\(1\\) jednim skokom mo\u017ee iza\u0107i iz pe\u0107ine. Zec \\(2\\) mo\u017ee prvo sko\u010diti u sobu \\(3\\) koja je iznad njegove. Zatim, mo\u017ee napraviti skok du\u017eine dva i isko\u010diti iz pe\u0107ine. Za to mu je ukupno potrebno dva skoka. Tre\u0107i zec mo\u017ee odjednom napraviti skok kojim izlazi iz pe\u0107ine.</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#ulaz_1","title":"Ulaz","text":"<pre><code>5\n1 5\n5 4\n4 3\n4 2\n0 0 0 0 0\n1 1 2 3 2\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#izlaz_1","title":"Izlaz","text":"<pre><code>1 -1 -1 1 1 \n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>U ovom primeru ima promena. Na po\u010detku se ni u jednoj sobi ne nalazi platforma za skakanje. Pre pohoda prvog zeca menja se stanje sobe \\(1\\), i time ona dobija platformu za skakanje. Pre pohoda drugog zeca opet se menja stanje sobe \\(1\\), \u010dime ona gubi platformu. Kada do\u0111e red na zeca broj \\(2\\) da izlazi iz pe\u0107ine, on ne\u0107e imati sobu na koju mo\u017ee dosko\u010diti, a izlaz iz pe\u0107ine mu je predalek. On ne sti\u017ee da iza\u0111e iz pe\u0107ine, te \u0107e ga sa\u010dekati ekipa evakuacionih glista. Pre pohoda zeca \\(3\\) menja se stanje sobe \\(2\\). Me\u0111utim, soba iznad njega, druga soba iznad njega, kao i tre\u0107a soba iznad njega ostaju bez platforme za skakanje. To zna\u010di da ni on ne mo\u017ee iza\u0107i iz pe\u0107ine. Ze\u010devi \\(4\\) i \\(5\\) mogu odmah iza\u0107i iz pe\u0107ine, te je odgovor za njih \\(1\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#ulaz_2","title":"Ulaz","text":"<pre><code>2\n1 2\n0 0\n1 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#izlaz_2","title":"Izlaz","text":"<pre><code>1 1 \n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#objasnjenje_2","title":"Obja\u0161njenje","text":"<p>U ovom primeru svaki zec mo\u017ee odmah iza\u0107i iz pe\u0107ine.</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#primer-4","title":"Primer 4","text":""},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#ulaz_3","title":"Ulaz","text":"<pre><code>16\n1 16\n16 7\n16 8\n7 15\n15 14\n14 13\n13 12\n12 11\n12 10\n10 9\n10 5\n10 6\n6 2\n6 3\n14 4\n0 1 0 1 1 0 1 0 1 1 1 0 1 1 0 0\n1 16 15 12 13 14 9 4 6 7 12 15 13 13 16 15\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#izlaz_3","title":"Izlaz","text":"<pre><code>1 6 4 2 2 2 1 1 1 1 1 1 1 1 1 1\n</code></pre>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#prvi-podzadatak","title":"Prvi podzadatak","text":"<p>U ovim testovima pe\u0107ina se mo\u017ee predstaviti kao niz, i skok nagore kao prelazak na levi element niza.</p> <p>Najjednostavnije re\u0161enje je da se simuliraju skokovi svakog zeca: krenemo iz njegove po\u010detne pozicije, i svaki put idemo u najlevlju dosti\u017enu poziciju. Drugim re\u010dima, ako je \\(i\\)-ti zec ternutno na \\(v\\)-tom mestu sleva, on \u0107e u slede\u0107em koraku oti\u0107i na najlevlju poziciju sa platformom u intervalu \\([v-i, v)\\) (naravno, ako takva pozicija ne postoji, onda \\(i\\)-ti zec ne mo\u017ee da iza\u0111e). Ovo se lako nalazi ako imamo niz pozicija sa platformom, jer onda u tom nizu mo\u017eemo binarnom pretragom na\u0107i najmanju poziciju ve\u0107u ili jednaku \\(v-i\\).</p> <p>Primetimo da u ovako tra\u017eenom re\u0161enju suma visina bilo koja dva uzastopna skoka \\(i\\)-tog zeca mora biti ve\u0107a od \\(i\\) (ina\u010de bi se oni mogli zameniti jednim skokom), pa je i broj njegovih skokova ograni\u010den odozgo sa \\(2\\lceil  \\frac{N}{i} \\rceil\\). Ukupan broj skokova svih ze\u010deva bi\u0107e ograni\u010den odozgo sa \\(2  \\sum  \\limits_{i=1}^n \\lceil \\frac{N}{i} \\rceil\\), \u0161to je \\(O(NlogN)\\) (suma harmonijskog reda), a po\u0161to svaki skok tra\u017eimo u vremenskoj slo\u017eenosti \\(O(logN)\\), ukupna vremenska slo\u017eenost algoritma bi\u0107e \\(O(Nlog^2N)\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#prva-dva-podzadatka","title":"Prva dva podzadatka","text":"<p>Umesto niza, koristi\u0107emo strukturu std::set da \u010duvamo pozicije soba sa platformom. Umesto binarne pretrage mo\u017eemo onda koristiti funkciju lower_bound, koja tako\u0111e radi u \\(O(logN)\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#resenje-kada-je-x_i-0-za-svako-i","title":"Re\u0161enje kada je \\(X_i = 0\\) za svako \\(i\\)","text":"<p>U ovom zadatku dato je stablo, ali bez promena stanja \u010dvorova (soba). Sli\u010dno kao ranije, potrebno je prona\u0107i najvi\u0161u slobodnu sobu od prvih nekoliko soba iznad date (i to uraditi puno puta). Po\u0161to nema promena, to je mogu\u0107e uraditi binarnim podizanjem (binary lifting). \u010cuvamo dve sparse tabele, jednu sa informacijom o \\(2^k\\)-tom pretku, a drugu sa informacijom koliko me\u0111u \\(2^k\\) predaka (ra\u010dunaju\u0107i sam taj \u010dvor u njih) postoji soba sa platformom. Ove informacije \u010duvamo za svaki \u010dvor i svako \\(k = 0,1,2,\\ldots,\\lfloor  \\log N \\rfloor\\).</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#resenje-kada-je-n-leq-100000","title":"Re\u0161enje kada je \\(N \\leq 100.000\\)","text":"<p>Ove testove prolaze sporije implementacije glavnog re\u0161enja.</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Prisetimo se ranijih zaklju\u010daka. Potrebno je \\(O(N\\log N)\\) puta na\u0107i prvu slobodnu sobu me\u0111u \\(x\\) predataka datog \u010dvora. Tako\u0111e, sada je potrebno i podr\u017eati \\(O(N)\\) promena soba. Standardna ideja je upotreba te\u0161ko-lake dekompozicije stabla, koja je od ove godine u programu takmi\u010denja. Stablo particioni\u0161emo u lance na poseban na\u010din. Prvi lanac kre\u0107e iz korena i nastavlja u \u010dvor koji ima najvi\u0161e dece (ra\u010dunaju\u0107i decu na svim dubinama). Ponavljamo postupak sa novim krajem dok ne do\u0111e do lista stabla, \u010dime smo tada napravili ceo lanac. Izbacivanjem ovog lanca nastaju nova podstabla, svaki sa svojim korenom. Algoritam se vr\u0161i za svaki od njih.</p> <p>Na upite odgovaramo tako \u0161to napravimo Fenvikovo stablo za svaki lanac, a potom preko \u0161etnje na\u0111emo poslednji potreban slobodan \u010dvor. Promene su podr\u017eane pomenutom strukturom.</p> <p>Za dat po\u010detni \u010dvor, tvrdimo da prolazimo kroz \\(O(\\log N)\\) lanaca dekompozicije prilikom cele \u0161etnje (do izlaska iz pe\u0107ine, tj. stabla). Neka je \\(s_p\\) veli\u010dina podstabla \u010dvora \\(p\\). Razmotrimo algoritam koji, po\u010dev od datog \u010dvora, u svakom trenutku podi\u017ee trenutni za jedan iznad njega. Ako promenimo lanac dekompozicije, broja\u010d (inicijalno \\(0\\)) se pove\u0107a za \\(1\\). Posmatrajmo situaciju promene. Neka je prethodni \u010dvor \\(u\\), naredni \\(v\\), a \\(w\\) \u010dvor u kome se lanac od \\(v\\) nastavlja. Zbog na\u010dina izbora dekompozicije, va\u017ei \\(s_w \\geq s_u\\). Odavde je jasno \\(s_v &gt; 2\\cdot s_u\\). Dakle, \\(s\\)-vrednost trenutnog \u010dvora se pove\u0107a barem duplo. To se najvi\u0161e desi \\(O(\\log N)\\) puta, odakle sledi tvrdnja.</p> <p>Pravilna implementacija dovodi do re\u0161enja slo\u017eenosti \\(O(N\\log ^2 N)\\). Komisija tvrdi da postoji i re\u0161enje bolje slo\u017eenosti. Takmi\u010daru ostavljamo za ve\u017ebu da ga prona\u0111e.</p>"},{"location":"takprog/2023_2024/kv2/05_pecinski_zecevi/#alternativno-glavno-resenje","title":"Alternativno glavno re\u0161enje","text":"<p>Prvo, razmotrimo alternativno re\u0161enje za niz. Postoji druga\u010diji na\u010din da na\u0111emo najlevlju slobodnu poziciju u \\([v-i, v)\\): to je ujedno i najlevlja pozicija \\(x\\) za koju je broj slobodnih pozicija od \\(1\\) do \\(x\\) strogo ve\u0107i od broja slobodnih pozicija od \\(1\\) do \\(v - i - 1\\). Upiti \"broj slobodnih pozicija od \\(1\\) do \\(x\\)\", kao i promene vrednosti neke pozicije, mogu se re\u0161iti segmentnim ili Fenvikovim stablom. Najlevlja slobodna pozicija mo\u017ee se ponovo na\u0107i binarnom pretragom, samo \u0161to sada na ovaj na\u010din u \\(O(logN)\\) odgovaramo na upit \"postoji li slobodna pozicija u \\([v-i, x]\\)\". Dakle, ukupna vremenska slo\u017eenost ovog re\u0161enja bi bila \\(O(Nlog^3N)\\).</p> <p>Ovo re\u0161enje mo\u017eemo da uop\u0161timo i na stablo, samo nam je potrebno da mo\u017eemo da na\u0111emo sumu elemenata na putu od korena do proizvoljnog \u010dvora.</p> <p>Razmislimo kako bismo mogli da to uradimo kada ne postoje promene. Mo\u017eemo da pro\u0111emo kroz stablo pretragom u dubinu iz korena, i \u010duvamo promenljivu \\(x\\) koja predstavlja sumu od korena do trenutnog \u010dvora. Kada u\u0111emo u \u010dvor, dodajemo njegovu vrednost (u ovom slu\u010daju, \\(1\\) ako ima platformu, \\(0\\) ako nema) u \\(x\\). Kada izlazimo iz \u010dvora, oduzimamo njegovu vrednost od \\(x\\). Ovakvim postupkom za svaki \u010dvor imamo sumu elemenata od korena do njega.</p> <p>Kako se ovde mogu primeniti promene? Konstrui\u0161emo niz \\(b\\) veli\u010dine \\(2N\\) koji odgovara gorenavedenom postupku: kada ulazimo u \u010dvor, na kraj niza dodajemo njegovu vrednost, a kada izlazimo, dodajemo minus od te vrednosti. Neka su \\(in_v\\) i \\(out_v\\) pozicije u nizu \\(b\\) koje odgovaraju ulasku u \u010dvor \\(v\\) i izlasku iz njega, redom. Tada je suma elemenata u stablu od korena do \\(v\\) zapravo suma elemenata u nizu \\(b\\) od 1 do \\(in_v\\).</p> <p>Sada se re\u0161enje za stablo svodi na re\u0161enje za niz, jedino \u0161to pri promeni vrednosti \u010dvora \\(v\\) moramo u nizu promeniti vrednosti u \\(in_v\\) i \\(out_v\\), \u0161to ponovo mo\u017eemo uraditi segmentnim ili Fenvikovim stablom (mada je u ovom slu\u010daju, radi brzine i jednostavnosti, bolje koristiti Fenvikovo). Tako\u0111e, potrebno nam je da brzo nalazimo \\(k\\)-tog roditelja proizvoljnog \u010dvora, \u0161to se lako mo\u017ee uraditi metodom binary lifting.</p> <p>Vremenska slo\u017eenost ovog re\u0161enja je \\(O(Nlog^3N)\\), mada je u praksi dosta br\u017ee: delom jer je binarna pretraga uglavnom radi na manjim skokovima (jer sa ve\u0107im skokovima zavr\u0161avamo br\u017ee), delom jer su operacije nad Fenvikovim stablom vrlo brze. U svakom slu\u010daju, konstanta re\u0161enja je jako mala, i komisijina implementacija prolazi za 2.5s.</p> 05_pecinski_zecevi.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nlong long int typedef li;\n\nvector&lt;vector&lt;int&gt;&gt; g(500005);\nint up[500005];\nint siz[500005];\nint dub[500005];\n\nvoid dfs(int p, int q)\n{\n    up[p]=q,siz[p]=1,dub[p]=dub[q]+1;\n    for (auto it : g[p]) if (it!=q) dfs(it,p),siz[p]+=siz[it];\n}\n\nint chin[500005]; //kom chain-u pripada\nint president[500005]; //najvisi u chain-u\nint chnt[500005]; //koliko dat chain ima elemenata\nvector&lt;int&gt; podub[500005]; //za svaki chain, njegovi cvorovi izlistani po dubinskom redu\n\nint idx=0;\nvoid hfs(int p, int cc, int r)\n{\n    chin[p]=cc,president[p]=r,chnt[cc]++,podub[cc].push_back(p);\n    if (g[p].empty()) return;\n    int gde=0;\n    for (auto it : g[p]) if (siz[it]&gt;siz[gde]) gde=it;\n    hfs(gde,cc,r);\n    for (auto it : g[p]) if (it!=gde) hfs(it,++idx,it);\n}\n\nbool ima[500005]; //korisna informacija za imati\nint fwtsiz[500005];\nint logsiz[500005]; //floor(log(fwtsiz))\nvector&lt;int&gt; fwt[500005]; //za dat chain fenwick (po dubini, offest-ovan)\nvoid add(int c, int i)\n{\n    for (;i&lt;=fwtsiz[c];i+=(i&amp;-i)) fwt[c][i]++;\n}\nvoid rmv(int c, int i)\n{\n    for (;i&lt;=fwtsiz[c];i+=(i&amp;-i)) fwt[c][i]--;\n}\nint pre(int c, int i)\n{\n    int ret=0;\n    for (;i;i-=(i&amp;-i)) ret+=fwt[c][i];\n    return ret;\n}\nint walk(int c, int x) //prvi index sa tom vrednoscu...\n{\n    int i=0,cur=0;\n    for (int k=logsiz[c];k&gt;=0;k--) if (i+(1&lt;&lt;k)&lt;=fwtsiz[c])\n    {\n        int sta=fwt[c][i+(1&lt;&lt;k)];\n        if (cur+sta&lt;x) i+=(1&lt;&lt;k),cur+=sta;\n    }\n    return i+1;\n}\n\nint MaxUpwalk(int p, int k)\n{\n    int r=president[p];\n    if (dub[p]-dub[r]+1&lt;=k)\n    {\n        int sta=MaxUpwalk(up[r],k-(dub[p]-dub[r]+1));\n        if (sta==-1)\n        {\n            int c=chin[p];\n            int F=walk(c,1);\n            if (F-1&gt;dub[p]-dub[r]) return -1;\n            return podub[c][F-1];\n        }\n        return sta;\n    }\n\n    int c=chin[p];\n    int F=walk(c,pre(c,dub[p]-dub[r]-k)+1);\n    if (F-1&gt;dub[p]-dub[r]) return -1;\n    return podub[c][F-1];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n; cin&gt;&gt;n;\n    for (int i=1;i&lt;n;i++)\n    {\n        int u,v; cin&gt;&gt;u&gt;&gt;v;\n        g[u].push_back(v);\n    }\n    dfs(1,0);\n    hfs(1,++idx,1);\n\n    for (int c=1;c&lt;=idx;c++)\n    {\n        int temp=chnt[c]+1;\n        fwtsiz[c]=temp;\n        fwt[c].resize(temp+1);\n        int lele=0;\n        while (temp&gt;1)\n        {\n            temp&gt;&gt;=1;\n            lele++;\n        }\n        logsiz[c]=lele;\n    }\n\n    for (int i=1;i&lt;=n;i++)\n    {\n        cin&gt;&gt;ima[i];\n        if (ima[i])\n        {\n            add(chin[i],dub[i]-dub[president[i]]+1);\n        }\n    }\n\n    vector&lt;int&gt; cvormenjaniz(n);\n    for (int i=0;i&lt;n;i++) cin&gt;&gt;cvormenjaniz[i];\n\n    for (int i=1;i&lt;=n;i++)\n    {\n        int cvormenja=cvormenjaniz[i-1];\n        if (cvormenja)\n        {\n            if (ima[cvormenja]) rmv(chin[cvormenja],dub[cvormenja]-dub[president[cvormenja]]+1);\n            else add(chin[cvormenja],dub[cvormenja]-dub[president[cvormenja]]+1);\n            ima[cvormenja]=!ima[cvormenja];\n        }\n\n        int p=i; //pocetni cvor\n        int k=i; //jacina skoka\n        int skokova=0;\n        while (true)\n        {\n            skokova++;\n            if (dub[p]&lt;=k) break;\n            int newp=MaxUpwalk(p,k);\n            if (newp==-1 || newp==p) goto nemoze;\n            p=newp;\n        }\n\n        cout&lt;&lt;skokova&lt;&lt;\" \";\n        continue;\n        nemoze: cout&lt;&lt;-1&lt;&lt;\" \";\n\n        //cout&lt;&lt;endl&lt;&lt;endl;\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/01_usamljenost/","title":"B1 - Usamljenost","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 300ms 64MB <p>U godini \\(3024\\) takmi\u010denja iz matematike i fizike se i dalje rade na papiru, a postala su toliko sli\u010dna da se sada odr\u017eavaju na istom mestu.</p> <p>Ovogodi\u0161nje izglasano mesto odr\u017eavanja je Kineski zid. Nakon zavr\u0161etka izrade zadataka, u\u010denici takmi\u010dari ovih dveju oblasti okupili su se zajedno na zidu i pore\u0111ali u ogroman red. Poznato je da se svaki u\u010denik takmi\u010di iz ta\u010dno jedne oblasti - ili matematike ili fizike. Tako\u0111e, njih je mogu\u0107e numerisati prirodnim brojevima od \\(1\\) do \\(N\\), gde \\(N\\) predstavlja ukupan broj takmi\u010dara. Za svakog od njih je, naravno, poznata oblast iz koje se takmi\u010di.</p> <p>Profesor Vang odlu\u010dio je da slika svaku grupu od barem \\(3\\) u\u010denika. Ta\u010dnije, uslika\u0107e sve segmente uzastopnih takmi\u010dara du\u017eine barem \\(3\\). Dakle, za svako \\(1 \\leq L \\leq R \\leq N,\\ R-L \\geq 2\\), on je uslikao u\u010denike sa rednim brojevima \\(L,L+1,\\ldots, R\\).</p> <p>Nakon \u0161to je Vang ostavio slike na stolu, svi takmi\u010dari su navalili da ih pogledaju. Neki od njih su se mo\u017eda osetili razo\u010darano jer su se na\u0161li usamljeni na slici. To se de\u0161ava ukoliko je njegova oblast takmi\u010denja (matematika ili fizika) druga\u010dija od svih ostalih takmi\u010dara na slici. Potpuno revoltirani ovom katastrofom, takvi su pocepali sve slike na kojoj su ispali usamljeni.</p> <p>Ovo je zanemarljiva bol za profesora Vanga, ali velika tragedija za \u010dove\u010danstvo. Po\u0161to je on zauzet pregledanjem radova, upitao je Vas da mu ka\u017eete koliko je slika ukupno bilo pocepano.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Vladimir Milovanovi\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107 Aleksandar Vi\u0161nji\u0107"},{"location":"takprog/2023_2024/okr/01_usamljenost/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, nalazi se pozitivan ceo broj \\(N\\) - ukupan broj takmi\u010dara.</p> <p>U drugom redu standardnog ulaza, nalazi se niska \\(S\\) du\u017eine \\(N\\). Ona predstavlja, redom, oblasti iz koje se svaki takmi\u010dar takmi\u010di. Slovo <code>M</code> predstavlja matemati\u010dara, a slovo <code>F</code> predstavlja fizi\u010dara.</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati jedan nenegativan ceo broj - broj pocepanih slika.</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/01_usamljenost/#ulaz","title":"Ulaz","text":"<pre><code>6\nMFMFMF\n</code></pre>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#izlaz","title":"Izlaz","text":"<pre><code>4\n</code></pre>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Pocepane su slike koje odgovaraju segmentima u\u010denika \\([1,3]\\), \\([2,4]\\), \\([3,5]\\) i \\([4,6]\\).</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/01_usamljenost/#ulaz_1","title":"Ulaz","text":"<pre><code>5\nMMMMF\n</code></pre>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Pocepane su slike koje odgovaraju segmentima \\([1,5]\\), \\([2,5]\\) i \\([3,5]\\).</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(3 \\leq N \\leq 100\\,000\\)</li> <li>\\(|S| = N\\), niska \\(S\\) sastoji se od latini\u010dnih slova <code>M</code> i <code>F</code> (isklju\u010divo velikih).</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U testovima vrednim 30 poena: \\(N \\leq 100\\);</li> <li>U testovima vrednim 40 poena: \\(N \\leq 5\\,000\\);</li> <li>U testovima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#resenje-kada-nleq-100","title":"Re\u0161enje kada \\(N\\leq 100\\)","text":"<p>Prolazimo po podnizovima uzastopnih u\u010denika preko dve ugne\u017e\u0111ene petlje. Zatim za svaki podniz proveravamo da li je usamljen ili ne. Broj podnizova je \\(O(N^2)\\), a slo\u017eenost provere za svaki je \\(O(N)\\). Stoga je ukupna vremenska slo\u017eenost \\(O(N^3)\\).</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#resenje-kada-nleq-5000","title":"Re\u0161enje kada \\(N\\leq 5\\,000\\)","text":"<p>Ponavljamo ideju prethodnog podzadataka - prolazimo po svim podnizovima. Proveru je neophodno izvr\u0161iti efikasnije. Najjednostavnije je to u\u010diniti narednim pseudo-kodom, u kome \"usputno\" ra\u010dunamo broj matemati\u010dara i fizi\u010dara:</p> <pre><code>for (i in [1,N]):\nbr_mat=0\nbr_fiz=0\nfor (j in [i,N]):\nif S[i] is 'M':\nbr_mat+=1\nif S[i] is 'F':\nbr_fiz+=1\n</code></pre> <p>Vremenska slo\u017eenost je \\(O(N^2)\\).</p>"},{"location":"takprog/2023_2024/okr/01_usamljenost/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Prethodnu iteraciju zamenjujemo matemati\u010dkom formulom. Za svakog u\u010denika prebrojavamo broj slika koje je pocepao. Primetimo da ne postoji slika koja je pocepana od strane dva ili vi\u0161e u\u010denika, po\u0161to svaka slika du\u017eine barem \\(3\\) ima najvi\u0161e jednog usamljenog u\u010denika.</p> <p>Neka su \\(F_1 &lt; F_2 &lt; \\ldots &lt; F_K\\) pozicije svih fizi\u010dara. Za \\(1 &lt; i &lt; K\\) va\u017ei da je fizi\u010dar \\(i\\) pocepao slike koje predstavljaju pod-intervale \\([L,R] \\subseteq [F_{i-1}+1,F_{i+1}-1]\\) koji sadr\u017ee \\(i\\). Ta\u010dnije, va\u017ei \\(F_{i+1}+1 \\leq L \\leq F_i\\) i \\(F_i \\leq R \\leq F_{i+1}-1\\). </p> <ul> <li>Za \\(L\\) imamo \\(F_i - F_{i-1}\\) opcija;</li> <li>Za \\(R\\) imamo \\(F_{i+1}-F_i\\).</li> </ul> <p>Kako je izbor \\(L\\) i \\(R\\) nezavisan, ukupan broj izbora je \\((F_i-F_{i-1}) \\cdot (F_{i+1}-F_i) - 3\\). Oduzimamo podnizove du\u017eine manje od \\(3\\) (njih ima ta\u010dno \\(3\\)). Ukoliko je vrednost izraza negativna, uzimamo \\(0\\) (de\u0161ava se da u\u010denik ne pocepa nijednu sliku).</p> <p>Prilikom ra\u010dunanja formule, u slu\u010daju \\(i=1\\) mo\u017eemo uzeti \\(F_{i-1}=F_i\\), a u slu\u010daju \\(i=K\\) mo\u017eemo uzeti \\(F_{i+1}=F_i\\).</p> <p>Sada znamo kako da za svakog fizi\u010dara izra\u010dunamo broj slika koje je pocepao. Isti postupak primenjujemo i za matemati\u010dare. Kada sve brojeve dobijene kao rezultate formula prosumiramo, dobijamo kona\u010dan odgovor. Slo\u017eenost navedenog re\u0161enja je \\(O(N)\\).</p> 01_usamljenost.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n; cin&gt;&gt;n;\n    string s; cin&gt;&gt;s;\n    vector&lt;int&gt; blokovi;\n    blokovi.push_back(1);\n    for (int i=1;i&lt;(int)s.size();i++)\n    {\n        if (s[i]==s[i-1]) blokovi.back()++;\n        else blokovi.push_back(1);\n    }\n\n    if ((int)blokovi.size()==1)\n    {\n        cout&lt;&lt;0&lt;&lt;endl;\n        return 0;\n    }\n\n    long long odg=0;\n    odg+=blokovi[1]-1;\n    for (int i=1;i&lt;(int)blokovi.size()-1;i++)\n    {\n        if (blokovi[i]==1)\n        {\n            odg+=(long long)(blokovi[i-1]+1)*(blokovi[i+1]+1)-3;\n        }\n        else\n        {\n            odg+=(blokovi[i-1]-1);\n            odg+=(blokovi[i+1]-1);\n        }\n    }\n    odg+=blokovi[(int)blokovi.size()-2]-1;\n\n    cout&lt;&lt;odg&lt;&lt;endl;\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/","title":"B2 - Dejn","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 64MB <p>Policajac Dejn va\u017ei za vrlo strogog \u0161efa u policijskoj stanici. Ipak, jedno je odr\u017eavati autoritet u stanici, a drugo u ku\u0107i sa nesta\u0161nim sinom tinejd\u017eerom Petru\u0107ijem. Dejnu najvi\u0161e smeta kada mu sin u pola no\u0107u ulazi u stan i probudi ga, pa on ne mo\u017ee da se uspava po drugi put. U poku\u0161aju da zavede red u sopstvenom domu, Dejn je instalirao senzor koji bele\u017ei kada je neko u\u0161ao u stan ili iza\u0161ao iz stana.</p> <p>Dejn uklju\u010duje senzor uve\u010de, dok je Petru\u0107i jo\u0161 uvek u stanu, a isklju\u010duje ujutru pred posao, kada mu sin uveliko spava u sobi. Po isklju\u010denju, senzor mu daje niz \\(t\\) od \\(n\\) brojeva. \u010clan \\(t_i\\) tog niza je negativan ukoliko je re\u010d o ulasku u stan, a pozitivan ukoliko je re\u010d o izlasku iz stana. Apsolutna vrednost \u010dlana \\(t_i\\) ozna\u010dava trenutak u kom se akcija ulaska ili izlaska desila.</p> <p>Petru\u0107i je opasan programer-haker i redovno upada u vezu sa senzorom i poku\u0161ava da omete Dejnovu akciju! Naime, pre nego \u0161to Dejn preuzme niz, njegov sin izme\u0161a taj niz. Va\u0161 zadatak je da pomognete Dejnu da ustanovi da li je niz koji dobio ispravan niz ulazaka i izlazaka iz stana u nekom poretku, i ukoliko jeste, da izra\u010dunate koliko dugo je Dejnov sin bio van stana.</p> <p>Pretpostavimo da postoji raspored \u010dlanova niza \\(t\\) tako da on predstavlja ispravnu sekvencu ulazaka i izlazaka Petru\u0107ija iz stana. Ako je Petru\u0107i napustio stan u trenutku \\(t_1\\), i vratio se u stan u trenutku \\(t_2\\), onda Dejn ra\u010duna da je Petru\u0107i proveo \\(t_2 - t_1\\) trenutaka van stana.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Andrej Iva\u0161kovi\u0107 Marko Milenkovi\u0107 Vladimir Milovanovi\u0107 Andrej Iva\u0161kovi\u0107"},{"location":"takprog/2023_2024/okr/02_dejn/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se prirodan broj \\(T\\) \u2013 broj test primera.</p> <p>Svaki test primer je u slede\u0107em formatu:</p> <p>U prvoj liniji test primera nalazi se prirodan broj \\(n\\) \u2013 du\u017eina niza \\(t\\).</p> <p>U drugoj liniji test primera se nalazi niz od \\(n\\) celih brojeva \\(t\\) \u2013 gde ceo broj \\(t_i\\) predstavlja Petru\u0107ijev izlazak iz stana u trenutku \\(t_i\\) ukoliko je \\(t_i &gt; 0\\), odnosno Petru\u0107ijev ulazak u stan u trenutku \\(-t_i\\), ukoliko je \\(t_i &lt; 0\\).</p>"},{"location":"takprog/2023_2024/okr/02_dejn/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(T\\) test primera ispisati po jednu liniju izlaza u slede\u0107em formatu:</p> <p>Ukoliko postoji raspored elemenata niza \\(t\\) tako da on predstavlja ispravnu sekvencu Petru\u0107ijevih ulazaka i izlazaka iz stana, ispisati koliko trenutaka je Dejnov sin proveo van stana. U suprotnom, ispisati <code>-1</code>.</p>"},{"location":"takprog/2023_2024/okr/02_dejn/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/02_dejn/#ulaz","title":"Ulaz","text":"<pre><code>1\n6\n10 3 -5 7 -8 -15\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#izlaz","title":"Izlaz","text":"<pre><code>8\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Senzor detektuje izlaske u trenucima: \\(3\\), \\(7\\) i \\(10\\), a ulaske u trenucima \\(5\\), \\(8\\) i \\(15\\). Postoji ispravna sekvenca ulazaka i izlazaka iz stana u toku no\u0107i. Petru\u0107i je prvo iza\u0161ao iz stana u trenutku \\(3\\), zatim se vratio u stan u trenutku \\(5\\). Ponovo je iza\u0161ao iz stana u trenutku \\(7\\) i vratio se u trenutku \\(8\\). Na kraju, iza\u0161ao je u trenutku \\(10\\) i u\u0161ao u stan u trenutku \\(15\\). Ukupno je van stana proveo \\((5-3) + (8-7) + (15-10) = 8\\) trenutaka.</p>"},{"location":"takprog/2023_2024/okr/02_dejn/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/02_dejn/#ulaz_1","title":"Ulaz","text":"<pre><code>1\n4\n8 -2 -15 17\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#izlaz_1","title":"Izlaz","text":"<pre><code>-1\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Iz postavke zadatka znamo da je Petru\u0107i na po\u010detku ve\u010deri, kada Dejn uklju\u010di senzor, u svojoj sobi u stanu. Nije mogu\u0107e da se Petru\u0107i vrati u stan u trenutku \\(2\\), jer prethodno ga nije ni napu\u0161tao.</p>"},{"location":"takprog/2023_2024/okr/02_dejn/#primer-3","title":"Primer 3","text":""},{"location":"takprog/2023_2024/okr/02_dejn/#ulaz_2","title":"Ulaz","text":"<pre><code>2\n5\n10 -11 5 -6 15\n8\n12 -14 15 -15 15 -15 20 -21\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#izlaz_2","title":"Izlaz","text":"<pre><code>-1\n3\n</code></pre>"},{"location":"takprog/2023_2024/okr/02_dejn/#objasnjenje_2","title":"Obja\u0161njenje","text":"<p>U prvom test primeru, iz postavke zadatka znamo da je Petru\u0107i ujutru, kada Dejn isklju\u010di senzor, u svojoj sobi u stanu. Nije mogu\u0107e da Petru\u0107i u trenutku \\(15\\) napusti stan, jer se nikad kasnije ne vra\u0107a u njega.</p> <p>U drugom test primeru, Petru\u0107i izlazi iz stana u trenutku \\(12\\) i vra\u0107a se u stan u trenutku \\(14\\), pa je ukupno bio \\(2\\) trenutka van stana. Zatim je ulazio i izlazio u trenutku \\(15\\) po dva puta i tu je ukupno bio \\(0\\) trenutaka van stana. Na kraju, Petru\u0107i je iza\u0161ao iz stana u trenutku \\(20\\) i vratio se u stan u trenutku \\(21\\), \u0161to zna\u010di da je bio van stana jedan trenutak. Kada sve saberemo, Petru\u0107i je van stana ukupno bio \\(2+0+1=3\\) trenutaka.</p>"},{"location":"takprog/2023_2024/okr/02_dejn/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 5\\)</li> <li>\\(1 \\leq n \\leq 10^5\\)</li> <li>\\(1 \\leq \\mid t_i \\mid \\leq 10^9\\), za \\(1 \\leq i \\leq n\\)</li> </ul> <p>Test primeri su podeljeni u tri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 30 poena: \\(1 \\leq n \\leq 1000\\);</li> <li>U test primerima vrednim 30 poena: \\(1 \\leq \\mid t_i \\mid \\leq 10^5\\);</li> <li>U test primerima vrednim 40 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/02_dejn/#napomena","title":"Napomena","text":"<p>Primetite da je mogu\u0107e da Petru\u0107i u istom trenutku vi\u0161e puta ulazi i izlazi iz stana (desi se da je zaboravio nov\u010danik, parfem, ...). </p>"},{"location":"takprog/2023_2024/okr/02_dejn/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Po\u0161to je ve\u0107 dat celobrojni niz \\(t\\) u kome \u010dlanovi niza \\(t_i\\) ako su strogo pozitivni, \\(t_i&gt;0\\), predstavljaju izlazak, a ukoliko su negativni, \\(t_i&lt;0\\) ulazak, to je najsvrsishodnije najpre ispitati da li je broj izlazaka jednak broju ulazaka i ispisati <code>-1</code> ako se utvrdi da broj strogo pozitivnih \u010dlanova ne odgovara broju negativnih \u010dlanova niza. Ovo prebrajanje pozitivnih i negativnih \u010dlanova mogu\u0107e je izvesti jednim prolaskom kroz sve \u010dlanove niza, odnosno u vremenskoj slo\u017eenosti \\(\\mathcal{O}(n)\\), gde je \\(n\\) broj \u010dlanova niza.</p> <p>Da bi se olak\u0161alo dalje ispitivanje zadati niz \\(t\\) se mo\u017ee zatim sortirati po apsolutnoj vrednosti bez mutiranja istog tako da se dobije monotono rastu\u0107i niz, ta\u010dnije monotono neopadaju\u0107i niz prema apsolutnoj vrednosti jer se vrednosti u nizu mogu ponavljati. Sortiranje je mogu\u0107e izvr\u0161ti u vremenskoj slo\u017eenosti \\(\\mathcal{O}(n \\log n)\\) koriste\u0107i se nekim od efikasnih algoritama ili bibliote\u010dkim funkcijama koje ih koriste.</p> <p>Kada je niz sortiran, na jednostavan na\u010din mogu\u0107e je dovr\u0161iti proveru da li je on zaista i ispravan. Naime, svi jedinstveni \u010dlanovi niza na parnim indeksima (uklju\u010duju\u0107i i prvi) moraju biti pozitivni, a na neparnim (uklju\u010duju\u0107i i poslednji) negativni, po\u0161tuju\u0107i konvenciju da prvi \u010dlan niza ima nulti indeks. Primetiti da svi ispravni nizovi imaju parnu du\u017einu (na osnovu uslova da broj pozitivnih \u010dlanova mora biti jednak broju negativnih), odnosno da je \\(n\\) deljivo sa dva. Stoga, ako su se prvi izlazak i poslednji ulazak desili u jedinstvenim vremenskim trenucima to je prvi \u010dlan sortiranog niza pozitivan, a poslednji negativan.</p> <p>Pri proveri ispravnosti niza, neophodno je u obzir uzeti i slu\u010dajeve u kojima se izlasci i ulasci de\u0161avaju u istom vremenskom trenutku jer prilikom sortiranja ovih trenutaka po apsolutnoj vrednosti u op\u0161tem slu\u010daju ne dobijamo podniz alterniraju\u0107ih znakovnih vrednosti. Kada se kona\u010dno utvrdi ispravnost niza, ukupno vreme se ra\u010duna tako \u0161to se sukcesivno od svakog trenutka ulaska oduzme njemu odgovaraju\u0107i, to jest njemu prethode\u0107i trenutak izlaska i napravi zbir svih ovakvih razlika. Tra\u017eenu sumu razlika apsolutnih vrednosti svih uzastopnih neparnih i parnih \u010dlanova ve\u0107 sortiranog niza tako\u0111e je mogu\u0107e prona\u0107i u linearnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(n)\\), ba\u0161 kao i proveru ispravnosti tog niza.</p> <p>Kona\u010dno, kako je najslo\u017eenija operacija u prethodno opisanom re\u0161enju zapravo algoritam sortiranja, to \\(\\mathcal{O}(n \\log n)\\) predstavlja ukupnu vremensku slo\u017eenost re\u0161enja ovog zadatka koja je loglinearna po du\u017eini ulaznog niza. Iako je zadatak bilo mogu\u0107e re\u0161iti i bez upotrebe sortiranja u linearnoj vremenskoj slo\u017eenosti \\(\\mathcal{O}(n)\\) koriste\u0107i se nekim malo naprednijim strukturama podataka, ovo re\u0161enje se nije zahtevalo za maksimalan broj poena na ovom nivou takmi\u010denja.</p> 02_dejn.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair&lt;int, int&gt; pi;\ntypedef pair&lt;ll, ll&gt; pl;\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;ll&gt; vl;\ntypedef vector&lt;double&gt; vd;\ntypedef vector&lt;bool&gt; vb;\ntypedef vector&lt;char&gt; vc;\ntypedef vector&lt;string&gt; vs;\ntypedef vector&lt;pi&gt; vp;\ntypedef vector&lt;pl&gt; vpl;\n\nbool cmp(int a, int b){\n    return abs(a) &lt; abs(b);\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false); \n    cin.tie(nullptr); \n    cout.tie(nullptr); \n    cerr.tie(nullptr);  \n\n    int t;\n    cin &gt;&gt; t;\n\n    for (int e = 0; e &lt; t; ++e){\n        int n;\n        cin &gt;&gt; n;\n\n        map&lt;int, int&gt; m;\n        for (int i = 0; i &lt; n; ++i){\n            int x;\n            cin &gt;&gt; x;\n\n            if (m[-1 * x] &gt; 0){\n                --m[-1 * x];\n            } else {\n                m[x]++;\n            }\n        }\n\n        bool ok = 1;\n        vi a;\n        for (auto&amp; i : m){\n            if (i.second &gt; 1){\n                ok = 0; break;\n            }\n\n            if (i.second == 0) continue;\n            a.push_back(i.first);\n        }\n\n        sort(a.begin(), a.end(), cmp);\n        n = a.size();\n\n        if (n % 2 || !ok){\n            cout &lt;&lt; \"-1\\n\";\n            continue;\n        }\n\n        int sol = 0;\n        for (int i = 0; i &lt; n; ++i){\n            if (i % 2 &amp;&amp; a[i] &gt; 0){\n                ok = 0; break;\n            }\n\n            if (i % 2 == 0 &amp;&amp; a[i] &lt; 0){\n                ok = 0; break;\n            }\n\n            if (i % 2){\n                sol += -1 * a[i] -a[i-1];\n            }\n        }\n\n        if (!ok) sol = -1;\n        cout &lt;&lt; sol &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/","title":"B3 - Bitvajz oranje","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 2000ms 256MB <p>Anja i Bogdan igraju igru \"Njive\". Ona se igra tako \u0161to se na po\u010detku odredi broj \\(x\\) i \u0161pil karata \\(S_1, S_2, \\ldots , S_K\\). Na \\(i\\)-toj karti nalazi se \\(S_i\\) zrna kukuruza (\\(1 \\leq i \\leq K\\)). Zatim se vuku slede\u0107i potezi:</p> <ul> <li> <p>Anja bira dve karte sa \\(a\\) i \\(b\\) zrna kukuruza.</p> </li> <li> <p>Bogdan izbacuje te dve karte iz igre, a zatim ima izbor da ubaci kartu sa \\(a \\ | \\ b\\) ili \\(a\\oplus b\\) zrna kukuruza.</p> </li> <li> <p>Primetimo da se broj karata smanjuje za ta\u010dno jedan nakon ovog procesa. Igra se zavr\u0161ava kada ostane samo jedna karta. Pobednik se odre\u0111uje na osnovu vrednosti te poslednje karte. Ako ona ima \\(x\\) zrna kukuruza, onda Anja pobe\u0111uje. U suprotnom, Bogdan je pobednik.</p> </li> </ul> <p>Prisetimo se da \\(a\\ |\\ b\\) ozna\u010dava bitovsku disjunkciju, a \\(a\\oplus b\\) bitovsku ekskluzivnu disjunkciju. Na primer, \\((0110)_2 \\ |\\ (1010)_2 = (1110)_2\\) , dok \\((0110)_2 \\oplus (1010)_2 = (1100)_2\\)</p> <p>Igra jo\u0161 nije po\u010dela, a pred vama je trenutno \u0161pil karata \\(A_1,A_2,\\ldots,A_N\\). Kako igra ne bi predugo trajala, ne\u0107e se igrati na celom \u0161pilu, ve\u0107 samo na nekim njegovim uzastopnim delovima. Naime, desi\u0107e se \\(Q\\) scenarija dve vrste:</p> <ul> <li> <p>Dat je (ne nu\u017eno isti) podniz \\(A_L, A_{L+1}, \\ldots, A_R\\) \u0161pila karata, a na vama je da odredite koliko ima celih brojeva \\(x\\) (\\(0 \\leq x &lt; 2^{64}\\)) za koje Anja pobe\u0111uje nezavisno od toga koje poteze Bogdan vu\u010de.</p> </li> <li> <p>Karta \\(P\\) se pohabala, \u010dime njen novi broj zrna kukuruza postaje \\(X\\).</p> </li> </ul> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Pavle Martinovi\u0107 Aleksandar Vi\u0161nji\u0107 Pavle Martinovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza, nalazi se prirodan broj \\(N\\) koji predstavlja veli\u010dinu celog \u0161pila.</p> <p>U drugom redu standardnog ulaza, nalazi se \\(N\\) nenegativnih celih brojeva \\(A_1,A_2,\\ldots A_N\\) - opis \u0161pila.</p> <p>U tre\u0107em redu standardnog ulaza, nalazi se prirodan broj \\(Q\\) koji predstavlja broj scenarija.</p> <p>U narednih \\(i\\)-om od narednih \\(Q\\) redova, nalaze se dva cela broja \\(L_i\\) i \\(R_i\\). Ukoliko je \\(L_i&gt;0\\), onda je re\u010d o scenariju prve vrste. Igra po\u010dinje \u0161pilom za igru \\(A_{L_i}, A_{L_i + 1}, \\ldots , A_{R_i}\\). Pritom, garantuje se \\(L_i &lt; R_i\\). Ukoliko je \\(L_i&lt;0\\), onda je re\u010d o scenariju druge vrste. Tada karta \\(-L_i\\) dobija novi broj zrna kukuruza \\(R_i\\).</p> <p>Garantuje se da postoji scenario prve vrste, kao i da \\(L_i \\neq 0\\).</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki scenario prve vrste potrebno je u zasebnoj liniji ispisati broj po\u010detnih vrednosti \\(x\\) (\\(0 \\leq x &lt; 2^{64}\\)) za koje Anja pobe\u0111uje nezavisno od Bogdanovih poteza.</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#ulaz","title":"Ulaz","text":"<pre><code>5\n3 1 2 4 5\n3\n1 2\n2 4\n3 5\n</code></pre>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#izlaz","title":"Izlaz","text":"<pre><code>0\n1\n0\n</code></pre>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#ulaz_1","title":"Ulaz","text":"<pre><code>4\n1 2 3 4\n5\n-1 4\n-3 1\n1 4\n-1 192\n1 4\n</code></pre>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#izlaz_1","title":"Izlaz","text":"<pre><code>0\n1\n</code></pre>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq N \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq Q \\leq 2\\cdot 10^5\\)</li> <li>\\(1 \\leq A_i &lt; 2^{60}\\)</li> </ul> <p>Test primeri su podeljeni u \u0161est disjunktnih grupa:</p> <ul> <li>U testovima vrednim 8 poena: \\(N=2\\);</li> <li>U testovima vrednim 16 poena: Mogu\u0107e vrednosti karata su \\(1\\), \\(2\\) i \\(3\\);</li> <li>U testovima vrednim 16 poena: Mogu\u0107e vrednosti karata su oblika \\(2^x\\) za neki ceo broj \\(x\\);</li> <li>U testovima vrednim 16 poena: \\(N \\leq 100\\);</li> <li>U testovima vrednim 16 poena: Nema upita druge vrste;</li> <li>U testovima vrednim 28 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#resenje-kada-n2","title":"Re\u0161enje kada \\(N=2\\)","text":"<p>Vidimo da ukoliko je u pitanju interval du\u017eine \\(1\\), Anja ima pobedni\u010dku strategiju samo sa jedan broj (upravo tu vrednost). Ukoliko je interval du\u017eine \\(2\\), onda Bogdan bira da li \u0107e na ta dva primeniti <code>or</code> ili <code>xor</code>, tako da Anja mo\u017ee pobediti samo za jednu vrednost i to samo ukoliko su \\(a\\bigoplus b\\) i \\(a|b\\) jednaki. </p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#kada-anja-ima-pobednicku-strateiju","title":"Kada Anja ima pobedni\u010dku strateiju?","text":"<p>Doka\u017eimo slede\u0107e tvr\u0111enje: Za svaki poziciju bita \\(i\\) pogledajmo u koliko elemenata je inicijalno postavljen na \\(1\\). Ukoliko je svaki bit najvi\u0161e jednom postavljen na \\(1\\), onda Anja pobe\u0111uje za ta\u010dno jednu vrednost, a ukoliko nije tako, onda Anja nikad ne pobe\u0111uje.</p> <p>Zaista, ako se svaki bit javlja najvi\u0161e jednom, onda ma \u0161ta radili Anja i Bogdan, na kraju \u0107e se dobiti broj koji ima jedinice upravo na pozicijama na kojima postoji jedinica na nekom inicijalnih brojeva. (ovo se mo\u017ee npr formalno videti indukcijom). Ukoliko postoji neki bit na kom bar dva inicijalna broja imaju jedinice, onda Bogdan mo\u017ee da namesti da je vrednost na toj poziciji ili \\(0\\) ili \\(1\\) na kraju kako \u017eeli, i samim tim izbegne bilo koji Anjin ciljni broj. Naime, on mo\u017ee da uvek bira da radi \\(a|b\\), dok ne ostanu ta\u010dno dva broja sa tim bitom. Nadalje radi proizvoljno dok ga ne pita upravo za ta dva broja \u0161to imaju jedinicu na bitu koji posmatramo (ako u\u010destvuje samo jedan takav broj u operaciji, ne smeta Bogdanu ni\u0161ta jer \u0161ta god radio, novi broj \u0107e opet imati jedinicu na toj poziciji, pa \u0107e jo\u0161 uvek ostati ta\u010dno dva broja sa jedinicom na toj poziciji). Ukoliko \u017eeli da dobije na kraju \\(0\\) na toj poziciji, uradi\u0107e \\(a\\bigoplus b\\) i ne\u0107e ostati nijedna jedinica na toj poziciji, pa \u0107e i na kraju tu biti \\(0\\). Sa druge strane ako \u017eeli na kraju da dobije \\(1\\) na toj poziciji, uradi\u0107e \\(a|b\\), pa \u0107e ostati jedna jedinica na toj poziciji, a nadalje \u0161ta god Anja i Bogdan radili \u0107e ostati ta\u010dno jedna jedinica na toj poziciji, sli\u010dno prvom re\u0161enju. Ovime je tvr\u0111enje dokazano.</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#resenje-kada-su-sve-vrednosti-1-2-ili-3","title":"Re\u0161enje kada su sve vrednosti \\(1\\), \\(2\\) ili \\(3\\)","text":"<p>Mo\u017ee se  lako dokazati iz prethodnog da ovde Anja ima pobedni\u010dku strategiju za jednu vrednost ako je niz du\u017eine \\(1\\) ili je skup karata upravo \\(\\{1,2\\}\\), u suprotnom je odgovor \\(0\\). </p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#resenje-kada-su-sve-vrednosti-stepeni-dvojke","title":"Re\u0161enje kada su sve vrednosti stepeni dvojke","text":"<p>Mo\u017ee se dokazati iz prethodnog da ovde Anja ima pobedni\u010dku strategiju za jednu vrednost ako  i samo ako su sve vrednosti niza razli\u010dite, a u suprotnom je odgovor \\(0\\). Implementaciju ovog mo\u017eemo uraditi tako \u0161to ako je interval du\u017eine preko \\(60\\) samo ka\u017eemo da je odgovor \\(0\\) (jer postoji samo \\(60\\) razli\u010ditih vrednosti), a u suprotnom mo\u017eemo da ga sortiramo i vidimo da li su susedne vrednosti razli\u010dite, \u0161to nam daje da na svaki upit mo\u017eemo odgovoriti u slo\u017eenosti \\(O(\\log\\max A_i\\log\\log\\max A_i)\\).</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#resenje-kada-je-nleq-100","title":"Re\u0161enje kada je \\(N\\leq 100\\)","text":"<p>Ovde za svaki bit mo\u017eemo da idemo redom kroz i vidimo da li je na jedinstvenoj poziciji setovan na jedan, i time svaki upit re\u0161imo u \\(O(N\\log\\max A_i)\\).</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#resenje-kada-nema-upita-prvog-tipa","title":"Re\u0161enje kada nema upita prvog tipa","text":"<p>Ukoliko nema promena niza, mo\u017eemo za svaki bit da zapamtimo prvo slede\u0107e i prvo prethodno pojavljivanje na svakoj poziciji. Onda mo\u017eemo preko tih nizova lako u \\(O(\\log\\max A_i)\\) po upitu da na\u0111emo odgovor.</p>"},{"location":"takprog/2023_2024/okr/03_bitvajz_oranje/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Sli\u010dno kao u tre\u0107em zadatku vidimo da   ako je interval du\u017eine \\(&gt;60\\) onda je odgovor \\(0\\). Zaista, jer je svaki broj pozitivan, svaki ima barem po jedan bit setovan na \\(1\\), ali onda po Dirihleovom principu mora da postoje dva broja sa zajedni\u010dkim bitom, pa Anja ne mo\u017ee da pobedi. Ako je interval du\u017eine do \\(60\\) mo\u017eemo da izvr\u0161imo proveru u linearnom vremenu kao u \\(4\\) podzadatku, pa nam treba \\(O(\\log^2\\max A_i)\\) po upitu.</p> 03_bitvajz_oranje.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nlong long typedef ll;\n\nll a[200005];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0),cout.tie(0);\n\n    int n; cin&gt;&gt;n;\n    for (int i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n    int q; cin&gt;&gt;q;\n    while (q--)\n    {\n        int l; cin&gt;&gt;l;\n        if (l&lt;0)\n        {\n            ll r; cin&gt;&gt;r;\n            a[-l-1]=r;\n        }\n        else\n        {\n            int r; cin&gt;&gt;r;\n            if (r-l&gt;=60)\n            {\n                cout&lt;&lt;0&lt;&lt;\"\\n\";\n                continue;\n            }\n\n            ll x=0;\n            bool moze=true;\n            for (int i=l-1;i&lt;=r-1;i++)\n            {\n                if (x&amp;a[i])\n                {\n                    moze=false;\n                    break;\n                }\n                x|=a[i];\n            }\n\n            if (moze) cout&lt;&lt;1&lt;&lt;\"\\n\";\n            else cout&lt;&lt;0&lt;&lt;\"\\n\";\n        }\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/04_xormutacije/","title":"A1 - Xormutacije","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 1000ms 256MB <p>Stefan je od nedavno postao profesor na jednom vrlo presti\u017enom univerzitetu i povodom toga organizuje \u017eurku. Ipak, organizacija mu nikad nije bila ja\u010da strana, pa je zakazao \u017eurku u sred ispitnog roka!</p> <p>Na ispitu je Stefan dao svakom studentu po jedan niz \\(P\\) du\u017eine \\(N+1\\) u kome se svaki od brojeva \\(0,1,2,\\ldots,N\\) pojavljuje ta\u010dno jednom. Zadatak im je da konstrui\u0161u jo\u0161 jedan takav niz \\(Q\\) tako da slede\u0107i izraz bude najve\u0107i mogu\u0107:</p> \\[ X = (P_0 \\oplus Q_0) + (P_1 \\oplus Q_1) + \\ldots + (P_N \\oplus Q_N). \\] <p>Kako biste pomogli Stefanu da se \u0161to pre vrati na \u017eurku, na koju kasni iako je organizator, potrebno je da napi\u0161ete program koji \u0107e za zadat niz \\(P\\) ispisati najve\u0107u mogu\u0107u vrednost izraza \\(X\\) i odgovaraju\u0107i niz \\(Q\\). Ukoliko postoji vi\u0161e odgovaraju\u0107ih nizova \\(Q\\), ispisati bilo koji. </p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Marko Milenkovi\u0107 Marko Milenkovi\u0107 Marko Milenkovi\u0107 Pavle Martinovi\u0107"},{"location":"takprog/2023_2024/okr/04_xormutacije/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvoj liniji ulaza nalazi se prirodan broj \\(T\\) - broj test primera.</p> <p>Svaki test primer je u slede\u0107em formatu: U prvoj liniji test primera nalazi se prirodan broj \\(N\\).</p> <p>U drugoj liniji test primera se nalazi niz \\(P\\) od \\(N+1\\) brojeva \\(P_0, P_1, \\ldots, P_N\\).</p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#opis-izlaza","title":"Opis izlaza","text":"<p>Za svaki od \\(T\\) test primera ispisati po dve linije izlaza u slede\u0107em formatu:</p> <p>U prvoj liniji izlaza ispisati vrednost izraza \\(X\\).</p> <p>U drugoj liniji izlaza ispisati \\(N\\) brojeva koji predstavljaju niz \\(Q\\).</p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/04_xormutacije/#ulaz","title":"Ulaz","text":"<pre><code>1\n5\n4 1 3 2 0 5\n</code></pre>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#izlaz","title":"Izlaz","text":"<pre><code>30\n3 0 4 5 1 2\n</code></pre>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Vrednost izraza \\(X\\) jednaka je \\((4 \\oplus 3) + (1 \\oplus 0) + (3 \\oplus 4) + (2 \\oplus 5) + (0 \\oplus 1) + (5 \\oplus 2) = 7+1+7+7+1+7=30\\) i mo\u017ee se pokazati da ni za jedan drugi niz \\(Q\\) ne dosti\u017ee ve\u0107u vrednost.</p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/04_xormutacije/#ulaz_1","title":"Ulaz","text":"<pre><code>2\n3\n0 1 3 2\n2\n0 2 1\n</code></pre>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#izlaz_1","title":"Izlaz","text":"<pre><code>12\n3 2 0 1\n6\n0 1 2\n</code></pre>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq T \\leq 5\\)</li> <li>\\(1 \\leq N \\leq 10^5\\)</li> <li>\\(1 \\leq P_i \\leq N\\) i svaka od ovih vrednosti se pojavljuje ta\u010dno jednom.</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 10 poena: \\(T = 1\\) i \\(1 \\leq N \\leq 9\\);</li> <li>U test primerima vrednim 30 poena: \\(N+1\\) je stepen dvojke;</li> <li>U test primerima vrednim 40 poena: \\(P_i = i\\) za svako \\(0 \\leq i \\leq N\\);</li> <li>U test primerima vrednim 20 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#napomena","title":"Napomena","text":"<p>Operator \\(\\oplus\\) predstavlja operaciju isklju\u010dive disjunkcije.</p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#t-1-i-n-leq-9","title":"\\(T = 1\\) i \\(N \\leq 9\\)","text":"<p>U ovom podzadatku je dovoljno izgenerisati sve permutacije du\u017eine \\(N+1\\) i izra\u010dunati za svaku od njih izraz \\(X\\). Kako bi se izbegla nepotrebna konstanta \\(N\\) u slo\u017eenosti, izraz \\(X\\) ra\u010dunamo dok generi\u0161emo sve permutacije. Ukupna slo\u017eenost je onda \\(\\mathcal{O}((N+1)!)\\) ili \\(\\mathcal{O}((N+1)! \\cdot N)\\) u zavisnosti od toga kako ra\u010dunamo izraz \\(X\\). </p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#n1-je-stepen-dvojke","title":"\\(N+1\\) je stepen dvojke","text":"<p>Primetimo da je mogu\u0107e da uparimo brojeve \\(x\\) i \\(N-x\\). Oni su komplementarni u binarnom zapisu - kada na nekom mestu u binarnom zapisu broj \\(x\\) ima jedinicu, tada je na istom tom mestu nula u broju \\(N-x\\), i obrnuto. To zna\u010di da \u0107e \\(\\oplus\\) svakog para biti \\(N\\), a onda i ukupna suma \\(N\\cdot(N+1)\\). Vremenska slo\u017eenost ovog algoritma je \\(\\mathcal{O}(N)\\). </p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#p_i-i-za-svako-i-0-1-2-ldots-n","title":"\\(P_i = i\\) za svako \\(i = 0, 1, 2, \\ldots, N\\)","text":"<p>Primetimo da ukoliko imamo re\u0161enje kada va\u017ei \\(P_i = i\\), onda imamo i re\u0161enje u op\u0161tem slu\u010daju - samo je potrebno da izmapiramo koji element ide kome umesto da ih ispisujemo redom za \\(i=0,1,2,\\ldots,N\\). </p>"},{"location":"takprog/2023_2024/okr/04_xormutacije/#resenje-bez-dodatnih-ogranicenja","title":"Re\u0161enje bez dodatnih ograni\u010denja","text":"<p>Posmatrajmo najve\u0107i broj \\(K\\) manji od \\(N\\), za koji va\u017ei da je \\(K+1\\) stepen dvojke. Jasno je da ukoliko uparimo \\(K\\) i \\(K+1\\) ne gubimo nijedan bit primenom operacije \\(\\oplus\\), jer su komplementarni brojevi u binarnom zapisu. Isto to va\u017ei i za brojeve \\(K-1\\) i \\(K+2\\), \\(K-2\\) i \\(K+3\\), i tako dalje. Nakon \u0161to uparimo broj \\(N\\) sa njegovim parnjakom, rekurzivno re\u0161avamo za preostale brojeve. Iz ove konstrukcije se lako mo\u017ee pokazati da je najve\u0107a mogu\u0107a vrednost izraza \\(X\\) upravo jednaka \\(N(N+1)\\). U zavisnosti od implementacije mapiranja elementa ili pronala\u017eenja broja \\(K\\), ukupna vremenska slo\u017eenost bi\u0107e \\(\\mathcal{O}(N)\\) ili \\(\\mathcal{O}(N\\log N)\\).</p> 04_xormutacije.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair&lt;int, int&gt; pi;\ntypedef pair&lt;ll, ll&gt; pl;\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;ll&gt; vl;\ntypedef vector&lt;double&gt; vd;\ntypedef vector&lt;bool&gt; vb;\ntypedef vector&lt;char&gt; vc;\ntypedef vector&lt;string&gt; vs;\ntypedef vector&lt;pi&gt; vp;\ntypedef vector&lt;pl&gt; vpl;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false); \n    cin.tie(nullptr); \n    cout.tie(nullptr); \n    cerr.tie(nullptr);  \n\n    int t;\n    cin &gt;&gt; t;\n\n    for (int e = 0; e &lt; t; ++e){\n        int n;\n        cin &gt;&gt; n;\n\n        vi a(n+1);\n        for (int i = 0; i &lt;= n; ++i){\n            cin &gt;&gt; a[i];\n        }\n\n        vi res(n+1,0);\n        int sol = 0;\n        while(n){\n            int k = log2(n);\n\n            int m = 1&lt;&lt;k, suprotan = m-1;\n            for (int i = m; i &lt;= n; --suprotan, ++i){\n                res[i] = suprotan;\n                res[suprotan] = i;\n                sol += (i^suprotan) * 2;\n            }\n\n            n=suprotan;\n        }\n\n\n        cout &lt;&lt; sol &lt;&lt; '\\n';\n        for (int i = 0; i &lt; res.size(); ++i)\n            cout &lt;&lt; res[a[i]] &lt;&lt; ' ';\n        cout &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/05_monopol/","title":"A2 - Monopol","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 700ms 64MB <p>Godina je 3024 i ljudska rasa kolonizovala je ve\u0107i deo Sun\u010devog sistema. Me\u0111uplanetarna trgovina cveta, a najvrednija roba su bitovi. Sanja je ambiciozna mlada prodava\u010dica bitova, koja ima plan da zavlada tr\u017ei\u0161tem bitova na najve\u0107oj planeti Sun\u010devog sistema, Jupiteru. </p> <p>Na Jupiteru postoji \\(N\\) gradova, numerisanih brojevima od \\(1\\) do \\(N\\). Ovi gradovi su povezani putevima tako da je grad \\(i\\) povezan sa gradom \\(i+1\\) za sve \\(i=1, \\dots,  N-1\\). Tako\u0111e, gradovi \\(1\\) i \\(N\\) su povezani. Svi putevi su iste du\u017eine.</p> <p>Kako su bitovi nasu\u0161na potreba svakog stanovnika Jupitera, postoji \\(K\\) prodavnica bitova, koje se nalaze u gradovima \\(A_1, \\dots,  A_K\\). Stanovnici Jupitera ne vole preterano da putuju, pa biraju da svakog jutra kupe bitove u prodavnici koja je najbli\u017ea gradu u kojem \u017eive. Ukoliko je grad \\(i\\) podjednako udaljen od dve prodavnice bitova, pola stanovnika tog grada kupova\u0107e bitove u jednoj, a pola u drugoj prodavnici.</p> <p>Sanja je odlu\u010dila da izgradi \\(M\\) novih prodavnica bitova, s ciljem da preuzme monopol nad tr\u017ei\u0161tem, to jest da vi\u0161e od pola stanovnika Jupitera kupuje bitove u njenim prodavnicama. Zato je napravila detaljnu analizu tr\u017ei\u0161ta i saznala da u gradu \\(i\\) \u017eivi ta\u010dno \\(X_i\\) stanovnika.</p> <p>Naravno, Sanja bi htela da u\u0161tedi i zato planira da izgradi minimalan broj prodavnica. Zato Vas je zamolila da joj pomognete i odredite minimalan broj prodavnica koje treba da izgradi tako da postigne monopol na tr\u017ei\u0161tu ili da prijavite da to nije mogu\u0107e. Pri tome, morate po\u0161tovati zakone Jupitera koji propisuju da se dve prodavnice bitova ne smeju nalaziti u istom gradu.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Bogdan Petrovi\u0107 Aleksa Milojevi\u0107 Aleksa Milisavljevi\u0107 Aleksa Milisavljevi\u0107"},{"location":"takprog/2023_2024/okr/05_monopol/#opis-ulaza","title":"Opis ulaza","text":"<p>Na prvoj liniji standardnog ulaza dati su brojevi \\(N\\) i \\(K\\), koji predstavljaju broj gradova i broj prodavnica bitova na Jupiteru.</p> <p>U drugoj liniji standardnog ulaza dato je \\(K\\) razli\u010ditih brojeva \\(A_1, \\dots,  A_K\\), koji predstavljaju lokacije prodavnica na Jupiteru.</p> <p>U tre\u0107oj liniji standardnog ulaza dato je \\(N\\) parnih brojeva \\(X_1, \\dots, X_N\\).</p>"},{"location":"takprog/2023_2024/okr/05_monopol/#opis-izlaza","title":"Opis izlaza","text":"<p>Na standardni izlaz ispisati jedan ceo broj - minimalan broj prodavnica koji Sanja treba da izgradi da bi preuzela monopol. Ukoliko Sanja ne mo\u017ee preuzeti monopol, ispisati -1.</p>"},{"location":"takprog/2023_2024/okr/05_monopol/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/05_monopol/#ulaz","title":"Ulaz","text":"<pre><code>5 2\n2 5\n2 2 2 2 2\n</code></pre>"},{"location":"takprog/2023_2024/okr/05_monopol/#izlaz","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2023_2024/okr/05_monopol/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Postoji samo jedan na\u010din da Sanja preuzme vi\u0161e od pola kupaca - da izgradi po jednu prodavnicu u gradovima 1, 3, 5. Stoga, Sanja mora da izgradi barem tri prodavnice. Tada \u0107e Sanja imati \u0161estoro kupaca.</p>"},{"location":"takprog/2023_2024/okr/05_monopol/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/05_monopol/#ulaz_1","title":"Ulaz","text":"<pre><code>4 2\n1 4\n2 2 8 4\n</code></pre>"},{"location":"takprog/2023_2024/okr/05_monopol/#izlaz_1","title":"Izlaz","text":"<pre><code>1\n</code></pre>"},{"location":"takprog/2023_2024/okr/05_monopol/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Sanja mo\u017ee da postigne monopol pomo\u0107u samo jedne prodavnice u gradu broj 3. U tom slu\u010daju, Sanja \u0107e imati 9 kupaca, jednog iz grada 2 i osmoro iz grada 3.</p>"},{"location":"takprog/2023_2024/okr/05_monopol/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(2 \\leq K \\leq N \\leq 500\\,000\\)</li> <li>\\(0 \\leq X_i \\leq 10^9\\) za sve \\(i=1, \\dots, N\\).</li> <li>Brojevi \\(X_i\\) su parni</li> <li>\\(1 \\leq A_i \\leq N\\) za sve \\(i=1, \\dots, K\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 10 poena: \\(N \\leq 10\\);</li> <li>U test primerima vrednim 20 poena: U svakom gradu \u017eivi jednak broj ljudi;</li> <li>U test primerima vrednim 20 poena: \\(N \\leq 3000\\);</li> <li>U test primerima vrednim 50 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/05_monopol/#resenje-kada-n-leq-10","title":"Re\u0161enje kada \\(N \\leq 10\\)","text":"<p>U ovom podzadatku mo\u017eemo da simuliramo svih \\(2^N\\) mogu\u0107nosti gra\u0111enja prodavnica i potom za svaki grad prona\u0111emo najbli\u017eu prodavnicu u \\(O(N)\\). Ukupna vremenska slo\u017eenost je \\(O(2^N \\cdot N^2)\\). </p>"},{"location":"takprog/2023_2024/okr/05_monopol/#resenje-kada-u-svakom-gradu-stanuje-isti-broj-ljudi","title":"Re\u0161enje kada u svakom gradu stanuje isti broj ljudi","text":"<p>Neka je broj stanovnika svakog grada \\(g\\). Posmatrajmo dve postoje\u0107e uzastopne prodavnice. Neka su one u gradovima \\(i\\) i \\(j\\) i neka izme\u0111u te dve prodavnice postoji barem jedan grad. Primetimo da sa gradnjom dve dodatne prodavnice, jednom u \\(i+1\\) a drugom u \\(j-1\\), Sanja mo\u017ee da preuzme mu\u0161terije iz svih gradova iz (cikli\u010dnog) intervala \\([i+1,j-1]\\). Dakle, ako gradimo dve prodavnice u (cikli\u010dnom) intervalu \\([i+1,j-1]\\), preuze\u0107emo sve mu\u0161terije iz tog intervala. Ako gradimo samo jednu, preuze\u0107emo pola mu\u0161terija, ta\u010dnije: \\(g \\cdot ( \\frac{j-i-2}{2} + 1 )\\) mu\u0161terija. Zadatak re\u0161avamo greedy algoritmom. U svakom koraku biramo interval u kome je optimalno izgraditi novu prodavnicu. Primetimo da, ako je to prva prodavnica iz intervala, postavljanjem nje dobijamo \\(g \\cdot ( \\frac{j-i-2}{2} + 1 )\\) novih mu\u0161terija, dok za drugu dobijamo \\(g \\cdot ( \\frac{j-i-2}{2}  )\\) novih mu\u0161terija. Dakle, dovoljno je da sortiramo svih \\(2K\\) dobitaka opadaju\u0107e i odaberemo prefiks najmanje du\u017eine tako da je njegova suma strogo ve\u0107a od polovine ukupnog broja stanovnika. Ovo re\u0161enje radi u vremenskoj slo\u017eenosti \\(O(K \\log K)\\).</p>"},{"location":"takprog/2023_2024/okr/05_monopol/#resenje-kada-n-leq-3000","title":"Re\u0161enje kada \\(N \\leq 3\\,000\\)","text":"<p>Za ovo re\u0161enje je dovoljno da modifikujemo prethodno re\u0161enje, tako \u0161to za svaki cikli\u010dni interval tra\u017eimo optimalnu poziciju za prvu prodavnicu koja \u0107e biti izgra\u0111ena u njemu. Ovo mo\u017eemo posti\u0107i u slo\u017eenosti \\(O(N^2)\\), proverom koliko nam svaki odabir donosi mu\u0161terija.</p> <p>Primetite da je neophodan uslov da bi greedy radio taj da prva prodavnica izgra\u0111ena u intervalu donosi barem onoliko mu\u0161terija koliko \u0107e doneti i druga (Za\u0161to?). Primetimo i da je taj uslov ovde ispunjen, jer \u0107e prva prodavnica preuzeti barem polovinu mu\u0161terija iz intervala. Naime, primetite da gradnjom na poziciji \\(i+1\\) preuzimamo celu prvu polovinu intervala, dok gradnjom na poziciji \\(j-1\\) preuzimamo celu drugu polovinu intervala. Jedna od ove dve vrednosti je barem polovina sume celog intervala. </p>"},{"location":"takprog/2023_2024/okr/05_monopol/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Za glavno re\u0161enje, dovoljno je optimizovati re\u0161enje prethodnog podzadatka. Kori\u0161\u0107enjem prefiksnih suma, mogu\u0107e je u \\(O(N)\\) proveriti koliko \u0107e mu\u0161terija iz odgovaraju\u0107eg intervala preuzeri prva prodavnica izgra\u0111ena u njemu.</p> 05_monopol.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\n#define MAX_N 500000\n#define MAX_K 500000\n\nusing namespace std;\n\nint N, K;\nint A[MAX_K];\n\nlong long X[2*MAX_N];\nlong long gain[MAX_K+1][3];\nlong long psum[2*MAX_N];\nint ind[2*MAX_K];\n\n\nlong long compute_gain(int a){\n    if(a&lt;K)\n        return gain[a][1];\n    else\n        return gain[a-K][2]-gain[a-K][1];\n}\n\nbool compare(int a, int b){\n    return compute_gain(a)&gt;compute_gain(b);\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin&gt;&gt;N&gt;&gt;K;\n\n    for(int i=0; i&lt;K; i++){\n        cin&gt;&gt;A[i];\n        A[i]-=1;\n    }\n    sort(A, A+K);\n    A[K]=A[0]+N;\n\n    for(int i=0; i&lt;N; i++){\n        cin&gt;&gt;X[i];\n        X[i+N]=X[i];\n    }\n\n    psum[0]=X[0];\n    for(int i=1; i&lt;2*N; i++){\n        psum[i]+=psum[i-1]+X[i];\n    }\n\n\n    for(int i=0; i&lt;K; i++){\n        if(A[i+1]==A[i]+2){\n            gain[i][2]=0;\n            continue;\n\n        }\n        gain[i][2]=psum[A[i+1]-1]-psum[A[i]];\n    }\n\n    for(int i=0; i&lt;K; i++){\n        if(A[i+1]==A[i]+1){\n            gain[i][1]=0;\n            continue;\n        }\n        long long max=0, imax=-1;\n        for(int t=A[i]+1; t&lt;A[i+1]; t++){\n            long long gaint=psum[ (t+A[i+1]+1)/2 -1] - psum[ (t+A[i])/2 ];\n            if(t%2==A[i]%2){\n                gaint+=X[ (t+A[i])/2 ]/2;\n            }\n            if(t%2==A[i+1]%2){\n                gaint+=X[ (t+A[i+1])/2 ]/2;\n            }\n\n            if(gaint&gt;max){\n                max=gaint;\n                imax=t;\n            }\n        }\n        gain[i][1]=max;\n    }\n\n    for(int i=0; i&lt;K; i++){\n        ind[i]=i;\n        ind[K+i]=K+i;\n    }\n\n    sort(ind, ind+2*K, compare);\n\n    long long sum=0, m=0;\n    for(int i=0; i&lt;2*K; i++){\n        sum+=compute_gain(ind[i]);\n        m++;\n        if(sum&gt;psum[N-1]/2){\n            break;\n        }\n    }\n\n    if(sum&gt;psum[N-1]/2)\n        cout&lt;&lt;m;\n    else\n        cout&lt;&lt;-1;\n    return 0;\n}\n</code></pre>"},{"location":"takprog/2023_2024/okr/06_linijopolis/","title":"A3 - Linijopolis","text":"ZadatakRe\u0161enje Vremensko ograni\u010denje Memorijsko ograni\u010denje 4000ms 128MB <p>Velelepni Linijopolis su urbanisti zamislili tako da ima dokazano najbolju organizaciju: linijsku. Grad se sastoji od jedne jedine ulice, pored koje se nalaze blokovi jednakih veli\u010dina numerisani redom (po\u010dev od nultog). Za prevoz stanovnika Linijopolisa predvi\u0111en je javni prevoz u vidu \\(M\\) ultra-brzih autobusa koje pokre\u0107u bitovi (vozovi \u0107e biti uvedeni tek u fazi 3C projekta Linijopolis), koji se dr\u017ee jedne stalne trase od \\(N\\) stanica (u razli\u010ditim terminima u toku dana). Da bi pre\u0161ao rastojanje izme\u0111u dva susedna bloka, svaki autobus potro\u0161i ta\u010dno jedan bit svog goriva. Na\u017ealost, ovi autobusi na po\u010detku prvog dana rada GSP Linijopolis imaju ograni\u010den broj bitova u rezervoaru: \\(i\\)-ti autobus (\\(1 \\leq i \\leq m\\)) na po\u010detku dana ima na raspolaganju \\(A_i\\) bitova.</p> <p>Po trenutnom planu, u Linijopolisu \u0107e u okviru svake od \\(N\\) stanica biti i pumpa bitova. Stanica sa rednim brojem \\(j\\) (\\(1 \\leq j \\leq N\\)) se nalazi u okviru bloka \\(X_j\\) i sadr\u017ei pumpu koja na raspolaganju ima ukupno \\(B_j\\) bitova. Trasa nije nu\u017eno koncipirana tako da autobusi uvek idu u istom smeru (stanice mogu da imaju \"cik-cak\" raspored). Autobusi jedino mogu da dodaju bitove dok se putnici ukrcavaju ili iskrcavaju na trenutnoj stanici, i ne mogu da menjaju trasu ili se privremeno zaustave na stanici koja nije slede\u0107a u nizu.</p> <p>Ispostavlja se da je te\u0161ko, a mo\u017eda i nemogu\u0107e iskoristiti svih \\(M\\) autobusa u svrhu javnog prevoza. Zato \u0107e se iskoristiti neki podskup navedenih autobusa, pri \u010demu \u0107e za svaki biti unapred odre\u0111eno koliko bitova treba da preuzme sa koje pumpe, da bi neki drugi autobusi imali priliku da dodaju bitove u svoje rezervoare. Bitovi su nedeljivi: svaki autobus mo\u017ee da preuzme isklju\u010divo celobrojan broj bitova.</p> <p>Pomozite idejnim tvorcima Linijopolisa da njihova ideja za\u017eivi tako \u0161to \u0107ete odrediti najve\u0107i broj autobusa koji u toku dana mogu da u potpunosti zavr\u0161e svoj put kroz svih \\(N\\) stanica.</p> Autor Tekst i test primeri Analiza r\u0435\u0161enja Testiranje Aleksandar Vi\u0161nji\u0107 Andrej Iva\u0161kovi\u0107 Aleksandar Vi\u0161nji\u0107 Marko \u0160i\u0161ovi\u0107"},{"location":"takprog/2023_2024/okr/06_linijopolis/#opis-ulaza","title":"Opis ulaza","text":"<p>U prvom redu standardnog ulaza dati su celi brojevi \\(M\\) i \\(N\\), koji redom predstavljaju broj autobusa i broj stanica.</p> <p>U drugog redu je dato \\(M\\) celih brojeva \\(A_i\\), koji predstavljaju po\u010detne koli\u010dine bitova kojima raspola\u017ee svaki od autobusa.</p> <p>U tre\u0107em redu je dato \\(N\\) celih brojeva \\(X_j\\), koji predstavljaju redne brojeve blokova u kojima se stanice redom nalaze.</p> <p>U \u010detvrtom redu je dato \\(N\\) celih brojeva \\(B_j\\), koji predstavljaju kapacitete pumpi na stanicama.</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#opis-izlaza","title":"Opis izlaza","text":"<p>U prvom i jedinom redu standardnog izlaza treba ispisati najve\u0107i broj autobusa koji mogu da pre\u0111u put od prve do \\(N\\)-te stanice.</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#primer-1","title":"Primer 1","text":""},{"location":"takprog/2023_2024/okr/06_linijopolis/#ulaz","title":"Ulaz","text":"<pre><code>3 4\n3 0 2\n1 3 7 8\n2 5 3 6\n</code></pre>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#izlaz","title":"Izlaz","text":"<pre><code>2\n</code></pre>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#objasnjenje","title":"Obja\u0161njenje","text":"<p>Prvi i tre\u0107i autobus mogu da obi\u0111u sve stanice u datom redosledu, ukoliko prate naredni postupak: * Prvi autobus po\u010dinje sa 3 bita i preuzima jedan bit sa prve stanice, nakon \u010dega ima ukupno 4 bita. Po dolasku do druge stanice preostaju 2 bita, potom preuzima dva bita i ukupno ima na raspolaganju 4 bita. Ta 4 bita su dovoljna da autobus stigne do tre\u0107e stanice bez preostalih bitova, nakon \u010dega preuzima jedan bit sa tre\u0107e stanice koji je dovoljan da bi stigao do poslednje \u010detvrte stanice. * Tre\u0107i autobus po\u010dinje sa dva bita i preuzima jedan bit sa prve stanice, nakon \u010dega ima ukupno 3 bita. Potom sti\u017ee do druge stanice sa preostalim jednim bitom i uzima tri bita sa ove stanice, nakon \u010dega ima \u010detiri bita koja su dovoljna za dolazak do tre\u0107e stanice. Pri dolasku u tre\u0107u stanicu nema nijedan preostali bit, potom preuzima jedan bit sa ove stanice koji je dovoljan da se trasa zavr\u0161i.</p> <p>Drugi autobus mo\u017ee da pre\u0111e celu trasu kori\u0161\u0107enjem, ali tada na stanicama nema dovoljno preostalih bitova da bi ijedan drugi autobus tako\u0111e mogao da obi\u0111e sve stanice.</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#primer-2","title":"Primer 2","text":""},{"location":"takprog/2023_2024/okr/06_linijopolis/#ulaz_1","title":"Ulaz","text":"<pre><code>5 3\n50 50 50 50 150\n200 150 175\n25 25 200\n</code></pre>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#izlaz_1","title":"Izlaz","text":"<pre><code>3\n</code></pre>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#objasnjenje_1","title":"Obja\u0161njenje","text":"<p>Dva autobusa sa po\u010detnim brojem bitova 50 i jedan autobus sa po\u010detnim brojem bitova 150 mogu da obi\u0111u sve stanice. Pri tom jedan od autobusa sa po\u010detnim brojem bitova 50 dodaje svih 25 bitova sa prve stanice, a drugi dodaje svih 25 bitova sa druge stanice.</p> <p>Primetimo da stanice idu \"cik-cak\": \\(200\\), \\(150\\), \\(175\\).</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#ogranicenja","title":"Ograni\u010denja","text":"<ul> <li>\\(1 \\leq M, N \\leq 10^6\\).</li> <li>\\(0 \\leq A_i \\leq 10^9\\) za sve \\(i=1, \\dots, M\\).</li> <li>\\(0 \\leq X_i, B_i \\leq 10^9\\) za sve \\(i=1, \\dots, N\\).</li> </ul> <p>Test primeri su podeljeni u \u010detiri disjunktne grupe:</p> <ul> <li>U test primerima vrednim 20 poena: \\(M \\leq 10\\), \\(N \\leq 100\\);</li> <li>U test primerima vrednim 20 poena: \\(M,N \\leq 10^4\\);</li> <li>U test primerima vrednim 30 poena: \\(M,N \\leq 10^5\\);</li> <li>U test primerima vrednim 30 poena: Bez dodatnih ograni\u010denja.</li> </ul>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#resenje-kada-mleq-10-nleq-100","title":"Re\u0161enje kada \\(M\\leq 10, N\\leq 100\\)","text":"<p>Za svaki podskup autobusa proveravamo da li mogu pre\u0107i celu trasu. Kada se odlu\u010dimo za neki takav, pu\u0161tamo autobuse po principu \"jedan po jedan\". Svakom je cilj da kori\u0161\u0107enjem \u0161to manje dodatnih bitova stigne do kraja. Ukoliko mu je to potrebno, bitove \u0107e uzimati u najkasnijem mogu\u0107em trenutku. Ako je mogu\u0107e ispuniti cilj, on ne\u0107e uzurpirati ostale autobuse. Vremenska slo\u017eenost je \\(O(2^M \\cdot M\\cdot N)\\).</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#resenje-kada-nmleq-104","title":"Re\u0161enje kada \\(N,M\\leq 10^4\\)","text":"<p>Nadovezujemo se na prethodni podzadatak. Umesto razmatranja svakog podskupa, mo\u017eemo uo\u010diti to da autobusi sa ve\u0107om po\u010detnom koli\u010dinom bitova imaju ve\u0107u \u0161ansu da stignu do kraja i \u0161tede vi\u0161e bitova. Zato ih sortiramo po tom parametru i pu\u0161tamo ih redom od najve\u0107eg ka najmanjem. Primetimo da ne znamo unapred veli\u010dinu grupe autobusa, ve\u0107 je odre\u0107ujemo naknadno nakon neuspe\u0161ne trase (ili nakon \u0161to svi autobusi stignu do kraja). Najve\u0107a grupa \u0107e upravo biti poslednja \"trenutna\" grupa koju je opisani algoritam na\u0161ao. Vremenska slo\u017eenost je \\(O(M\\log M + M\\cdot N)\\).</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#resenje-kada-nmleq-105","title":"Re\u0161enje kada \\(N,M\\leq 10^5\\)","text":"<p>Optimalno je odrediti nekoliko autobusa sa najve\u0107om po\u010detnom koli\u010dinom bitova. Stoga vr\u0161imo binarnu pretragu po vrednosti re\u0161enja. Pretpostavimo da smo se odlu\u010dili za grupu od \\(K\\) autobusa. Njih paralelno pu\u0161tamo da putuju zajedno kroz svaku stanicu. Kada do\u0107u do stanice upotrebljavaju sve dostupne bitove. Prioritet ima autobus koji je \"najprazniji\". Promene je mogu\u0107e simulirati preko min heap (priority queue) strukture. </p> <p>U njoj pamtimo koli\u010dine bitova, kao i broj autobusa koji imaju istu. Ukoliko imamo dovoljno bitova na raspolaganju, desi\u0107e se da \"spojimo\" dve najni\u017ee vrednosti, \u010dime se veli\u010dina strukture smanjuje za jedan. Prilikom jedne ovakve operacije, smanjivanje se mo\u017ee desiti proizvoljan broj puta, ali dodavanje se de\u0161ava najvi\u0161e dvaput (prilikom deljenja nedovoljnog broja bitova sa ostatkom). Kako u strukturu ne mo\u017eemo oduzeti vi\u0161e nego \u0161to smo dodali, slo\u017eenost provere je \\(O((N+M)\\log M\\).</p> <p>Zbog upotrebe binarne pretrage, ukupna vremenska slo\u017eenost je \\(O((N+M)\\log^2M)\\).</p>"},{"location":"takprog/2023_2024/okr/06_linijopolis/#glavno-resenje","title":"Glavno re\u0161enje","text":"<p>Umesto min heap strukture koristimo stack. Provera postaje linearna, a ukupna slo\u017eenost je \\(O((N+M)\\log M\\).</p> 06_linijopolis.cpp<pre><code>#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\n#define MAXN 1000000\n#define MAXM 1000000\n\n// indeksirano od nule\nint M, N;\nint A[MAXM];\nint X[MAXN], B[MAXN];\n\nstruct autobus {\n    int broj;\n    long long bitovi;\n};\n\nvoid ulaz() {\n    scanf(\"%d %d\", &amp;M, &amp;N);\n    for (int i = 0; i &lt; M; i++) {\n        scanf(\"%d\", &amp;A[i]);\n    }\n    for (int i = 0; i &lt; N; i++) {\n        scanf(\"%d\", &amp;X[i]);\n    }\n    for (int i = 0; i &lt; N; i++) {\n        scanf(\"%d\", &amp;B[i]);\n    }\n}\n\nbool isprobaj_resenje(int broj) {\n    if (broj == 0) {\n        return true;\n    }\n    stack&lt;autobus&gt; busevi;\n    for (int i = 0; i &lt; broj; i++) {\n        autobus bus;\n        bus.bitovi = A[M - i - 1];\n        bus.broj = 1;\n        busevi.push(bus);\n    }\n    long long udaljenost = 0;\n    for (int i = 0; i &lt; N - 1; i++) {\n        int preostalo = B[i];\n        while (preostalo &gt; 0) {\n            bool spojDva = false;\n            bool barDva = (busevi.size() &gt; 1);\n            autobus najmanji = busevi.top();\n            busevi.pop();\n            if (barDva) {\n                autobus drugi = busevi.top();\n                long long razlika = drugi.bitovi - najmanji.bitovi;\n                spojDva = (razlika * najmanji.broj &lt;= preostalo);\n            }\n            if (spojDva) {\n                autobus drugi = busevi.top();\n                busevi.pop();\n                long long razlika = drugi.bitovi - najmanji.bitovi;\n                preostalo -= razlika * najmanji.broj;\n                drugi.broj += najmanji.broj;\n                busevi.push(drugi);\n            } else {\n                int broj_dodatnih = preostalo % najmanji.broj;\n                int uvecanje = preostalo / najmanji.broj;\n                preostalo = 0;\n                najmanji.bitovi += uvecanje;\n                najmanji.broj -= broj_dodatnih;\n                if (broj_dodatnih &gt; 0) {\n                    autobus novi;\n                    novi.broj = broj_dodatnih;\n                    novi.bitovi = najmanji.bitovi + 1;\n                    busevi.push(novi);\n                }\n                busevi.push(najmanji);\n            }\n        }\n        long long najmanje = busevi.top().bitovi;\n        udaljenost += abs(X[i + 1] - X[i]);\n        if (najmanje &lt; udaljenost) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid resi() {\n    sort(A, A + M);\n    int levo = 0, desno = M;\n    while (levo &lt; desno) {\n        int pokusaj = (levo + desno + 1) / 2;\n        if (isprobaj_resenje(pokusaj)) {\n            levo = pokusaj;\n        } else {\n            desno = pokusaj - 1;\n        }\n    }\n    printf(\"%d\\n\", levo);\n}\n\nint main() {\n    ulaz();\n    resi();\n    return 0;\n}\n</code></pre>"}]}